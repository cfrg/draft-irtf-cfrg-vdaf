<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>Verifiable Distributed Aggregation Functions</title>
<meta content="Richard L. Barnes" name="author">
<meta content="David Cook" name="author">
<meta content="Christopher Patton" name="author">
<meta content="Phillipp Schoppmann" name="author">
<meta content="
       This document describes Verifiable Distributed Aggregation Functions (VDAFs), a
family of multi-party protocols for computing aggregate statistics over user
measurements. These protocols are designed to ensure that, as long as at least
one aggregation server executes the protocol honestly, individual measurements
are never seen by any server in the clear. At the same time, VDAFs allow the
servers to detect if a malicious or misconfigured client submitted an
measurement that would result in an invalid aggregate result. 
    " name="description">
<meta content="xml2rfc 3.23.1" name="generator">
<meta content="Internet-Draft" name="keyword">
<meta content="draft-irtf-cfrg-vdaf-latest" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.23.1
    Python 3.12.6
    ConfigArgParse 1.7
    google-i18n-address 3.1.1
    intervaltree 3.1.0
    Jinja2 3.1.4
    lxml 4.9.4
    platformdirs 4.3.6
    pycountry 22.3.5
    PyYAML 6.0.1
    requests 2.32.3
    setuptools 70.3.0
    wcwidth 0.2.13
-->
<link href="draft-irtf-cfrg-vdaf.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}

@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Lora SemiBold'), local('Lora-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-semibold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Cabin Condensed';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Cabin Condensed SemiBold'), local('CabinCondensed-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/cabincondensed-semibold-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Cabin Condensed';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Cabin Condensed SemiBold'), local('CabinCondensed-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/cabincondensed-semibold-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Cabin Condensed';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Cabin Condensed SemiBold'), local('CabinCondensed-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/cabincondensed-semibold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

:root {
  color-scheme: light dark;
  --background-color: #fff;
  --text-color: #222;
  --title-color: #191919;
  --link-color: #2a6496;
  --highlight-color: #f9f9f9;
  --line-color: #eee;
  --pilcrow-weak: #ddd;
  --pilcrow-strong: #bbb;
  --small-font-size: 14.5px;
  --font-mono: 'Oxygen Mono', monospace;
  scrollbar-color: #bbb #eee;
}
body {
  max-width: 600px;
  margin: 75px auto;
  padding: 0 5px;
  color: var(--text-color);
  background-color: var(--background-color);
  font: 16px/22px "Lora", serif;
  scroll-behavior: smooth;
}

.ears {
  display: none;
}

/* headings */
h1, h2, h3, h4, h5, h6 {
  font-family: "Cabin Condensed", sans-serif;
  font-weight: 600;
  margin: 0.8em 0 0.3em;
  font-size-adjust: 0.5;
  color: var(--title-color);
}
h1#title {
  font-size: 32px;
  line-height: 40px;
  clear: both;
}
h1#title, h1#rfcnum {
  margin: 1.5em 0 0.2em;
}
h1#rfcnum + h1#title {
  margin: 0.2em 0;
}

h1, h2, h3 {
  font-size: 22px;
  line-height: 27px;
}
h4, h5, h6 {
  font-size: 20px;
  line-height: 24px;
}

/* general structure */
.author {
  padding-bottom: 0.3em;
}
#abstract+p {
  font-size: 18px;
  line-height: 24px;
}
#abstract+p code, #abstract+p samp, #abstract+p tt {
  font-size: 16px;
  line-height: 0;
}

p {
  padding: 0;
  margin: 0.5em 0;
  text-align: left;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignRight.art-text pre {
  padding: 0;
  width: auto;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
/* font-family isn't space-separated, but =~ will have to do */
svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
  font-family: var(--font-mono);
}
.alignCenter.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignCenter.art-text pre {
  padding: 0;
  width: auto;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 0.5em 2em;
}
:is(ol, ul) :is(ol, ul) {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
:is(ul, ol).compact, .ulCompact, .olCompact {
  line-height: 1;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
  clear: left;
  --indent: 3ch;
  /* --indent: attr(indent ch); not supported in any browser, but we can dream */
}
dl.olPercent {
  --indent: 5ch;
}
dl > dt {
  float: left;
  margin-right: 2ch;
  min-width: 8ch;
}
dl.dlNewline > dt {
  float: none;
}
dl > dd {
  margin-bottom: .8em;
  margin-left: var(--indent) !important; /* stupid element overrides */
  min-height: 2ex;
}
dl.olPercent > dt {
  min-width: calc(var(--indent) - 2ch);
}
:is(dl.compact, .dlCompact) > dd {
  margin-bottom: 0;
}
:is(dl.compact, .dlCompact) > dd > :is(:first-child, .break:first-child + *) {
  margin-top: 0;
}
:is(dl.compact, .dlCompact) > dd > :is(:last-child) {
  margin-bottom: 0;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0;
}
:is(dd, span).break {
  display: none;
}

/* links */
a, a[href].selfRef:hover {
  text-decoration: none;
}
a[href] {
  color: var(--link-color);
}
a[href].selfRef, .iref + a[href].internal {
  color: var(--text-color);
}
a[href]:hover {
  text-decoration: underline;
}
a[href].selfRef:hover {
  background-color: var(--highlight-color);
}
a.xref:is(.cite, .auto), :is(#status-of-memo, #copyright) a {
  white-space: nowrap;
}

/* Figures */
tt, code, pre {
  background-color: var(--highlight-color);
  font: 14px/22px var(--font-mono);
}
tt, code {
  /* changing the font for inline elements leads to different ascender
     and descender heights; as we want to retain baseline alignment,
     remove leading to avoid altering the final height of lines
     note: this fails if these blocks take an entire line,
     a different solution would be great */
  line-height: 0;
}
:is(h1, h2, h3, h4, h5, h6) :is(tt, code) {
  font-size: 84%;
}
pre {
  border: 1px solid var(--line-color);
  font-size: 13.5px;
  line-height: 16px;
  letter-spacing: -0.2px;
  margin: 5px;
  padding: 5px;
}
img {
  max-width: 100%;
}
figure {
  margin: 0.5em 0;
  padding: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption, caption {
  font-style: italic;
  margin: 0.5em 1.5em;
  text-align: left;
}
@media screen {
  /* Auto-collapse boilerplate. */
  :is(#status-of-memo, #copyright) p {
    margin: -2px 0;
    max-height: 0;
    transition: max-height 2s ease, margin 0.5s ease 0.5s;
    overflow: hidden;
  }
  :is(#status-of-memo, #copyright):hover p,
  :is(#status-of-memo, #copyright) h2:target ~ p {
    margin: 0.5em 0;
    max-height: 500px;
    overflow: auto;
  }
  pre, svg {
    display: inline-block;
    overflow-x: auto;
  }
  pre {
    max-width: 100%;
    width: calc(100% - 22px - 1em);
  }
  svg {
    max-width: calc(100% - 22px - 1em);
  }
  figure pre {
    display: block;
    width: calc(100% - 25px);
  }
  :is(pre, svg) + .pilcrow {
    display: inline-block;
    vertical-align: text-bottom;
    padding-bottom: 8px;
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 0 2em;
  font-style: italic;
}
blockquote {
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  max-width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
}
table.right {
  margin-left: auto;
}
table.center {
  margin-left: auto;
  margin-right: auto;
}
table.left {
  margin-right: auto;
}
thead, tbody {
  border: 1px solid var(--line-color);
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 5px 10px;
}
th {
  background-color: var(--line-color);
}
:is(tr:nth-child(2n), thead+tbody > tr:nth-child(2n+1)) > td {
  background-color: var(--background-color);
}
:is(tr:nth-child(2n+1), thead+tbody > tr:nth-child(2n)) > td {
  background-color: var(--highlight-color);
}
table caption {
  margin: 0;
  padding: 3px 0 3px 1em;
}
table p {
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  margin-left: 3px;
  opacity: 0.2;
  user-select: none;
}
a.pilcrow[href] { color: var(--pilcrow-weak); }
a.pilcrow[href]:hover { text-decoration: none; }
@media not print {
  :hover > a.pilcrow {
    opacity: 1;
  }
  a.pilcrow[href]:hover {
    color: var(--pilcrow-strong);
    background-color: transparent;
  }
}
@media print {
  a.pilcrow {
    display: none;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid var(--line-color);
}
.bcp14 {
  font-variant: small-caps;
  font-weight: 600;
  font-size: var(--small-font-size);
}
.role {
  font-variant: all-small-caps;
}
sub, sup {
  line-height: 1;
  font-size: 80%;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: var(--small-font-size);
  line-height: 18px;
  --identifier-width: 15ch;
}
#identifiers dt {
  width: var(--identifier-width);
  min-width: var(--identifier-width);
  clear: left;
  float: left;
  text-align: right;
  margin-right: 1ch;
}
#identifiers dd {
  margin: 0;
  margin-left: calc(1em + var(--identifier-width)) !important;
  min-width: 5em;
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #999;
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
#toc nav ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
#toc nav li {
  line-height: 1.3em;
  margin: 2px 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
#toc a.xref {
  white-space: normal;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 10ch;
  margin-right: 1.5ch;
}
.references dt:target::before {
  content: "⇒";
  width: 15px;
  margin: 0 10px 0 -25px;
}
.references dd {
  margin-left: 12ch !important;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
#rfc\.index\.index + ul {
  margin-left: 0;
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}
address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}
@media (min-width: 500px) {
  #authors-addresses > section {
    column-count: 2;
    column-gap: 20px;
  }
  #authors-addresses > section > h2 {
    column-span: all;
  }
  /* hack for break-inside: avoid-column */
  #authors-addresses address {
    display: inline-block;
    break-inside: avoid-column;
  }
}

.rfcEditorRemove p:first-of-type {
  font-style: italic;
}
.cref {
  background-color: rgba(249, 232, 105, 0.3);
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 929px) {
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 1px 0 0 0;
    margin: 0;
    border-bottom: 1px solid #ccc;
    opacity: 0.6;
  }
  #toc.active {
      opacity: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 2px 0 2px 6px;
    padding-right: 1em;
    font-size: 18px;
    line-height: 24px;
    min-width: 190px;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 8px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    background-color: var(--background-color);
    padding: 0.5em 1em 1em;
    overflow: auto;
    overscroll-behavior: contain;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
  #toc.active nav {
    display: block;
  }
  /* Make the collapsed ToC header render white on gray also when it's a link */
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
  #toc a.toplink {
    margin-top: 2px;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 930px) {
  body {
    padding-right: 360px;
    padding-right: calc(min(180px + 20%, 500px));
  }
  #toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 480px);
    width: 312px;
    margin: 0;
    padding: 0;
    z-index: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 2em;
    overflow: auto;
    overscroll-behavior: contain;
    scrollbar-width: thin;
  }
  #toc nav > ul  {
    margin-bottom: 2em;
  }
  #toc ul {
    margin: 0 0 0 4px;
    font-size: var(--small-font-size);
  }
  #toc ul :is(p, li) {
    margin: 2px 0;
    line-height: 22px;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {
    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre, .vcard {
    page-break-inside: avoid;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  :is(h2, h3, h4, h5, h6)+*, dd {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
  .toplink {
    display: none;
  }
}

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
}

/* Changes introduced to fix issues found during implementation */

/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}

/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin: 8px 0.5em 0;
}

/* Provide styling for table cell text alignment */
table .text-left {
  text-align: left;
}
table .text-center {
  text-align: center;
}
table .text-right {
  text-align: right;
}

/* Make the alternative author contact information look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 20em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Dark mode. */
@media (prefers-color-scheme: dark) {
:root {
  --background-color: #121212;
  --text-color: #f0f0f0;
  --title-color: #fff;
  --link-color: #4da4f0;
  --highlight-color: #282828;
  --line-color: #444;
  --pilcrow-weak: #444;
  --pilcrow-strong: #666;
  scrollbar-color: #777 #333;
}
}

/* SVG Trick: a prefix match works because only black and white are allowed */
svg :is([stroke="black"], [stroke^="#000"]) {
  stroke: var(--text-color);
}
svg :is([stroke="white"], [stroke^="#fff"]) {
  stroke: var(--background-color);
}
svg :is([fill="black"], [fill^="#000"], :not([fill])) {
  fill: var(--text-color);
}
svg :is([fill="white"], [fill^="#fff"]) {
  fill: var(--background-color);
}
</style>

</head>
<body class="xml2rfc">
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">VDAF</td>
<td class="right">September 2024</td>
</tr></thead>
<tfoot><tr>
<td class="left">Barnes, et al.</td>
<td class="center">Expires 27 March 2025</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">CFRG</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-irtf-cfrg-vdaf-latest</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2024-09-23" class="published">23 September 2024</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Informational</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2025-03-27">27 March 2025</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">R. L. Barnes</div>
<div class="org">Cisco</div>
</div>
<div class="author">
      <div class="author-name">D. Cook</div>
<div class="org">ISRG</div>
</div>
<div class="author">
      <div class="author-name">C. Patton</div>
<div class="org">Cloudflare</div>
</div>
<div class="author">
      <div class="author-name">P. Schoppmann</div>
<div class="org">Google</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">Verifiable Distributed Aggregation Functions</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This document describes Verifiable Distributed Aggregation Functions (VDAFs), a
family of multi-party protocols for computing aggregate statistics over user
measurements. These protocols are designed to ensure that, as long as at least
one aggregation server executes the protocol honestly, individual measurements
are never seen by any server in the clear. At the same time, VDAFs allow the
servers to detect if a malicious or misconfigured client submitted an
measurement that would result in an invalid aggregate result.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<section class="note rfcEditorRemove" id="section-note.1">
      <h2 id="name-discussion-venues">
<a href="#name-discussion-venues" class="section-name selfRef">Discussion Venues</a>
      </h2>
<p id="section-note.1-1">This note is to be removed before publishing as an RFC.<a href="#section-note.1-1" class="pilcrow">¶</a></p>
<p id="section-note.1-2">Discussion of this document takes place on the
    Crypto Forum Research Group mailing list (cfrg@ietf.org),
    which is archived at <span><a href="https://mailarchive.ietf.org/arch/search/?email_list=cfrg">https://mailarchive.ietf.org/arch/search/?email_list=cfrg</a></span>.<a href="#section-note.1-2" class="pilcrow">¶</a></p>
<p id="section-note.1-3">Source for this draft and an issue tracker can be found at
    <span><a href="https://github.com/cjpatton/vdaf">https://github.com/cjpatton/vdaf</a></span>.<a href="#section-note.1-3" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 27 March 2025.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2024 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="auto internal xref">1</a>.  <a href="#name-introduction" class="internal xref">Introduction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="auto internal xref">1.1</a>.  <a href="#name-change-log" class="internal xref">Change Log</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1" class="keepWithNext"><a href="#section-2" class="auto internal xref">2</a>.  <a href="#name-conventions-and-definitions" class="internal xref">Conventions and Definitions</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="auto internal xref">3</a>.  <a href="#name-overview" class="internal xref">Overview</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="auto internal xref">4</a>.  <a href="#name-definition-of-dafs" class="internal xref">Definition of DAFs</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="auto internal xref">4.1</a>.  <a href="#name-sharding" class="internal xref">Sharding</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="auto internal xref">4.2</a>.  <a href="#name-preparation" class="internal xref">Preparation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a href="#section-4.3" class="auto internal xref">4.3</a>.  <a href="#name-validity-of-aggregation-par" class="internal xref">Validity of Aggregation Parameters</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4">
                <p id="section-toc.1-1.4.2.4.1"><a href="#section-4.4" class="auto internal xref">4.4</a>.  <a href="#name-aggregation" class="internal xref">Aggregation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5">
                <p id="section-toc.1-1.4.2.5.1"><a href="#section-4.5" class="auto internal xref">4.5</a>.  <a href="#name-unsharding" class="internal xref">Unsharding</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.6">
                <p id="section-toc.1-1.4.2.6.1"><a href="#section-4.6" class="auto internal xref">4.6</a>.  <a href="#name-execution-of-a-daf" class="internal xref">Execution of a DAF</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="auto internal xref">5</a>.  <a href="#name-definition-of-vdafs" class="internal xref">Definition of VDAFs</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1">
                <p id="section-toc.1-1.5.2.1.1"><a href="#section-5.1" class="auto internal xref">5.1</a>.  <a href="#name-sharding-2" class="internal xref">Sharding</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.2">
                <p id="section-toc.1-1.5.2.2.1"><a href="#section-5.2" class="auto internal xref">5.2</a>.  <a href="#name-preparation-2" class="internal xref">Preparation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.3">
                <p id="section-toc.1-1.5.2.3.1"><a href="#section-5.3" class="auto internal xref">5.3</a>.  <a href="#name-validity-of-aggregation-para" class="internal xref">Validity of Aggregation Parameters</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.4">
                <p id="section-toc.1-1.5.2.4.1"><a href="#section-5.4" class="auto internal xref">5.4</a>.  <a href="#name-aggregation-2" class="internal xref">Aggregation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.5">
                <p id="section-toc.1-1.5.2.5.1"><a href="#section-5.5" class="auto internal xref">5.5</a>.  <a href="#name-unsharding-2" class="internal xref">Unsharding</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.6">
                <p id="section-toc.1-1.5.2.6.1"><a href="#section-5.6" class="auto internal xref">5.6</a>.  <a href="#name-execution-of-a-vdaf" class="internal xref">Execution of a VDAF</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.7">
                <p id="section-toc.1-1.5.2.7.1"><a href="#section-5.7" class="auto internal xref">5.7</a>.  <a href="#name-communication-patterns-for-" class="internal xref">Communication Patterns for Preparation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.8">
                <p id="section-toc.1-1.5.2.8.1"><a href="#section-5.8" class="auto internal xref">5.8</a>.  <a href="#name-ping-pong-topology-only-two" class="internal xref">Ping-Pong Topology (Only Two Aggregators)</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.9">
                <p id="section-toc.1-1.5.2.9.1"><a href="#section-5.9" class="auto internal xref">5.9</a>.  <a href="#name-star-topology-any-number-of" class="internal xref">Star Topology (Any Number of Aggregators)</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="auto internal xref">6</a>.  <a href="#name-preliminaries" class="internal xref">Preliminaries</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="auto internal xref">6.1</a>.  <a href="#name-finite-fields" class="internal xref">Finite Fields</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.1">
                    <p id="section-toc.1-1.6.2.1.2.1.1"><a href="#section-6.1.1" class="auto internal xref">6.1.1</a>.  <a href="#name-auxiliary-functions" class="internal xref">Auxiliary Functions</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.2">
                    <p id="section-toc.1-1.6.2.1.2.2.1"><a href="#section-6.1.2" class="auto internal xref">6.1.2</a>.  <a href="#name-ntt-friendly-fields" class="internal xref">NTT-Friendly Fields</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.3">
                    <p id="section-toc.1-1.6.2.1.2.3.1"><a href="#section-6.1.3" class="auto internal xref">6.1.3</a>.  <a href="#name-parameters" class="internal xref">Parameters</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2">
                <p id="section-toc.1-1.6.2.2.1"><a href="#section-6.2" class="auto internal xref">6.2</a>.  <a href="#name-extendable-output-functions" class="internal xref">Extendable Output Functions</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2.2.1">
                    <p id="section-toc.1-1.6.2.2.2.1.1"><a href="#section-6.2.1" class="auto internal xref">6.2.1</a>.  <a href="#name-xofturboshake128" class="internal xref">XofTurboShake128</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2.2.2">
                    <p id="section-toc.1-1.6.2.2.2.2.1"><a href="#section-6.2.2" class="auto internal xref">6.2.2</a>.  <a href="#name-xoffixedkeyaes128" class="internal xref">XofFixedKeyAes128</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2.2.3">
                    <p id="section-toc.1-1.6.2.2.2.3.1"><a href="#section-6.2.3" class="auto internal xref">6.2.3</a>.  <a href="#name-the-domain-separation-tag-a" class="internal xref">The Domain Separation Tag and Binder String</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="auto internal xref">7</a>.  <a href="#name-prio3" class="internal xref">Prio3</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="auto internal xref">7.1</a>.  <a href="#name-fully-linear-proof-flp-syst" class="internal xref">Fully Linear Proof (FLP) Systems</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.1.2.1">
                    <p id="section-toc.1-1.7.2.1.2.1.1"><a href="#section-7.1.1" class="auto internal xref">7.1.1</a>.  <a href="#name-encoding-the-input" class="internal xref">Encoding the Input</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.1.2.2">
                    <p id="section-toc.1-1.7.2.1.2.2.1"><a href="#section-7.1.2" class="auto internal xref">7.1.2</a>.  <a href="#name-multiple-proofs" class="internal xref">Multiple Proofs</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="auto internal xref">7.2</a>.  <a href="#name-construction" class="internal xref">Construction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.1">
                    <p id="section-toc.1-1.7.2.2.2.1.1"><a href="#section-7.2.1" class="auto internal xref">7.2.1</a>.  <a href="#name-sharding-3" class="internal xref">Sharding</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.2">
                    <p id="section-toc.1-1.7.2.2.2.2.1"><a href="#section-7.2.2" class="auto internal xref">7.2.2</a>.  <a href="#name-preparation-3" class="internal xref">Preparation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.3">
                    <p id="section-toc.1-1.7.2.2.2.3.1"><a href="#section-7.2.3" class="auto internal xref">7.2.3</a>.  <a href="#name-validity-of-aggregation-param" class="internal xref">Validity of Aggregation Parameters</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.4">
                    <p id="section-toc.1-1.7.2.2.2.4.1"><a href="#section-7.2.4" class="auto internal xref">7.2.4</a>.  <a href="#name-aggregation-3" class="internal xref">Aggregation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.5">
                    <p id="section-toc.1-1.7.2.2.2.5.1"><a href="#section-7.2.5" class="auto internal xref">7.2.5</a>.  <a href="#name-unsharding-3" class="internal xref">Unsharding</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.6">
                    <p id="section-toc.1-1.7.2.2.2.6.1"><a href="#section-7.2.6" class="auto internal xref">7.2.6</a>.  <a href="#name-auxiliary-functions-2" class="internal xref">Auxiliary Functions</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.7">
                    <p id="section-toc.1-1.7.2.2.2.7.1"><a href="#section-7.2.7" class="auto internal xref">7.2.7</a>.  <a href="#name-message-serialization" class="internal xref">Message Serialization</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3">
                <p id="section-toc.1-1.7.2.3.1"><a href="#section-7.3" class="auto internal xref">7.3</a>.  <a href="#name-the-flp-of" class="internal xref">The FLP of BBCGGI19</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3.2.1">
                    <p id="section-toc.1-1.7.2.3.2.1.1"><a href="#section-7.3.1" class="auto internal xref">7.3.1</a>.  <a href="#name-overview-2" class="internal xref">Overview</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3.2.2">
                    <p id="section-toc.1-1.7.2.3.2.2.1"><a href="#section-7.3.2" class="auto internal xref">7.3.2</a>.  <a href="#name-validity-circuits" class="internal xref">Validity Circuits</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3.2.3">
                    <p id="section-toc.1-1.7.2.3.2.3.1"><a href="#section-7.3.3" class="auto internal xref">7.3.3</a>.  <a href="#name-construction-2" class="internal xref">Construction</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4">
                <p id="section-toc.1-1.7.2.4.1"><a href="#section-7.4" class="auto internal xref">7.4</a>.  <a href="#name-instantiations" class="internal xref">Instantiations</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4.2.1">
                    <p id="section-toc.1-1.7.2.4.2.1.1"><a href="#section-7.4.1" class="auto internal xref">7.4.1</a>.  <a href="#name-prio3count" class="internal xref">Prio3Count</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4.2.2">
                    <p id="section-toc.1-1.7.2.4.2.2.1"><a href="#section-7.4.2" class="auto internal xref">7.4.2</a>.  <a href="#name-prio3sum" class="internal xref">Prio3Sum</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4.2.3">
                    <p id="section-toc.1-1.7.2.4.2.3.1"><a href="#section-7.4.3" class="auto internal xref">7.4.3</a>.  <a href="#name-prio3sumvec" class="internal xref">Prio3SumVec</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4.2.4">
                    <p id="section-toc.1-1.7.2.4.2.4.1"><a href="#section-7.4.4" class="auto internal xref">7.4.4</a>.  <a href="#name-prio3histogram" class="internal xref">Prio3Histogram</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4.2.5">
                    <p id="section-toc.1-1.7.2.4.2.5.1"><a href="#section-7.4.5" class="auto internal xref">7.4.5</a>.  <a href="#name-prio3multihotcountvec" class="internal xref">Prio3MultihotCountVec</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="auto internal xref">8</a>.  <a href="#name-poplar1" class="internal xref">Poplar1</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.1">
                <p id="section-toc.1-1.8.2.1.1"><a href="#section-8.1" class="auto internal xref">8.1</a>.  <a href="#name-incremental-distributed-poi" class="internal xref">Incremental Distributed Point Functions (IDPFs)</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.1.2.1">
                    <p id="section-toc.1-1.8.2.1.2.1.1"><a href="#section-8.1.1" class="auto internal xref">8.1.1</a>.  <a href="#name-encoding-inputs-as-indices" class="internal xref">Encoding inputs as indices</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2">
                <p id="section-toc.1-1.8.2.2.1"><a href="#section-8.2" class="auto internal xref">8.2</a>.  <a href="#name-construction-3" class="internal xref">Construction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.1">
                    <p id="section-toc.1-1.8.2.2.2.1.1"><a href="#section-8.2.1" class="auto internal xref">8.2.1</a>.  <a href="#name-sharding-4" class="internal xref">Sharding</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.2">
                    <p id="section-toc.1-1.8.2.2.2.2.1"><a href="#section-8.2.2" class="auto internal xref">8.2.2</a>.  <a href="#name-preparation-4" class="internal xref">Preparation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.3">
                    <p id="section-toc.1-1.8.2.2.2.3.1"><a href="#section-8.2.3" class="auto internal xref">8.2.3</a>.  <a href="#name-validity-of-aggregation-paramet" class="internal xref">Validity of Aggregation Parameters</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.4">
                    <p id="section-toc.1-1.8.2.2.2.4.1"><a href="#section-8.2.4" class="auto internal xref">8.2.4</a>.  <a href="#name-aggregation-5" class="internal xref">Aggregation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.5">
                    <p id="section-toc.1-1.8.2.2.2.5.1"><a href="#section-8.2.5" class="auto internal xref">8.2.5</a>.  <a href="#name-unsharding-4" class="internal xref">Unsharding</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.6">
                    <p id="section-toc.1-1.8.2.2.2.6.1"><a href="#section-8.2.6" class="auto internal xref">8.2.6</a>.  <a href="#name-message-serialization-2" class="internal xref">Message Serialization</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.3">
                <p id="section-toc.1-1.8.2.3.1"><a href="#section-8.3" class="auto internal xref">8.3</a>.  <a href="#name-the-idpf-scheme-of" class="internal xref">The IDPF scheme of BBCGGI21</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.3.2.1">
                    <p id="section-toc.1-1.8.2.3.2.1.1"><a href="#section-8.3.1" class="auto internal xref">8.3.1</a>.  <a href="#name-key-generation" class="internal xref">Key Generation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.3.2.2">
                    <p id="section-toc.1-1.8.2.3.2.2.1"><a href="#section-8.3.2" class="auto internal xref">8.3.2</a>.  <a href="#name-key-evaluation" class="internal xref">Key Evaluation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.3.2.3">
                    <p id="section-toc.1-1.8.2.3.2.3.1"><a href="#section-8.3.3" class="auto internal xref">8.3.3</a>.  <a href="#name-auxiliary-functions-3" class="internal xref">Auxiliary Functions</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.4">
                <p id="section-toc.1-1.8.2.4.1"><a href="#section-8.4" class="auto internal xref">8.4</a>.  <a href="#name-instantiation" class="internal xref">Instantiation</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="auto internal xref">9</a>.  <a href="#name-security-considerations" class="internal xref">Security Considerations</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.1">
                <p id="section-toc.1-1.9.2.1.1"><a href="#section-9.1" class="auto internal xref">9.1</a>.  <a href="#name-requirements-for-the-verifi" class="internal xref">Requirements for the Verification Key</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.2">
                <p id="section-toc.1-1.9.2.2.1"><a href="#section-9.2" class="auto internal xref">9.2</a>.  <a href="#name-requirements-for-the-nonce" class="internal xref">Requirements for the Nonce</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.3">
                <p id="section-toc.1-1.9.2.3.1"><a href="#section-9.3" class="auto internal xref">9.3</a>.  <a href="#name-requirements-for-the-public" class="internal xref">Requirements for the Public Share</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.4">
                <p id="section-toc.1-1.9.2.4.1"><a href="#section-9.4" class="auto internal xref">9.4</a>.  <a href="#name-requirements-for-aggregatio" class="internal xref">Requirements for Aggregation Parameters</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.4.2.1">
                    <p id="section-toc.1-1.9.2.4.2.1.1"><a href="#section-9.4.1" class="auto internal xref">9.4.1</a>.  <a href="#name-additional-privacy-consider" class="internal xref">Additional Privacy Considerations</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.4.2.2">
                    <p id="section-toc.1-1.9.2.4.2.2.1"><a href="#section-9.4.2" class="auto internal xref">9.4.2</a>.  <a href="#name-safe-usage-of-idpf-outputs" class="internal xref">Safe Usage of IDPF Outputs</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.5">
                <p id="section-toc.1-1.9.2.5.1"><a href="#section-9.5" class="auto internal xref">9.5</a>.  <a href="#name-requirements-for-xofs" class="internal xref">Requirements for XOFs</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.6">
                <p id="section-toc.1-1.9.2.6.1"><a href="#section-9.6" class="auto internal xref">9.6</a>.  <a href="#name-choosing-the-field-size" class="internal xref">Choosing the Field Size</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.7">
                <p id="section-toc.1-1.9.2.7.1"><a href="#section-9.7" class="auto internal xref">9.7</a>.  <a href="#name-choosing-the-number-of-aggr" class="internal xref">Choosing the Number of Aggregators</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.8">
                <p id="section-toc.1-1.9.2.8.1"><a href="#section-9.8" class="auto internal xref">9.8</a>.  <a href="#name-defense-in-depth-measures" class="internal xref">Defense-in-Depth Measures</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="auto internal xref">10</a>. <a href="#name-iana-considerations" class="internal xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#section-11" class="auto internal xref">11</a>. <a href="#name-references" class="internal xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.1">
                <p id="section-toc.1-1.11.2.1.1"><a href="#section-11.1" class="auto internal xref">11.1</a>.  <a href="#name-normative-references" class="internal xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.2">
                <p id="section-toc.1-1.11.2.2.1"><a href="#section-11.2" class="auto internal xref">11.2</a>.  <a href="#name-informative-references" class="internal xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#appendix-A" class="auto internal xref"></a><a href="#name-acknowledgments" class="internal xref">Acknowledgments</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#appendix-B" class="auto internal xref"></a><a href="#name-test-vectors" class="internal xref">Test Vectors</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.1">
                <p id="section-toc.1-1.13.2.1.1"><a href="#appendix-B.1" class="auto internal xref"></a><a href="#name-schema" class="internal xref">Schema</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.1.2.1">
                    <p id="section-toc.1-1.13.2.1.2.1.1"><a href="#appendix-B.1.1" class="auto internal xref"></a><a href="#name-prio3count-2" class="internal xref">Prio3Count</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.1.2.2">
                    <p id="section-toc.1-1.13.2.1.2.2.1"><a href="#appendix-B.1.2" class="auto internal xref"></a><a href="#name-prio3sum-2" class="internal xref">Prio3Sum</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.1.2.3">
                    <p id="section-toc.1-1.13.2.1.2.3.1"><a href="#appendix-B.1.3" class="auto internal xref"></a><a href="#name-prio3sumvec-2" class="internal xref">Prio3SumVec</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.1.2.4">
                    <p id="section-toc.1-1.13.2.1.2.4.1"><a href="#appendix-B.1.4" class="auto internal xref"></a><a href="#name-prio3histogram-2" class="internal xref">Prio3Histogram</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.1.2.5">
                    <p id="section-toc.1-1.13.2.1.2.5.1"><a href="#appendix-B.1.5" class="auto internal xref"></a><a href="#name-prio3multihotcountvec-2" class="internal xref">Prio3MultihotCountVec</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13.2.1.2.6">
                    <p id="section-toc.1-1.13.2.1.2.6.1"><a href="#appendix-B.1.6" class="auto internal xref"></a><a href="#name-poplar1-2" class="internal xref">Poplar1</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a href="#appendix-C" class="auto internal xref"></a><a href="#name-authors-addresses" class="internal xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">(RFC EDITOR: remove this paragraph.) The source for this draft and and the
reference implementation can be found at
https://github.com/cfrg/draft-irtf-cfrg-vdaf.<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">The ubiquity of the Internet makes it an ideal platform for measurement of
large-scale phenomena, whether public health trends or the behavior of computer
systems at scale. There is substantial overlap, however, between information
that is valuable to measure and information that users consider private.<a href="#section-1-2" class="pilcrow">¶</a></p>
<p id="section-1-3">For example, consider an application that provides health information to users.
The operator of an application might want to know which parts of their
application are used most often, as a way to guide future development of the
application. Specific users' patterns of usage, though, could reveal sensitive
things about them, such as which users are researching a given health
condition.<a href="#section-1-3" class="pilcrow">¶</a></p>
<p id="section-1-4">In many situations, the measurement collector is only interested in aggregate
statistics, e.g., which portions of an application are most used or what
fraction of people have experienced a given disease. Thus systems that provide
aggregate statistics while protecting individual measurements can deliver the
value of the measurements while protecting users' privacy.<a href="#section-1-4" class="pilcrow">¶</a></p>
<p id="section-1-5">This problem is often formulated in terms of differential privacy (DP)
<span>[<a href="#Dwo06" class="cite xref">Dwo06</a>]</span>. Roughly speaking, a data aggregation system that is differentially
private ensures that the degree to which any individual measurement influences
the value of the aggregate result can be precisely controlled. For example, in
systems like RAPPOR <span>[<a href="#EPK14" class="cite xref">EPK14</a>]</span>, each user samples noise from a well-known
distribution and adds it to their measurement before submitting to the
aggregation server. The aggregation server then adds up the noisy measurements,
and because it knows the distribution from which the noise was sampled, it can
estimate the true sum with reasonable accuracy.<a href="#section-1-5" class="pilcrow">¶</a></p>
<p id="section-1-6">Even when noise is added to the measurements, collecting them in the clear
still reveals a significant amount of information to the collector. On the one
hand, depending on the "amount" of noise a client adds to its measurement, it
may be possible for a curious collector to make a reasonable guess of the
measurement's true value. On the other hand, the more noise the clients add,
the less reliable will be the server's estimate of the aggregate. Thus systems
relying solely on a DP mechanism must strike a delicate balance between privacy
and utility.<a href="#section-1-6" class="pilcrow">¶</a></p>
<p id="section-1-7">The ideal goal for a privacy-preserving measurement system is that of secure
multi-party computation (MPC): no participant in the protocol should learn
anything about an individual measurement beyond what it can deduce from the
aggregate. MPC achieves this goal by distributing the computation of the
aggregate across multiple aggregation servers, one of which is presumed to be
honest, i.e., not under control of the attacker. Moreover, MPC can be composed
with various DP mechanisms to ensure the aggregate itself does leak too much
information about any one of the measurements <span>[<a href="#MPRV09" class="cite xref">MPRV09</a>]</span>.<a href="#section-1-7" class="pilcrow">¶</a></p>
<p id="section-1-8">This document describes two classes of MPC protocols, each aiming for a
different set of goals.<a href="#section-1-8" class="pilcrow">¶</a></p>
<p id="section-1-9">In a Distributed Aggregation Function (DAF, <a href="#daf" class="auto internal xref">Section 4</a>), each client splits its
measurement into multiple secret shares, one for each aggregation
server. DAFs require two properties of the secret sharing scheme. First, we can
reconstruct the underlying measurement by simply adding up all of the shares.
(Typically the shares are vectors over some finite field.) Second, given all
but one of the shares, it is impossible to learn anything about the underlying
measurement. These properties give rise to a simple strategy for privately
aggregating the measurements: each aggregation server adds up its measurement
shares locally before revealing their sum to the data collector; then all
the data collector has to do is add up these sums to get the aggregate.<a href="#section-1-9" class="pilcrow">¶</a></p>
<p id="section-1-10">This strategy is compatible with any aggregation function that can be
represented as the sum of some encoding of the measurements. Examples include:
summary statistics such as sum, mean, and standard deviation; estimation of
quantiles, e.g., median; histograms; linear regression; or counting data
structures, e.g., Bloom filters. However, not all functions fit into this
rubric, as it is constrained to linear computations over the encoded
measurements.<a href="#section-1-10" class="pilcrow">¶</a></p>
<p id="section-1-11">In fact, our framework admits DAFs with slightly more
functionality, computing aggregation functions of the form<a href="#section-1-11" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-1-12">
<pre>
f(agg_param, meas_1, ..., meas_N) =
    g(agg_param, meas_1) + ... + g(agg_param, meas_N)
</pre><a href="#section-1-12" class="pilcrow">¶</a>
</div>
<p id="section-1-13">where <code>meas_1, ..., meas_N</code> are the measurements, <code>g</code> is a possibly non-linear
function, and <code>agg_param</code> is a parameter of that function chosen by the data
collector. This paradigm, known as function secret sharing <span>[<a href="#BGI15" class="cite xref">BGI15</a>]</span>, allows
for more sophisticated data analysis tasks, such as grouping metrics by private
client attributes <span>[<a href="#MPDST25" class="cite xref">MPDST25</a>]</span> or computing heavy hitters <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>. (More
on the latter task below.)<a href="#section-1-13" class="pilcrow">¶</a></p>
<p id="section-1-14">The second class of protocols defined in this document are called Verifiable
Distributed Aggregation Functions (VDAFs, <a href="#vdaf" class="auto internal xref">Section 5</a>). In addition to being
private, VDAFs are verifiable in the following sense. By design, a secret
sharing of a valid measurement, e.g., a number between 1 and 10, is
indistinguishable from a secret sharing of an invalid measurement, e.g., a
number larger than 10. This means that DAFs are vulnerable to attacks from
malicious clients attempting to disrupt the computation by submitting invalid
measurements. Thus VDAFs are designed to allow the servers to detect and remove
these measurements prior to aggregation. We refer to this property as
robustness.<a href="#section-1-14" class="pilcrow">¶</a></p>
<p id="section-1-15">Achieving robustness without sacrificing privacy requires the servers to
interact with one another over a number of rounds of communication. DAFs on the
other hand are non-interactive, and are therefore easier to deploy; but they do
not provide robustness on their own. This may be tolerable in some
applications. For instance, if the client's software is executed in a trusted
execution environment, it may be reasonable to assume that no client is
malicious.<a href="#section-1-15" class="pilcrow">¶</a></p>
<p id="section-1-16">The DAF and VDAF abstractions encompass a variety of MPC techniques in the
literature. These protocols vary in their operational and security
requirements, sometimes in subtle but consequential ways. This document
therefore has two important goals:<a href="#section-1-16" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-1-17">
<li id="section-1-17.1">
          <p id="section-1-17.1.1">Providing higher-level protocols like <span>[<a href="#DAP" class="cite xref">DAP</a>]</span> (RFC
EDITOR: remove this reference if not published before the current document)
with a simple, uniform interface for accessing privacy-preserving measurement
schemes, documenting relevant operational and security requirements, and
specifying constraints for safe usage:<a href="#section-1-17.1.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-1-17.1.2">
<li id="section-1-17.1.2.1">
              <p id="section-1-17.1.2.1.1">General patterns of communications among the various actors involved in
the system (clients, aggregation servers, and the collector of the
aggregate result);<a href="#section-1-17.1.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-1-17.1.2.2">
              <p id="section-1-17.1.2.2.1">Capabilities of a malicious coalition of servers attempting to divulge
information about client measurements; and<a href="#section-1-17.1.2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-1-17.1.2.3">
              <p id="section-1-17.1.2.3.1">Conditions that are necessary to ensure that malicious clients cannot
corrupt the computation.<a href="#section-1-17.1.2.3.1" class="pilcrow">¶</a></p>
</li>
          </ol>
</li>
        <li id="section-1-17.2">
          <p id="section-1-17.2.1">Providing cryptographers with design criteria that provide a clear
deployment roadmap for new constructions.<a href="#section-1-17.2.1" class="pilcrow">¶</a></p>
</li>
      </ol>
<p id="section-1-18">This document also specifies two concrete VDAF schemes, each based on a protocol
from the literature.<a href="#section-1-18" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1-19.1">
          <p id="section-1-19.1.1">The Prio system <span>[<a href="#CGB17" class="cite xref">CGB17</a>]</span> allows for the privacy-preserving computation of a
variety of aggregate statistics, combining additive secret sharing as described
above with a mechanism for checking the validity of each measurement. In
<a href="#prio3" class="auto internal xref">Section 7</a> we specify Prio3, a VDAF that follows the same overall framework as
the original Prio protocol, but incorporates techniques introduced in
<span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span> that result in significant performance gains.<a href="#section-1-19.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-1-19.2">
          <p id="section-1-19.2.1">The Poplar protocol <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span> solves the heavy-hitters problem in a
privacy-preserving manner. Here each client holds a bit-string, and the goal
of the aggregation servers is to compute the set of strings that occur at
least <code>t</code> times for some threshold <code>t</code>. The core primitive in their protocol
is a secret sharing of a point function <span>[<a href="#GI14" class="cite xref">GI14</a>]</span> (<code>g</code> in the notation above)
that allows the servers to privately count how many of the clients' strings
begin with a given prefix (<code>agg_param</code> in the notation above). In <a href="#poplar1" class="auto internal xref">Section 8</a>
we specify a VDAF called Poplar1 that implements this functionality.<a href="#section-1-19.2.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-1-20">The remainder of this document is organized as follows: <a href="#conventions" class="auto internal xref">Section 2</a> lists
definitions and conventions used for specification; <a href="#overview" class="auto internal xref">Section 3</a> gives a brief
overview of DAFs and VDAFs, the parties involved in the computation, and the
requirements for non-collusion; <a href="#daf" class="auto internal xref">Section 4</a> defines the syntax for DAFs; <a href="#vdaf" class="auto internal xref">Section 5</a>
defines the syntax for VDAFs; <a href="#prelim" class="auto internal xref">Section 6</a> defines various functionalities that
are common to our constructions; <a href="#prio3" class="auto internal xref">Section 7</a> describes the Prio3 construction;
<a href="#poplar1" class="auto internal xref">Section 8</a> describes the Poplar1 construction; and <a href="#security" class="auto internal xref">Section 9</a> enumerates the
security considerations for DAFs and VDAFs.<a href="#section-1-20" class="pilcrow">¶</a></p>
<div id="change-log">
<section id="section-1.1">
        <h3 id="name-change-log">
<a href="#section-1.1" class="section-number selfRef">1.1. </a><a href="#name-change-log" class="section-name selfRef">Change Log</a>
        </h3>
<p id="section-1.1-1">(RFC EDITOR: remove this section.)<a href="#section-1.1-1" class="pilcrow">¶</a></p>
<p id="section-1.1-2">(*) Indicates a change that breaks wire compatibility with the previous draft.<a href="#section-1.1-2" class="pilcrow">¶</a></p>
<p id="section-1.1-3">11:<a href="#section-1.1-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-4.1">
            <p id="section-1.1-4.1.1">Define message formats for the Poplar1 aggregation parameter and IDPF public
share.<a href="#section-1.1-4.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-4.2">
            <p id="section-1.1-4.2.1">IDPF: Require the IDPF binder must be a random nonce.<a href="#section-1.1-4.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-4.3">
            <p id="section-1.1-4.3.1">VDAF: Replace the pseudocode description of the ping-ping topology with
Python and sketch the star topology.<a href="#section-1.1-4.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-4.4">
            <p id="section-1.1-4.4.1">DAF: Align aggregation parameter validation with VDAF.<a href="#section-1.1-4.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-4.5">
            <p id="section-1.1-4.5.1">Replace <code>Union[A, B]</code> type with <code>A | B</code>.<a href="#section-1.1-4.5.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-4.6">
            <p id="section-1.1-4.6.1">Rename FFT ("Fast Fourier Transform") with NTT ("Number Theoretic
Transform").<a href="#section-1.1-4.6.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-5">10:<a href="#section-1.1-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-6.1">
            <p id="section-1.1-6.1.1">Define Prio3MultihotCountVec, a variant of Prio3 for aggregating bit vectors
with bounded weight.<a href="#section-1.1-6.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-6.2">
            <p id="section-1.1-6.2.1">FLP: Allow the output of the circuit to be a vector. This makes it possible
to skip joint randomness derivation in more cases.<a href="#section-1.1-6.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-6.3">
            <p id="section-1.1-6.3.1">Poplar1: On the first round of preparation, handle <code>None</code> as an error.
Previously this message was interpreted as a length-3 vector of zeros.<a href="#section-1.1-6.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-6.4">
            <p id="section-1.1-6.4.1">Prio3: Move specification of the field from the FLP validity circuit to the
VDAF itself.<a href="#section-1.1-6.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-6.5">
            <p id="section-1.1-6.5.1">Clarify the extent to which the attacker controls the network in our threat
models for privacy and robustness.<a href="#section-1.1-6.5.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-6.6">
            <p id="section-1.1-6.6.1">Clean up various aspects of the code, including: Follow existing
object-oriented programming patterns for Python more closely; make the type
hints enforceable; and avoid shadowing variables.<a href="#section-1.1-6.6.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-6.7">
            <p id="section-1.1-6.7.1">Poplar1: Align terminology with <span>[<a href="#BBCGGI23" class="cite xref">BBCGGI23</a>]</span>.<a href="#section-1.1-6.7.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-6.8">
            <p id="section-1.1-6.8.1">IDPF: Add guidance for encoding byte strings as indices.<a href="#section-1.1-6.8.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-7">09:<a href="#section-1.1-7" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-8.1">
            <p id="section-1.1-8.1.1">Poplar1: Make prefix tree traversal stricter by requiring each node to be a
child of a node that was already visited. This change is intended to make it
harder for a malicious Aggregator to steer traversal towards
non-heavy-hitting measurements.<a href="#section-1.1-8.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-8.2">
            <p id="section-1.1-8.2.1">Prio3: Add more explicit guidance for choosing the field size.<a href="#section-1.1-8.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-8.3">
            <p id="section-1.1-8.3.1">IDPF: Define extractability and clarify (un)safe usage of intermediate prefix
counts. Accordingly, add text ensuring public share consistency to security
considerations.<a href="#section-1.1-8.3.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-9">08:<a href="#section-1.1-9" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-10.1">
            <p id="section-1.1-10.1.1">Poplar1: Bind the report nonce to the authenticator vector programmed into
the IDPF. (*)<a href="#section-1.1-10.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-10.2">
            <p id="section-1.1-10.2.1">IdpfPoplar: Modify <code>extend()</code> by stealing each control bit from its
corresponding seed. This improves performance by reducing the number of AES
calls per level from 3 to 2. The cost is a slight reduction in the concrete
privacy bound. (*)<a href="#section-1.1-10.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-10.3">
            <p id="section-1.1-10.3.1">Prio3: Add support for generating and verifying mutliple proofs per
measurement. This enables a trade-off between communication cost and runtime:
if more proofs are used, then a smaller field can be used without impacting
robustness. (*)<a href="#section-1.1-10.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-10.4">
            <p id="section-1.1-10.4.1">Replace SHAKE128 with TurboSHAKE128. (*)<a href="#section-1.1-10.4.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-11">07:<a href="#section-1.1-11" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-12.1">
            <p id="section-1.1-12.1.1">Rename PRG to XOF ("eXtendable Output Function"). Accordingly, rename PrgSha3
to XofShake128 and PrgFixedKeyAes128 to XofFixedKeyAes128. "PRG" is a misnomer
since we don't actually treat this object as a pseudorandom generator in
existing security analysis.<a href="#section-1.1-12.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-12.2">
            <p id="section-1.1-12.2.1">Replace cSHAKE128 with SHAKE128, re-implementing domain separation for the
customization string using a simpler scheme. This change addresses the
reality that implementations of cSHAKE128 are less common. (*)<a href="#section-1.1-12.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-12.3">
            <p id="section-1.1-12.3.1">Define a new VDAF, called Prio3SumVec, that generalizes Prio3Sum to a vector
of summands.<a href="#section-1.1-12.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-12.4">
            <p id="section-1.1-12.4.1">Prio3Histogram: Update the codepoint and use the parallel sum optimization
introduced by Prio3SumVec to reduce the proof size. (*)<a href="#section-1.1-12.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-12.5">
            <p id="section-1.1-12.5.1">Daf, Vdaf: Rename interface methods to match verbiage in the draft.<a href="#section-1.1-12.5.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-12.6">
            <p id="section-1.1-12.6.1">Daf: Align with Vdaf by adding a nonce to <code>shard()</code> and <code>prep()</code>.<a href="#section-1.1-12.6.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-12.7">
            <p id="section-1.1-12.7.1">Vdaf: Have <code>prep_init()</code> compute the first prep share. This change is
intended to simplify the interface by making the input to <code>prep_next()</code> not
optional.<a href="#section-1.1-12.7.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-12.8">
            <p id="section-1.1-12.8.1">Prio3: Split sharding into two auxiliary functions, one for sharding with
joint randomness and another without. This change is intended to improve
readability.<a href="#section-1.1-12.8.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-12.9">
            <p id="section-1.1-12.9.1">Fix bugs in the ping-pong interface discovered after implementing it.<a href="#section-1.1-12.9.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-13">06:<a href="#section-1.1-13" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-14.1">
            <p id="section-1.1-14.1.1">Vdaf: Define a wrapper interface for preparation that is suitable for the
"ping-pong" topology in which two Aggregators exchange messages over a
request/response protocol, like HTTP, and take turns executing the
computation until input from the peer is required.<a href="#section-1.1-14.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-14.2">
            <p id="section-1.1-14.2.1">Prio3Histogram: Generalize the measurement type so that the histogram can be
used more easily with discrete domains. (*)<a href="#section-1.1-14.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-14.3">
            <p id="section-1.1-14.3.1">Daf, Vdaf: Change the aggregation parameter validation algorithm to take the
set of previous parameters rather than a list. (The order of the parameters
is irrelevant.)<a href="#section-1.1-14.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-14.4">
            <p id="section-1.1-14.4.1">Daf, Vdaf, Idpf: Add parameter <code>RAND_SIZE</code> that specifies the number of
random bytes consumed by the randomized algorithm (<code>shard()</code> for Daf and Vdaf
and <code>gen()</code> for Idpf).<a href="#section-1.1-14.4.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-15">05:<a href="#section-1.1-15" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-16.1">
            <p id="section-1.1-16.1.1">IdpfPoplar: Replace PrgSha3 with PrgFixedKeyAes128, a fixed-key mode for
AES-128 based on a construction from <span>[<a href="#GKWWY20" class="cite xref">GKWWY20</a>]</span>. This change is intended to
improve performance of IDPF evaluation. Note that the new PRG is not suitable
for all applications. (*)<a href="#section-1.1-16.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-16.2">
            <p id="section-1.1-16.2.1">Idpf: Add a binder string to the key-generation and evaluation algorithms.
This is used to plumb the nonce generated by the Client to the PRG.<a href="#section-1.1-16.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-16.3">
            <p id="section-1.1-16.3.1">Plumb random coins through the interface of randomized algorithms.
Specifically, add a random input to (V)DAF sharding algorithm and IDPF
key-generation algorithm and require implementations to specify the length of
the random input. Accordingly, update Prio3, Poplar1, and IdpfPoplar to match
the new interface. This change is intended to improve coverage of test
vectors.<a href="#section-1.1-16.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-16.4">
            <p id="section-1.1-16.4.1">Use little-endian byte-order for field element encoding. (*)<a href="#section-1.1-16.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-16.5">
            <p id="section-1.1-16.5.1">Poplar1: Move the last step of sketch evaluation from <code>prep_next()</code> to
<code>prep_shares_to_prep()</code>.<a href="#section-1.1-16.5.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-17">04:<a href="#section-1.1-17" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-18.1">
            <p id="section-1.1-18.1.1">Align security considerations with the security analysis of <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>.<a href="#section-1.1-18.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-18.2">
            <p id="section-1.1-18.2.1">Vdaf: Pass the nonce to the sharding algorithm.<a href="#section-1.1-18.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-18.3">
            <p id="section-1.1-18.3.1">Vdaf: Rather than allow the application to choose the nonce length, have each
implementation of the Vdaf interface specify the expected nonce length. (*)<a href="#section-1.1-18.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-18.4">
            <p id="section-1.1-18.4.1">Prg: Split "info string" into two components: the "customization string",
intended for domain separation; and the "binder string", used to bind the
output to ephemeral values, like the nonce, associated with execution of a
(V)DAF.<a href="#section-1.1-18.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-18.5">
            <p id="section-1.1-18.5.1">Replace PrgAes128 with PrgSha3, an implementation of the Prg interface based
on SHA-3, and use the new scheme as the default. Accordingly, replace
Prio3Aes128Count with Prio3Count, Poplar1Aes128 with Poplar1, and so on. SHA-3
is a safer choice for instantiating a random oracle, which is used in the
analysis of Prio3 of <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>. (*)<a href="#section-1.1-18.5.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-18.6">
            <p id="section-1.1-18.6.1">Prio3, Poplar1: Ensure each invocation of the Prg uses a distinct
customization string, as suggested by <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>. This is intended to make
domain separation clearer, thereby simplifying security analysis. (*)<a href="#section-1.1-18.6.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-18.7">
            <p id="section-1.1-18.7.1">Prio3: Replace "joint randomness hints" sent in each input share with "joint
randomness parts" sent in the public share. This reduces communication
overhead when the number of shares exceeds two. (*)<a href="#section-1.1-18.7.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-18.8">
            <p id="section-1.1-18.8.1">Prio3: Bind nonce to joint randomness parts. This is intended to address
birthday attacks on robustness pointed out by <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>. (*)<a href="#section-1.1-18.8.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-18.9">
            <p id="section-1.1-18.9.1">Poplar1: Use different Prg invocations for producing the correlated randomness
for inner and leaf nodes of the IDPF tree. This is intended to simplify
implementations. (*)<a href="#section-1.1-18.9.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-18.10">
            <p id="section-1.1-18.10.1">Poplar1: Don't bind the candidate prefixes to the verifier randomness. This is
intended to improve performance, while not impacting security. According to
the analysis of <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>, it is necessary to restrict Poplar1 usage such
that no report is aggregated more than once at a given level of the IDPF tree;
otherwise, attacks on privacy may be possible. In light of this restriction,
there is no added benefit of binding to the prefixes themselves. (*)<a href="#section-1.1-18.10.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-18.11">
            <p id="section-1.1-18.11.1">Poplar1: During preparation, assert that all candidate prefixes are unique
and appear in order. Uniqueness is required to avoid erroneously rejecting a
valid report; the ordering constraint ensures the uniqueness check can be
performed efficiently. (*)<a href="#section-1.1-18.11.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-18.12">
            <p id="section-1.1-18.12.1">Poplar1: Increase the maximum candidate prefix count in the encoding of the
aggregation parameter. (*)<a href="#section-1.1-18.12.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-18.13">
            <p id="section-1.1-18.13.1">Poplar1: Bind the nonce to the correlated randomness derivation. This is
intended to provide defense-in-depth by ensuring the Aggregators reject the
report if the nonce does not match what the Client used for sharding. (*)<a href="#section-1.1-18.13.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-18.14">
            <p id="section-1.1-18.14.1">Poplar1: Clarify that the aggregation parameter encoding is <span class="bcp14">OPTIONAL</span>.
Accordingly, update implementation considerations around cross-aggregation
state.<a href="#section-1.1-18.14.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-18.15">
            <p id="section-1.1-18.15.1">IdpfPoplar: Add implementation considerations around branching on the values
of control bits.<a href="#section-1.1-18.15.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-18.16">
            <p id="section-1.1-18.16.1">IdpfPoplar: When decoding the the control bits in the public share, assert
that the trailing bits of the final byte are all zero. (*)<a href="#section-1.1-18.16.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-19">03:<a href="#section-1.1-19" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-20.1">
            <p id="section-1.1-20.1.1">Define codepoints for (V)DAFs and use them for domain separation in Prio3 and
Poplar1. (*)<a href="#section-1.1-20.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-20.2">
            <p id="section-1.1-20.2.1">Prio3: Align joint randomness computation with revised paper <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>.
This change mitigates an attack on robustness. (*)<a href="#section-1.1-20.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-20.3">
            <p id="section-1.1-20.3.1">Prio3: Remove an intermediate PRG evaluation from query randomness generation.
(*)<a href="#section-1.1-20.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-20.4">
            <p id="section-1.1-20.4.1">Add additional guidance for choosing FFT-friendly fields.<a href="#section-1.1-20.4.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-21">02:<a href="#section-1.1-21" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-22.1">
            <p id="section-1.1-22.1.1">Complete the initial specification of Poplar1.<a href="#section-1.1-22.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-22.2">
            <p id="section-1.1-22.2.1">Extend (V)DAF syntax to include a "public share" output by the Client and
distributed to all of the Aggregators. This is to accommodate "extractable"
IDPFs as required for Poplar1. (See <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>, Section 4.3 for details.)<a href="#section-1.1-22.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-22.3">
            <p id="section-1.1-22.3.1">Extend (V)DAF syntax to allow the unsharding step to take into account the
number of measurements aggregated.<a href="#section-1.1-22.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-22.4">
            <p id="section-1.1-22.4.1">Extend FLP syntax by adding a method for decoding the aggregate result from a
vector of field elements. The new method takes into account the number of
measurements.<a href="#section-1.1-22.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-22.5">
            <p id="section-1.1-22.5.1">Prio3: Align aggregate result computation with updated FLP syntax.<a href="#section-1.1-22.5.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-22.6">
            <p id="section-1.1-22.6.1">Prg: Add a method for statefully generating a vector of field elements.<a href="#section-1.1-22.6.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-22.7">
            <p id="section-1.1-22.7.1">Field: Require that field elements are fully reduced before decoding. (*)<a href="#section-1.1-22.7.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-22.8">
            <p id="section-1.1-22.8.1">Define new field Field255.<a href="#section-1.1-22.8.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-23">01:<a href="#section-1.1-23" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-24.1">
            <p id="section-1.1-24.1.1">Require that VDAFs specify serialization of aggregate shares.<a href="#section-1.1-24.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-24.2">
            <p id="section-1.1-24.2.1">Define Distributed Aggregation Functions (DAFs).<a href="#section-1.1-24.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-24.3">
            <p id="section-1.1-24.3.1">Prio3: Move proof verifier check from <code>prep_next()</code> to
<code>prep_shares_to_prep()</code>. (*)<a href="#section-1.1-24.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-24.4">
            <p id="section-1.1-24.4.1">Remove public parameter and replace verification parameter with a
"verification key" and "Aggregator ID".<a href="#section-1.1-24.4.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
</section>
</div>
<div id="conventions">
<section id="section-2">
      <h2 id="name-conventions-and-definitions">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-conventions-and-definitions" class="section-name selfRef">Conventions and Definitions</a>
      </h2>
<p id="section-2-1">The key words "<span class="bcp14">MUST</span>", "<span class="bcp14">MUST NOT</span>", "<span class="bcp14">REQUIRED</span>", "<span class="bcp14">SHALL</span>", "<span class="bcp14">SHALL NOT</span>", "<span class="bcp14">SHOULD</span>", "<span class="bcp14">SHOULD NOT</span>", "<span class="bcp14">RECOMMENDED</span>", "<span class="bcp14">NOT RECOMMENDED</span>",
"<span class="bcp14">MAY</span>", and "<span class="bcp14">OPTIONAL</span>" in this document are to be interpreted as
described in BCP 14 <span>[<a href="#RFC2119" class="cite xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="cite xref">RFC8174</a>]</span> when, and only when, they
appear in all capitals, as shown here.<a href="#section-2-1" class="pilcrow">¶</a></p>
<p id="section-2-2">Algorithms in this document are written in Python 3. Type hints are used to
define input and output types. The type variable <code>F</code> is used in signatures to
signify any type that is a subclass of <code>Field</code>. A fatal error in a program
(e.g., failure to parse one of the function parameters) is usually handled by
raising an exception.<a href="#section-2-2" class="pilcrow">¶</a></p>
<p id="section-2-3">A variable with type <code>bytes</code> is a byte string. This document defines several
byte-string constants. When comprised of printable ASCII characters, they are
written as Python 3 byte-string literals (e.g., <code>b'some constant string'</code>).<a href="#section-2-3" class="pilcrow">¶</a></p>
<p id="section-2-4">A global constant <code>VERSION</code> of type <code>int</code> is defined, which algorithms are
free to use as desired. Its value <span class="bcp14">SHALL</span> be <code>12</code>.<a href="#section-2-4" class="pilcrow">¶</a></p>
<p id="section-2-5">This document describes algorithms for multi-party computations in which the
parties typically communicate over a network. Wherever a quantity is defined
that must be be transmitted from one party to another, this document prescribes
a particular encoding of that quantity as a byte string.<a href="#section-2-5" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-2-6.1">
          <p id="section-2-6.1.1">OPEN ISSUE It might be better to not be prescriptive about how quantities are
encoded on the wire. See issue #58.<a href="#section-2-6.1.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-2-7">Some common functionalities:<a href="#section-2-7" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-2-8.1">
          <p id="section-2-8.1.1"><code>zeros(len: int) -&gt; bytes</code> returns an array of zero bytes. The length of
<code>output</code> <span class="bcp14">MUST</span> be <code>len</code>.<a href="#section-2-8.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-8.2">
          <p id="section-2-8.2.1"><code>gen_rand(len: int) -&gt; bytes</code> returns an array of random bytes generated by a
cryptographically secure pseudorandom number generator (CSPRNG). The length
of <code>output</code> <span class="bcp14">MUST</span> be <code>len</code>.<a href="#section-2-8.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-8.3">
          <p id="section-2-8.3.1"><code>byte(int: int) -&gt; bytes</code> returns the representation of <code>int</code> as a byte
string. The value of <code>int</code> <span class="bcp14">MUST</span> be in <code>[0,256)</code>.<a href="#section-2-8.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-8.4">
          <p id="section-2-8.4.1"><code>concat(parts: list[bytes]) -&gt; bytes</code> returns the concatenation of the input
byte strings, i.e., <code>parts[0] || ... || parts[len(parts)-1]</code>.<a href="#section-2-8.4.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-8.5">
          <p id="section-2-8.5.1"><code>front(length: int, vec: list[Any]) -&gt; (list[Any], list[Any])</code> splits <code>vec</code>
into two vectors, where the first vector is made up of the first <code>length</code>
elements of the input. I.e., <code>(vec[:length], vec[length:])</code>.<a href="#section-2-8.5.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-8.6">
          <p id="section-2-8.6.1"><code>xor(left: bytes, right: bytes) -&gt; bytes</code> returns the bitwise XOR of <code>left</code>
and <code>right</code>. An exception is raised if the inputs are not the same length.<a href="#section-2-8.6.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-8.7">
          <p id="section-2-8.7.1"><code>to_be_bytes(val: int, length: int) -&gt; bytes</code> converts <code>val</code> to big-endian
bytes; its value <span class="bcp14">MUST</span> be at least <code>0</code> but less than <code>2**(8*length)</code>. Function
<code>from_be_bytes(encoded: bytes) -&gt; int</code> computes the inverse.<a href="#section-2-8.7.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-8.8">
          <p id="section-2-8.8.1"><code>to_le_bytes(val: int, length: int) -&gt; bytes</code> converts <code>val</code> to little-endian
bytes; its value <span class="bcp14">MUST</span> be at least <code>0</code> but less than <code>2**(8*length)</code>. Function
<code>from_le_bytes(encoded: bytes) -&gt; int</code> computes the inverse.<a href="#section-2-8.8.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-8.9">
          <p id="section-2-8.9.1"><code>next_power_of_2(n: int) -&gt; int</code> returns the smallest integer
greater than or equal to <code>n</code> that is also a power of two.<a href="#section-2-8.9.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-8.10">
          <p id="section-2-8.10.1"><code>additive_secret_share(vec: list[Field], num_shares: int, field: type)
-&gt; list[list[Field]]</code> takes a vector of field elements and returns multiple
vectors of the same length, such that they all add up to the input vector,
and each proper subset of the vectors are indistinguishable from random.<a href="#section-2-8.10.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-8.11">
          <p id="section-2-8.11.1"><code>cast(typ: type, val: object) -&gt; object</code> returns the input value unchanged.
This is only present to assist with static analysis of the Python code.
Type checkers will ignore the inferred type of the input value, and assume
the output value has the given type.<a href="#section-2-8.11.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-8.12">
          <p id="section-2-8.12.1"><code>range(stop)</code> or <code>range(start, stop[, step])</code> is the range function from the
Python standard library. The one-argument form returns the integers from zero
(inclusive) to <code>stop</code>, exclusive. The two- and three-argument forms allow
overriding the start of the range and overriding the step between successive
output values.<a href="#section-2-8.12.1" class="pilcrow">¶</a></p>
</li>
      </ul>
</section>
</div>
<div id="overview">
<section id="section-3">
      <h2 id="name-overview">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-overview" class="section-name selfRef">Overview</a>
      </h2>
<span id="name-overall-data-flow-of-a-vdaf"></span><div id="overall-flow">
<figure id="figure-1">
        <div class="alignLeft art-text artwork" id="section-3-1.1">
<pre>
                 +--------------+
           +----&gt;| Aggregator 0 |----+
           |     +--------------+    |
           |             ^           |
           |             |           |
           |             V           |
           |     +--------------+    |
           | +--&gt;| Aggregator 1 |--+ |
           | |   +--------------+  | |
+--------+-+ |           ^         | +-&gt;+-----------+
| Client |---+           |         +---&gt;| Collector |--&gt; Aggregate
+--------+-+                         +-&gt;+-----------+
           |            ...          |
           |                         |
           |             |           |
           |             V           |
           |    +----------------+   |
           +---&gt;| Aggregator N-1 |---+
                +----------------+

      Input shares           Aggregate shares
</pre>
</div>
<figcaption><a href="#figure-1" class="selfRef">Figure 1</a>:
<a href="#name-overall-data-flow-of-a-vdaf" class="selfRef">Overall data flow of a (V)DAF</a>
        </figcaption></figure>
</div>
<p id="section-3-2">In a DAF- or VDAF-based private measurement system, we distinguish three types
of actors: Clients, Aggregators, and Collectors.  The overall flow of the
measurement process is as follows:<a href="#section-3-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3-3.1">
          <p id="section-3-3.1.1">To submit an individual measurement, the Client shards the measurement into
"input shares" and sends one input share to each Aggregator. We sometimes
refer to this sequence of input shares collectively as the Client's "report".<a href="#section-3-3.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-3-3.2">
          <p id="section-3-3.2.1">The Aggregators refine their input shares into "output shares".<a href="#section-3-3.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3-3.2.2.1">
              <p id="section-3-3.2.2.1.1">Output shares are in one-to-one correspondence with the input shares.<a href="#section-3-3.2.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-3-3.2.2.2">
              <p id="section-3-3.2.2.2.1">Just as each Aggregator receives one input share of each measurement, if
this process succeeds, then each aggregator holds one output share.<a href="#section-3-3.2.2.2.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-3-3.2.2.3">
              <p id="section-3-3.2.2.3.1">In VDAFs, Aggregators will need to exchange information among themselves
as part of the validation process.<a href="#section-3-3.2.2.3.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</li>
        <li class="normal" id="section-3-3.3">
          <p id="section-3-3.3.1">Each Aggregator combines the output shares in the batch to compute the
"aggregate share" for that batch, i.e., its share of the desired aggregate
result.<a href="#section-3-3.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-3-3.4">
          <p id="section-3-3.4.1">The Aggregators submit their aggregate shares to the Collector, who combines
them to obtain the aggregate result over the batch.<a href="#section-3-3.4.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-3-4">Aggregators are a new class of actor relative to traditional measurement systems
where Clients submit measurements to a single server.  They are critical for
both the privacy properties of the system and, in the case of VDAFs, the
correctness of the measurements obtained.  The privacy properties of the system
are assured by non-collusion among Aggregators, and Aggregators are the entities
that perform validation of Client measurements.  Thus Clients trust Aggregators
not to collude (typically it is required that at least one Aggregator is
honest; see <a href="#num-aggregators" class="auto internal xref">Section 9.7</a>), and Collectors trust Aggregators to correctly
run the protocol.<a href="#section-3-4" class="pilcrow">¶</a></p>
<p id="section-3-5">Within the bounds of the non-collusion requirements of a given (V)DAF instance,
it is possible for the same entity to play more than one role.  For example, the
Collector could also act as an Aggregator, effectively using the other
Aggregator(s) to augment a basic client-server protocol.<a href="#section-3-5" class="pilcrow">¶</a></p>
<p id="section-3-6">In this document, we describe the computations performed by the actors in this
system. It is up to the higher-level protocol making use of the (V)DAF to
arrange for the required information to be delivered to the proper actors in the
proper sequence. In general, we assume that all communications are confidential
and mutually authenticated, with the exception that Clients submitting
measurements may be anonymous.<a href="#section-3-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="daf">
<section id="section-4">
      <h2 id="name-definition-of-dafs">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-definition-of-dafs" class="section-name selfRef">Definition of DAFs</a>
      </h2>
<p id="section-4-1">By way of a gentle introduction to VDAFs, this section describes a simpler class
of schemes called Distributed Aggregation Functions (DAFs). Unlike VDAFs, DAFs
do not provide verifiability of the computation. Clients must therefore be
trusted to compute their input shares correctly. Because of this fact, the use
of a DAF is <span class="bcp14">NOT RECOMMENDED</span> for most applications. See <a href="#security" class="auto internal xref">Section 9</a> for
additional discussion.<a href="#section-4-1" class="pilcrow">¶</a></p>
<p id="section-4-2">A DAF scheme is used to compute a particular "aggregation function" over a set
of measurements generated by Clients. Depending on the aggregation function, the
Collector might select an "aggregation parameter" and disseminates it to the
Aggregators. The semantics of this parameter is specific to the aggregation
function, but in general it is used to represent the set of "queries" that can
be made on the measurement set. For example, the aggregation parameter is used
to represent the candidate prefixes in Poplar1 <a href="#poplar1" class="auto internal xref">Section 8</a>.<a href="#section-4-2" class="pilcrow">¶</a></p>
<p id="section-4-3">Execution of a DAF has four distinct stages:<a href="#section-4-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4-4.1">
          <p id="section-4-4.1.1">Sharding - Each Client generates input shares from its measurement and
distributes them among the Aggregators.<a href="#section-4-4.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-4-4.2">
          <p id="section-4-4.2.1">Preparation - Each Aggregator converts each input share into an output share
compatible with the aggregation function. This computation involves the
aggregation parameter. In general, each aggregation parameter may result in a
different an output share.<a href="#section-4-4.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-4-4.3">
          <p id="section-4-4.3.1">Aggregation - Each Aggregator combines a sequence of output shares into its
aggregate share and sends the aggregate share to the Collector.<a href="#section-4-4.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-4-4.4">
          <p id="section-4-4.4.1">Unsharding - The Collector combines the aggregate shares into the aggregate
result.<a href="#section-4-4.4.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-4-5">Sharding and Preparation are done once per measurement. Aggregation and
Unsharding are done over a batch of measurements (more precisely, over the
recovered output shares).<a href="#section-4-5" class="pilcrow">¶</a></p>
<p id="section-4-6">A concrete DAF specifies an algorithm for the computation needed in each of
these stages. The interface of each algorithm is defined in the remainder of
this section. In addition, a concrete DAF defines the associated constants and
types enumerated in the following table.<a href="#section-4-6" class="pilcrow">¶</a></p>
<span id="name-constants-and-types-defined"></span><div id="daf-param">
<table class="center" id="table-1">
        <caption>
<a href="#table-1" class="selfRef">Table 1</a>:
<a href="#name-constants-and-types-defined" class="selfRef">Constants and types defined by each concrete DAF.</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Parameter</th>
            <th class="text-left" rowspan="1" colspan="1">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>ID: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Algorithm identifier for this DAF, in <code>range(2**32)</code>.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>SHARES: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Number of input shares into which each measurement is sharded.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>NONCE_SIZE: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Size of the nonce passed by the application.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>RAND_SIZE: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Size of the random byte string passed to sharding algorithm.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>Measurement</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each measurement.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>PublicShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each public share.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>InputShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each input share.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>AggParam</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of aggregation parameter.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>OutShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each output share.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>AggShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of the aggregate share.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>AggResult</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of the aggregate result.</td>
          </tr>
        </tbody>
      </table>
</div>
<p id="section-4-8">These types define the inputs and outputs of DAF methods at various stages of
the computation. Some of these values need to be written to the network in
order to carry out the computation. In particular, it is <span class="bcp14">RECOMMENDED</span> that
concrete instantiations of the <code>Daf</code> interface specify a method of encoding the
<code>PublicShare</code>, <code>InputShare</code>, and <code>AggShare</code>.<a href="#section-4-8" class="pilcrow">¶</a></p>
<p id="section-4-9">Each DAF is identified by a unique, 32-bit integer <code>ID</code>. Identifiers for each
(V)DAF specified in this document are defined in <a href="#codepoints" class="auto internal xref">Table 23</a>.<a href="#section-4-9" class="pilcrow">¶</a></p>
<div id="sec-daf-shard">
<section id="section-4.1">
        <h3 id="name-sharding">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-sharding" class="section-name selfRef">Sharding</a>
        </h3>
<p id="section-4.1-1">In order to protect the privacy of its measurements, a DAF Client shards its
measurements into a sequence of input shares. The <code>shard</code> method is used for
this purpose.<a href="#section-4.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.1-2.1">
            <p id="section-4.1-2.1.1"><code>daf.shard(measurement: Measurement, nonce: bytes, rand: bytes) -&gt;
tuple[PublicShare, list[InputShare]]</code> is the randomized sharding algorithm
run by each Client that consumes a measurement and nonce and produces a
"public share" distributed to each of the Aggregate and a corresponding
sequence of input shares, one for each Aggregator.<a href="#section-4.1-2.1.1" class="pilcrow">¶</a></p>
<p id="section-4.1-2.1.2">
Pre-conditions:<a href="#section-4.1-2.1.2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.1-2.1.3.1">
                <p id="section-4.1-2.1.3.1.1"><code>nonce</code> <span class="bcp14">MUST</span> have length equal to <code>NONCE_SIZE</code> and <span class="bcp14">MUST</span> be generated using
a CSPRNG.<a href="#section-4.1-2.1.3.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-4.1-2.1.3.2">
                <p id="section-4.1-2.1.3.2.1"><code>rand</code> consists of the random bytes consumed by the algorithm. It <span class="bcp14">MUST</span> have
length equal to <code>RAND_SIZE</code> and <span class="bcp14">MUST</span> be generated using a CSPRNG.<a href="#section-4.1-2.1.3.2.1" class="pilcrow">¶</a></p>
</li>
            </ul>
<p id="section-4.1-2.1.4">
Post-conditions:<a href="#section-4.1-2.1.4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.1-2.1.5.1">
                <p id="section-4.1-2.1.5.1.1">The number of input shares <span class="bcp14">MUST</span> equal <code>SHARES</code>.<a href="#section-4.1-2.1.5.1.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
        </ul>
<span id="name-the-client-divides-its-meas"></span><div id="shard-flow">
<figure id="figure-2">
          <div class="alignLeft art-text artwork" id="section-4.1-3.1">
<pre>
    Client
    ======

    measurement
      |
      V
    +----------------------------------------------+
    | shard                                        |
    +----------------------------------------------+
      |              |              |     |
      |              |         ...  |    public_share
      |              |              |     |
      |    +---------|-----+--------|-----+
      |    |         |     |        |     |
      V    |         V     |        V     |
     input_share_0  input_share_1  input_share_[SHARES-1]
      |    |         |     |   ...  |     |
      V    V         V     V        V     V
    Aggregator 0   Aggregator 1    Aggregator SHARES-1
</pre>
</div>
<figcaption><a href="#figure-2" class="selfRef">Figure 2</a>:
<a href="#name-the-client-divides-its-meas" class="selfRef">The Client divides its measurement into input shares and distributes them to the Aggregators. The public share is broadcast to all Aggregators.</a>
          </figcaption></figure>
</div>
</section>
</div>
<div id="sec-daf-prepare">
<section id="section-4.2">
        <h3 id="name-preparation">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-preparation" class="section-name selfRef">Preparation</a>
        </h3>
<p id="section-4.2-1">Once an Aggregator has received the public share and one of the input shares,
the next step is to prepare the input share for aggregation. This is
accomplished using the following algorithm:<a href="#section-4.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.2-2.1">
            <p id="section-4.2-2.1.1"><code>daf.prep(agg_id: int, agg_param: AggParam, nonce: bytes, public_share:
PublicShare, input_share: InputShare) -&gt; OutShare</code> is the deterministic
preparation algorithm. It takes as input the public share and one of the
input shares generated by a Client, the Aggregator's unique identifier, the
aggregation parameter selected by the Collector, and a nonce and returns an
output share.<a href="#section-4.2-2.1.1" class="pilcrow">¶</a></p>
<p id="section-4.2-2.1.2">
Pre-conditions:<a href="#section-4.2-2.1.2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.2-2.1.3.1">
                <p id="section-4.2-2.1.3.1.1"><code>agg_id</code> <span class="bcp14">MUST</span> be in <code>range(SHARES)</code> and match the index of
<code>input_share</code> in the sequence of input shares produced by the Client.<a href="#section-4.2-2.1.3.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-4.2-2.1.3.2">
                <p id="section-4.2-2.1.3.2.1"><code>nonce</code> <span class="bcp14">MUST</span> have length <code>NONCE_SIZE</code>.<a href="#section-4.2-2.1.3.2.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
        </ul>
</section>
</div>
<div id="sec-daf-validity-scopes">
<section id="section-4.3">
        <h3 id="name-validity-of-aggregation-par">
<a href="#section-4.3" class="section-number selfRef">4.3. </a><a href="#name-validity-of-aggregation-par" class="section-name selfRef">Validity of Aggregation Parameters</a>
        </h3>
<p id="section-4.3-1">Concrete DAFs implementations <span class="bcp14">MAY</span> impose certain restrictions for input shares
and aggregation parameters. Protocols using a DAF <span class="bcp14">MUST</span> ensure that for each
input share and aggregation parameter <code>agg_param</code>, <code>daf.prep</code> is only called if
<code>daf.is_valid(agg_param, previous_agg_params)</code> returns True, where
<code>previous_agg_params</code> contains all aggregation parameters that have previously
been used with the same input share.<a href="#section-4.3-1" class="pilcrow">¶</a></p>
<p id="section-4.3-2">DAFs <span class="bcp14">MUST</span> implement the following function:<a href="#section-4.3-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3-3.1">
            <p id="section-4.3-3.1.1"><code>daf.is_valid(agg_param: AggParam, previous_agg_params: list[AggParam]) -&gt;
bool</code>: checks if the <code>agg_param</code> is compatible with all elements of
<code>previous_agg_params</code>.<a href="#section-4.3-3.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
<div id="sec-daf-aggregate">
<section id="section-4.4">
        <h3 id="name-aggregation">
<a href="#section-4.4" class="section-number selfRef">4.4. </a><a href="#name-aggregation" class="section-name selfRef">Aggregation</a>
        </h3>
<p id="section-4.4-1">Once an Aggregator holds output shares for a batch of measurements (where
batches are defined by the application), it combines them into a share of the
desired aggregate result:<a href="#section-4.4-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.4-2.1">
            <p id="section-4.4-2.1.1"><code>daf.aggregate(agg_param: AggParam, out_shares: list[OutShare]) -&gt; AggShare</code>
is the deterministic aggregation algorithm. It is run by each Aggregator a
set of recovered output shares.<a href="#section-4.4-2.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<span id="name-aggregation-of-output-share"></span><div id="aggregate-flow">
<figure id="figure-3">
          <div class="alignLeft art-text artwork" id="section-4.4-3.1">
<pre>
    Aggregator 0    Aggregator 1        Aggregator SHARES-1
    ============    ============        ===================

    out_share_0_0   out_share_1_0       out_share_[SHARES-1]_0
    out_share_0_1   out_share_1_1       out_share_[SHARES-1]_1
    out_share_0_2   out_share_1_2       out_share_[SHARES-1]_2
         ...             ...                     ...
    out_share_0_B   out_share_1_B       out_share_[SHARES-1]_B
      |               |                   |
      V               V                   V
    +-----------+   +-----------+       +-----------+
    | aggregate |   | aggregate |   ... | aggregate |
    +-----------+   +-----------+       +-----------+
      |               |                   |
      V               V                   V
    agg_share_0     agg_share_1         agg_share_[SHARES-1]
</pre>
</div>
<figcaption><a href="#figure-3" class="selfRef">Figure 3</a>:
<a href="#name-aggregation-of-output-share" class="selfRef">Aggregation of output shares. `B` indicates the number of measurements in the batch.</a>
          </figcaption></figure>
</div>
<p id="section-4.4-4">For simplicity, we have written this algorithm in a "one-shot" form, where all
output shares for a batch are provided at the same time. Many DAFs may also
support a "streaming" form, where shares are processed one at a time.<a href="#section-4.4-4" class="pilcrow">¶</a></p>
<p id="section-4.4-5">Implementation note: for most natural DAFs (and VDAFs) it is not necessary for
an Aggregator to store all output shares individually before aggregating.
Typically it is possible to merge output shares into aggregate shares as they
arrive, merge these into other aggregate shares, and so on. In particular, this
is the case when the output shares are vectors over some finite field and
aggregating them involves merely adding up the vectors element-wise. Such is the
case for Prio3 <a href="#prio3" class="auto internal xref">Section 7</a> and Poplar1 <a href="#poplar1" class="auto internal xref">Section 8</a>.<a href="#section-4.4-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-daf-unshard">
<section id="section-4.5">
        <h3 id="name-unsharding">
<a href="#section-4.5" class="section-number selfRef">4.5. </a><a href="#name-unsharding" class="section-name selfRef">Unsharding</a>
        </h3>
<p id="section-4.5-1">After the Aggregators have aggregated a sufficient number of output shares, each
sends its aggregate share to the Collector, who runs the following algorithm to
recover the following output:<a href="#section-4.5-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.5-2.1">
            <p id="section-4.5-2.1.1"><code>daf.unshard(agg_param: AggParam, agg_shares: list[AggShare],
num_measurements: int) -&gt; AggResult</code> is run by the Collector in order to
compute the aggregate result from the Aggregators' shares. The length of
<code>agg_shares</code> <span class="bcp14">MUST</span> be <code>SHARES</code>. <code>num_measurements</code> is the number of
measurements that contributed to each of the aggregate shares. This algorithm
is deterministic.<a href="#section-4.5-2.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<span id="name-computation-of-the-final-ag"></span><div id="unshard-flow">
<figure id="figure-4">
          <div class="alignLeft art-text artwork" id="section-4.5-3.1">
<pre>
    Aggregator 0    Aggregator 1        Aggregator SHARES-1
    ============    ============        ===================

    agg_share_0     agg_share_1         agg_share_[SHARES-1]
      |               |                   |
      V               V                   V
    +-----------------------------------------------+
    | unshard                                       |
    +-----------------------------------------------+
      |
      V
    agg_result

    Collector
    =========
</pre>
</div>
<figcaption><a href="#figure-4" class="selfRef">Figure 4</a>:
<a href="#name-computation-of-the-final-ag" class="selfRef">Computation of the final aggregate result from aggregate shares.</a>
          </figcaption></figure>
</div>
</section>
</div>
<div id="daf-execution">
<section id="section-4.6">
        <h3 id="name-execution-of-a-daf">
<a href="#section-4.6" class="section-number selfRef">4.6. </a><a href="#name-execution-of-a-daf" class="section-name selfRef">Execution of a DAF</a>
        </h3>
<p id="section-4.6-1">Securely executing a DAF involves emulating the following procedure.<a href="#section-4.6-1" class="pilcrow">¶</a></p>
<span id="name-execution-of-a-daf-2"></span><div id="run-daf">
<figure id="figure-5">
          <div class="breakable lang-python sourcecode" id="section-4.6-2.1">
<pre>
def run_daf(
        daf: Daf[
            Measurement,
            AggParam,
            PublicShare,
            InputShare,
            OutShare,
            AggShare,
            AggResult,
        ],
        agg_param: AggParam,
        measurements: list[Measurement],
        nonces: list[bytes]) -&gt; AggResult:
    """
    Run a DAF on a list of measurements.

    Pre-conditions:

        - `type(agg_param) == daf.AggParam`
        - `type(measurement) == daf.Measurement` for each
          `measurement` in `measurements`
        - `len(nonce) == daf.NONCE_SIZE` for each `nonce` in `nonces`
        - `len(nonces) == len(measurements)`
    """
    if any(len(nonce) != daf.NONCE_SIZE for nonce in nonces):
        raise ValueError("incorrect nonce size")
    if len(nonces) != len(measurements):
        raise ValueError(
            "measurements and nonces lists have different lengths"
        )

    out_shares: list[list[OutShare]]
    out_shares = [[] for j in range(daf.SHARES)]
    for (measurement, nonce) in zip(measurements, nonces):
        # Each Client shards its measurement into input shares and
        # distributes them among the Aggregators.
        rand = gen_rand(daf.RAND_SIZE)
        (public_share, input_shares) = \
            daf.shard(measurement, nonce, rand)

        # Each Aggregator prepares its input share for aggregation.
        for j in range(daf.SHARES):
            out_shares[j].append(
                daf.prep(j, agg_param, nonce,
                         public_share, input_shares[j]))

    # Each Aggregator aggregates its output shares into an aggregate
    # share and sends it to the Collector.
    agg_shares = []
    for j in range(daf.SHARES):
        agg_share_j = daf.aggregate(agg_param,
                                    out_shares[j])
        agg_shares.append(agg_share_j)

    # Collector unshards the aggregate result.
    num_measurements = len(measurements)
    agg_result = daf.unshard(agg_param, agg_shares,
                             num_measurements)
    return agg_result
</pre>
</div>
<figcaption><a href="#figure-5" class="selfRef">Figure 5</a>:
<a href="#name-execution-of-a-daf-2" class="selfRef">Execution of a DAF.</a>
          </figcaption></figure>
</div>
<p id="section-4.6-3">The inputs to this procedure are the same as the aggregation function computed by
the DAF: an aggregation parameter and a sequence of measurements. The procedure
prescribes how a DAF is executed in a "benign" environment in which there is no
adversary and the messages are passed among the protocol participants over
secure point-to-point channels. In reality, these channels need to be
instantiated by some "wrapper protocol", such as <span>[<a href="#DAP" class="cite xref">DAP</a>]</span>,
that realizes these channels using suitable cryptographic mechanisms. Moreover,
some fraction of the Aggregators (or Clients) may be malicious and diverge from
their prescribed behaviors. <a href="#security" class="auto internal xref">Section 9</a> describes the execution of the DAF in
various adversarial environments and what properties the wrapper protocol needs
to provide in each.<a href="#section-4.6-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="vdaf">
<section id="section-5">
      <h2 id="name-definition-of-vdafs">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-definition-of-vdafs" class="section-name selfRef">Definition of VDAFs</a>
      </h2>
<p id="section-5-1">Like DAFs described in the previous section, a VDAF scheme is used to compute a
particular aggregation function over a set of Client-generated measurements.
Evaluation of a VDAF involves the same four stages as for DAFs: Sharding,
Preparation, Aggregation, and Unsharding. However, the Preparation stage will
require interaction among the Aggregators in order to facilitate verifiability
of the computation's correctness. Accommodating this interaction will require
syntactic changes.<a href="#section-5-1" class="pilcrow">¶</a></p>
<p id="section-5-2">Overall execution of a VDAF comprises the following stages:<a href="#section-5-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5-3.1">
          <p id="section-5-3.1.1">Sharding - Computing input shares from an individual measurement<a href="#section-5-3.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-5-3.2">
          <p id="section-5-3.2.1">Preparation - Conversion and verification of input shares to output shares
compatible with the aggregation function being computed<a href="#section-5-3.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-5-3.3">
          <p id="section-5-3.3.1">Aggregation - Combining a sequence of output shares into an aggregate share<a href="#section-5-3.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-5-3.4">
          <p id="section-5-3.4.1">Unsharding - Combining a sequence of aggregate shares into an aggregate
result<a href="#section-5-3.4.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-5-4">In contrast to DAFs, the Preparation stage for VDAFs now performs an additional
task: verification of the validity of the recovered output shares. This process
ensures that aggregating the output shares will not lead to a garbled aggregate
result.<a href="#section-5-4" class="pilcrow">¶</a></p>
<p id="section-5-5">The remainder of this section defines the VDAF interface. The attributes are
listed in <a href="#vdaf-param" class="auto internal xref">Table 2</a> are defined by each concrete VDAF.<a href="#section-5-5" class="pilcrow">¶</a></p>
<span id="name-constants-and-types-defined-"></span><div id="vdaf-param">
<table class="center" id="table-2">
        <caption>
<a href="#table-2" class="selfRef">Table 2</a>:
<a href="#name-constants-and-types-defined-" class="selfRef">Constants and types defined by each concrete VDAF.</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Parameter</th>
            <th class="text-left" rowspan="1" colspan="1">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>ID</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Algorithm identifier for this VDAF.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>VERIFY_KEY_SIZE</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Size (in bytes) of the verification key (<a href="#sec-vdaf-prepare" class="auto internal xref">Section 5.2</a>).</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>RAND_SIZE</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Size of the random byte string passed to sharding algorithm.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>NONCE_SIZE</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Size (in bytes) of the nonce.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>ROUNDS</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Number of rounds of communication during the Preparation stage (<a href="#sec-vdaf-prepare" class="auto internal xref">Section 5.2</a>).</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>SHARES</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Number of input shares into which each measurement is sharded (<a href="#sec-vdaf-shard" class="auto internal xref">Section 5.1</a>).</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>Measurement</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each measurement.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>PublicShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each public share.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>InputShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each input share.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>AggParam</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of aggregation parameter.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>OutShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each output share.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>AggShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of the aggregate share.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>AggResult</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of the aggregate result.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>PrepState</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Aggregator's state during preparation.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>PrepShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each prep share.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>PrepMessage</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each prep message.</td>
          </tr>
        </tbody>
      </table>
</div>
<p id="section-5-7">Some of these values need to be written to the network in order to carry out
the computation. In particular, it is <span class="bcp14">RECOMMENDED</span> that concrete instantiations
of the <code>Vdaf</code> interface specify a method of encoding the <code>PublicShare</code>,
<code>InputShare</code>, <code>AggShare</code>, <code>PrepShare</code>, and <code>PrepMessage</code>.<a href="#section-5-7" class="pilcrow">¶</a></p>
<p id="section-5-8">Each VDAF is identified by a unique, 32-bit integer <code>ID</code>. Identifiers for each
(V)DAF specified in this document are defined in <a href="#codepoints" class="auto internal xref">Table 23</a>. The following
method is defined for every VDAF:<a href="#section-5-8" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-5-9">
<pre>
def domain_separation_tag(self, usage: int) -&gt; bytes:
    """
    Format domain separation tag for this VDAF with the given usage.

    Pre-conditions:

        - `usage` in `range(2**16)`
    """
    return format_dst(0, self.ID, usage)
</pre><a href="#section-5-9" class="pilcrow">¶</a>
</div>
<p id="section-5-10">It is used to construct a domain separation tag for an instance of <code>Xof</code> used by
the VDAF. (See <a href="#xof" class="auto internal xref">Section 6.2</a>.)<a href="#section-5-10" class="pilcrow">¶</a></p>
<div id="sec-vdaf-shard">
<section id="section-5.1">
        <h3 id="name-sharding-2">
<a href="#section-5.1" class="section-number selfRef">5.1. </a><a href="#name-sharding-2" class="section-name selfRef">Sharding</a>
        </h3>
<p id="section-5.1-1">Sharding transforms a measurement and nonce into a public share and input shares
as it does in DAFs (cf. <a href="#sec-daf-shard" class="auto internal xref">Section 4.1</a>):<a href="#section-5.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.1-2.1">
            <p id="section-5.1-2.1.1"><code>vdaf.shard(measurement: Measurement, nonce: bytes, rand: bytes) -&gt;
tuple[PublicShare, list[InputShare]]</code> is the randomized sharding algorithm
run by each Client that consumes a measurement and nonce and produces a
public share distributed to each of the Aggregate and a corresponding
sequence of input shares, one for each Aggregator. Depending on the VDAF, the
input shares may encode additional information used to verify the recovered
output shares (e.g., the "proof shares" in Prio3 <a href="#prio3" class="auto internal xref">Section 7</a>)<a href="#section-5.1-2.1.1" class="pilcrow">¶</a></p>
<p id="section-5.1-2.1.2">
Pre-conditions:<a href="#section-5.1-2.1.2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.1-2.1.3.1">
                <p id="section-5.1-2.1.3.1.1"><code>nonce</code> <span class="bcp14">MUST</span> have length equal to <code>NONCE_SIZE</code> and <span class="bcp14">MUST</span> be generated using
a CSPRNG. (See <a href="#security" class="auto internal xref">Section 9</a> for details.)<a href="#section-5.1-2.1.3.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-5.1-2.1.3.2">
                <p id="section-5.1-2.1.3.2.1"><code>rand</code> consists of the random bytes consumed by the algorithm. It <span class="bcp14">MUST</span> have
length equal to <code>RAND_SIZE</code> and <span class="bcp14">MUST</span> be generated using a CSPRNG.<a href="#section-5.1-2.1.3.2.1" class="pilcrow">¶</a></p>
</li>
            </ul>
<p id="section-5.1-2.1.4">
Post-conditions:<a href="#section-5.1-2.1.4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.1-2.1.5.1">
                <p id="section-5.1-2.1.5.1.1">The number of input shares <span class="bcp14">MUST</span> equal <code>SHARES</code>.<a href="#section-5.1-2.1.5.1.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
        </ul>
</section>
</div>
<div id="sec-vdaf-prepare">
<section id="section-5.2">
        <h3 id="name-preparation-2">
<a href="#section-5.2" class="section-number selfRef">5.2. </a><a href="#name-preparation-2" class="section-name selfRef">Preparation</a>
        </h3>
<p id="section-5.2-1">To recover and verify output shares, the Aggregators interact with one another
over <code>ROUNDS</code> rounds. Prior to each round, each Aggregator constructs an
outbound message. Next, the sequence of outbound messages is combined into a
single message, called a "preparation message", or "prep message" for short.
(Each of the outbound messages are called "preparation-message shares", or
"prep shares" for short.) Finally, the preparation message is distributed to
the Aggregators to begin the next round.<a href="#section-5.2-1" class="pilcrow">¶</a></p>
<p id="section-5.2-2">An Aggregator begins the first round with its input share and it begins each
subsequent round with the previous prep message. Its output in the last round
is its output share and its output in each of the preceding rounds is a prep
share.<a href="#section-5.2-2" class="pilcrow">¶</a></p>
<p id="section-5.2-3">This process involves a value called the "aggregation parameter" used to map the
input shares to output shares. The Aggregators need to agree on this parameter
before they can begin preparing the measurement shares for aggregation.<a href="#section-5.2-3" class="pilcrow">¶</a></p>
<span id="name-vdaf-preparation-process-on"></span><div id="prep-flow">
<figure id="figure-6">
          <div class="alignLeft art-text artwork" id="section-5.2-4.1">
<pre>
    Aggregator 0   Aggregator 1           Aggregator SHARES-1
    ============   ============           ===================

    input_share_0  input_share_1          input_share_[SHARES-1]
      |              |                 ...  |
      V              V                      V
    +-----------+  +-----------+          +-----------+
    | prep_init |  | prep_init |          | prep_init |
    +-----------+  +-----------+          +-----------+
      |       |      |       |         ...  |       |
      V       |      V       |              V       |
    +---------|--------------|----------------------|-+   \
    |         |              | prep_shares_to_prep  | |   |
    +---------|--------------|----------------------|-+   |
      |       |      |       |         ...  |       |     |
      V       V      V       V              V       |     | x ROUNDS
    +-----------+  +-----------+          +-----------+   |
    | prep_next |  | prep_next |          | prep_next |   |
    +-----------+  +-----------+          +-----------+   |
      |       |      |                 ...  |       |     |
      V       V      V                      V       V     /
     ...            ...                    ...
      |              |                 ...  |
      V              V                      V
    out_share_0    out_share_1         out_share_[SHARES-1]
</pre>
</div>
<figcaption><a href="#figure-6" class="selfRef">Figure 6</a>:
<a href="#name-vdaf-preparation-process-on" class="selfRef">VDAF preparation process on the input shares for a single measurement. At the end of the computation, each Aggregator holds an output share or an error.</a>
          </figcaption></figure>
</div>
<p id="section-5.2-5">To facilitate the preparation process, a concrete VDAF implements the following
methods:<a href="#section-5.2-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.2-6.1">
            <p id="section-5.2-6.1.1"><code>vdaf.prep_init(verify_key: bytes, agg_id: int, agg_param: AggParam, nonce:
bytes, public_share: PublicShare, input_share: InputShare) -&gt;
tuple[PrepState, PrepShare]</code> is the deterministic preparation-state
initialization algorithm run by each Aggregator to begin processing its input
share into an output share. Its inputs are the shared verification key
(<code>verify_key</code>), the Aggregator's unique identifier (<code>agg_id</code>), the
aggregation parameter (<code>agg_param</code>), the nonce provided by the environment
(<code>nonce</code>, see <a href="#run-vdaf" class="auto internal xref">Figure 7</a>), the public share (<code>public_share</code>), and one of
the input shares generated by the Client (<code>input_share</code>). Its output is the
Aggregator's initial preparation state and initial prep share.<a href="#section-5.2-6.1.1" class="pilcrow">¶</a></p>
<p id="section-5.2-6.1.2">
It is up to the high level protocol in which the VDAF is used to arrange for
the distribution of the verification key prior to generating and processing
reports. (See <a href="#security" class="auto internal xref">Section 9</a> for details.)<a href="#section-5.2-6.1.2" class="pilcrow">¶</a></p>
<p id="section-5.2-6.1.3">
Protocols <span class="bcp14">MUST</span> ensure that public share consumed by each of the Aggregators is
identical. This is security critical for VDAFs such as Poplar1.<a href="#section-5.2-6.1.3" class="pilcrow">¶</a></p>
<p id="section-5.2-6.1.4">
Pre-conditions:<a href="#section-5.2-6.1.4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.2-6.1.5.1">
                <p id="section-5.2-6.1.5.1.1"><code>verify_key</code> <span class="bcp14">MUST</span> have length <code>vdaf.VERIFY_KEY_SIZE</code>.<a href="#section-5.2-6.1.5.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-5.2-6.1.5.2">
                <p id="section-5.2-6.1.5.2.1"><code>agg_id</code> <span class="bcp14">MUST</span> be the integer in <code>range(vdaf.SHARES)</code> that matches the
index of <code>input_share</code> in the sequence of input shares output by the
Client.<a href="#section-5.2-6.1.5.2.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-5.2-6.1.5.3">
                <p id="section-5.2-6.1.5.3.1"><code>nonce</code> <span class="bcp14">MUST</span> have length <code>vdaf.NONCE_SIZE</code>.<a href="#section-5.2-6.1.5.3.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
          <li class="normal" id="section-5.2-6.2">
            <p id="section-5.2-6.2.1"><code>vdaf.prep_next(prep_state: PrepState, prep_msg: PrepMessage) -&gt;
tuple[PrepState, PrepShare] | OutShare</code> is the deterministic
preparation-state update algorithm run by each Aggregator. It updates the
Aggregator's preparation state (<code>prep_state</code>) and returns either its next
preparation state and its message share for the current round or, if this is
the last round, its output share. An exception is raised if a valid output
share could not be recovered. The input of this algorithm is the inbound
preparation message.<a href="#section-5.2-6.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-5.2-6.3">
            <p id="section-5.2-6.3.1"><code>vdaf.prep_shares_to_prep(agg_param: AggParam, prep_shares: list[PrepShare])
-&gt; PrepMessage</code> is the deterministic preparation-message pre-processing
algorithm. It combines the prep shares generated by the Aggregators in the
previous round into the prep message consumed by each in the next round.<a href="#section-5.2-6.3.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-5.2-7">In effect, each Aggregator moves through a linear state machine with <code>ROUNDS</code>
states.  The Aggregator enters the first state on using the initialization
algorithm, and the update algorithm advances the Aggregator to the next state.
Thus, in addition to defining the number of rounds (<code>ROUNDS</code>), a VDAF instance
defines the state of the Aggregator after each round.<a href="#section-5.2-7" class="pilcrow">¶</a></p>
<p id="section-5.2-8">The preparation-state update accomplishes two tasks: recovery of output shares
from the input shares and ensuring that the recovered output shares are valid.
The abstraction boundary is drawn so that an Aggregator only recovers an output
share if it is deemed valid (at least, based on the Aggregator's view of the
protocol). Another way to draw this boundary would be to have the Aggregators
recover output shares first, then verify that they are valid. However, this
would allow the possibility of misusing the API by, say, aggregating an invalid
output share. Moreover, in protocols like Prio+ <span>[<a href="#AGJOP21" class="cite xref">AGJOP21</a>]</span> based on oblivious
transfer, it is necessary for the Aggregators to interact in order to recover
aggregatable output shares at all.<a href="#section-5.2-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-vdaf-validity-scopes">
<section id="section-5.3">
        <h3 id="name-validity-of-aggregation-para">
<a href="#section-5.3" class="section-number selfRef">5.3. </a><a href="#name-validity-of-aggregation-para" class="section-name selfRef">Validity of Aggregation Parameters</a>
        </h3>
<p id="section-5.3-1">Similar to DAFs (see <a href="#sec-daf-validity-scopes" class="auto internal xref">Section 4.3</a>), VDAFs <span class="bcp14">MAY</span> impose
restrictions for input shares and aggregation parameters. Protocols using a VDAF
<span class="bcp14">MUST</span> ensure that for each input share and aggregation parameter <code>agg_param</code>, the
preparation phase (including <code>vdaf.prep_init</code>, <code>vdaf.prep_next</code>, and
<code>vdaf.prep_shares_to_prep</code>; see <a href="#sec-vdaf-prepare" class="auto internal xref">Section 5.2</a>) is only called if
<code>vdaf.is_valid(agg_param, previous_agg_params)</code> returns True, where
<code>previous_agg_params</code> contains all aggregation parameters that have previously
been used with the same input share.<a href="#section-5.3-1" class="pilcrow">¶</a></p>
<p id="section-5.3-2">VDAFs <span class="bcp14">MUST</span> implement the following function:<a href="#section-5.3-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.3-3.1">
            <p id="section-5.3-3.1.1"><code>vdaf.is_valid(agg_param: AggParam, previous_agg_params: list[AggParam]) -&gt;
bool</code>: checks if the <code>agg_param</code> is compatible with all elements of
<code>previous_agg_params</code>.<a href="#section-5.3-3.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
<div id="sec-vdaf-aggregate">
<section id="section-5.4">
        <h3 id="name-aggregation-2">
<a href="#section-5.4" class="section-number selfRef">5.4. </a><a href="#name-aggregation-2" class="section-name selfRef">Aggregation</a>
        </h3>
<p id="section-5.4-1">VDAF Aggregation is identical to DAF Aggregation (cf. <a href="#sec-daf-aggregate" class="auto internal xref">Section 4.4</a>):<a href="#section-5.4-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.4-2.1">
            <p id="section-5.4-2.1.1"><code>vdaf.aggregate(agg_param: AggParam, out_shares: list[OutShare]) -&gt; AggShare</code>
is the deterministic aggregation algorithm. It is run by each Aggregator over
the output shares it has computed for a batch of measurements.<a href="#section-5.4-2.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-5.4-3">The data flow for this stage is illustrated in <a href="#aggregate-flow" class="auto internal xref">Figure 3</a>. Here again,
we have the aggregation algorithm in a "one-shot" form, where all shares for a
batch are provided at the same time. VDAFs typically also support a "streaming"
form, where shares are processed one at a time.<a href="#section-5.4-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-vdaf-unshard">
<section id="section-5.5">
        <h3 id="name-unsharding-2">
<a href="#section-5.5" class="section-number selfRef">5.5. </a><a href="#name-unsharding-2" class="section-name selfRef">Unsharding</a>
        </h3>
<p id="section-5.5-1">VDAF Unsharding is identical to DAF Unsharding (cf. <a href="#sec-daf-unshard" class="auto internal xref">Section 4.5</a>):<a href="#section-5.5-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.5-2.1">
            <p id="section-5.5-2.1.1"><code>vdaf.unshard(agg_param: AggParam, agg_shares: list[AggShare],
num_measurements: int) -&gt; AggResult</code> is run by the Collector in order to
compute the aggregate result from the Aggregators' shares. The length of
<code>agg_shares</code> <span class="bcp14">MUST</span> be <code>SHARES</code>. <code>num_measurements</code> is the number of
measurements that contributed to each of the aggregate shares. This algorithm
is deterministic.<a href="#section-5.5-2.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-5.5-3">The data flow for this stage is illustrated in <a href="#unshard-flow" class="auto internal xref">Figure 4</a>.<a href="#section-5.5-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="vdaf-execution">
<section id="section-5.6">
        <h3 id="name-execution-of-a-vdaf">
<a href="#section-5.6" class="section-number selfRef">5.6. </a><a href="#name-execution-of-a-vdaf" class="section-name selfRef">Execution of a VDAF</a>
        </h3>
<p id="section-5.6-1">Secure execution of a VDAF involves simulating the following procedure.<a href="#section-5.6-1" class="pilcrow">¶</a></p>
<span id="name-execution-of-a-vdaf-2"></span><div id="run-vdaf">
<figure id="figure-7">
          <div class="breakable lang-python sourcecode" id="section-5.6-2.1">
<pre>
def run_vdaf(
        vdaf: Vdaf[
            Measurement,
            AggParam,
            PublicShare,
            InputShare,
            list[F],  # OutShare
            AggShare,
            AggResult,
            PrepState,
            PrepShare,
            PrepMessage,
        ],
        verify_key: bytes,
        agg_param: AggParam,
        nonces: list[bytes],
        measurements: list[Measurement]) -&gt; AggResult:
    """
    Run the VDAF on a list of measurements.

    Pre-conditions:

        - `len(verify_key) == vdaf.VERIFY_KEY_SIZE`
        - `len(nonces) == len(measurements)`
        - `all(len(nonce) == vdaf.NONCE_SIZE for nonce in nonces)`
    """

    if len(verify_key) != vdaf.VERIFY_KEY_SIZE:
        raise ValueError("incorrect verify_key size")
    if any(len(nonce) != vdaf.NONCE_SIZE for nonce in nonces):
        raise ValueError("incorrect nonce size")
    if len(nonces) != len(measurements):
        raise ValueError(
            "measurements and nonces lists have different lengths"
        )

    out_shares = []
    for (nonce, measurement) in zip(nonces, measurements):
        assert len(nonce) == vdaf.NONCE_SIZE

        # Each Client shards its measurement into input shares.
        rand = gen_rand(vdaf.RAND_SIZE)
        (public_share, input_shares) = \
            vdaf.shard(measurement, nonce, rand)

        # Each Aggregator initializes its preparation state.
        prep_states = []
        outbound_prep_shares = []
        for j in range(vdaf.SHARES):
            (state, share) = vdaf.prep_init(verify_key, j,
                                            agg_param,
                                            nonce,
                                            public_share,
                                            input_shares[j])
            prep_states.append(state)
            outbound_prep_shares.append(share)

        # Aggregators recover their output shares.
        for i in range(vdaf.ROUNDS - 1):
            prep_msg = vdaf.prep_shares_to_prep(agg_param,
                                                outbound_prep_shares)
            outbound_prep_shares = []
            for j in range(vdaf.SHARES):
                out = vdaf.prep_next(prep_states[j], prep_msg)
                assert isinstance(out, tuple)
                (prep_states[j], prep_share) = out
                outbound_prep_shares.append(prep_share)

        # The final outputs of the prepare phase are the output
        # shares.
        prep_msg = vdaf.prep_shares_to_prep(agg_param,
                                            outbound_prep_shares)

        outbound_out_shares = []
        for j in range(vdaf.SHARES):
            out_share = vdaf.prep_next(prep_states[j], prep_msg)
            assert not isinstance(out_share, tuple)
            outbound_out_shares.append(out_share)
        out_shares.append(outbound_out_shares)

    # Each Aggregator aggregates its output shares into an
    # aggregate share. In a distributed VDAF computation, the
    # aggregate shares are sent over the network.
    agg_shares = []
    for j in range(vdaf.SHARES):
        out_shares_j = [out[j] for out in out_shares]
        agg_share_j = vdaf.aggregate(agg_param, out_shares_j)
        agg_shares.append(agg_share_j)

    # Collector unshards the aggregate.
    num_measurements = len(measurements)
    agg_result = vdaf.unshard(agg_param, agg_shares,
                              num_measurements)
    return agg_result
</pre>
</div>
<figcaption><a href="#figure-7" class="selfRef">Figure 7</a>:
<a href="#name-execution-of-a-vdaf-2" class="selfRef">Execution of a VDAF.</a>
          </figcaption></figure>
</div>
<p id="section-5.6-3">The inputs to this algorithm are the aggregation parameter, a list of
measurements, and a nonce for each measurement. This document does not specify
how the nonces are chosen, but security requires that the nonces be unique. See
<a href="#security" class="auto internal xref">Section 9</a> for details. As explained in <a href="#daf-execution" class="auto internal xref">Section 4.6</a>, the secure
execution of a VDAF requires the application to instantiate secure channels
between each of the protocol participants.<a href="#section-5.6-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="vdaf-prep-comm">
<section id="section-5.7">
        <h3 id="name-communication-patterns-for-">
<a href="#section-5.7" class="section-number selfRef">5.7. </a><a href="#name-communication-patterns-for-" class="section-name selfRef">Communication Patterns for Preparation</a>
        </h3>
<p id="section-5.7-1">In each round of preparation, each Aggregator writes a prep share to some
broadcast channel, which is then processed into the prep message using the
public <code>prep_shares_to_prep()</code> algorithm and broadcast to the Aggregators to
start the next round. In this section we describe some approaches to realizing
this broadcast channel functionality in protocols that use VDAFs.<a href="#section-5.7-1" class="pilcrow">¶</a></p>
<p id="section-5.7-2">The state machine of each Aggregator is shown in <a href="#vdaf-prep-state-machine" class="auto internal xref">Figure 8</a>.<a href="#section-5.7-2" class="pilcrow">¶</a></p>
<span id="name-state-machine-for-vdaf-prep"></span><div id="vdaf-prep-state-machine">
<figure id="figure-8">
          <div class="alignLeft art-text artwork" id="section-5.7-3.1">
<pre>
                  +----------------+
                  |                |
                  v                |
Start ----&gt; Continued(prep_state, prep_round) --&gt; Finished(out_share)
 |                |
 |                |
 +--&gt; Rejected &lt;--+
</pre>
</div>
<figcaption><a href="#figure-8" class="selfRef">Figure 8</a>:
<a href="#name-state-machine-for-vdaf-prep" class="selfRef">State machine for VDAF preparation.</a>
          </figcaption></figure>
</div>
<p id="section-5.7-4">State transitions are made when the state is acted upon by the host's local
inputs and/or messages sent by the peers. The initial state is <code>Start</code>. The
terminal states are <code>Rejected</code>, which indicates that the report cannot be
processed any further, and <code>Finished(out_share)</code>, which indicates that the
Aggregator has recovered an output share <code>out_share</code>.<a href="#section-5.7-4" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-5.7-5">
<pre>
class State:
    pass

class Start(State):
    pass

class Continued(State, Generic[PrepState]):
    def __init__(self, prep_state: PrepState, prep_round: int):
        self.prep_state = prep_state
        self.prep_round = prep_round

    def __eq__(self, other: object) -&gt; bool:
        return isinstance(other, Continued) and \
            self.prep_state == other.prep_state and \
            self.prep_round == other.prep_round

class Finished(State, Generic[OutShare]):
    def __init__(self, out_share: OutShare):
        self.out_share = out_share

    def __eq__(self, other: object) -&gt; bool:
        return isinstance(other, Finished) and \
            self.out_share == other.out_share

class Rejected(State):
    pass
</pre><a href="#section-5.7-5" class="pilcrow">¶</a>
</div>
<p id="section-5.7-6">The methods described in this section are defined in terms of opaque byte
strings. A compatible <code>Vdaf</code> <span class="bcp14">MUST</span> specify methods for encoding public shares,
input shares, prep shares, prep messages, and aggregation parameters.<a href="#section-5.7-6" class="pilcrow">¶</a></p>
<p id="section-5.7-7">Implementations of Prio3 and Poplar1 <span class="bcp14">MUST</span> use the encoding scheme specified in
<a href="#prio3-encode" class="auto internal xref">Section 7.2.7</a> and <a href="#poplar1-encode" class="auto internal xref">Section 8.2.6</a> respectively.<a href="#section-5.7-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="ping-pong-topology-only-two-aggregators">
<section id="section-5.8">
        <h3 id="name-ping-pong-topology-only-two">
<a href="#section-5.8" class="section-number selfRef">5.8. </a><a href="#name-ping-pong-topology-only-two" class="section-name selfRef">Ping-Pong Topology (Only Two Aggregators)</a>
        </h3>
<p id="section-5.8-1">For VDAFs with precisely two Aggregators (i.e., <code>SHARES == 2</code>), the following
"ping pong" communication pattern can be used. It is compatible with any
request/response transport protocol, such as HTTP.<a href="#section-5.8-1" class="pilcrow">¶</a></p>
<p id="section-5.8-2">Let us call the initiating party the "Leader" and the responding party the
"Helper". The high-level idea is that the Leader and Helper will take turns
running the computation locally until input from their peer is required:<a href="#section-5.8-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.8-3.1">
            <p id="section-5.8-3.1.1">For a 1-round VDAF (e.g., Prio3 (<a href="#prio3" class="auto internal xref">Section 7</a>)), the Leader sends its prep share
to the Helper, who computes the prep message locally, computes its output
share, then sends the prep message to the Leader. Preparation requires just
one round trip between the Leader and the Helper.<a href="#section-5.8-3.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-5.8-3.2">
            <p id="section-5.8-3.2.1">For a 2-round VDAF (e.g., Poplar1 (<a href="#poplar1" class="auto internal xref">Section 8</a>)), the Leader sends its
first-round prep share to the Helper, who replies with the first-round prep
message and its second-round prep share. In the next request, the Leader
computes its second-round prep share locally, computes its output share, and
sends the second-round prep message to the Helper. Finally, the Helper
computes its own output share.<a href="#section-5.8-3.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-5.8-3.3">
            <p id="section-5.8-3.3.1">In general, each request includes the Leader's prep share for the previous
round and/or the prep message for the current round; correspondingly, each
response consists of the prep message for the current round and the Helper's
prep share for the next round.<a href="#section-5.8-3.3.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-5.8-4">The Aggregators proceed in this ping-ponging fashion until a step of the
computation fails (indicating the report is invalid and should be rejected) or
preparation is completed. All told there there are <code>ceil((ROUNDS+1)/2)</code>
requests sent.<a href="#section-5.8-4" class="pilcrow">¶</a></p>
<p id="section-5.8-5">Each message in the ping-pong protocol is structured as follows (expressed in
TLS syntax as defined in <span><a href="https://rfc-editor.org/rfc/rfc8446#section-3" class="relref">Section 3</a> of [<a href="#RFC8446" class="cite xref">RFC8446</a>]</span>):<a href="#section-5.8-5" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-5.8-6">
<pre>
enum {
  initialize(0),
  continue(1),
  finish(2),
  (255)
} MessageType;

struct {
  MessageType type;
  select (Message.type) {
    case initialize:
      opaque prep_share&lt;0..2^32-1&gt;;
    case continue:
      opaque prep_msg&lt;0..2^32-1&gt;;
      opaque prep_share&lt;0..2^32-1&gt;;
    case finish:
      opaque prep_msg&lt;0..2^32-1&gt;;
  };
} Message;
</pre><a href="#section-5.8-6" class="pilcrow">¶</a>
</div>
<p id="section-5.8-7">These messages are used to transition between the states described in
<a href="#vdaf-prep-comm" class="auto internal xref">Section 5.7</a>. The Leader's initial transition is computed with the
following method, implemented on <code>Vdaf</code>:<a href="#section-5.8-7" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-5.8-8">
<pre>
def ping_pong_leader_init(
        self,
        vdaf_verify_key: bytes,
        agg_param: bytes,
        nonce: bytes,
        public_share: bytes,
        input_share: bytes) -&gt; tuple[State, Optional[bytes]]:
    """Called by the leader to initialize ping-ponging."""
    try:
        (prep_state, prep_share) = self.prep_init(
            vdaf_verify_key,
            0,
            self.decode_agg_param(agg_param),
            nonce,
            self.decode_public_share(public_share),
            self.decode_input_share(0, input_share),
        )
        encoded_prep_share = self.encode_prep_share(prep_share)
        return (
            Continued(prep_state, 0),
            encode(0, encoded_prep_share),  # initialize
        )
    except:
        return (Rejected(), None)
</pre><a href="#section-5.8-8" class="pilcrow">¶</a>
</div>
<p id="section-5.8-9">The output is the <code>State</code> to which the Leader has transitioned and an encoded
<code>Message</code>. If the Leader's state is <code>Rejected</code>, then processing halts.
Otherwise, if the state is <code>Continued</code>, then processing continues. Function
<code>encode</code>  is used to encode the outbound message, here the <code>initialize</code> variant
(hence <code>0</code>).<a href="#section-5.8-9" class="pilcrow">¶</a></p>
<p id="section-5.8-10">The Leader sends the outbound message to the Helper. The Helper's initial
transition is computed using the following procedure:<a href="#section-5.8-10" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-5.8-11">
<pre>
def ping_pong_helper_init(
        self,
        vdaf_verify_key: bytes,
        agg_param: bytes,
        nonce: bytes,
        public_share: bytes,
        input_share: bytes,
        inbound: bytes) -&gt; tuple[State, Optional[bytes]]:
    """
    Called by the helper in response to the leader's initial
    message.
    """
    try:
        (prep_state, prep_share) = self.prep_init(
            vdaf_verify_key,
            1,
            self.decode_agg_param(agg_param),
            nonce,
            self.decode_public_share(public_share),
            self.decode_input_share(1, input_share),
        )

        (inbound_type, inbound_items) = decode(inbound)
        if inbound_type != 0:  # initialize
            return (Rejected(), None)

        encoded_prep_share = inbound_items[0]
        prep_shares = [
            self.decode_prep_share(prep_state, encoded_prep_share),
            prep_share,
        ]
        return self.ping_pong_transition(
            self.decode_agg_param(agg_param),
            prep_shares,
            prep_state,
            0,
        )
    except:
        return (Rejected(), None)
</pre><a href="#section-5.8-11" class="pilcrow">¶</a>
</div>
<p id="section-5.8-12">Procedure <code>decode</code> decodes the inbound message and returns the MessageType
variant (<code>initialize</code>, <code>continue</code>, or <code>finalize</code>) and the sequence of fields.
Procedure <code>ping_pong_transition</code> takes in the prep shares, combines them into
the prep message, and computes the next prep state of the caller:<a href="#section-5.8-12" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-5.8-13">
<pre>
def ping_pong_transition(
        self,
        agg_param: AggParam,
        prep_shares: list[PrepShare],
        prep_state: PrepState,
        prep_round: int) -&gt; tuple[State, bytes]:
    prep_msg = self.prep_shares_to_prep(agg_param,
                                        prep_shares)
    encoded_prep_msg = self.encode_prep_msg(prep_msg)
    out = self.prep_next(prep_state, prep_msg)
    if prep_round+1 == self.ROUNDS:
        return (
            Finished(out),
            encode(2, encoded_prep_msg),  # finalize
        )
    (prep_state, prep_share) = cast(
        tuple[PrepState, PrepShare], out)
    encoded_prep_share = self.encode_prep_share(prep_share)
    return (
        Continued(prep_state, prep_round+1),
        encode(1, encoded_prep_msg, encoded_prep_share)  # continue
    )
</pre><a href="#section-5.8-13" class="pilcrow">¶</a>
</div>
<p id="section-5.8-14">The output is the <code>State</code> to which the Helper has transitioned and an encoded
<code>Message</code>. If the Helper's state is <code>Finished</code> or <code>Rejected</code>, then processing
halts. Otherwise, if the state is <code>Continued</code>, then processing continues.<a href="#section-5.8-14" class="pilcrow">¶</a></p>
<p id="section-5.8-15">Next, the Helper sends the outbound message to the Leader. The Leader computes
its next state transition using the function <code>ping_pong_leader_continued</code>:<a href="#section-5.8-15" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-5.8-16">
<pre>
def ping_pong_leader_continued(
    self,
    agg_param: bytes,
    state: State,
    inbound: bytes,
) -&gt; tuple[State, Optional[bytes]]:
    """
    Called by the leader to start the next step of ping-ponging.
    """
    return self.ping_pong_continued(
        True, agg_param, state, inbound)

def ping_pong_continued(
    self,
    is_leader: bool,
    agg_param: bytes,
    state: State,
    inbound: bytes,
) -&gt; tuple[State, Optional[bytes]]:
    try:
        if not isinstance(state, Continued):
            return (Rejected(), None)
        prep_round = state.prep_round

        (inbound_type, inbound_items) = decode(inbound)
        if inbound_type == 0:  # initialize
            return (Rejected(), None)

        encoded_prep_msg = inbound_items[0]
        prep_msg = self.decode_prep_msg(
            state.prep_state,
            encoded_prep_msg,
        )
        out = self.prep_next(state.prep_state, prep_msg)
        if prep_round+1 &lt; self.ROUNDS and \
                inbound_type == 1:  # continue
            (prep_state, prep_share) = cast(
                tuple[PrepState, PrepShare], out)
            encoded_prep_share = inbound_items[1]
            prep_shares = [
                self.decode_prep_share(
                    prep_state,
                    encoded_prep_share,
                ),
                prep_share,
            ]
            if is_leader:
                prep_shares.reverse()
            return self.ping_pong_transition(
                self.decode_agg_param(agg_param),
                prep_shares,
                prep_state,
                prep_round+1,
            )
        elif prep_round+1 == self.ROUNDS and \
                inbound_type == 2:  # finish
            return (Finished(out), None)
        else:
            return (Rejected(), None)
    except:
        return (Rejected(), None)
</pre><a href="#section-5.8-16" class="pilcrow">¶</a>
</div>
<p id="section-5.8-17">If the Leader's state is <code>Finished</code> or <code>Rejected</code>, then processing halts.
Otherwise, the Leader sends the outbound message to the Helper. The Helper
computes its next state transition using the function
<code>ping_pong_helper_continued</code>:<a href="#section-5.8-17" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-5.8-18">
<pre>
def ping_pong_helper_continued(
    self,
    agg_param: bytes,
    state: State,
    inbound: bytes,
) -&gt; tuple[State, Optional[bytes]]:
    """Called by the helper to continue ping-ponging."""
    return self.ping_pong_continued(
        False, agg_param, state, inbound)
</pre><a href="#section-5.8-18" class="pilcrow">¶</a>
</div>
<p id="section-5.8-19">They continue in this way until processing halts. Note that, depending on the
number of rounds of preparation that are required, there may be one more
message to send before the peer can also finish processing (i.e., <code>outbound !=
None</code>).<a href="#section-5.8-19" class="pilcrow">¶</a></p>
</section>
</div>
<div id="star-topo">
<section id="section-5.9">
        <h3 id="name-star-topology-any-number-of">
<a href="#section-5.9" class="section-number selfRef">5.9. </a><a href="#name-star-topology-any-number-of" class="section-name selfRef">Star Topology (Any Number of Aggregators)</a>
        </h3>
<p id="section-5.9-1">The ping-pong topology of the previous section is only suitable for VDAFs
involving exactly two Aggregators. If the VDAF supports more than two
Aggregators, then the star topology described in this section can
be used instead.<a href="#section-5.9-1" class="pilcrow">¶</a></p>
<p id="section-5.9-2">We again designate an Aggregator to initiate the computation. We refer to this
Aggregator as the Leader and to all other Aggregators as Helpers.<a href="#section-5.9-2" class="pilcrow">¶</a></p>
<p id="section-5.9-3">At the start of each round, the Leader requests from each Helper its prep
share. After gathering each of the prep shares, the Leader computes the next
prep message (via <code>prep_shares_to_prep()</code>) and broadcasts it to the Helpers. At
this point, each Aggregator runs <code>prep_next()</code> locally to either recover an
output share or, if more rounds of preparation are required, compute its updated state
and prep share. If more are required, then the Helper responds to the broadcast
message with its next prep share.<a href="#section-5.9-3" class="pilcrow">¶</a></p>
<p id="section-5.9-4">The Aggregators proceed in this way until each recovers an output share or some
step of the computation fails.<a href="#section-5.9-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="prelim">
<section id="section-6">
      <h2 id="name-preliminaries">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-preliminaries" class="section-name selfRef">Preliminaries</a>
      </h2>
<p id="section-6-1">This section describes the primitives that are common to the VDAFs specified in
this document.<a href="#section-6-1" class="pilcrow">¶</a></p>
<div id="field">
<section id="section-6.1">
        <h3 id="name-finite-fields">
<a href="#section-6.1" class="section-number selfRef">6.1. </a><a href="#name-finite-fields" class="section-name selfRef">Finite Fields</a>
        </h3>
<p id="section-6.1-1">Both Prio3 and Poplar1 use finite fields of prime order. Finite field
elements are represented by a class <code>Field</code> with the following associated
parameters:<a href="#section-6.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-2.1">
            <p id="section-6.1-2.1.1"><code>MODULUS: int</code> is the prime modulus that defines the field.<a href="#section-6.1-2.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-6.1-2.2">
            <p id="section-6.1-2.2.1"><code>ENCODED_SIZE: int</code> is the number of bytes used to encode a field element
as a byte string.<a href="#section-6.1-2.2.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-6.1-3">A concrete <code>Field</code> also implements the following class methods:<a href="#section-6.1-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-4.1">
            <p id="section-6.1-4.1.1"><code>Field.zeros(length: int) -&gt; list[Self]</code> returns a vector of
zeros.<a href="#section-6.1-4.1.1" class="pilcrow">¶</a></p>
<p id="section-6.1-4.1.2">
Pre-conditions:<a href="#section-6.1-4.1.2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-4.1.3.1">
                <p id="section-6.1-4.1.3.1.1"><code>length</code> <span class="bcp14">MUST</span> be greater than or equal <code>0</code>.<a href="#section-6.1-4.1.3.1.1" class="pilcrow">¶</a></p>
</li>
            </ul>
<p id="section-6.1-4.1.4">
Post-conditions:<a href="#section-6.1-4.1.4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-4.1.5.1">
                <p id="section-6.1-4.1.5.1.1">The length of the output <span class="bcp14">MUST</span> be <code>length</code>.<a href="#section-6.1-4.1.5.1.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
          <li class="normal" id="section-6.1-4.2">
            <p id="section-6.1-4.2.1"><code>Field.rand_vec(length: int) -&gt; list[Self]</code> returns a vector of
random field elements. Same pre- and post-conditions as for <code>Field.zeros()</code>.<a href="#section-6.1-4.2.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-6.1-5">A field element is an instance of a concrete <code>Field</code>. The concrete class defines
the usual arithmetic operations on field elements. In addition, it defines the
following instance method for converting a field element to an unsigned integer:<a href="#section-6.1-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-6.1">
            <p id="section-6.1-6.1.1"><code>elem.as_unsigned() -&gt; int</code> returns the integer representation of
field element <code>elem</code>.<a href="#section-6.1-6.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-6.1-7">Likewise, each concrete <code>Field</code> implements a constructor for converting an
unsigned integer into a field element:<a href="#section-6.1-7" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-8.1">
            <p id="section-6.1-8.1.1"><code>Field(integer: int)</code> returns <code>integer</code> represented as a field element.
The value of <code>integer</code> <span class="bcp14">MUST</span> be non-negative and less than <code>Field.MODULUS</code>.<a href="#section-6.1-8.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-6.1-9">Each concrete <code>Field</code> has two derived class methods, one for encoding
a vector of field elements as a byte string and another for decoding a vector of
field elements.<a href="#section-6.1-9" class="pilcrow">¶</a></p>
<span id="name-derived-class-methods-for-f"></span><div id="field-derived-methods">
<figure id="figure-9">
          <div class="lang-python sourcecode" id="section-6.1-10.1">
<pre>
def encode_vec(cls, vec: list[Self]) -&gt; bytes:
    """
    Encode a vector of field elements `vec` as a byte string.
    """
    encoded = bytes()
    for x in vec:
        encoded += to_le_bytes(x.as_unsigned(), cls.ENCODED_SIZE)
    return encoded

def decode_vec(cls, encoded: bytes) -&gt; list[Self]:
    """
    Parse a vector of field elements from `encoded`.
    """
    L = cls.ENCODED_SIZE
    if len(encoded) % L != 0:
        raise ValueError(
            'input length must be a multiple of the size of an '
            'encoded field element')

    vec = []
    for i in range(0, len(encoded), L):
        encoded_x = encoded[i:i+L]
        x = from_le_bytes(encoded_x)
        if x &gt;= cls.MODULUS:
            raise ValueError('modulus overflow')
        vec.append(cls(x))
    return vec
</pre>
</div>
<figcaption><a href="#figure-9" class="selfRef">Figure 9</a>:
<a href="#name-derived-class-methods-for-f" class="selfRef">Derived class methods for finite fields.</a>
          </figcaption></figure>
</div>
<p id="section-6.1-11">Finally, <code>Field</code> implements the following methods for representing a value as
a sequence of field elements, each of which represents a bit of the input.<a href="#section-6.1-11" class="pilcrow">¶</a></p>
<span id="name-derived-class-methods-to-en"></span><div id="field-bit-rep">
<figure id="figure-10">
          <div class="lang-python sourcecode" id="section-6.1-12.1">
<pre>
def encode_into_bit_vector(
        cls,
        val: int,
        bits: int) -&gt; list[Self]:
    """
    Encode the bit representation of `val` with at most `bits` number
    of bits, as a vector of field elements.

    Pre-conditions:

        - `val &gt;= 0`
        - `bits &gt;= 0`
    """
    if val &gt;= 2 ** bits:
        # Sanity check we are able to represent `val` with `bits`
        # number of bits.
        raise ValueError("Number of bits is not enough to represent "
                         "the input integer.")
    encoded = []
    for l in range(bits):
        encoded.append(cls((val &gt;&gt; l) &amp; 1))
    return encoded

def decode_from_bit_vector(cls, vec: list[Self]) -&gt; Self:
    """
    Decode the field element from the bit representation, expressed
    as a vector of field elements `vec`.
    """
    bits = len(vec)
    if cls.MODULUS &gt;&gt; bits == 0:
        raise ValueError("Number of bits is too large to be "
                         "represented by field modulus.")
    decoded = cls(0)
    for (l, bit) in enumerate(vec):
        decoded += cls(1 &lt;&lt; l) * bit
    return decoded
</pre>
</div>
<figcaption><a href="#figure-10" class="selfRef">Figure 10</a>:
<a href="#name-derived-class-methods-to-en" class="selfRef">Derived class methods to encode integers into bit vector representation.</a>
          </figcaption></figure>
</div>
<div id="auxiliary-functions">
<section id="section-6.1.1">
          <h4 id="name-auxiliary-functions">
<a href="#section-6.1.1" class="section-number selfRef">6.1.1. </a><a href="#name-auxiliary-functions" class="section-name selfRef">Auxiliary Functions</a>
          </h4>
<p id="section-6.1.1-1">The following auxiliary functions on vectors of field elements are used in the
remainder of this document. Note that an exception is raised by each function if
the operands are not the same length.<a href="#section-6.1.1-1" class="pilcrow">¶</a></p>
<span id="name-common-functions-for-finite"></span><div id="field-helper-functions">
<figure id="figure-11">
            <div class="lang-python sourcecode" id="section-6.1.1-2.1">
<pre>
def vec_sub(left: list[F], right: list[F]) -&gt; list[F]:
    """
    Subtract the right operand from the left and return the result.
    """
    if len(left) != len(right):
        raise ValueError("mismatched vector sizes")
    return list(map(lambda x: x[0] - x[1], zip(left, right)))

def vec_add(left: list[F], right: list[F]) -&gt; list[F]:
    """Add the right operand to the left and return the result."""
    if len(left) != len(right):
        raise ValueError("mismatched vector sizes")
    return list(map(lambda x: x[0] + x[1], zip(left, right)))

def vec_neg(vec: list[F]) -&gt; list[F]:
    """Negate the input vector."""
    return list(map(lambda x: -x, vec))
</pre>
</div>
<figcaption><a href="#figure-11" class="selfRef">Figure 11</a>:
<a href="#name-common-functions-for-finite" class="selfRef">Common functions for finite fields.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="field-ntt-friendly">
<section id="section-6.1.2">
          <h4 id="name-ntt-friendly-fields">
<a href="#section-6.1.2" class="section-number selfRef">6.1.2. </a><a href="#name-ntt-friendly-fields" class="section-name selfRef">NTT-Friendly Fields</a>
          </h4>
<p id="section-6.1.2-1">Some VDAFs require fields that are suitable for efficient computation of the
number theoretic transform (NTT) <span>[<a href="#SML24" class="cite xref">SML24</a>]</span>, as this allows for fast polynomial
interpolation. (One example is Prio3 (<a href="#prio3" class="auto internal xref">Section 7</a>) when instantiated with the FLP
of <a href="#flp-bbcggi19-construction" class="auto internal xref">Section 7.3.3</a>.) Specifically, a field is said to be
"NTT-friendly" if, in addition to satisfying the interface described in
<a href="#field" class="auto internal xref">Section 6.1</a>, it implements the following method:<a href="#section-6.1.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.2-2.1">
              <p id="section-6.1.2-2.1.1"><code>Field.gen() -&gt; Field</code> returns the generator of a large subgroup of the
multiplicative group. To be NTT-friendly, the order of this subgroup <span class="bcp14">MUST</span> be a
power of 2. In addition, the size of the subgroup dictates how large
interpolated polynomials can be. It is <span class="bcp14">RECOMMENDED</span> that a generator is chosen
with order at least <code>2^20</code>.<a href="#section-6.1.2-2.1.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-6.1.2-3">NTT-friendly fields also define the following parameter:<a href="#section-6.1.2-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.2-4.1">
              <p id="section-6.1.2-4.1.1"><code>GEN_ORDER: int</code> is the order of a multiplicative subgroup generated by
<code>Field.gen()</code>.<a href="#section-6.1.2-4.1.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</section>
</div>
<div id="parameters">
<section id="section-6.1.3">
          <h4 id="name-parameters">
<a href="#section-6.1.3" class="section-number selfRef">6.1.3. </a><a href="#name-parameters" class="section-name selfRef">Parameters</a>
          </h4>
<p id="section-6.1.3-1">The tables below define finite fields used in the remainder of this document.<a href="#section-6.1.3-1" class="pilcrow">¶</a></p>
<span id="name-parameters-for-the-finite-f"></span><div id="fields">
<table class="center" id="table-3">
            <caption>
<a href="#table-3" class="selfRef">Table 3</a>:
<a href="#name-parameters-for-the-finite-f" class="selfRef">Parameters for the finite fields used in this document.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Field64</th>
                <th class="text-left" rowspan="1" colspan="1">Field128</th>
                <th class="text-left" rowspan="1" colspan="1">Field255</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">MODULUS</td>
                <td class="text-left" rowspan="1" colspan="1">2^32 * 4294967295 + 1</td>
                <td class="text-left" rowspan="1" colspan="1">2^66 * 4611686018427387897 + 1</td>
                <td class="text-left" rowspan="1" colspan="1">2^255 - 19</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">ENCODED_SIZE</td>
                <td class="text-left" rowspan="1" colspan="1">8</td>
                <td class="text-left" rowspan="1" colspan="1">16</td>
                <td class="text-left" rowspan="1" colspan="1">32</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">Generator</td>
                <td class="text-left" rowspan="1" colspan="1">7^4294967295</td>
                <td class="text-left" rowspan="1" colspan="1">7^4611686018427387897</td>
                <td class="text-left" rowspan="1" colspan="1">n/a</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">GEN_ORDER</td>
                <td class="text-left" rowspan="1" colspan="1">2^32</td>
                <td class="text-left" rowspan="1" colspan="1">2^66</td>
                <td class="text-left" rowspan="1" colspan="1">n/a</td>
              </tr>
            </tbody>
          </table>
</div>
</section>
</div>
</section>
</div>
<div id="xof">
<section id="section-6.2">
        <h3 id="name-extendable-output-functions">
<a href="#section-6.2" class="section-number selfRef">6.2. </a><a href="#name-extendable-output-functions" class="section-name selfRef">Extendable Output Functions</a>
        </h3>
<p id="section-6.2-1">VDAFs in this specification use extendable output functions (XOFs) to extract
short, fixed-length strings we call "seeds" from long input strings and expand
seeds into long output strings. We specify a single interface that is suitable
for both purposes.<a href="#section-6.2-1" class="pilcrow">¶</a></p>
<p id="section-6.2-2">XOFs are defined by a class <code>Xof</code> with the following associated parameter and
methods:<a href="#section-6.2-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.2-3.1">
            <p id="section-6.2-3.1.1"><code>SEED_SIZE: int</code> is the size (in bytes) of a seed.<a href="#section-6.2-3.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-6.2-3.2">
            <p id="section-6.2-3.2.1"><code>Xof(seed: bytes, dst: bytes, binder: bytes)</code> constructs an instance of <code>Xof</code>
from the given seed, domain separation tag, and binder string. (See below for
definitions of these.) The length of the seed will typically be <code>SEED_SIZE</code>,
but some XOFs may support multiple seed sizes. The seed <span class="bcp14">MUST</span> be generated
securely (i.e., it is either the output of a CSPRNG or a previous invocation
of the XOF).<a href="#section-6.2-3.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-6.2-3.3">
            <p id="section-6.2-3.3.1"><code>xof.next(length: int)</code> returns the next <code>length</code> bytes of output of
<code>xof</code>.<a href="#section-6.2-3.3.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-6.2-4">Each <code>Xof</code> has three derived methods. The first is used to derive a fresh seed
from an existing one. The second is used to compute a sequence of field
elements. The third is a convenience method to construct an <code>Xof</code> from a seed,
domain separation tag, and binder string, and then use it to compute a sequence
of field elements.<a href="#section-6.2-4" class="pilcrow">¶</a></p>
<span id="name-derived-methods-for-xofs"></span><div id="xof-derived-methods">
<figure id="figure-12">
          <div class="breakable lang-python sourcecode" id="section-6.2-5.1">
<pre>
def derive_seed(cls,
                seed: bytes,
                dst: bytes,
                binder: bytes) -&gt; bytes:
    """
    Derive a new seed.

    Pre-conditions:

        - `len(seed) == Xof.SEED_SIZE`
    """
    xof = cls(seed, dst, binder)
    return xof.next(cls.SEED_SIZE)

def next_vec(self, field: type[F], length: int) -&gt; list[F]:
    """
    Output the next `length` field elements.

    Pre-conditions:

        - `field` is sub-class of `Field`
        - `length &gt; 0`
    """
    m = next_power_of_2(field.MODULUS) - 1
    vec: list[F] = []
    while len(vec) &lt; length:
        x = from_le_bytes(self.next(field.ENCODED_SIZE))
        x &amp;= m
        if x &lt; field.MODULUS:
            vec.append(field(x))
    return vec

def expand_into_vec(cls,
                    field: type[F],
                    seed: bytes,
                    dst: bytes,
                    binder: bytes,
                    length: int) -&gt; list[F]:
    """
    Expand the input `seed` into vector of `length` field elements.

    Pre-conditions:

        - `field` is sub-class of `Field`
        - `len(seed) == Xof.SEED_SIZE`
        - `length &gt; 0`
    """
    xof = cls(seed, dst, binder)
    return xof.next_vec(field, length)
</pre>
</div>
<figcaption><a href="#figure-12" class="selfRef">Figure 12</a>:
<a href="#name-derived-methods-for-xofs" class="selfRef">Derived methods for XOFs.</a>
          </figcaption></figure>
</div>
<div id="xof-turboshake128">
<section id="section-6.2.1">
          <h4 id="name-xofturboshake128">
<a href="#section-6.2.1" class="section-number selfRef">6.2.1. </a><a href="#name-xofturboshake128" class="section-name selfRef">XofTurboShake128</a>
          </h4>
<p id="section-6.2.1-1">This section describes XofTurboShake128, an XOF based on the TurboSHAKE128
<span>[<a href="#TurboSHAKE" class="cite xref">TurboSHAKE</a>]</span>. (RFC EDITOR: Update this
reference to the RFC for draft-irtf-cfrg-kangarootwelve once published.) This
XOF is <span class="bcp14">RECOMMENDED</span> for all use cases within VDAFs. The length of the domain
separation string <code>dst</code> passed to XofTurboShake128 <span class="bcp14">MUST NOT</span> exceed 255 bytes.<a href="#section-6.2.1-1" class="pilcrow">¶</a></p>
<span id="name-definition-of-xof-xofturbos"></span><figure id="figure-13">
            <div class="lang-python sourcecode" id="section-6.2.1-2.1">
<pre>
class XofTurboShake128(Xof):
    """XOF wrapper for TurboSHAKE128."""

    # Associated parameters
    SEED_SIZE = 32

    def __init__(self, seed: bytes, dst: bytes, binder: bytes):
        self.l = 0
        self.m = \
            to_le_bytes(len(dst), 1) + dst \
            to_le_bytes(len(seed), 1) + seed + \
            binder

    def next(self, length: int) -&gt; bytes:
        self.l += length

        # Function `TurboSHAKE128(M, D, L)` is as defined in
        # Section 2.2 of [TurboSHAKE].
        #
        # Implementation note: rather than re-generate the output
        # stream each time `next()` is invoked, most implementations
        # of TurboSHAKE128 will expose an "absorb-then-squeeze" API
        # that allows stateful handling of the stream.
        stream = TurboSHAKE128(self.m, 1, self.l)
        return stream[-length:]
</pre>
</div>
<figcaption><a href="#figure-13" class="selfRef">Figure 13</a>:
<a href="#name-definition-of-xof-xofturbos" class="selfRef">Definition of XOF XofTurboShake128.</a>
            </figcaption></figure>
</section>
</div>
<div id="xof-fixed-key-aes128">
<section id="section-6.2.2">
          <h4 id="name-xoffixedkeyaes128">
<a href="#section-6.2.2" class="section-number selfRef">6.2.2. </a><a href="#name-xoffixedkeyaes128" class="section-name selfRef">XofFixedKeyAes128</a>
          </h4>
<p id="section-6.2.2-1">While XofTurboShake128 as described above can be securely used in all cases
where a XOF is needed in the VDAFs described in this document, there are some
cases where a more efficient instantiation based on fixed-key AES is possible.
For now, this is limited to the XOF used inside the Idpf <a href="#idpf" class="auto internal xref">Section 8.1</a>
implementation in Poplar1 <a href="#idpf-bbcggi21" class="auto internal xref">Section 8.3</a>. It is <span class="bcp14">NOT RECOMMENDED</span> to use this
XOF anywhere else. The length of the domain separation string <code>dst</code> passed to
XofFixedKeyAes128 <span class="bcp14">MUST NOT</span> exceed 255 bytes. See <a href="#security" class="auto internal xref">Section 9</a> for a more
detailed discussion.<a href="#section-6.2.2-1" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-6.2.2-2">
<pre>
class XofFixedKeyAes128(Xof):
    """
    XOF based on a circular collision-resistant hash function from
    fixed-key AES.
    """

    # Associated parameters
    SEED_SIZE = 16

    def __init__(self, seed: bytes, dst: bytes, binder: bytes):
        if len(seed) != self.SEED_SIZE:
            raise ValueError("incorrect seed size")

        self.length_consumed = 0

        # Use TurboSHAKE128 to derive a key from the binder string
        # and domain separation tag. Note that the AES key does not
        # need to be kept secret from any party. However, when used
        # with an IDPF, we require the binder to be a random nonce.
        #
        # Implementation note: this step can be cached across XOF
        # evaluations with many different seeds.
        dst_length = to_le_bytes(len(dst), 1)
        self.fixed_key = TurboSHAKE128(
            dst_length + dst + binder,
            2,
            16,
        )
        self.seed = seed

    def next(self, length: int) -&gt; bytes:
        offset = self.length_consumed % 16
        new_length = self.length_consumed + length
        block_range = range(
            self.length_consumed // 16,
            new_length // 16 + 1
        )
        self.length_consumed = new_length

        hashed_blocks = [
            self.hash_block(xor(self.seed, to_le_bytes(i, 16)))
            for i in block_range
        ]
        return concat(hashed_blocks)[offset:offset+length]

    def hash_block(self, block: bytes) -&gt; bytes:
        """
        The multi-instance tweakable circular correlation-robust hash
        function of [GKWWY20] (Section 4.2). The tweak here is the
        key that stays constant for all XOF evaluations of the same
        Client, but differs between Clients.

        Function `AES128(key, block)` is the AES-128 blockcipher.
        """
        lo, hi = block[:8], block[8:]
        sigma_block = concat([hi, xor(hi, lo)])
        return xor(AES128(self.fixed_key, sigma_block), sigma_block)
</pre><a href="#section-6.2.2-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="dst-binder">
<section id="section-6.2.3">
          <h4 id="name-the-domain-separation-tag-a">
<a href="#section-6.2.3" class="section-number selfRef">6.2.3. </a><a href="#name-the-domain-separation-tag-a" class="section-name selfRef">The Domain Separation Tag and Binder String</a>
          </h4>
<p id="section-6.2.3-1">XOFs are used to map a seed to a finite domain, e.g., a fresh seed or a vector
of field elements. To ensure domain separation, the derivation is needs to be
bound to some distinguished domain separation tag. The domain separation tag
encodes the following values:<a href="#section-6.2.3-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-6.2.3-2">
<li id="section-6.2.3-2.1">
              <p id="section-6.2.3-2.1.1">The document version (i.e.,<code>VERSION</code>);<a href="#section-6.2.3-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-6.2.3-2.2">
              <p id="section-6.2.3-2.2.1">The "class" of the algorithm using the output (e.g., VDAF);<a href="#section-6.2.3-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-6.2.3-2.3">
              <p id="section-6.2.3-2.3.1">A unique identifier for the algorithm; and<a href="#section-6.2.3-2.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-6.2.3-2.4">
              <p id="section-6.2.3-2.4.1">Some indication of how the output is used (e.g., for deriving the measurement
shares in Prio3 <a href="#prio3" class="auto internal xref">Section 7</a>).<a href="#section-6.2.3-2.4.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<p id="section-6.2.3-3">The following algorithm is used in the remainder of this document in order to
format the domain separation tag:<a href="#section-6.2.3-3" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-6.2.3-4">
<pre>
def format_dst(algo_class: int,
               algo: int,
               usage: int) -&gt; bytes:
    """
    Format XOF domain separation tag for use within a (V)DAF.

    Pre-conditions:

        - `algo_class` in `range(0, 2 ** 8)`
        - `algo` in `range(0, 2 ** 32)`
        - `usage` in `range(0, 2 ** 16)`
    """
    return concat([
        to_be_bytes(VERSION, 1),
        to_be_bytes(algo_class, 1),
        to_be_bytes(algo, 4),
        to_be_bytes(usage, 2),
    ])
</pre><a href="#section-6.2.3-4" class="pilcrow">¶</a>
</div>
<p id="section-6.2.3-5">It is also sometimes necessary to bind the output to some ephemeral value that
multiple parties need to agree on. We call this input the "binder string".<a href="#section-6.2.3-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="prio3">
<section id="section-7">
      <h2 id="name-prio3">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-prio3" class="section-name selfRef">Prio3</a>
      </h2>
<p id="section-7-1">This section describes Prio3, a VDAF for Prio <span>[<a href="#CGB17" class="cite xref">CGB17</a>]</span>. Prio is suitable for
a wide variety of aggregation functions, including (but not limited to) sum,
mean, standard deviation, estimation of quantiles (e.g., median), and linear
regression. In fact, the scheme described in this section is compatible with any
aggregation function that has the following structure:<a href="#section-7-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7-2.1">
          <p id="section-7-2.1.1">Each measurement is encoded as a vector over some finite field.<a href="#section-7-2.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-7-2.2">
          <p id="section-7-2.2.1">Measurement validity is determined by an arithmetic circuit evaluated over
the encoded measurement. (An "arithmetic circuit" is a function comprised of
arithmetic operations in the field.) The circuit's output is a single field
element: if zero, then the measurement is said to be "valid"; otherwise, if
the output is non-zero, then the measurement is said to be "invalid".<a href="#section-7-2.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-7-2.3">
          <p id="section-7-2.3.1">The aggregate result is obtained by summing up the encoded measurement
vectors and computing some function of the sum.<a href="#section-7-2.3.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-7-3">At a high level, Prio3 distributes this computation as follows. Each Client
first shards its measurement by first encoding it, then splitting the vector into
secret shares and sending a share to each Aggregator. Next, in the preparation
phase, the Aggregators carry out a multi-party computation to determine if their
shares correspond to a valid measurement (as determined by the arithmetic
circuit). This computation involves a "proof" of validity generated by the
Client. Next, each Aggregator sums up its shares locally. Finally, the
Collector sums up the aggregate shares and computes the aggregate result.<a href="#section-7-3" class="pilcrow">¶</a></p>
<p id="section-7-4">This VDAF does not have an aggregation parameter. Instead, the output share is
derived from the measurement share by applying a fixed map. See <a href="#poplar1" class="auto internal xref">Section 8</a> for
an example of a VDAF that makes meaningful use of the aggregation parameter.<a href="#section-7-4" class="pilcrow">¶</a></p>
<p id="section-7-5">The core component of Prio3 is a "Fully Linear Proof (FLP)" system. Introduced
by <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, the FLP encapsulates the functionality required for encoding
and validating measurements. Prio3 can be thought of as a transformation of a
particular class of FLPs into a VDAF.<a href="#section-7-5" class="pilcrow">¶</a></p>
<p id="section-7-6">The remainder of this section is structured as follows. The syntax for FLPs is
described in <a href="#flp" class="auto internal xref">Section 7.1</a>. The generic transformation of an FLP into Prio3 is
specified in <a href="#prio3-construction" class="auto internal xref">Section 7.2</a>. Next, a concrete FLP suitable for any
validity circuit is specified in <a href="#flp-bbcggi19" class="auto internal xref">Section 7.3</a>. Finally, instantiations of
Prio3 for various types of measurements are specified in
<a href="#prio3-instantiations" class="auto internal xref">Section 7.4</a>. Test vectors can be found in <a href="#test-vectors" class="auto internal xref">Appendix "Test Vectors"</a>.<a href="#section-7-6" class="pilcrow">¶</a></p>
<div id="flp">
<section id="section-7.1">
        <h3 id="name-fully-linear-proof-flp-syst">
<a href="#section-7.1" class="section-number selfRef">7.1. </a><a href="#name-fully-linear-proof-flp-syst" class="section-name selfRef">Fully Linear Proof (FLP) Systems</a>
        </h3>
<p id="section-7.1-1">Conceptually, an FLP is a two-party protocol executed by a prover and a
verifier. In actual use, however, the prover's computation is carried out by
the Client, and the verifier's computation is distributed among the
Aggregators. The Client generates a "proof" of its measurement's validity and
distributes shares of the proof to the Aggregators. Each Aggregator then
performs some computation on its measurement share and proof share locally and
sends the result to the other Aggregators. Combining the exchanged messages
allows each Aggregator to decide if it holds a share of a valid measurement.
(See <a href="#prio3-construction" class="auto internal xref">Section 7.2</a> for details.)<a href="#section-7.1-1" class="pilcrow">¶</a></p>
<p id="section-7.1-2">As usual, we will describe the interface implemented by a concrete FLP in terms
of an abstract base class <code>Flp</code> that specifies the set of methods and parameters
a concrete FLP must provide.<a href="#section-7.1-2" class="pilcrow">¶</a></p>
<p id="section-7.1-3">The parameters provided by a concrete FLP are listed in <a href="#flp-param" class="auto internal xref">Table 4</a>.<a href="#section-7.1-3" class="pilcrow">¶</a></p>
<span id="name-constants-and-types-defined-b"></span><div id="flp-param">
<table class="center" id="table-4">
          <caption>
<a href="#table-4" class="selfRef">Table 4</a>:
<a href="#name-constants-and-types-defined-b" class="selfRef">Constants and types defined by a concrete FLP.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Parameter</th>
              <th class="text-left" rowspan="1" colspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PROVE_RAND_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the prover randomness, the number of random field elements consumed by the prover when generating a proof</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>QUERY_RAND_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the query randomness, the number of random field elements consumed by the verifier</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>JOINT_RAND_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the joint randomness, the number of random field elements consumed by both the prover and verifier</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>MEAS_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the encoded measurement (<a href="#flp-encode" class="auto internal xref">Section 7.1.1</a>)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>OUTPUT_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the aggregatable output (<a href="#flp-encode" class="auto internal xref">Section 7.1.1</a>)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PROOF_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the proof</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>VERIFIER_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the verifier message generated by querying the measurement and proof</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Measurement</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Type of the measurement</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggResult</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Type of the aggregate result</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>field</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Class object for the field (<a href="#field" class="auto internal xref">Section 6.1</a>)</td>
            </tr>
          </tbody>
        </table>
</div>
<p id="section-7.1-5">An FLP specifies the following algorithms for generating and verifying proofs of
validity (encoding is described below in <a href="#flp-encode" class="auto internal xref">Section 7.1.1</a>):<a href="#section-7.1-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-6.1">
            <p id="section-7.1-6.1.1"><code>flp.prove(meas: list[F], prove_rand: list[F], joint_rand: list[F]) -&gt;
list[F]</code> is the deterministic proof-generation algorithm run by the prover.
Its inputs are the encoded measurement, the "prover randomness" <code>prove_rand</code>,
and the "joint randomness" <code>joint_rand</code>. The prover randomness is used only
by the prover, but the joint randomness is shared by both the prover and
verifier.<a href="#section-7.1-6.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-7.1-6.2">
            <p id="section-7.1-6.2.1"><code>flp.query(meas: list[F], proof: list[F], query_rand: list[F], joint_rand:
list[F], num_shares: int) -&gt; list[F]</code> is the query-generation algorithm run
by the verifier. This is used to "query" the measurement and proof. The
result of the query (i.e., the output of this function) is called the
"verifier message". In addition to the measurement and proof, this algorithm
takes as input the query randomness <code>query_rand</code> and the joint randomness
<code>joint_rand</code>. The former is used only by the verifier. <code>num_shares</code> specifies
how many shares were generated.<a href="#section-7.1-6.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-7.1-6.3">
            <p id="section-7.1-6.3.1"><code>flp.decide(verifier: list[F]) -&gt; bool</code> is the deterministic decision
algorithm run by the verifier. It takes as input the verifier message and
outputs a boolean indicating if the measurement from which it was generated
is valid.<a href="#section-7.1-6.3.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-7.1-7">Our application requires that the FLP is "fully linear" in the sense defined in
<span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>. As a practical matter, what this property implies is that, when
run on a share of the measurement and proof, the query-generation algorithm
outputs a share of the verifier message. Furthermore, the privacy property of
the FLP system ensures that the verifier message reveals nothing about the measurement
other than whether it is valid. Therefore, to decide if a measurement is valid, the
Aggregators will run the query-generation algorithm locally, exchange verifier
shares, combine them to recover the verifier message, and run the decision
algorithm.<a href="#section-7.1-7" class="pilcrow">¶</a></p>
<p id="section-7.1-8">The query-generation algorithm includes a parameter <code>num_shares</code> that specifies
the number of shares that were generated. If these data are not secret shared,
then <code>num_shares == 1</code>. This parameter is useful for certain FLP constructions.
For example, the FLP in <a href="#flp-bbcggi19" class="auto internal xref">Section 7.3</a> is defined in terms of an arithmetic
circuit; when the circuit contains constants, it is sometimes necessary to
normalize those constants to ensure that the circuit's output, when run on a
valid measurement, is the same regardless of the number of shares.<a href="#section-7.1-8" class="pilcrow">¶</a></p>
<p id="section-7.1-9">An FLP is executed by the prover and verifier as follows:<a href="#section-7.1-9" class="pilcrow">¶</a></p>
<span id="name-execution-of-an-flp"></span><div id="run-flp">
<figure id="figure-14">
          <div class="lang-python sourcecode" id="section-7.1-10.1">
<pre>
def run_flp(
        flp: Flp[Measurement, AggResult, F],
        meas: list[F],
        num_shares: int) -&gt; bool:
    """Run the FLP on an encoded measurement."""

    joint_rand = flp.field.rand_vec(flp.JOINT_RAND_LEN)
    prove_rand = flp.field.rand_vec(flp.PROVE_RAND_LEN)
    query_rand = flp.field.rand_vec(flp.QUERY_RAND_LEN)

    # Prover generates the proof.
    proof = flp.prove(meas, prove_rand, joint_rand)

    # Shard the measurement and the proof.
    meas_shares = additive_secret_share(
        meas,
        num_shares,
        flp.field,
    )
    proof_shares = additive_secret_share(
        proof,
        num_shares,
        flp.field,
    )

    # Verifier queries the meas shares and proof shares.
    verifier_shares = [
        flp.query(
            meas_share,
            proof_share,
            query_rand,
            joint_rand,
            num_shares,
        )
        for meas_share, proof_share in zip(meas_shares, proof_shares)
    ]

    # Combine the verifier shares into the verifier.
    verifier = flp.field.zeros(len(verifier_shares[0]))
    for verifier_share in verifier_shares:
        verifier = vec_add(verifier, verifier_share)

    # Verifier decides if the measurement is valid.
    return flp.decide(verifier)
</pre>
</div>
<figcaption><a href="#figure-14" class="selfRef">Figure 14</a>:
<a href="#name-execution-of-an-flp" class="selfRef">Execution of an FLP.</a>
          </figcaption></figure>
</div>
<p id="section-7.1-11">The proof system is constructed so that, if <code>meas</code> is valid, then <code>run_flp(flp,
meas, 1)</code> always returns <code>True</code>. On the other hand, if <code>meas</code> is invalid, then
as long as <code>joint_rand</code> and <code>query_rand</code> are generated uniform randomly, the
output is <code>False</code> with high probability. False positives are possible: there is
a small probability that a verifier accepts an invalid input as valid. An FLP
is said to be "sound" if this probability is sufficiently small. The soundness
of the FLP depends on a variety of parameters, like the length of the
input and the size of the field. See <a href="#flp-bbcggi19" class="auto internal xref">Section 7.3</a> for details.<a href="#section-7.1-11" class="pilcrow">¶</a></p>
<p id="section-7.1-12">Note that soundness of an FLP system is not the same as robustness for a VDAF
In particular, soundness of the FLP is necessary, but insufficient for
robusntess of Prio3 (<a href="#prio3" class="auto internal xref">Section 7</a>). See <a href="#security-multiproof" class="auto internal xref">Section 9.6</a> for details.<a href="#section-7.1-12" class="pilcrow">¶</a></p>
<p id="section-7.1-13">We remark that <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span> defines a much larger class of fully linear proof
systems than we consider here. In particular, what is called an "FLP" here is
called a 1.5-round, public-coin, interactive oracle proof system in their paper.<a href="#section-7.1-13" class="pilcrow">¶</a></p>
<div id="flp-encode">
<section id="section-7.1.1">
          <h4 id="name-encoding-the-input">
<a href="#section-7.1.1" class="section-number selfRef">7.1.1. </a><a href="#name-encoding-the-input" class="section-name selfRef">Encoding the Input</a>
          </h4>
<p id="section-7.1.1-1">The type of measurement being aggregated is defined by the FLP. Hence, the FLP
also specifies a method of encoding raw measurements as a vector of field
elements:<a href="#section-7.1.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1.1-2.1">
              <p id="section-7.1.1-2.1.1"><code>flp.encode(measurement: Measurement) -&gt; list[F]</code> encodes a raw measurement
as a vector of field elements. The return value <span class="bcp14">MUST</span> be of length <code>MEAS_LEN</code>.<a href="#section-7.1.1-2.1.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-7.1.1-3">For some FLPs, the encoded measurement also includes redundant field elements
that are useful for checking the proof, but which are not needed after the
proof has been checked. An example is the "integer sum" data type from
<span>[<a href="#CGB17" class="cite xref">CGB17</a>]</span> in which an integer in <code>range(2**k)</code> is encoded as a vector of <code>k</code>
field elements, each representing a bit of the integer (this type is also
defined in <a href="#prio3sum" class="auto internal xref">Section 7.4.2</a>). After consuming this vector, all that is needed is
the integer it represents. Thus the FLP defines an algorithm for truncating the
encoded measurement to the length of the aggregated output:<a href="#section-7.1.1-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1.1-4.1">
              <p id="section-7.1.1-4.1.1"><code>flp.truncate(meas: list[F]) -&gt; list[F]</code> maps an encoded measurement (e.g.,
the bit-encoding of the measurement) to an aggregatable output (e.g., the
singleton vector containing the measurement). The length of the input <span class="bcp14">MUST</span> be
<code>MEAS_LEN</code> and the length of the output <span class="bcp14">MUST</span> be <code>OUTPUT_LEN</code>.<a href="#section-7.1.1-4.1.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-7.1.1-5">Once the aggregate shares have been computed and combined together, their sum
can be converted into the aggregate result. This could be a projection from
the FLP's field to the integers, or it could include additional
post-processing.<a href="#section-7.1.1-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1.1-6.1">
              <p id="section-7.1.1-6.1.1"><code>flp.decode(output: list[F], num_measurements: int) -&gt; AggResult</code> maps a sum
of aggregate shares to an aggregate result.<a href="#section-7.1.1-6.1.1" class="pilcrow">¶</a></p>
<p id="section-7.1.1-6.1.2">
Pre-conditions:<a href="#section-7.1.1-6.1.2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1.1-6.1.3.1">
                  <p id="section-7.1.1-6.1.3.1.1">The length of <code>output</code> <span class="bcp14">MUST</span> be <code>OUTPUT_LEN</code>.<a href="#section-7.1.1-6.1.3.1.1" class="pilcrow">¶</a></p>
</li>
                <li class="normal" id="section-7.1.1-6.1.3.2">
                  <p id="section-7.1.1-6.1.3.2.1"><code>num_measurements</code> <span class="bcp14">MUST</span> equal the number of measurements that contributed
to the <code>output</code>.<a href="#section-7.1.1-6.1.3.2.1" class="pilcrow">¶</a></p>
</li>
              </ul>
</li>
          </ul>
<p id="section-7.1.1-7">We remark that, taken together, these three functionalities correspond roughly
to the notion of "Affine-aggregatable encodings (AFEs)" from <span>[<a href="#CGB17" class="cite xref">CGB17</a>]</span>.<a href="#section-7.1.1-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="multiproofs">
<section id="section-7.1.2">
          <h4 id="name-multiple-proofs">
<a href="#section-7.1.2" class="section-number selfRef">7.1.2. </a><a href="#name-multiple-proofs" class="section-name selfRef">Multiple Proofs</a>
          </h4>
<p id="section-7.1.2-1">It is sometimes desirable to generate and verify multiple independent proofs
for the same input. First, this improves the soundness of the proof system
without having to change any of its parameters. Second, it allows a smaller
field to be used (e.g., replace Field128 with Field64, see <a href="#flp-bbcggi19" class="auto internal xref">Section 7.3</a>)
without sacrificing soundness. Generally, choosing a smaller field can
significantly reduce communication cost. (This is a trade-off, of course, since
generating and verifying more proofs requires more time.) Given these benefits,
this feature is implemented by Prio3 (<a href="#prio3" class="auto internal xref">Section 7</a>).<a href="#section-7.1.2-1" class="pilcrow">¶</a></p>
<p id="section-7.1.2-2">To generate these proofs for a specific measurement, the prover calls
<code>flp.prove</code> multiple times, each time using an independently generated prover
and joint randomness string. The verifier checks each proof independently, each
time with an independently generated query randomness string. It accepts the
measurement only if all the decision algorithm accepts on each proof.<a href="#section-7.1.2-2" class="pilcrow">¶</a></p>
<p id="section-7.1.2-3">See <a href="#security-multiproof" class="auto internal xref">Section 9.6</a> below for discussions on choosing the right number
of proofs.<a href="#section-7.1.2-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="prio3-construction">
<section id="section-7.2">
        <h3 id="name-construction">
<a href="#section-7.2" class="section-number selfRef">7.2. </a><a href="#name-construction" class="section-name selfRef">Construction</a>
        </h3>
<p id="section-7.2-1">This section specifies <code>Prio3</code>, an implementation of the <code>Vdaf</code> interface
(<a href="#vdaf" class="auto internal xref">Section 5</a>). It has three generic parameters: an <code>NttField ({{ntt-field}}), an
</code>Flp<code> ({{flp}}) and a </code>Xof<code> ({{xof}}). It also has an associated constant,
</code>PROOFS<code>, with a value in </code>range(1, 256)`, denoting the number of FLPs
generated by the Client (<a href="#multiproofs" class="auto internal xref">Section 7.1.2</a>).<a href="#section-7.2-1" class="pilcrow">¶</a></p>
<p id="section-7.2-2">The associated constants and types required by the <code>Vdaf</code> interface are
defined in <a href="#prio3-param" class="auto internal xref">Table 5</a>. The methods required for sharding,
preparation, aggregation, and unsharding are described in the remaining
subsections. These methods refer to constants enumerated in
<a href="#prio3-const" class="auto internal xref">Table 6</a>.<a href="#section-7.2-2" class="pilcrow">¶</a></p>
<span id="name-vdaf-parameters-for-prio3"></span><div id="prio3-param">
<table class="center" id="table-5">
          <caption>
<a href="#table-5" class="selfRef">Table 5</a>:
<a href="#name-vdaf-parameters-for-prio3" class="selfRef">VDAF parameters for Prio3.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Parameter</th>
              <th class="text-left" rowspan="1" colspan="1">Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>VERIFY_KEY_SIZE</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Xof.SEED_SIZE</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>RAND_SIZE</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Xof.SEED_SIZE * SHARES if flp.JOINT_RAND_LEN == 0 else 2 * Xof.SEED_SIZE * SHARES</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>NONCE_SIZE</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>16</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>ROUNDS</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>1</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>SHARES</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">in <code>[2, 256)</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Measurement</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Flp.Measurement</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggParam</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>None</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PublicShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Optional[list[bytes]]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>InputShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>tuple[list[F], list[F], Optional[bytes]] | tuple[bytes, Optional[bytes]]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>OutShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>list[F]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>list[F]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggResult</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Flp.AggResult</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PrepState</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>tuple[list[F], Optional[bytes]]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PrepShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>tuple[list[F], Optional[bytes]]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PrepMessage</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Optional[bytes]</code>
</td>
            </tr>
          </tbody>
        </table>
</div>
<span id="name-constants-used-by-prio3"></span><div id="prio3-const">
<table class="center" id="table-6">
          <caption>
<a href="#table-6" class="selfRef">Table 6</a>:
<a href="#name-constants-used-by-prio3" class="selfRef">Constants used by Prio3.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Variable</th>
              <th class="text-left" rowspan="1" colspan="1">Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>USAGE_MEAS_SHARE: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">1</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>USAGE_PROOF_SHARE: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">2</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>USAGE_JOINT_RANDOMNESS: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">3</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>USAGE_PROVE_RANDOMNESS: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">4</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>USAGE_QUERY_RANDOMNESS: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">5</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>USAGE_JOINT_RAND_SEED: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">6</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>USAGE_JOINT_RAND_PART: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">7</td>
            </tr>
          </tbody>
        </table>
</div>
<div id="sharding">
<section id="section-7.2.1">
          <h4 id="name-sharding-3">
<a href="#section-7.2.1" class="section-number selfRef">7.2.1. </a><a href="#name-sharding-3" class="section-name selfRef">Sharding</a>
          </h4>
<p id="section-7.2.1-1">Recall from <a href="#flp" class="auto internal xref">Section 7.1</a> that the FLP syntax calls for "joint randomness" shared by
the prover (i.e., the Client) and the verifier (i.e., the Aggregators). VDAFs
have no such notion. Instead, the Client derives the joint randomness from its
measurement in a way that allows the Aggregators to reconstruct it from their
shares. (This idea is based on the Fiat-Shamir heuristic and is described in
Section 6.2.3 of <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>.)<a href="#section-7.2.1-1" class="pilcrow">¶</a></p>
<p id="section-7.2.1-2">The sharding algorithm involves the following steps:<a href="#section-7.2.1-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-7.2.1-3">
<li id="section-7.2.1-3.1">
              <p id="section-7.2.1-3.1.1">Encode the Client's measurement for the FLP<a href="#section-7.2.1-3.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-7.2.1-3.2">
              <p id="section-7.2.1-3.2.1">Shard the measurement into a sequence of measurement shares<a href="#section-7.2.1-3.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-7.2.1-3.3">
              <p id="section-7.2.1-3.3.1">Derive the joint randomness from the measurement shares and nonce<a href="#section-7.2.1-3.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-7.2.1-3.4">
              <p id="section-7.2.1-3.4.1">Run the FLP proof-generation algorithm using the derived joint randomness<a href="#section-7.2.1-3.4.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-7.2.1-3.5">
              <p id="section-7.2.1-3.5.1">Shard the proof into a sequence of proof shares<a href="#section-7.2.1-3.5.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-7.2.1-3.6">
              <p id="section-7.2.1-3.6.1">Return the public share, consisting of the joint randomness parts, and the
input shares, each consisting of the measurement share, proof share, and
blind of one of the Aggregators<a href="#section-7.2.1-3.6.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<p id="section-7.2.1-4">As described in <a href="#multiproofs" class="auto internal xref">Section 7.1.2</a>, the soundness of the FLP can be amplified
by generating and verifying multiple FLPs. (This in turn improves the
robustness of Prio3.) To support this, in Prio3:<a href="#section-7.2.1-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.2.1-5.1">
              <p id="section-7.2.1-5.1.1">In step 3, derive as much joint randomness as required by <code>PROOFS</code> proofs<a href="#section-7.2.1-5.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.2.1-5.2">
              <p id="section-7.2.1-5.2.1">Repeat step 4 <code>PROOFS</code> times, each time with a unique joint randomness<a href="#section-7.2.1-5.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-7.2.1-6">Depending on the FLP, joint randomness may not be required. In particular, when
<code>flp.JOINT_RAND_LEN == 0</code>, the Client does not derive the joint randomness
(Step 3). The sharding algorithm is specified below.<a href="#section-7.2.1-6" class="pilcrow">¶</a></p>
<span id="name-input-distribution-algorith"></span><div id="prio3-eval-input">
<figure id="figure-15">
            <div class="lang-python sourcecode" id="section-7.2.1-7.1">
<pre>
def shard(
        self,
        measurement: Measurement,
        nonce: bytes,
        rand: bytes) -&gt; tuple[
            Optional[list[bytes]],
            list[Prio3InputShare]]:
    if len(nonce) != self.NONCE_SIZE:
        raise ValueError("incorrect nonce size")
    if len(rand) != self.RAND_SIZE:
        raise ValueError("incorrect size of random bytes argument")

    l = self.xof.SEED_SIZE
    seeds = [rand[i:i + l] for i in range(0, self.RAND_SIZE, l)]

    meas = self.flp.encode(measurement)
    if self.flp.JOINT_RAND_LEN &gt; 0:
        return self.shard_with_joint_rand(meas, nonce, seeds)
    else:
        return self.shard_without_joint_rand(meas, seeds)
</pre>
</div>
<figcaption><a href="#figure-15" class="selfRef">Figure 15</a>:
<a href="#name-input-distribution-algorith" class="selfRef">Input-distribution algorithm for Prio3.</a>
            </figcaption></figure>
</div>
<p id="section-7.2.1-8">It starts by splitting the randomness into seeds. It then encodes the
measurement as prescribed by the FLP and calls one of two methods, depending on
whether joint randomness is required by the FLP. The methods are defined in the
subsections below.<a href="#section-7.2.1-8" class="pilcrow">¶</a></p>
<div id="flps-without-joint-randomness">
<section id="section-7.2.1.1">
            <h5 id="name-flps-without-joint-randomne">
<a href="#section-7.2.1.1" class="section-number selfRef">7.2.1.1. </a><a href="#name-flps-without-joint-randomne" class="section-name selfRef">FLPs without joint randomness</a>
            </h5>
<p id="section-7.2.1.1-1">The following method is used for FLPs that do not require joint randomness,
i.e., when <code>flp.JOINT_RAND_LEN == 0</code>:<a href="#section-7.2.1.1-1" class="pilcrow">¶</a></p>
<span id="name-sharding-an-encoded-measure"></span><div id="prio3-shard-without-joint-rand">
<figure id="figure-16">
              <div class="lang-python sourcecode" id="section-7.2.1.1-2.1">
<pre>
def shard_without_joint_rand(
        self,
        meas: list[F],
        seeds: list[bytes]) -&gt; tuple[
            Optional[list[bytes]],
            list[Prio3InputShare[F]]]:
    k_helper_shares, seeds = front(self.SHARES - 1, seeds)
    (k_prove,), seeds = front(1, seeds)

    # Shard the encoded measurement into shares.
    leader_meas_share = meas
    for j in range(self.SHARES - 1):
        leader_meas_share = vec_sub(
            leader_meas_share,
            self.helper_meas_share(j + 1, k_helper_shares[j]),
        )

    # Generate and shard each proof into shares.
    prove_rands = self.prove_rands(k_prove)
    leader_proofs_share = []
    for _ in range(self.PROOFS):
        prove_rand, prove_rands = front(
            self.flp.PROVE_RAND_LEN, prove_rands)
        leader_proofs_share += self.flp.prove(meas, prove_rand, [])
    for j in range(self.SHARES - 1):
        leader_proofs_share = vec_sub(
            leader_proofs_share,
            self.helper_proofs_share(
                j + 1,
                k_helper_shares[j],
            ),
        )

    # Each Aggregator's input share contains its measurement share
    # and share of proof(s).
    input_shares: list[Prio3InputShare[F]] = []
    input_shares.append((
        leader_meas_share,
        leader_proofs_share,
        None,
    ))
    for j in range(self.SHARES - 1):
        input_shares.append((
            k_helper_shares[j],
            None,
        ))
    return (None, input_shares)
</pre>
</div>
<figcaption><a href="#figure-16" class="selfRef">Figure 16</a>:
<a href="#name-sharding-an-encoded-measure" class="selfRef">Sharding an encoded measurement without joint randomness.</a>
              </figcaption></figure>
</div>
<p id="section-7.2.1.1-3">The steps in this method are as follows:<a href="#section-7.2.1.1-3" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-7.2.1.1-4">
<li id="section-7.2.1.1-4.1">
                <p id="section-7.2.1.1-4.1.1">Shard the encoded measurement into shares<a href="#section-7.2.1.1-4.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.2.1.1-4.2">
                <p id="section-7.2.1.1-4.2.1">Generate and shard each proof into shares<a href="#section-7.2.1.1-4.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.2.1.1-4.3">
                <p id="section-7.2.1.1-4.3.1">Encode each measurement and shares of each proof into an input share<a href="#section-7.2.1.1-4.3.1" class="pilcrow">¶</a></p>
</li>
            </ol>
<p id="section-7.2.1.1-5">Notice that only one pair of measurement and proof(s) share (called the
"leader" shares above) are vectors of field elements. The other shares (called
the "helper" shares) are represented instead by an XOF seed, which is expanded
into vectors of field elements.<a href="#section-7.2.1.1-5" class="pilcrow">¶</a></p>
<p id="section-7.2.1.1-6">The methods on <code>Prio3</code> for deriving the prover randomness, measurement shares,
and proof shares and the methods for encoding the input shares are defined in
<a href="#prio3-auxiliary" class="auto internal xref">Section 7.2.6</a>.<a href="#section-7.2.1.1-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="flps-with-joint-randomness">
<section id="section-7.2.1.2">
            <h5 id="name-flps-with-joint-randomness">
<a href="#section-7.2.1.2" class="section-number selfRef">7.2.1.2. </a><a href="#name-flps-with-joint-randomness" class="section-name selfRef">FLPs with joint randomness</a>
            </h5>
<p id="section-7.2.1.2-1">The following method is used for FLPs that require joint randomness,
i.e., for which <code>flp.JOINT_RAND_LEN &gt; 0</code>:<a href="#section-7.2.1.2-1" class="pilcrow">¶</a></p>
<span id="name-sharding-an-encoded-measurem"></span><div id="prio3-shard-with-joint-rand">
<figure id="figure-17">
              <div class="breakable lang-python sourcecode" id="section-7.2.1.2-2.1">
<pre>
def shard_with_joint_rand(
        self,
        meas: list[F],
        nonce: bytes,
        seeds: list[bytes]) -&gt; tuple[
            Optional[list[bytes]],
            list[Prio3InputShare[F]]]:
    k_helper_seeds, seeds = front((self.SHARES - 1) * 2, seeds)
    k_helper_shares = [
        k_helper_seeds[i]
        for i in range(0, (self.SHARES - 1) * 2, 2)
    ]
    k_helper_blinds = [
        k_helper_seeds[i]
        for i in range(1, (self.SHARES - 1) * 2, 2)
    ]
    (k_leader_blind, k_prove), seeds = front(2, seeds)

    # Shard the encoded measurement into shares and compute the
    # joint randomness parts.
    leader_meas_share = meas
    k_joint_rand_parts = []
    for j in range(self.SHARES - 1):
        helper_meas_share = self.helper_meas_share(
            j + 1, k_helper_shares[j])
        leader_meas_share = vec_sub(leader_meas_share,
                                    helper_meas_share)
        k_joint_rand_parts.append(self.joint_rand_part(
            j + 1, k_helper_blinds[j], helper_meas_share, nonce))
    k_joint_rand_parts.insert(0, self.joint_rand_part(
        0, k_leader_blind, leader_meas_share, nonce))

    # Generate the proof and shard it into proof shares.
    prove_rands = self.prove_rands(k_prove)
    joint_rands = self.joint_rands(
        self.joint_rand_seed(k_joint_rand_parts))
    leader_proofs_share = []
    for _ in range(self.PROOFS):
        prove_rand, prove_rands = front(
            self.flp.PROVE_RAND_LEN, prove_rands)
        joint_rand, joint_rands = front(
            self.flp.JOINT_RAND_LEN, joint_rands)
        leader_proofs_share += self.flp.prove(
            meas,
            prove_rand,
            joint_rand,
        )
    for j in range(self.SHARES - 1):
        leader_proofs_share = vec_sub(
            leader_proofs_share,
            self.helper_proofs_share(
                j + 1,
                k_helper_shares[j],
            ),
        )

    # Each Aggregator's input share contains its measurement share,
    # share of proof(s), and blind. The public share contains the
    # Aggregators' joint randomness parts.
    input_shares: list[Prio3InputShare[F]] = []
    input_shares.append((
        leader_meas_share,
        leader_proofs_share,
        k_leader_blind,
    ))
    for j in range(self.SHARES - 1):
        input_shares.append((
            k_helper_shares[j],
            k_helper_blinds[j],
        ))
    return (k_joint_rand_parts, input_shares)
</pre>
</div>
<figcaption><a href="#figure-17" class="selfRef">Figure 17</a>:
<a href="#name-sharding-an-encoded-measurem" class="selfRef">Sharding an encoded measurement with joint randomness.</a>
              </figcaption></figure>
</div>
<p id="section-7.2.1.2-3">The difference between this procedure and previous one is that here we compute
joint randomnesses <code>joint_rands</code>, split it into multiple <code>joint_rand</code>, and pass
each <code>joint_rand</code> to the proof generationg algorithm. (In
<a href="#prio3-shard-without-joint-rand" class="auto internal xref">Figure 16</a> the joint randomness is the empty vector,
<code>[]</code>.) This requires generating an additional value, called the "blind", that
is incorporated into each input share.<a href="#section-7.2.1.2-3" class="pilcrow">¶</a></p>
<p id="section-7.2.1.2-4">The joint randomness computation involves the following steps:<a href="#section-7.2.1.2-4" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-7.2.1.2-5">
<li id="section-7.2.1.2-5.1">
                <p id="section-7.2.1.2-5.1.1">Compute a "joint randomness part" from each measurement share and blind<a href="#section-7.2.1.2-5.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.2.1.2-5.2">
                <p id="section-7.2.1.2-5.2.1">Compute a "joint randomness seed" from the joint randomness parts<a href="#section-7.2.1.2-5.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.2.1.2-5.3">
                <p id="section-7.2.1.2-5.3.1">Compute the joint randomness for each proof evaluation from the joint randomness seed<a href="#section-7.2.1.2-5.3.1" class="pilcrow">¶</a></p>
</li>
            </ol>
<p id="section-7.2.1.2-6">This three-step process is designed to ensure that the joint randomness does
not leak the measurement to the Aggregators while preventing a malicious Client
from tampering with the joint randomness in a way that allows it to break
robustness. To bootstrap the required check, the Client encodes the joint
randomness parts in the public share. (See <a href="#prio3-preparation" class="auto internal xref">Section 7.2.2</a> for details.)<a href="#section-7.2.1.2-6" class="pilcrow">¶</a></p>
<p id="section-7.2.1.2-7">The methods used in this computation are defined in <a href="#prio3-auxiliary" class="auto internal xref">Section 7.2.6</a>.<a href="#section-7.2.1.2-7" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="prio3-preparation">
<section id="section-7.2.2">
          <h4 id="name-preparation-3">
<a href="#section-7.2.2" class="section-number selfRef">7.2.2. </a><a href="#name-preparation-3" class="section-name selfRef">Preparation</a>
          </h4>
<p id="section-7.2.2-1">This section describes the process of recovering output shares from the input
shares. The high-level idea is that each Aggregator first queries its
measurement and share of proof(s) locally, then exchanges its share of
verifier(s) with the other Aggregators. The shares of verifier(s) are then
combined into the verifier message(s) used to decide whether to accept.<a href="#section-7.2.2-1" class="pilcrow">¶</a></p>
<p id="section-7.2.2-2">In addition, for FLPs that require joint randomness, the Aggregators must
ensure that they have all used the same joint randomness for the
query-generation algorithm. To do so, they collectively re-derive the joint
randomness from their measurement shares just as the Client did during
sharding.<a href="#section-7.2.2-2" class="pilcrow">¶</a></p>
<p id="section-7.2.2-3">In order to avoid extra round of communication, the Client sends each
Aggregator a "hint" consisting of the joint randomness parts. This leaves open
the possibility that the Client cheated by, say, forcing the Aggregators to use
joint randomness that biases the proof check procedure some way in its favor.
To mitigate this, the Aggregators also check that they have all computed the
same joint randomness seed before accepting their output shares. To do so, they
exchange their parts of the joint randomness along with their shares of
verifier(s).<a href="#section-7.2.2-3" class="pilcrow">¶</a></p>
<p id="section-7.2.2-4">Implementation note: the preparation state for Prio3 includes the output share
that will be released once preparation is complete. In some situations, it may be
necessary for the Aggregator to encode this state as bytes and store it for
retrieval later on. For all but the first Aggregator, it is possible to save
storage by storing the measurement share rather than output share itself. It is
relatively inexpensive to expand this seed into the input share, then truncate
the input share to get the output share.<a href="#section-7.2.2-4" class="pilcrow">¶</a></p>
<p id="section-7.2.2-5">The definitions of constants and a few auxiliary functions are defined in
<a href="#prio3-auxiliary" class="auto internal xref">Section 7.2.6</a>.<a href="#section-7.2.2-5" class="pilcrow">¶</a></p>
<span id="name-preparation-state-for-prio3"></span><div id="prio3-prep-state">
<figure id="figure-18">
            <div class="breakable lang-python sourcecode" id="section-7.2.2-6.1">
<pre>
def prep_init(
        self,
        verify_key: bytes,
        agg_id: int,
        _agg_param: None,
        nonce: bytes,
        public_share: Optional[list[bytes]],
        input_share: Prio3InputShare[F]) -&gt; tuple[
            Prio3PrepState[F],
            Prio3PrepShare[F]]:
    k_joint_rand_parts = public_share
    (meas_share, proofs_share, k_blind) = \
        self.expand_input_share(agg_id, input_share)
    out_share = self.flp.truncate(meas_share)

    # Compute the joint randomness.
    joint_rand: list[F] = []
    k_corrected_joint_rand, k_joint_rand_part = None, None
    if self.flp.JOINT_RAND_LEN &gt; 0:
        assert k_blind is not None
        assert k_joint_rand_parts is not None
        k_joint_rand_part = self.joint_rand_part(
            agg_id, k_blind, meas_share, nonce)
        k_joint_rand_parts[agg_id] = k_joint_rand_part
        k_corrected_joint_rand = self.joint_rand_seed(
            k_joint_rand_parts)
        joint_rands = self.joint_rands(k_corrected_joint_rand)

    # Query the measurement and proof share.
    query_rands = self.query_rands(verify_key, nonce)
    verifiers_share = []
    for _ in range(self.PROOFS):
        proof_share, proofs_share = front(
            self.flp.PROOF_LEN, proofs_share)
        query_rand, query_rands = front(
            self.flp.QUERY_RAND_LEN, query_rands)
        if self.flp.JOINT_RAND_LEN &gt; 0:
            joint_rand, joint_rands = front(
                self.flp.JOINT_RAND_LEN, joint_rands)
        verifiers_share += self.flp.query(
            meas_share,
            proof_share,
            query_rand,
            joint_rand,
            self.SHARES,
        )

    prep_state = (out_share, k_corrected_joint_rand)
    prep_share = (verifiers_share, k_joint_rand_part)
    return (prep_state, prep_share)

def prep_next(
        self,
        prep_state: Prio3PrepState[F],
        prep_msg: Optional[bytes],
    ) -&gt; tuple[Prio3PrepState[F], Prio3PrepShare[F]] | list[F]:
    k_joint_rand = prep_msg
    (out_share, k_corrected_joint_rand) = prep_state

    # If joint randomness was used, check that the value computed by
    # the Aggregators matches the value indicated by the Client.
    if k_joint_rand != k_corrected_joint_rand:
        raise ValueError('joint randomness check failed')

    return out_share

def prep_shares_to_prep(
        self,
        _agg_param: None,
        prep_shares: list[Prio3PrepShare[F]]) -&gt; Optional[bytes]:
    # Unshard the verifier shares into the verifier message.
    verifiers = self.flp.field.zeros(
        self.flp.VERIFIER_LEN * self.PROOFS)
    k_joint_rand_parts = []
    for (verifiers_share, k_joint_rand_part) in prep_shares:
        verifiers = vec_add(verifiers, verifiers_share)
        if self.flp.JOINT_RAND_LEN &gt; 0:
            assert k_joint_rand_part is not None
            k_joint_rand_parts.append(k_joint_rand_part)

    # Verify that each proof is well-formed and input is valid
    for _ in range(self.PROOFS):
        verifier, verifiers = front(self.flp.VERIFIER_LEN, verifiers)
        if not self.flp.decide(verifier):
            raise ValueError('proof verifier check failed')

    # Combine the joint randomness parts computed by the
    # Aggregators into the true joint randomness seed. This is
    # used in the last step.
    k_joint_rand = None
    if self.flp.JOINT_RAND_LEN &gt; 0:
        k_joint_rand = self.joint_rand_seed(k_joint_rand_parts)
    return k_joint_rand
</pre>
</div>
<figcaption><a href="#figure-18" class="selfRef">Figure 18</a>:
<a href="#name-preparation-state-for-prio3" class="selfRef">Preparation state for Prio3.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="validity-of-aggregation-parameters">
<section id="section-7.2.3">
          <h4 id="name-validity-of-aggregation-param">
<a href="#section-7.2.3" class="section-number selfRef">7.2.3. </a><a href="#name-validity-of-aggregation-param" class="section-name selfRef">Validity of Aggregation Parameters</a>
          </h4>
<p id="section-7.2.3-1">Every input share <span class="bcp14">MUST</span> only be used once, regardless of the aggregation
parameters used.<a href="#section-7.2.3-1" class="pilcrow">¶</a></p>
<span id="name-validity-of-aggregation-parame"></span><div id="prio3-validity-scope">
<figure id="figure-19">
            <div class="lang-python sourcecode" id="section-7.2.3-2.1">
<pre>
def is_valid(
        self,
        _agg_param: None,
        previous_agg_params: list[None]) -&gt; bool:
    """
    Checks if `previous_agg_params` is empty, as input shares in
    Prio3 may only be used once.
    """
    return len(previous_agg_params) == 0
</pre>
</div>
<figcaption><a href="#figure-19" class="selfRef">Figure 19</a>:
<a href="#name-validity-of-aggregation-parame" class="selfRef">Validity of aggregation parameters for Prio3.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="aggregation">
<section id="section-7.2.4">
          <h4 id="name-aggregation-3">
<a href="#section-7.2.4" class="section-number selfRef">7.2.4. </a><a href="#name-aggregation-3" class="section-name selfRef">Aggregation</a>
          </h4>
<p id="section-7.2.4-1">Aggregating a set of output shares is simply a matter of adding up the vectors
element-wise.<a href="#section-7.2.4-1" class="pilcrow">¶</a></p>
<span id="name-aggregation-algorithm-for-p"></span><div id="prio3-out2agg">
<figure id="figure-20">
            <div class="lang-python sourcecode" id="section-7.2.4-2.1">
<pre>
def aggregate(
        self,
        _agg_param: None,
        out_shares: list[list[F]]) -&gt; list[F]:
    agg_share = self.flp.field.zeros(self.flp.OUTPUT_LEN)
    for out_share in out_shares:
        agg_share = vec_add(agg_share, out_share)
    return agg_share
</pre>
</div>
<figcaption><a href="#figure-20" class="selfRef">Figure 20</a>:
<a href="#name-aggregation-algorithm-for-p" class="selfRef">Aggregation algorithm for Prio3.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="unsharding">
<section id="section-7.2.5">
          <h4 id="name-unsharding-3">
<a href="#section-7.2.5" class="section-number selfRef">7.2.5. </a><a href="#name-unsharding-3" class="section-name selfRef">Unsharding</a>
          </h4>
<p id="section-7.2.5-1">To unshard a set of aggregate shares, the Collector first adds up the vectors
element-wise. It then converts each element of the vector into an integer.<a href="#section-7.2.5-1" class="pilcrow">¶</a></p>
<span id="name-computation-of-the-aggregat"></span><div id="prio3-agg-output">
<figure id="figure-21">
            <div class="lang-python sourcecode" id="section-7.2.5-2.1">
<pre>
def unshard(
        self,
        _agg_param: None,
        agg_shares: list[list[F]],
        num_measurements: int) -&gt; AggResult:
    agg = self.flp.field.zeros(self.flp.OUTPUT_LEN)
    for agg_share in agg_shares:
        agg = vec_add(agg, agg_share)
    return self.flp.decode(agg, num_measurements)
</pre>
</div>
<figcaption><a href="#figure-21" class="selfRef">Figure 21</a>:
<a href="#name-computation-of-the-aggregat" class="selfRef">Computation of the aggregate result for Prio3.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="prio3-auxiliary">
<section id="section-7.2.6">
          <h4 id="name-auxiliary-functions-2">
<a href="#section-7.2.6" class="section-number selfRef">7.2.6. </a><a href="#name-auxiliary-functions-2" class="section-name selfRef">Auxiliary Functions</a>
          </h4>
<p id="section-7.2.6-1">This section defines a number of auxiliary functions referenced by the main
algorithms for Prio3 in the preceding sections.<a href="#section-7.2.6-1" class="pilcrow">¶</a></p>
<p id="section-7.2.6-2">The following methods are called by the sharding and preparation algorithms.<a href="#section-7.2.6-2" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-7.2.6-3">
<pre>
def helper_meas_share(self, agg_id: int, k_share: bytes) -&gt; list[F]:
    return self.xof.expand_into_vec(
        self.flp.field,
        k_share,
        self.domain_separation_tag(USAGE_MEAS_SHARE),
        byte(agg_id),
        self.flp.MEAS_LEN,
    )

def helper_proofs_share(
        self,
        agg_id: int,
        k_share: bytes) -&gt; list[F]:
    return self.xof.expand_into_vec(
        self.flp.field,
        k_share,
        self.domain_separation_tag(USAGE_PROOF_SHARE),
        byte(self.PROOFS) + byte(agg_id),
        self.flp.PROOF_LEN * self.PROOFS,
    )

def expand_input_share(
        self,
        agg_id: int,
        input_share: Prio3InputShare[F]) -&gt; tuple[
            list[F],
            list[F],
            Optional[bytes]]:
    if agg_id &gt; 0:
        assert len(input_share) == 2
        (k_share, k_blind) = input_share
        meas_share = self.helper_meas_share(agg_id, k_share)
        proofs_share = self.helper_proofs_share(agg_id, k_share)
    else:
        assert len(input_share) == 3
        (meas_share, proofs_share, k_blind) = input_share
    return (meas_share, proofs_share, k_blind)

def prove_rands(self, k_prove: bytes) -&gt; list[F]:
    return self.xof.expand_into_vec(
        self.flp.field,
        k_prove,
        self.domain_separation_tag(USAGE_PROVE_RANDOMNESS),
        byte(self.PROOFS),
        self.flp.PROVE_RAND_LEN * self.PROOFS,
    )

def query_rands(self, verify_key: bytes, nonce: bytes) -&gt; list[F]:
    return self.xof.expand_into_vec(
        self.flp.field,
        verify_key,
        self.domain_separation_tag(USAGE_QUERY_RANDOMNESS),
        byte(self.PROOFS) + nonce,
        self.flp.QUERY_RAND_LEN * self.PROOFS,
    )

def joint_rand_part(
        self,
        agg_id: int,
        k_blind: bytes,
        meas_share: list[F],
        nonce: bytes) -&gt; bytes:
    return self.xof.derive_seed(
        k_blind,
        self.domain_separation_tag(USAGE_JOINT_RAND_PART),
        byte(agg_id) + nonce + self.flp.field.encode_vec(meas_share),
    )

def joint_rand_seed(self, k_joint_rand_parts: list[bytes]) -&gt; bytes:
    """Derive the joint randomness seed from its parts."""
    return self.xof.derive_seed(
        zeros(self.xof.SEED_SIZE),
        self.domain_separation_tag(USAGE_JOINT_RAND_SEED),
        concat(k_joint_rand_parts),
    )

def joint_rands(self, k_joint_rand_seed: bytes) -&gt; list[F]:
    """Derive the joint randomness from its seed."""
    return self.xof.expand_into_vec(
        self.flp.field,
        k_joint_rand_seed,
        self.domain_separation_tag(USAGE_JOINT_RANDOMNESS),
        byte(self.PROOFS),
        self.flp.JOINT_RAND_LEN * self.PROOFS,
    )
</pre><a href="#section-7.2.6-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="prio3-encode">
<section id="section-7.2.7">
          <h4 id="name-message-serialization">
<a href="#section-7.2.7" class="section-number selfRef">7.2.7. </a><a href="#name-message-serialization" class="section-name selfRef">Message Serialization</a>
          </h4>
<p id="section-7.2.7-1">This section defines serialization formats for messages exchanged over the
network while executing Prio3. It is <span class="bcp14">RECOMMENDED</span> that implementations provide
serialization methods for them.<a href="#section-7.2.7-1" class="pilcrow">¶</a></p>
<p id="section-7.2.7-2">Message structures are defined following <span><a href="https://rfc-editor.org/rfc/rfc8446#section-3" class="relref">Section 3</a> of [<a href="#RFC8446" class="cite xref">RFC8446</a>]</span>). In the
remainder we use <code>S</code> as an alias for <code>prio3.xof.SEED_SIZE</code> and <code>F</code> as an alias
for <code>prio3.field.ENCODED_SIZE</code>. XOF seeds are represented as follows:<a href="#section-7.2.7-2" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7-3">
<pre>
opaque Prio3Seed[S];
</pre><a href="#section-7.2.7-3" class="pilcrow">¶</a>
</div>
<p id="section-7.2.7-4">Field elements are encoded in little-endian byte order (as defined in
<a href="#field" class="auto internal xref">Section 6.1</a>) and represented as follows:<a href="#section-7.2.7-4" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7-5">
<pre>
opaque Prio3Field[F];
</pre><a href="#section-7.2.7-5" class="pilcrow">¶</a>
</div>
<div id="public-share">
<section id="section-7.2.7.1">
            <h5 id="name-public-share">
<a href="#section-7.2.7.1" class="section-number selfRef">7.2.7.1. </a><a href="#name-public-share" class="section-name selfRef">Public Share</a>
            </h5>
<p id="section-7.2.7.1-1">The encoding of the public share depends on whether joint randomness is
required for the underlying FLP (i.e., <code>prio3.flp.JOINT_RAND_LEN &gt; 0</code>). If
joint randomness is not used, then the public share is the empty string. If
joint randomness is used, then the public share encodes the joint randomness
parts as follows:<a href="#section-7.2.7.1-1" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7.1-2">
<pre>
struct {
    Prio3Seed k_joint_rand_parts[S * prio3.SHARES];
} Prio3PublicShareWithJointRand;
</pre><a href="#section-7.2.7.1-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="input-share">
<section id="section-7.2.7.2">
            <h5 id="name-input-share">
<a href="#section-7.2.7.2" class="section-number selfRef">7.2.7.2. </a><a href="#name-input-share" class="section-name selfRef">Input share</a>
            </h5>
<p id="section-7.2.7.2-1">Just as for the public share, the encoding of the input shares depends on
whether joint randomness is used. If so, then each input share includes the
Aggregator's blind for generating its joint randomness part.<a href="#section-7.2.7.2-1" class="pilcrow">¶</a></p>
<p id="section-7.2.7.2-2">In addition, the encoding of the input shares depends on which aggregator is
receiving the message. If the aggregator ID is <code>0</code>, then the input share
includes the full measurement and share of proof(s). Otherwise, if the aggregator ID
is greater than <code>0</code>, then the measurement and shares of proof(s) are
represented by an XOF seed. We shall call the former the "Leader" and the
latter the "Helpers".<a href="#section-7.2.7.2-2" class="pilcrow">¶</a></p>
<p id="section-7.2.7.2-3">In total there are four variants of the input share. When joint randomness is
not used, the Leader's share is structured as follows:<a href="#section-7.2.7.2-3" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7.2-4">
<pre>
struct {
    Prio3Field meas_share[F * prio3.flp.MEAS_LEN];
    Prio3Field proofs_share[F * prio3.flp.PROOF_LEN * prio3.PROOFS];
} Prio3LeaderShare;
</pre><a href="#section-7.2.7.2-4" class="pilcrow">¶</a>
</div>
<p id="section-7.2.7.2-5">When joint randomness is not used, the Helpers' shares are structured
as follows:<a href="#section-7.2.7.2-5" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7.2-6">
<pre>
struct {
    Prio3Seed k_share;
} Prio3HelperShare;
</pre><a href="#section-7.2.7.2-6" class="pilcrow">¶</a>
</div>
<p id="section-7.2.7.2-7">When joint randomness is used, the Leader's input share is structured as
follows:<a href="#section-7.2.7.2-7" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7.2-8">
<pre>
struct {
    Prio3LeaderShare inner;
    Prio3Seed k_blind;
} Prio3LeaderShareWithJointRand;
</pre><a href="#section-7.2.7.2-8" class="pilcrow">¶</a>
</div>
<p id="section-7.2.7.2-9">Finally, when joint randomness is used, the Helpers' shares are structured as
follows:<a href="#section-7.2.7.2-9" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7.2-10">
<pre>
struct {
    Prio3HelperShare inner;
    Prio3Seed k_blind;
} Prio3HelperShareWithJointRand;
</pre><a href="#section-7.2.7.2-10" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="prep-share">
<section id="section-7.2.7.3">
            <h5 id="name-prep-share">
<a href="#section-7.2.7.3" class="section-number selfRef">7.2.7.3. </a><a href="#name-prep-share" class="section-name selfRef">Prep Share</a>
            </h5>
<p id="section-7.2.7.3-1">When joint randomness is not used, the prep share is structured as follows:<a href="#section-7.2.7.3-1" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7.3-2">
<pre>
struct {
    Prio3Field verifiers_share[
        F * prio3.flp.VERIFIER_LEN * prio3.PROOFS
    ];
} Prio3PrepShare;
</pre><a href="#section-7.2.7.3-2" class="pilcrow">¶</a>
</div>
<p id="section-7.2.7.3-3">When joint randomness is used, the prep share includes the Aggregator's joint
randomness part and is structured as follows:<a href="#section-7.2.7.3-3" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7.3-4">
<pre>
struct {
    Prio3Field verifiers_share[
        F * prio3.flp.VERIFIER_LEN * prio3.PROOFS
    ];
    Prio3Seed k_joint_rand_part;
} Prio3PrepShareWithJointRand;
</pre><a href="#section-7.2.7.3-4" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="prep-message">
<section id="section-7.2.7.4">
            <h5 id="name-prep-message">
<a href="#section-7.2.7.4" class="section-number selfRef">7.2.7.4. </a><a href="#name-prep-message" class="section-name selfRef">Prep Message</a>
            </h5>
<p id="section-7.2.7.4-1">When joint randomness is not used, the prep message is the empty string.
Otherwise the prep message consists of the joint randomness seed computed by
the Aggregators:<a href="#section-7.2.7.4-1" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7.4-2">
<pre>
struct {
    Prio3Seed k_joint_rand;
} Prio3PrepMessageWithJointRand;
</pre><a href="#section-7.2.7.4-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="aggregation-1">
<section id="section-7.2.7.5">
            <h5 id="name-aggregation-4">
<a href="#section-7.2.7.5" class="section-number selfRef">7.2.7.5. </a><a href="#name-aggregation-4" class="section-name selfRef">Aggregation</a>
            </h5>
<p id="section-7.2.7.5-1">Aggregate shares are structured as follows:<a href="#section-7.2.7.5-1" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7.5-2">
<pre>
struct {
    Prio3Field agg_share[F * prio3.flp.OUTPUT_LEN];
} Prio3AggShare;
</pre><a href="#section-7.2.7.5-2" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="flp-bbcggi19">
<section id="section-7.3">
        <h3 id="name-the-flp-of">
<a href="#section-7.3" class="section-number selfRef">7.3. </a><a href="#name-the-flp-of" class="section-name selfRef">The FLP of <span class="cite xref">[BBCGGI19]</span></a>
        </h3>
<p id="section-7.3-1">This section describes an FLP based on the construction from <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>,
Section 4.2. We begin in <a href="#flp-bbcggi19-overview" class="auto internal xref">Section 7.3.1</a> with an overview of their
proof system and some extensions to it. The construction is specified in
<a href="#flp-bbcggi19-construction" class="auto internal xref">Section 7.3.3</a>.<a href="#section-7.3-1" class="pilcrow">¶</a></p>
<div id="flp-bbcggi19-overview">
<section id="section-7.3.1">
          <h4 id="name-overview-2">
<a href="#section-7.3.1" class="section-number selfRef">7.3.1. </a><a href="#name-overview-2" class="section-name selfRef">Overview</a>
          </h4>
<p id="section-7.3.1-1">Conventional zero-knowledge proof systems involve two parties:<a href="#section-7.3.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.1-2.1">
              <p id="section-7.3.1-2.1.1">The prover, who holds a measurement and generates a proof of the
measurement's validity<a href="#section-7.3.1-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.3.1-2.2">
              <p id="section-7.3.1-2.2.1">The verifier who holds an encryption of, or commitment to, the measurement
and checks the proof<a href="#section-7.3.1-2.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-7.3.1-3">Our proof system is much the same, except the verifier is split across multiple
Aggregators, each of which has a secret share of the measurement rather than an
encryption of it.<a href="#section-7.3.1-3" class="pilcrow">¶</a></p>
<p id="section-7.3.1-4">Validity is defined in terms of an arithmetic circuit evaluated over the
measurement. The inputs to this circuit are elements of a finite field that
comprise the encoded measurement; the gates of the circuit are multiplication,
addition, and subtraction operations; and the output of the circuit is a single
field element. If the value is zero, then the measurement is deemed valid;
otherwise, if the output is non-zero, then the measurement is deemed invalid.<a href="#section-7.3.1-4" class="pilcrow">¶</a></p>
<p id="section-7.3.1-5">For example, the simplest circuit specified in this document is the following
(<a href="#prio3count" class="auto internal xref">Section 7.4.1</a>):<a href="#section-7.3.1-5" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.3.1-6">
<pre>
C(x) = x * (x-1)
</pre><a href="#section-7.3.1-6" class="pilcrow">¶</a>
</div>
<p id="section-7.3.1-7">This circuit contains one subtraction gate (<code>x - 1</code>) and one multiplication
gate (<code>x * (x - 1)</code>). Observe that <code>C(x) = 0</code> if and only if <code>x in range(2)</code>.<a href="#section-7.3.1-7" class="pilcrow">¶</a></p>
<p id="section-7.3.1-8">Our goal is to allow each Aggregator, who holds a secret share of <code>x</code>, to
correctly compute a secret share of <code>C(x)</code>. This allows the Aggregators to
determine validity by combining their shares of the output.<a href="#section-7.3.1-8" class="pilcrow">¶</a></p>
<p id="section-7.3.1-9">Suppose for a moment that the validity circuit <code>C</code> is an affine arithmetic
circuit, meaning its only operations are addition, subtraction, and
multiplication-by-constant. (The circuit above is non-affine because it
contains a multiplication gate with two non-constant inputs.) Then each
Aggregator can compute its share locally, since<a href="#section-7.3.1-9" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.3.1-10">
<pre>
C(x_shares[0] + ... + x_shares[SHARES-1]) =
    C(x_shares[0]) + ... + C(x_shares[SHARES-1])
</pre><a href="#section-7.3.1-10" class="pilcrow">¶</a>
</div>
<p id="section-7.3.1-11">(Note that, for this equality to hold, it is necessary to scale any addition of
a constant in the circuit by <code>1/SHARES</code>.) However, this is not the case if <code>C</code>
contains multiplication gates with two non-constant inputs. Thus our goal is to
transform these multiplication gates into computations on secret shared data
that each Aggregator can perform locally.<a href="#section-7.3.1-11" class="pilcrow">¶</a></p>
<p id="section-7.3.1-12">The key idea is to have the prover construct a polynomial <code>p</code> such that <code>p(j)</code>
is equal to the output of the <code>j</code>-th multiplication gate. Polynomial evaluation
is fully linear, which means the coefficients of the polynomial can be secret
shared in a way that allows each Aggregator to compute a share of <code>p(j)</code> for
any <code>j</code>. These intermediate results can then be combined with the affine
arithmetic operations of the validity circuit to produce the final output.<a href="#section-7.3.1-12" class="pilcrow">¶</a></p>
<p id="section-7.3.1-13">Applying this idea to the example circuit <code>C</code> above:<a href="#section-7.3.1-13" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-7.3.1-14">
<li id="section-7.3.1-14.1">
              <p id="section-7.3.1-14.1.1">The Client, given its measurement <code>x</code>, constructs the lowest degree
polynomial <code>p</code> for which <code>p(0) = s</code> and <code>p(1) = x * (x - 1)</code>, where <code>s</code> is a
random blinding value generated by the Client. (The blinding value is to
protect the privacy of the measurement.) It sends secret shares of <code>x</code> and
the coefficients of <code>p</code> to each of the Aggregators.<a href="#section-7.3.1-14.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-7.3.1-14.2">
              <p id="section-7.3.1-14.2.1">Each Aggregator locally computes and broadcasts its share of <code>p(1)</code>, which
is equal to its share of <code>C(x)</code>.<a href="#section-7.3.1-14.2.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<p id="section-7.3.1-15">In fact, our FLP is slightly more general than this. We can replace the
multiplication gate with any non-affine sub-circuit and apply the same idea.
For example, in <a href="#prio3sum" class="auto internal xref">Section 7.4.2</a>, the validity circuit uses the following
sub-circuit multiple times:<a href="#section-7.3.1-15" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.3.1-16">
<pre>
Range2(x) = x * (x - 1) = x^2 - x
</pre><a href="#section-7.3.1-16" class="pilcrow">¶</a>
</div>
<p id="section-7.3.1-17">(This is the same functionality computed by the example circuit <code>C</code> above.)
Here again we can interpolate the lowest degree polynomial <code>p</code> for which <code>p(j)</code>
is the value of the <code>j</code>-th call to <code>Range2</code> in the validity circuit. Each
validity circuit defines a sub-circuit that encapsulates its non-affine
arithmetic operations. We refer to this sub-circuit as the "gadget".<a href="#section-7.3.1-17" class="pilcrow">¶</a></p>
<p id="section-7.3.1-18">This idea provides the needed functionality, but it has one more problem: it is
possible for a malicious Client to produce a gadget polynomial <code>p</code> that would
result in <code>C(x)</code> being computed incorrectly, potentially resulting in an
invalid measurement being accepted. To prevent this, the Aggregators perform a
probabilistic test to check that the gadget polynomial was constructed
properly. This "gadget test", and the procedure for constructing the
polynomial, are described in detail in <a href="#flp-bbcggi19-construction" class="auto internal xref">Section 7.3.3</a>.<a href="#section-7.3.1-18" class="pilcrow">¶</a></p>
<div id="flp-bbcggi19-overview-extensions">
<section id="section-7.3.1.1">
            <h5 id="name-extensions">
<a href="#section-7.3.1.1" class="section-number selfRef">7.3.1.1. </a><a href="#name-extensions" class="section-name selfRef">Extensions</a>
            </h5>
<p id="section-7.3.1.1-1">The FLP described in {#flp-bbcggi19-construction} extends the proof system of
<span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, Section 4.2 in a few ways.<a href="#section-7.3.1.1-1" class="pilcrow">¶</a></p>
<p id="section-7.3.1.1-2">First, the validity circuit in our construction includes an additional, random
input (this is the "joint randomness" derived from the measurement shares in
Prio3; see <a href="#prio3-construction" class="auto internal xref">Section 7.2</a>). This allows for circuit optimizations that
trade a small soundness error for a shorter proof. For example, consider a
circuit that recognizes the set of length-<code>N</code> vectors for which each element is
either one or zero. A deterministic circuit could be constructed for this
language, but it would involve a large number of multiplications that would
result in a large proof. (See the discussion in <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, Section 5.2 for
details). A much shorter proof can be constructed for the following randomized
circuit:<a href="#section-7.3.1.1-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.3.1.1-3">
<pre>
C(x, r) = r * Range2(x[0]) + ... + r^N * Range2(x[N-1])
</pre><a href="#section-7.3.1.1-3" class="pilcrow">¶</a>
</div>
<p id="section-7.3.1.1-4">(Note that this is a special case of <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, Theorem 5.2.) Here <code>x</code> is
the length-<code>N</code> input and <code>r</code> is a random field element. The gadget circuit
<code>Range2</code> is the "range-check" polynomial described above, i.e., <code>Range2(x) =
x^2 - x</code>. The idea is that, if <code>x</code> is valid (i.e., each <code>x[j]</code> is in
<code>range(2)</code>), then the circuit will evaluate to 0 regardless of the value of
<code>r</code>; but if some <code>x[j]</code> is not in <code>range(2)</code>, then output will be non-zero with
high probability.<a href="#section-7.3.1.1-4" class="pilcrow">¶</a></p>
<p id="section-7.3.1.1-5">The second extension implemented by our FLP allows the validity circuit to
contain multiple gadget types. (This generalization was suggested in
<span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, Remark 4.5.) This provides additional flexibility for designing
circuits by allowing multiple, non-affine sub-circuits. For example, the
following circuit is allowed:<a href="#section-7.3.1.1-5" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.3.1.1-6">
<pre>
C(meas, r) = r * Range2(meas[0]) + ... + r^L * Range2(meas[L-1]) + \
            r^(L+1) * Range3(meas[L]) + ... + r^N * Range3(meas[N-1])
</pre><a href="#section-7.3.1.1-6" class="pilcrow">¶</a>
</div>
<p id="section-7.3.1.1-7">where <code>Range3(x) = x^3 - 3x^2 + 2x</code>. This circuit checks that the first <code>L</code>
inputs are in <code>range(2)</code> and the last <code>N-L</code> inputs are in <code>range(3)</code>. The
same circuit can be expressed using a simpler gadget, namely multiplication,
but the resulting proof would be longer.<a href="#section-7.3.1.1-7" class="pilcrow">¶</a></p>
<p id="section-7.3.1.1-8">Third, rather than interpolate the gadget polynomial at inputs <code>1</code>, <code>2</code>, ...,
<code>j</code>, ..., where <code>j</code> is the <code>j</code>-th invocation of the gadget, we use powers of
<code>alpha</code>, where <code>alpha</code> is a root of unity for the field. This allows us to
construct each gadget polynomial via the number theoretic transform <span>[<a href="#SML24" class="cite xref">SML24</a>]</span>,
which is far more efficient than  generic formulas. This requires the field to
be "NTT-friendly" as defined in <a href="#field-ntt-friendly" class="auto internal xref">Section 6.1.2</a>.<a href="#section-7.3.1.1-8" class="pilcrow">¶</a></p>
<p id="section-7.3.1.1-9">Finally, the validity circuit in our FLP may have any number of outputs (at
least one). The input is said to be valid if each of the outputs is zero. To
save bandwidth, we take a random linear combination of the outputs. If each of
the outputs is zero, then the reduced output will be zero; but if one of the
outputs is non-zero, then the reduced output will be non-zero with high
probability.<a href="#section-7.3.1.1-9" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="flp-bbcggi19-valid">
<section id="section-7.3.2">
          <h4 id="name-validity-circuits">
<a href="#section-7.3.2" class="section-number selfRef">7.3.2. </a><a href="#name-validity-circuits" class="section-name selfRef">Validity Circuits</a>
          </h4>
<p id="section-7.3.2-1">The FLP described in <a href="#flp-bbcggi19-construction" class="auto internal xref">Section 7.3.3</a> is defined in terms of a
validity circuit <code>Valid</code> that implements the interface described here.<a href="#section-7.3.2-1" class="pilcrow">¶</a></p>
<p id="section-7.3.2-2">A concrete <code>Valid</code> defines the following parameters:<a href="#section-7.3.2-2" class="pilcrow">¶</a></p>
<span id="name-validity-circuit-parameters"></span><table class="center" id="table-7">
            <caption>
<a href="#table-7" class="selfRef">Table 7</a>:
<a href="#name-validity-circuit-parameters" class="selfRef">Validity circuit parameters.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGETS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">A list of gadgets</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGET_CALLS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Number of times each gadget is called</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>MEAS_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Length of the measurement</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>OUTPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Length of the aggregatable output</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>JOINT_RAND_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Length of the random input</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>EVAL_OUTPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Length of the circuit output</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Measurement</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">The type of measurement</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>AggResult</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Type of the aggregate result</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>field</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Class object for the field</td>
              </tr>
            </tbody>
          </table>
<p id="section-7.3.2-4">Each gadget <code>G</code> in <code>GADGETS</code> defines a constant <code>DEGREE</code> that specifies the
circuit's "arithmetic degree". This is defined to be the degree of the
polynomial that computes it. For example, the <code>Mul</code> circuit in
<a href="#flp-bbcggi19-overview" class="auto internal xref">Section 7.3.1</a> is defined by the polynomial <code>Mul(x) = x * x</code>, which
has degree <code>2</code>. Hence, the arithmetic degree of this gadget is <code>2</code>.<a href="#section-7.3.2-4" class="pilcrow">¶</a></p>
<p id="section-7.3.2-5">Each gadget also defines a parameter <code>ARITY</code> that specifies the circuit's arity
(i.e., the number of input wires).<a href="#section-7.3.2-5" class="pilcrow">¶</a></p>
<p id="section-7.3.2-6">Gadgets provide a method to evaluate their circuit on a list of inputs,
<code>eval()</code>. The inputs can either belong to the validity circuit's field, or the
polynomial ring over that field.<a href="#section-7.3.2-6" class="pilcrow">¶</a></p>
<p id="section-7.3.2-7">A concrete <code>Valid</code> provides the following methods for encoding a measurement as
an input vector, truncating an input vector to the length of an aggregatable
output, and converting an aggregated output to an aggregate result:<a href="#section-7.3.2-7" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.2-8.1">
              <p id="section-7.3.2-8.1.1"><code>valid.encode(measurement: Measurement) -&gt; list[F]</code> returns a vector of
length <code>MEAS_LEN</code> representing a measurement.<a href="#section-7.3.2-8.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.3.2-8.2">
              <p id="section-7.3.2-8.2.1"><code>valid.truncate(meas: list[F]) -&gt; list[F]</code> returns a vector of length
<code>OUTPUT_LEN</code> representing an aggregatable output.<a href="#section-7.3.2-8.2.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.3.2-8.3">
              <p id="section-7.3.2-8.3.1"><code>valid.decode(output: list[F], num_measurements: int) -&gt; AggResult</code>
returns an aggregate result.<a href="#section-7.3.2-8.3.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-7.3.2-9">Finally, the following methods are derived for each concrete <code>Valid</code>:<a href="#section-7.3.2-9" class="pilcrow">¶</a></p>
<span id="name-derived-methods-for-validit"></span><figure id="figure-22">
            <div class="lang-python sourcecode" id="section-7.3.2-10.1">
<pre>
def prove_rand_len(self) -&gt; int:
    """Length of the prover randomness."""
    return sum(g.ARITY for g in self.GADGETS)

def query_rand_len(self) -&gt; int:
    """Length of the query randomness."""
    query_rand_len = len(self.GADGETS)
    if self.EVAL_OUTPUT_LEN &gt; 1:
        query_rand_len += 1
    return query_rand_len

def proof_len(self) -&gt; int:
    """Length of the proof."""
    length = 0
    for (g, g_calls) in zip(self.GADGETS, self.GADGET_CALLS):
        P = next_power_of_2(1 + g_calls)
        length += g.ARITY + g.DEGREE * (P - 1) + 1
    return length

def verifier_len(self) -&gt; int:
    """Length of the verifier message."""
    length = 1
    for g in self.GADGETS:
        length += g.ARITY + 1
    return length

def check_valid_eval(
        self,
        meas: list[F],
        joint_rand: list[F]) -&gt; None:
    if len(meas) != self.MEAS_LEN:
        raise ValueError('incorrect measurement length')
    if len(joint_rand) != self.JOINT_RAND_LEN:
        raise ValueError('incorrect joint randomness length')
</pre>
</div>
<figcaption><a href="#figure-22" class="selfRef">Figure 22</a>:
<a href="#name-derived-methods-for-validit" class="selfRef">Derived methods for validity circuits.</a>
            </figcaption></figure>
</section>
</div>
<div id="flp-bbcggi19-construction">
<section id="section-7.3.3">
          <h4 id="name-construction-2">
<a href="#section-7.3.3" class="section-number selfRef">7.3.3. </a><a href="#name-construction-2" class="section-name selfRef">Construction</a>
          </h4>
<p id="section-7.3.3-1">This section specifies an implementation of the <code>Flp</code> interface (<a href="#flp" class="auto internal xref">Section 7.1</a>). It
has as a generic parameter a validity circuit <code>Valid</code> implementing the
interface defined in <a href="#flp-bbcggi19-valid" class="auto internal xref">Section 7.3.2</a>.<a href="#section-7.3.3-1" class="pilcrow">¶</a></p>
<p id="section-7.3.3-2">The parameters are defined in <a href="#flp-bbcggi19-param" class="auto internal xref">Table 8</a>. The required methods for
generating the proof, generating the verifier, and deciding validity are
specified in the remaining subsections.<a href="#section-7.3.3-2" class="pilcrow">¶</a></p>
<p id="section-7.3.3-3">In the remainder, we let <code>[n]</code> denote the set <code>{1, ..., n}</code> for positive integer
<code>n</code>. We also define the following constants:<a href="#section-7.3.3-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.3-4.1">
              <p id="section-7.3.3-4.1.1">Let <code>H = len(valid.GADGETS)</code><a href="#section-7.3.3-4.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.3.3-4.2">
              <p id="section-7.3.3-4.2.1">For each <code>i</code> in <code>[H]</code>:<a href="#section-7.3.3-4.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.3-4.2.2.1">
                  <p id="section-7.3.3-4.2.2.1.1">Let <code>G_i = valid.GADGETS[i]</code><a href="#section-7.3.3-4.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li class="normal" id="section-7.3.3-4.2.2.2">
                  <p id="section-7.3.3-4.2.2.2.1">Let <code>L_i = valid.GADGETS[i].ARITY</code><a href="#section-7.3.3-4.2.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li class="normal" id="section-7.3.3-4.2.2.3">
                  <p id="section-7.3.3-4.2.2.3.1">Let <code>M_i = valid.GADGET_CALLS[i]</code><a href="#section-7.3.3-4.2.2.3.1" class="pilcrow">¶</a></p>
</li>
                <li class="normal" id="section-7.3.3-4.2.2.4">
                  <p id="section-7.3.3-4.2.2.4.1">Let <code>P_i = next_power_of_2(M_i+1)</code><a href="#section-7.3.3-4.2.2.4.1" class="pilcrow">¶</a></p>
</li>
                <li class="normal" id="section-7.3.3-4.2.2.5">
                  <p id="section-7.3.3-4.2.2.5.1">Let <code>alpha_i = field.gen()^(field.GEN_ORDER / P_i)</code><a href="#section-7.3.3-4.2.2.5.1" class="pilcrow">¶</a></p>
</li>
              </ul>
</li>
          </ul>
<span id="name-parameters-of-flp-of-bbcggi"></span><div id="flp-bbcggi19-param">
<table class="center" id="table-8">
            <caption>
<a href="#table-8" class="selfRef">Table 8</a>:
<a href="#name-parameters-of-flp-of-bbcggi" class="selfRef">Parameters of FLP of BBCGGI19.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>PROVE_RAND_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>valid.prove_rand_len()</code> (see <a href="#flp-bbcggi19-valid" class="auto internal xref">Section 7.3.2</a>)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>QUERY_RAND_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>valid.query_rand_len()</code> (see <a href="#flp-bbcggi19-valid" class="auto internal xref">Section 7.3.2</a>)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>JOINT_RAND_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>valid.JOINT_RAND_LEN</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>MEAS_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>valid.MEAS_LEN</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>OUTPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>valid.OUTPUT_LEN</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>PROOF_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>valid.proof_len()</code> (see <a href="#flp-bbcggi19-valid" class="auto internal xref">Section 7.3.2</a>)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>VERIFIER_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>valid.verifier_len()</code> (see <a href="#flp-bbcggi19-valid" class="auto internal xref">Section 7.3.2</a>)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Measurement</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>valid.Measurement</code>
</td>
              </tr>
            </tbody>
          </table>
</div>
<div id="flp-bbcggi19-construction-prove">
<section id="section-7.3.3.1">
            <h5 id="name-proof-generation">
<a href="#section-7.3.3.1" class="section-number selfRef">7.3.3.1. </a><a href="#name-proof-generation" class="section-name selfRef">Proof Generation</a>
            </h5>
<span id="name-the-proof-generation-algori"></span><div id="flp-bbcggi19-prove-illustration">
<figure id="figure-23">
              <div class="alignLeft art-text artwork" id="section-7.3.3.1-1.1">
<pre>
+------------------+
| Prove            |
| +-------------+  |
| | Valid       |&lt;---- meas
| | +--------+  |&lt;---- joint rand
| | | Gadget |  |  |&lt;- prove rand
| | +--------+  |  |
| +-------------+  |
+------------------+
 |
 V proof
</pre>
</div>
<figcaption><a href="#figure-23" class="selfRef">Figure 23</a>:
<a href="#name-the-proof-generation-algori" class="selfRef">The proof generation algorithm invokes the validity circuit on the encoded measurement and joint randomness. The validity circuit in turn invokes the gadget(s) defined by the circuit. The prove randomness is used to construct the gadget polynomial(s).</a>
              </figcaption></figure>
</div>
<p id="section-7.3.3.1-2">On input of <code>meas</code>, <code>prove_rand</code>, and <code>joint_rand</code>, the proof is computed as
follows:<a href="#section-7.3.3.1-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-7.3.3.1-3">
<li id="section-7.3.3.1-3.1">
                <p id="section-7.3.3.1-3.1.1">For each <code>i</code> in <code>[H]</code> create an empty table <code>wire_i</code>.<a href="#section-7.3.3.1-3.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.3.3.1-3.2">
                <p id="section-7.3.3.1-3.2.1">Partition the prover randomness <code>prove_rand</code> into sub-vectors <code>seed_1, ...,
seed_H</code> where <code>len(seed_i) == L_i</code> for all <code>i</code> in <code>[H]</code>. Let us call these
the "wire seeds" of each gadget.<a href="#section-7.3.3.1-3.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.3.3.1-3.3">
                <p id="section-7.3.3.1-3.3.1">Evaluate <code>Valid</code> on input of <code>meas</code> and <code>joint_rand</code>, recording the inputs
of each gadget in the corresponding table. Specifically, for every <code>i</code> in
<code>[H]</code>, set <code>wire_i[j-1,k-1]</code> to the value on the <code>j</code>th wire into the <code>k</code>th
call to gadget <code>G_i</code>.<a href="#section-7.3.3.1-3.3.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.3.3.1-3.4">
                <p id="section-7.3.3.1-3.4.1">Compute the "wire polynomials". That is, for every <code>i</code> in <code>[H]</code> and <code>j</code> in
<code>[L_i]</code>, construct <code>poly_wire_i[j-1]</code>, the <code>j</code>th wire polynomial for the
<code>i</code>th gadget, as follows:<a href="#section-7.3.3.1-3.4.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.3.1-3.4.2.1">
                    <p id="section-7.3.3.1-3.4.2.1.1">Let <code>w = [seed_i[j-1], wire_i[j-1,0], ..., wire_i[j-1,M_i-1]]</code>.<a href="#section-7.3.3.1-3.4.2.1.1" class="pilcrow">¶</a></p>
</li>
                  <li class="normal" id="section-7.3.3.1-3.4.2.2">
                    <p id="section-7.3.3.1-3.4.2.2.1">Let <code>padded_w = w + field.zeros(P_i - len(w))</code>.<a href="#section-7.3.3.1-3.4.2.2.1" class="pilcrow">¶</a></p>
</li>
                  <li class="normal" id="section-7.3.3.1-3.4.2.3">
                    <p id="section-7.3.3.1-3.4.2.3.1">Let <code>poly_wire_i[j-1]</code> be the lowest degree polynomial for which
<code>poly_wire_i[j-1](alpha_i^k) == padded_w[k]</code> for all <code>k</code> in <code>[P_i]</code>.<a href="#section-7.3.3.1-3.4.2.3.1" class="pilcrow">¶</a></p>
</li>
                </ul>
</li>
              <li id="section-7.3.3.1-3.5">
                <p id="section-7.3.3.1-3.5.1">Compute the "gadget polynomials". That is, for every <code>i</code> in <code>[H]</code>:<a href="#section-7.3.3.1-3.5.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.3.1-3.5.2.1">
                    <p id="section-7.3.3.1-3.5.2.1.1">Let <code>poly_gadget_i = G_i(poly_wire_i[0], ..., poly_wire_i[L_i-1])</code>. That
is, evaluate the circuit <code>G_i</code> on the wire polynomials for the <code>i</code>th
gadget. (Arithmetic is in the ring of polynomials over <code>field</code>.)<a href="#section-7.3.3.1-3.5.2.1.1" class="pilcrow">¶</a></p>
</li>
                </ul>
</li>
            </ol>
<p id="section-7.3.3.1-4">The proof is the vector <code>proof = seed_1 + coeff_1 + ... + seed_H + coeff_H</code>,
where <code>coeff_i</code> is the vector of coefficients of <code>poly_gadget_i</code> for each <code>i</code> in
<code>[H]</code>.<a href="#section-7.3.3.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="flp-bbcggi19-construction-query">
<section id="section-7.3.3.2">
            <h5 id="name-query-generation">
<a href="#section-7.3.3.2" class="section-number selfRef">7.3.3.2. </a><a href="#name-query-generation" class="section-name selfRef">Query Generation</a>
            </h5>
<span id="name-the-query-generation-algori"></span><div id="flp-bbcggi19-query-illustration">
<figure id="figure-24">
              <div class="alignLeft art-text artwork" id="section-7.3.3.2-1.1">
<pre>
 | proof (share)
 +--------+
 V        |
+---------|--------+
| Query   |        |
| +-------|-----+  |
| | Valid |     |&lt;---- meas (share)
| | +-----|--+  |&lt;---- joint rand
| | |     V  |  |  |&lt;- query rand
| | +--------+  |  |
| +-------------+  |
+------------------+
 |
 V verifier (share)
</pre>
</div>
<figcaption><a href="#figure-24" class="selfRef">Figure 24</a>:
<a href="#name-the-query-generation-algori" class="selfRef">The query generation algorithm invokes the validity circuit on the encoded measurement and joint randomness. It evaluates the gadget polynomials(s) encoded by the proof (share) to produce (a share of) each gadget output. The verifier (share) consists of (a share of) the validity circuit's output and (a share of) each gadget test. The tests consume the query randomness.</a>
              </figcaption></figure>
</div>
<p id="section-7.3.3.2-2">On input of <code>meas</code>, <code>proof</code>, <code>query_rand</code>, and <code>joint_rand</code>, the verifier message
is generated as follows:<a href="#section-7.3.3.2-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-7.3.3.2-3">
<li id="section-7.3.3.2-3.1">
                <p id="section-7.3.3.2-3.1.1">For every <code>i</code> in <code>[H]</code> create an empty table <code>wire_i</code>.<a href="#section-7.3.3.2-3.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.3.3.2-3.2">
                <p id="section-7.3.3.2-3.2.1">Partition <code>proof</code> into the sub-vectors <code>seed_1</code>, <code>coeff_1</code>, ..., <code>seed_H</code>,
<code>coeff_H</code> defined in <a href="#flp-bbcggi19-construction-prove" class="auto internal xref">Section 7.3.3.1</a>.<a href="#section-7.3.3.2-3.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.3.3.2-3.3">
                <p id="section-7.3.3.2-3.3.1">Evaluate <code>Valid</code> on input of <code>meas</code> and <code>joint_rand</code>, recording the inputs
of each gadget in the corresponding table. This step is similar to the
prover's step (3.) except the verifier does not evaluate the gadgets.
Instead, it computes the output of the <code>k</code>th call to <code>G_i</code> by evaluating
<code>poly_gadget_i(alpha_i^k)</code>. Let <code>out</code> denote the output of the circuit
evaluation.<a href="#section-7.3.3.2-3.3.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.3.3.2-3.4">
                <p id="section-7.3.3.2-3.4.1">Next, reduce <code>out</code> as follows. If <code>EVAL_OUTPUT_LEN &gt; 1</code>, then consume the
first element of <code>query_rand</code> by letting <code>[r], query_rand = front(1,
query_rand)</code>. Then let <code>v = r*out[0] + r**2*out[1] + r**3*out[2] + ...</code>.
That is, interpret the outputs as coefficients of a polynomial <code>f(x)</code> and
evaluate polynomial <code>f(x)*x</code> at a random point <code>r</code>.<a href="#section-7.3.3.2-3.4.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.3.3.2-3.5">
                <p id="section-7.3.3.2-3.5.1">Compute the wire polynomials just as in the prover's step (4.).<a href="#section-7.3.3.2-3.5.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.3.3.2-3.6">
                <p id="section-7.3.3.2-3.6.1">Compute the tests for well-formedness of the gadget polynomials. That is, for
every <code>i</code> in <code>[H]</code>:<a href="#section-7.3.3.2-3.6.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.3.2-3.6.2.1">
                    <p id="section-7.3.3.2-3.6.2.1.1">Let <code>t = query_rand[i]</code>. Check if <code>t^(P_i) == 1</code>: if so, then raise
ERR_ABORT and halt. (This prevents the verifier from inadvertently leaking
a gadget output in the verifier message.)<a href="#section-7.3.3.2-3.6.2.1.1" class="pilcrow">¶</a></p>
</li>
                  <li class="normal" id="section-7.3.3.2-3.6.2.2">
                    <p id="section-7.3.3.2-3.6.2.2.1">Let <code>y_i = poly_gadget_i(t)</code>.<a href="#section-7.3.3.2-3.6.2.2.1" class="pilcrow">¶</a></p>
</li>
                  <li class="normal" id="section-7.3.3.2-3.6.2.3">
                    <p id="section-7.3.3.2-3.6.2.3.1">For each <code>j</code> in <code>[0,L_i)</code> let <code>x_i[j-1] = poly_wire_i[j-1](t)</code>.<a href="#section-7.3.3.2-3.6.2.3.1" class="pilcrow">¶</a></p>
</li>
                </ul>
</li>
            </ol>
<p id="section-7.3.3.2-4">The verifier message is the vector <code>verifier = [v] + x_1 + [y_1] + ... + x_H +
[y_H]</code>.<a href="#section-7.3.3.2-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="decision">
<section id="section-7.3.3.3">
            <h5 id="name-decision">
<a href="#section-7.3.3.3" class="section-number selfRef">7.3.3.3. </a><a href="#name-decision" class="section-name selfRef">Decision</a>
            </h5>
<span id="name-the-decision-algorithm-cons"></span><div id="flp-bbcggi19-decide-illustration">
<figure id="figure-25">
              <div class="alignLeft art-text artwork" id="section-7.3.3.3-1.1">
<pre>
 | verifier
 V
+------------------+
| Decide           |
+------------------+
 |
 V is_valid
</pre>
</div>
<figcaption><a href="#figure-25" class="selfRef">Figure 25</a>:
<a href="#name-the-decision-algorithm-cons" class="selfRef">The decision algorithm consumes the verifier, consisting of the reduced output of the validity circuit and each gadget test. The verifier is produced by adding up the verifier shares output by each Aggregator.</a>
              </figcaption></figure>
</div>
<p id="section-7.3.3.3-2">On input of vector <code>verifier</code>, the verifier decides if the measurement is valid
as follows:<a href="#section-7.3.3.3-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-7.3.3.3-3">
<li id="section-7.3.3.3-3.1">
                <p id="section-7.3.3.3-3.1.1">Parse <code>verifier</code> into <code>v</code>, <code>x_1</code>, <code>y_1</code>, ..., <code>x_H</code>, <code>y_H</code> as defined in
<a href="#flp-bbcggi19-construction-query" class="auto internal xref">Section 7.3.3.2</a>.<a href="#section-7.3.3.3-3.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.3.3.3-3.2">
                <p id="section-7.3.3.3-3.2.1">Check for well-formedness of the gadget polynomials. For every <code>i</code> in <code>[H]</code>:<a href="#section-7.3.3.3-3.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.3.3-3.2.2.1">
                    <p id="section-7.3.3.3-3.2.2.1.1">Let <code>z = G_i(x_i)</code>. That is, evaluate the circuit <code>G_i</code> on <code>x_i</code> and set
<code>z</code> to the output.<a href="#section-7.3.3.3-3.2.2.1.1" class="pilcrow">¶</a></p>
</li>
                  <li class="normal" id="section-7.3.3.3-3.2.2.2">
                    <p id="section-7.3.3.3-3.2.2.2.1">If <code>z != y_i</code>, then return <code>False</code> and halt.<a href="#section-7.3.3.3-3.2.2.2.1" class="pilcrow">¶</a></p>
</li>
                </ul>
</li>
              <li id="section-7.3.3.3-3.3">
                <p id="section-7.3.3.3-3.3.1">Return <code>True</code> if <code>v == 0</code> and <code>False</code> otherwise.<a href="#section-7.3.3.3-3.3.1" class="pilcrow">¶</a></p>
</li>
            </ol>
</section>
</div>
<div id="encoding">
<section id="section-7.3.3.4">
            <h5 id="name-encoding">
<a href="#section-7.3.3.4" class="section-number selfRef">7.3.3.4. </a><a href="#name-encoding" class="section-name selfRef">Encoding</a>
            </h5>
<p id="section-7.3.3.4-1">The FLP encoding and truncation methods invoke <code>valid.encode</code>,
<code>valid.truncate</code>, and <code>valid.decode</code> in the natural way.<a href="#section-7.3.3.4-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="prio3-instantiations">
<section id="section-7.4">
        <h3 id="name-instantiations">
<a href="#section-7.4" class="section-number selfRef">7.4. </a><a href="#name-instantiations" class="section-name selfRef">Instantiations</a>
        </h3>
<p id="section-7.4-1">This section specifies instantiations of Prio3 for various measurement types.
Each is determined by a field (<a href="#field" class="auto internal xref">Section 6.1</a>), a validity circuit
(<a href="#flp-bbcggi19-valid" class="auto internal xref">Section 7.3.2</a>), an XOF (<a href="#xof" class="auto internal xref">Section 6.2</a>). and the number of proofs to
generate and verify. Test vectors for each can be found in <a href="#test-vectors" class="auto internal xref">Appendix "Test Vectors"</a>.<a href="#section-7.4-1" class="pilcrow">¶</a></p>
<div id="prio3count">
<section id="section-7.4.1">
          <h4 id="name-prio3count">
<a href="#section-7.4.1" class="section-number selfRef">7.4.1. </a><a href="#name-prio3count" class="section-name selfRef">Prio3Count</a>
          </h4>
<span id="name-parameters-for-prio3count"></span><table class="center" id="table-9">
            <caption>
<a href="#table-9" class="selfRef">Table 9</a>:
<a href="#name-parameters-for-prio3count" class="selfRef">Parameters for Prio3Count.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Count(Field64)</code> (this section)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field64</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>PROOFS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Xof</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>XofTurboShake128</code> (<a href="#xof-turboshake128" class="auto internal xref">Section 6.2.1</a>)</td>
              </tr>
            </tbody>
          </table>
<p id="section-7.4.1-2">Our first instance of Prio3 is for a simple counter: each measurement is either
one or zero and the aggregate result is the sum of the measurements.<a href="#section-7.4.1-2" class="pilcrow">¶</a></p>
<p id="section-7.4.1-3">Its validity circuit, denoted <code>Count</code>, uses the following degree-2, arity-2
gadget, denoted <code>Mul</code>:<a href="#section-7.4.1-3" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.4.1-4">
<pre>
def eval(self, _field: type[F], inp: list[F]) -&gt; F:
    self.check_gadget_eval(inp)
    return inp[0] * inp[1]
</pre><a href="#section-7.4.1-4" class="pilcrow">¶</a>
</div>
<p id="section-7.4.1-5">The call to <code>check_gadget_eval()</code> raises an error if the length of the input is
not equal to the gadget's <code>ARITY</code> parameter.<a href="#section-7.4.1-5" class="pilcrow">¶</a></p>
<p id="section-7.4.1-6">The <code>Count</code> validity circuit is defined as<a href="#section-7.4.1-6" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.4.1-7">
<pre>
def eval(
        self,
        meas: list[F],
        joint_rand: list[F],
        _num_shares: int) -&gt; list[F]:
    self.check_valid_eval(meas, joint_rand)
    squared = self.GADGETS[0].eval(self.field, [meas[0], meas[0]])
    return [squared - meas[0]]
</pre><a href="#section-7.4.1-7" class="pilcrow">¶</a>
</div>
<p id="section-7.4.1-8">The measurement is encoded and decoded as a singleton vector in the natural
way. The parameters for this circuit are summarized below.<a href="#section-7.4.1-8" class="pilcrow">¶</a></p>
<span id="name-parameters-of-validity-circ"></span><table class="center" id="table-10">
            <caption>
<a href="#table-10" class="selfRef">Table 10</a>:
<a href="#name-parameters-of-validity-circ" class="selfRef">Parameters of validity circuit Count.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGETS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>[Mul]</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGET_CALLS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>[1]</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>MEAS_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>OUTPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>JOINT_RAND_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>0</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>EVAL_OUTPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Measurement</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>int</code> in <code>range(2)</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>AggResult</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>int</code>
</td>
              </tr>
            </tbody>
          </table>
</section>
</div>
<div id="prio3sum">
<section id="section-7.4.2">
          <h4 id="name-prio3sum">
<a href="#section-7.4.2" class="section-number selfRef">7.4.2. </a><a href="#name-prio3sum" class="section-name selfRef">Prio3Sum</a>
          </h4>
<span id="name-parameters-for-prio3sum"></span><table class="center" id="table-11">
            <caption>
<a href="#table-11" class="selfRef">Table 11</a>:
<a href="#name-parameters-for-prio3sum" class="selfRef">Parameters for Prio3Sum.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Sum(Field64, max_measurement)</code> (this section)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field64</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>PROOFS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Xof</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>XofTurboShake128</code> (<a href="#xof-turboshake128" class="auto internal xref">Section 6.2.1</a>)</td>
              </tr>
            </tbody>
          </table>
<p id="section-7.4.2-2">The next instance of Prio3 supports summing of integers in a pre-determined
range. Each measurement is an integer in <code>range(max_measurement+1)</code>, where
<code>max_measurement</code> is an associated parameter equal to the largest valid
measurement.<a href="#section-7.4.2-2" class="pilcrow">¶</a></p>
<p id="section-7.4.2-3">The range check is accomplished by encoding the measurement as a bit vector,
encoding the measurement plus an offset as a bit vector, then checking that the
two encoded integers are consistent. Let<a href="#section-7.4.2-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.4.2-4.1">
              <p id="section-7.4.2-4.1.1"><code>bits = max_measurement.bit_length()</code>, the number of bits needed to encode
the largest valid measurement<a href="#section-7.4.2-4.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.4.2-4.2">
              <p id="section-7.4.2-4.2.1"><code>offset = 2**bits - 1 - max_measurement</code><a href="#section-7.4.2-4.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-7.4.2-5">The first bit-encoded integer is the measurement itself. Note that only
measurements between <code>0</code> and <code>2**bits - 1</code> can be encoded this way with
<code>bits</code> bits. The second bit-encoded integer is the sum of the measurement and
<code>offset</code>. Observe that this sum can only be encoded this way if it is between <code>0</code>
and <code>2**bits - 1</code>, which implies that the measurement is between <code>-offset</code> and
<code>max_measurement</code>.<a href="#section-7.4.2-5" class="pilcrow">¶</a></p>
<p id="section-7.4.2-6">The circuit, denoted <code>Sum</code>, first checks that each entry of both bit vectors is
a one or a zero. It then decodes both the measurement and the offset
measurement, and subtracts <code>offset</code> from the latter. It then checks if these
two values are equal. Since both the measurement and the measurement plus
<code>offset</code> are in the same range of <code>range(2**bits)</code>, this means that the
measurement itself is between <code>0</code> and <code>max_measurement</code>.<a href="#section-7.4.2-6" class="pilcrow">¶</a></p>
<p id="section-7.4.2-7">The measurement is encoded in <code>2*bits</code> field elements as follows:<a href="#section-7.4.2-7" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.4.2-8">
<pre>
def encode(self, measurement: int) -&gt; list[F]:
    encoded = []
    encoded += self.field.encode_into_bit_vector(
        measurement,
        self.bits
    )
    encoded += self.field.encode_into_bit_vector(
        measurement + self.offset.as_unsigned(),
        self.bits
    )
    return encoded

def truncate(self, meas: list[F]) -&gt; list[F]:
    return [self.field.decode_from_bit_vector(meas[:self.bits])]

def decode(self, output: list[F], _num_measurements: int) -&gt; int:
    return output[0].as_unsigned()
</pre><a href="#section-7.4.2-8" class="pilcrow">¶</a>
</div>
<p id="section-7.4.2-9">The validity circuit checks that the input consists of ones and zeros. Its
gadget, denoted <code>Range2</code>, is the degree-2, arity-1 gadget defined as<a href="#section-7.4.2-9" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.4.2-10">
<pre>
def eval(self, _field: type[F], inp: list[F]) -&gt; F:
    self.check_gadget_eval(inp)
    return inp[0] * inp[0] - inp[0]
</pre><a href="#section-7.4.2-10" class="pilcrow">¶</a>
</div>
<p id="section-7.4.2-11">The <code>Sum</code> validity circuit is defined as<a href="#section-7.4.2-11" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.4.2-12">
<pre>
def eval(
        self,
        meas: list[F],
        joint_rand: list[F],
        num_shares: int) -&gt; list[F]:
    self.check_valid_eval(meas, joint_rand)
    shares_inv = self.field(num_shares).inv()

    out = []
    for b in meas:
        out.append(self.GADGETS[0].eval(self.field, [b]))

    range_check = self.offset * shares_inv + \
        self.field.decode_from_bit_vector(meas[:self.bits]) - \
        self.field.decode_from_bit_vector(meas[self.bits:])
    out.append(range_check)
    return out
</pre><a href="#section-7.4.2-12" class="pilcrow">¶</a>
</div>
<span id="name-parameters-of-validity-circu"></span><table class="center" id="table-12">
            <caption>
<a href="#table-12" class="selfRef">Table 12</a>:
<a href="#name-parameters-of-validity-circu" class="selfRef">Parameters of validity circuit Sum.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGETS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>[Range2]</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGET_CALLS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>[2*bits]</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>MEAS_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>2*bits</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>OUTPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>JOINT_RAND_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>0</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>EVAL_OUTPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>2*bits + 1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Measurement</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>int</code> in <code>range(max_measurement+1)</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>AggResult</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>int</code>
</td>
              </tr>
            </tbody>
          </table>
</section>
</div>
<div id="prio3sumvec">
<section id="section-7.4.3">
          <h4 id="name-prio3sumvec">
<a href="#section-7.4.3" class="section-number selfRef">7.4.3. </a><a href="#name-prio3sumvec" class="section-name selfRef">Prio3SumVec</a>
          </h4>
<span id="name-parameters-for-prio3sumvec"></span><table class="center" id="table-13">
            <caption>
<a href="#table-13" class="selfRef">Table 13</a>:
<a href="#name-parameters-for-prio3sumvec" class="selfRef">Parameters for Prio3SumVec.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>SumVec(Field128, length, bits, chunk_lengh)</code> (this section)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field128</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>PROOFS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Xof</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>XofTurboShake128</code> (<a href="#xof-turboshake128" class="auto internal xref">Section 6.2.1</a>)</td>
              </tr>
            </tbody>
          </table>
<p id="section-7.4.3-2">This instance of Prio3 supports summing a vector of integers. It has three
parameters, <code>length</code>, <code>bits</code>, and <code>chunk_length</code>. Each measurement is a vector
of positive integers with length equal to the <code>length</code> parameter. Each element
of the measurement is an integer in the <code>range(2**bits)</code>. It is <span class="bcp14">RECOMMENDED</span>
to set <code>chunk_length</code> to an integer near the square root of <code>length * bits</code>
(see <a href="#parallel-sum-chunk-length" class="auto internal xref">Section 7.4.3.1</a>).<a href="#section-7.4.3-2" class="pilcrow">¶</a></p>
<p id="section-7.4.3-3">The validity circuit is denoted <code>SumVec</code>. Measurements are encoded as a vector
of field elements with length <code>length * bits</code>. The field elements in the
encoded vector represent all the bits of the measurement vector's elements,
consecutively, in LSB to MSB order:<a href="#section-7.4.3-3" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.4.3-4">
<pre>
def encode(self, measurement: list[int]) -&gt; list[F]:
    if len(measurement) != self.length:
        raise ValueError('incorrect measurement length')

    encoded = []
    for val in measurement:
        if val not in range(2**self.bits):
            raise ValueError(
                'entry of measurement vector is out of range'
            )

        encoded += self.field.encode_into_bit_vector(val, self.bits)
    return encoded

def truncate(self, meas: list[F]) -&gt; list[F]:
    truncated = []
    for i in range(self.length):
        truncated.append(self.field.decode_from_bit_vector(
            meas[i * self.bits: (i + 1) * self.bits]
        ))
    return truncated

def decode(
        self,
        output: list[F],
        _num_measurements: int) -&gt; list[int]:
    return [x.as_unsigned() for x in output]
</pre><a href="#section-7.4.3-4" class="pilcrow">¶</a>
</div>
<p id="section-7.4.3-5">This validity circuit uses a <code>ParallelSum</code> gadget to achieve a smaller proof
size. This optimization for "parallel-sum circuits" is described in
<span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, section 4.4. Briefly, for circuits that add up the output of
multiple identical subcircuits, it is possible to achieve smaller proof sizes
(on the order of O(sqrt(MEAS_LEN)) instead of O(MEAS_LEN)) by packaging more
than one such subcircuit into a gadget.<a href="#section-7.4.3-5" class="pilcrow">¶</a></p>
<p id="section-7.4.3-6">The <code>ParallelSum</code> gadget is parameterized with an arithmetic subcircuit, and a
<code>count</code> of how many times it evaluates that subcircuit. It takes in a list of
inputs and passes them through to instances of the subcircuit in the same order.
It returns the sum of the subcircuit outputs. Note that only the <code>ParallelSum</code>
gadget itself, and not its subcircuit, participates in the FLP's wire recording
during evaluation, gadget consistency proofs, and proof validation, even though
the subcircuit is provided to <code>ParallelSum</code> as an implementation of the
<code>Gadget</code> interface.<a href="#section-7.4.3-6" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.4.3-7">
<pre>
def eval(self, field: type[F], inp: list[F]) -&gt; F:
    self.check_gadget_eval(inp)
    out = field(0)
    for i in range(self.count):
        start_index = i * self.subcircuit.ARITY
        end_index = (i + 1) * self.subcircuit.ARITY
        out += self.subcircuit.eval(
            field,
            inp[start_index:end_index],
        )
    return out
</pre><a href="#section-7.4.3-7" class="pilcrow">¶</a>
</div>
<p id="section-7.4.3-8">The <code>SumVec</code> validity circuit checks that the encoded measurement consists of
ones and zeros. Rather than use the <code>Range2</code> gadget on each element, as in the
<code>Sum</code> validity circuit, it instead uses <code>Mul</code> subcircuits and "free" constant
multiplication and addition gates to simultaneously evaluate the same range
check polynomial on each element, and multiply by a constant. One of the two
<code>Mul</code> subcircuit inputs is equal to a measurement element multiplied by a power
of the joint randomness value, and the other is equal to the same measurement
element minus one. These <code>Mul</code> subcircuits are evaluated by a <code>ParallelSum</code>
gadget, and the results are added up both within the <code>ParallelSum</code> gadget and
after it.<a href="#section-7.4.3-8" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.4.3-9">
<pre>
def eval(
        self,
        meas: list[F],
        joint_rand: list[F],
        num_shares: int) -&gt; list[F]:
    self.check_valid_eval(meas, joint_rand)

    out = self.field(0)
    r = joint_rand[0]
    r_power = r
    shares_inv = self.field(num_shares).inv()

    for i in range(self.GADGET_CALLS[0]):
        inputs: list[Optional[F]]
        inputs = [None] * (2 * self.chunk_length)
        for j in range(self.chunk_length):
            index = i * self.chunk_length + j
            if index &lt; len(meas):
                meas_elem = meas[index]
            else:
                meas_elem = self.field(0)

            inputs[j * 2] = r_power * meas_elem
            inputs[j * 2 + 1] = meas_elem - shares_inv

            r_power *= r

        out += self.GADGETS[0].eval(
            self.field,
            cast(list[F], inputs),
        )

    return [out]
</pre><a href="#section-7.4.3-9" class="pilcrow">¶</a>
</div>
<span id="name-parameters-of-validity-circui"></span><table class="center" id="table-14">
            <caption>
<a href="#table-14" class="selfRef">Table 14</a>:
<a href="#name-parameters-of-validity-circui" class="selfRef">Parameters of validity circuit SumVec.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGETS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>[ParallelSum(Mul(), chunk_length)]</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGET_CALLS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>[(length * bits + chunk_length - 1) // chunk_length]</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>MEAS_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>length * bits</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>OUTPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>length</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>JOINT_RAND_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>EVAL_OUTPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Measurement</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>list[int]</code>, each element in <code>range(2**bits)</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>AggResult</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>list[int]</code>
</td>
              </tr>
            </tbody>
          </table>
<div id="parallel-sum-chunk-length">
<section id="section-7.4.3.1">
            <h5 id="name-selection-of-parallelsum-ch">
<a href="#section-7.4.3.1" class="section-number selfRef">7.4.3.1. </a><a href="#name-selection-of-parallelsum-ch" class="section-name selfRef">Selection of <code>ParallelSum</code> chunk length</a>
            </h5>
<p id="section-7.4.3.1-1">The <code>chunk_length</code> parameter provides a trade-off between the arity of the
<code>ParallelSum</code> gadget and the number of times the gadget is called. The proof
length is asymptotically minimized when the chunk length is near the square root
of the length of the measurement. However, the relationship between VDAF
parameters and proof length is complicated, involving two forms of rounding (the
circuit pads the inputs to its last <code>ParallelSum</code> gadget call, up to the chunk
length, and proof system rounds the degree of wire polynomials -- determined by
the number of times a gadget is called -- up to the next power of two).
Therefore, the optimal choice of <code>chunk_length</code> for a concrete measurement size
will vary, and must be found through trial and error. Setting <code>chunk_length</code>
equal to the square root of the appropriate measurement length will result in
proofs up to 50% larger than the optimal proof size.<a href="#section-7.4.3.1-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="prio3histogram">
<section id="section-7.4.4">
          <h4 id="name-prio3histogram">
<a href="#section-7.4.4" class="section-number selfRef">7.4.4. </a><a href="#name-prio3histogram" class="section-name selfRef">Prio3Histogram</a>
          </h4>
<span id="name-parameters-for-prio3histogr"></span><table class="center" id="table-15">
            <caption>
<a href="#table-15" class="selfRef">Table 15</a>:
<a href="#name-parameters-for-prio3histogr" class="selfRef">Parameters for Prio3Histogram.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Histogram(Field128, length, chunk_lengh)</code> (this section)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field128</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>PROOFS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Xof</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>XofTurboShake128</code> (<a href="#xof-turboshake128" class="auto internal xref">Section 6.2.1</a>)</td>
              </tr>
            </tbody>
          </table>
<p id="section-7.4.4-2">This instance of Prio3 allows for estimating the distribution of some quantity
by computing a simple histogram. Each measurement increments one histogram
bucket, out of a set of fixed buckets. (Bucket indexing begins at <code>0</code>.) For
example, the buckets might quantize the real numbers, and each measurement would
report the bucket that the corresponding client's real-numbered value falls
into. The aggregate result counts the number of measurements in each bucket.<a href="#section-7.4.4-2" class="pilcrow">¶</a></p>
<p id="section-7.4.4-3">The validity circuit is denoted <code>Histogram</code>. It has two parameters, <code>length</code>,
the number of histogram buckets, and <code>chunk_length</code>, which is used by by a
circuit optimization described below. It is <span class="bcp14">RECOMMENDED</span> to set <code>chunk_length</code>
to an integer near the square root of <code>length</code> (see
<a href="#parallel-sum-chunk-length" class="auto internal xref">Section 7.4.3.1</a>).<a href="#section-7.4.4-3" class="pilcrow">¶</a></p>
<p id="section-7.4.4-4">The measurement is encoded as a one-hot vector representing the bucket into
which the measurement falls:<a href="#section-7.4.4-4" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.4.4-5">
<pre>
def encode(self, measurement: int) -&gt; list[F]:
    encoded = [self.field(0)] * self.length
    encoded[measurement] = self.field(1)
    return encoded

def truncate(self, meas: list[F]) -&gt; list[F]:
    return meas

def decode(
        self,
        output: list[F],
        _num_measurements: int) -&gt; list[int]:
    return [bucket_count.as_unsigned() for bucket_count in output]
</pre><a href="#section-7.4.4-5" class="pilcrow">¶</a>
</div>
<p id="section-7.4.4-6">The <code>Histogram</code> validity circuit checks for one-hotness in two steps, by
checking that the encoded measurement consists of ones and zeros, and by
checking that the sum of all elements in the encoded measurement is equal to
one. All the individual checks are combined together in a random linear
combination.<a href="#section-7.4.4-6" class="pilcrow">¶</a></p>
<p id="section-7.4.4-7">As in the <code>SumVec</code> validity circuit (<a href="#prio3sumvec" class="auto internal xref">Section 7.4.3</a>), the first part of the
validity circuit uses the <code>ParallelSum</code> gadget to perform range checks while
achieving a smaller proof size. The <code>ParallelSum</code> gadget uses <code>Mul</code> subcircuits
to evaluate a range check polynomial on each element, and includes an additional
constant multiplication. One of the two <code>Mul</code> subcircuit inputs is equal to a
measurement element multiplied by a power of the first joint randomness value,
and the other is equal to the same measurement element minus one. The results
are added up both within the <code>ParallelSum</code> gadget and after it.<a href="#section-7.4.4-7" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.4.4-8">
<pre>
def eval(
        self,
        meas: list[F],
        joint_rand: list[F],
        num_shares: int) -&gt; list[F]:
    self.check_valid_eval(meas, joint_rand)

    # Check that each bucket is one or zero.
    range_check = self.field(0)
    r = joint_rand[0]
    r_power = r
    shares_inv = self.field(num_shares).inv()
    for i in range(self.GADGET_CALLS[0]):
        inputs: list[Optional[F]]
        inputs = [None] * (2 * self.chunk_length)
        for j in range(self.chunk_length):
            index = i * self.chunk_length + j
            if index &lt; len(meas):
                meas_elem = meas[index]
            else:
                meas_elem = self.field(0)

            inputs[j * 2] = r_power * meas_elem
            inputs[j * 2 + 1] = meas_elem - shares_inv

            r_power *= r

        range_check += self.GADGETS[0].eval(
            self.field,
            cast(list[F], inputs),
        )

    # Check that the buckets sum to 1.
    sum_check = -shares_inv
    for b in meas:
        sum_check += b

    out = joint_rand[1] * range_check + \
        joint_rand[1] ** 2 * sum_check
    return [out]
</pre><a href="#section-7.4.4-8" class="pilcrow">¶</a>
</div>
<p id="section-7.4.4-9">Note that this circuit depends on the number of shares into which the
measurement is sharded. This is provided to the FLP by Prio3.<a href="#section-7.4.4-9" class="pilcrow">¶</a></p>
<span id="name-parameters-of-validity-circuit"></span><table class="center" id="table-16">
            <caption>
<a href="#table-16" class="selfRef">Table 16</a>:
<a href="#name-parameters-of-validity-circuit" class="selfRef">Parameters of validity circuit Histogram.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGETS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>[ParallelSum(Mul(), chunk_length)]</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGET_CALLS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>[(length + chunk_length - 1) // chunk_length]</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>MEAS_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>length</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>OUTPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>length</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>JOINT_RAND_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>2</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>EVAL_OUTPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Measurement</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>int</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>AggResult</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>list[int]</code>
</td>
              </tr>
            </tbody>
          </table>
</section>
</div>
<div id="prio3multihotcountvec">
<section id="section-7.4.5">
          <h4 id="name-prio3multihotcountvec">
<a href="#section-7.4.5" class="section-number selfRef">7.4.5. </a><a href="#name-prio3multihotcountvec" class="section-name selfRef">Prio3MultihotCountVec</a>
          </h4>
<span id="name-parameters-for-prio3multiho"></span><table class="center" id="table-17">
            <caption>
<a href="#table-17" class="selfRef">Table 17</a>:
<a href="#name-parameters-for-prio3multiho" class="selfRef">Parameters for Prio3MultihotCountVec.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>MultihotCountVec(Field128, length, max_weight, chunk_lengh)</code> (this section)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field128</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>PROOFS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Xof</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>XofTurboShake128</code> (<a href="#xof-turboshake128" class="auto internal xref">Section 6.2.1</a>)</td>
              </tr>
            </tbody>
          </table>
<p id="section-7.4.5-2">For this instance of Prio3, each measurement is a vector of ones and zeros,
where the number of ones is bounded. This provides a functionality similar to
Prio3Histogram except that more than one entry may be non-zero. This allows
Prio3MultihotCountVec to be composed with a randomized response mechanism, like
<span>[<a href="#EPK14" class="cite xref">EPK14</a>]</span>, for providing differential privacy. (For example, each Client would
set each entry to one with some small probability.)<a href="#section-7.4.5-2" class="pilcrow">¶</a></p>
<p id="section-7.4.5-3">Prio3MultihotCountVec uses XofTurboShake128 (<a href="#xof-turboshake128" class="auto internal xref">Section 6.2.1</a>) as its XOF.
Its validity circuit is denoted <code>MultihotCountVec</code>. It has three parameters:
<code>length</code>, the number of of entries in the count vector; <code>max_weight</code>, the
maximum number of non-zero entries (i.e., the weight must be at most
<code>max_weight</code>); and <code>chunk_length</code>, used the same way as in <a href="#prio3sumvec" class="auto internal xref">Section 7.4.3</a> and
<a href="#prio3histogram" class="auto internal xref">Section 7.4.4</a>.<a href="#section-7.4.5-3" class="pilcrow">¶</a></p>
<p id="section-7.4.5-4">Validation works as follows. Let<a href="#section-7.4.5-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.4.5-5.1">
              <p id="section-7.4.5-5.1.1"><code>bits_for_weight = max_weight.bit_length()</code><a href="#section-7.4.5-5.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.4.5-5.2">
              <p id="section-7.4.5-5.2.1"><code>offset = 2**bits_for_weight - 1 - max_weight</code><a href="#section-7.4.5-5.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-7.4.5-6">The Client reports the weight of the count vector by adding <code>offset</code> to it and
bit-encoding the result. Observe that only a weight of at most <code>max_weight</code> can
be encoded with <code>bits_for_weight</code> bits.<a href="#section-7.4.5-6" class="pilcrow">¶</a></p>
<p id="section-7.4.5-7">The verifier checks that each entry of the encoded measurement is a bit (i.e.,
either one or zero). It then decodes the reported weight and subtracts it from
<code>offset + sum(count_vec)</code>, where <code>count_vec</code> is the count vector. The result is
zero if and only if the reported weight is equal to the true weight.<a href="#section-7.4.5-7" class="pilcrow">¶</a></p>
<p id="section-7.4.5-8">Encoding, truncation, and decoding are defined as follows:<a href="#section-7.4.5-8" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.4.5-9">
<pre>
def encode(self, measurement: list[int]) -&gt; list[F]:
    if len(measurement) != self.length:
        raise ValueError('invalid Client measurement length')

    # The first part is the vector of counters.
    count_vec = list(map(self.field, measurement))

    # The second part is the reported weight.
    weight_reported = sum(count_vec, self.field(0))

    encoded = []
    encoded += count_vec
    encoded += self.field.encode_into_bit_vector(
        (self.offset + weight_reported).as_unsigned(),
        self.bits_for_weight)
    return encoded

def truncate(self, meas: list[F]) -&gt; list[F]:
    return meas[:self.length]

def decode(
        self,
        output: list[F],
        _num_measurements: int) -&gt; list[int]:
    return [bucket_count.as_unsigned() for bucket_count in output]
</pre><a href="#section-7.4.5-9" class="pilcrow">¶</a>
</div>
<p id="section-7.4.5-10">Circuit evaluation is defined as follows:<a href="#section-7.4.5-10" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.4.5-11">
<pre>
def eval(
        self,
        meas: list[F],
        joint_rand: list[F],
        num_shares: int) -&gt; list[F]:
    self.check_valid_eval(meas, joint_rand)

    # Check that each entry in the input vector is one or zero.
    range_check = self.field(0)
    r = joint_rand[0]
    r_power = r
    shares_inv = self.field(num_shares).inv()
    for i in range(self.GADGET_CALLS[0]):
        inputs: list[Optional[F]]
        inputs = [None] * (2 * self.chunk_length)
        for j in range(self.chunk_length):
            index = i * self.chunk_length + j
            if index &lt; len(meas):
                meas_elem = meas[index]
            else:
                meas_elem = self.field(0)

            inputs[j * 2] = r_power * meas_elem
            inputs[j * 2 + 1] = meas_elem - shares_inv

            r_power *= r

        range_check += self.GADGETS[0].eval(
            self.field,
            cast(list[F], inputs),
        )

    # Check that the weight `offset` plus the sum of the counters
    # is equal to the value claimed by the Client.
    count_vec = meas[:self.length]
    weight = sum(count_vec, self.field(0))
    weight_reported = \
        self.field.decode_from_bit_vector(meas[self.length:])
    weight_check = self.offset*shares_inv + weight - \
        weight_reported

    out = joint_rand[1] * range_check + \
        joint_rand[1] ** 2 * weight_check
    return [out]
</pre><a href="#section-7.4.5-11" class="pilcrow">¶</a>
</div>
<span id="name-parameters-of-validity-circuit-"></span><table class="center" id="table-18">
            <caption>
<a href="#table-18" class="selfRef">Table 18</a>:
<a href="#name-parameters-of-validity-circuit-" class="selfRef">Parameters of validity circuit MultihotCountVec.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGETS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>[ParallelSum(Mul(), chunk_length)]</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGET_CALLS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>[(length + bits_for_weight + chunk_length - 1) // chunk_length]</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>MEAS_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>length + bits_for_weight</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>OUTPUT_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>length</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>JOINT_RAND_LEN</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>2</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Measurement</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>list[int]</code>
</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>AggResult</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>list[int]</code>
</td>
              </tr>
            </tbody>
          </table>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="poplar1">
<section id="section-8">
      <h2 id="name-poplar1">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-poplar1" class="section-name selfRef">Poplar1</a>
      </h2>
<p id="section-8-1">This section specifies Poplar1, a VDAF for the following task. Each Client
holds a bit-string of length <code>BITS</code> and the Aggregators hold a sequence of
<code>L</code>-bit strings, where <code>L &lt;= BITS</code>. We will refer to the latter as the set of
"candidate prefixes". The Aggregators' goal is to count how many measurements
are prefixed by each candidate prefix.<a href="#section-8-1" class="pilcrow">¶</a></p>
<p id="section-8-2">This functionality is the core component of the Poplar protocol <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>,
which was designed to compute the heavy hitters over a set of input strings. At
a high level, the protocol works as follows.<a href="#section-8-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-8-3">
<li id="section-8-3.1">
          <p id="section-8-3.1.1">Each Client splits its string into input shares and sends one share to each
Aggregator.<a href="#section-8-3.1.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-8-3.2">
          <p id="section-8-3.2.1">The Aggregators agree on an initial set of candidate prefixes, say <code>0</code> and
<code>1</code>.<a href="#section-8-3.2.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-8-3.3">
          <p id="section-8-3.3.1">The Aggregators evaluate the VDAF on each set of input shares and aggregate
the recovered output shares. The aggregation parameter is the set of
candidate prefixes.<a href="#section-8-3.3.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-8-3.4">
          <p id="section-8-3.4.1">The Aggregators send their aggregate shares to the Collector, who combines
them to recover the counts of each candidate prefix.<a href="#section-8-3.4.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-8-3.5">
          <p id="section-8-3.5.1">Let <code>H</code> denote the set of prefixes that occurred at least <code>t</code> times. If the
prefixes all have length <code>BITS</code>, then <code>H</code> is the set of <code>t</code>-heavy-hitters.
Otherwise compute the next set of candidate prefixes, e.g., for each <code>p</code> in
<code>H</code>, add <code>p || 0</code> and <code>p || 1</code> to the set. Repeat step 3 with the new set of
candidate prefixes.<a href="#section-8-3.5.1" class="pilcrow">¶</a></p>
</li>
      </ol>
<p id="section-8-4">Poplar1 is constructed from an "Incremental Distributed Point Function (IDPF)",
a primitive described by <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span> that generalizes the notion of a
Distributed Point Function (DPF) <span>[<a href="#GI14" class="cite xref">GI14</a>]</span>. Briefly, a DPF is used to distribute
the computation of a "point function", a function that evaluates to zero on
every input except at a programmable "point". The computation is distributed in
such a way that no one party knows either the point or what it evaluates to.<a href="#section-8-4" class="pilcrow">¶</a></p>
<p id="section-8-5">An IDPF generalizes this "point" to a path on a full binary tree from the root
to one of the leaves. It is evaluated on an "index" representing a unique node
of the tree. If the node is on the programmed path, then the function evaluates
to a non-zero value; otherwise it evaluates to zero. This structure allows an
IDPF to provide the functionality required for the above protocol: to compute
the hit count for an index, just evaluate each set of IDPF shares at that index
and add up the results.<a href="#section-8-5" class="pilcrow">¶</a></p>
<p id="section-8-6">Consider the sub-tree constructed from a set of input strings and a target
threshold <code>t</code> by including all indices that prefix at least <code>t</code> of the input
strings. We shall refer to this structure as the "prefix tree" for the batch of
inputs and target threshold. To compute the <code>t</code>-heavy hitters for a set of
inputs, the Aggregators and Collector first compute the prefix tree, then
extract the heavy hitters from the leaves of this tree. (Note that the prefix
tree may leak more information about the set than the heavy hitters themselves;
see <a href="#agg-param-privacy" class="auto internal xref">Section 9.4.1</a> for details.)<a href="#section-8-6" class="pilcrow">¶</a></p>
<p id="section-8-7">Poplar1 composes an IDPF with the arithmetic sketch of <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>, Section
4.2. (The paper calls this a "secure sketch", but the underlying technique was
later generalized in <span>[<a href="#BBCGGI23" class="cite xref">BBCGGI23</a>]</span>, where it is called "arithmetic sketching".)
This protocol ensures that evaluating a set of input shares on a unique set of
candidate prefixes results in shares of a "one-hot" vector, i.e., a vector that
is zero everywhere except for at most one element, which is equal to one.<a href="#section-8-7" class="pilcrow">¶</a></p>
<p id="section-8-8">The remainder of this section is structured as follows. IDPFs are defined in
<a href="#idpf" class="auto internal xref">Section 8.1</a>; a concrete instantiation is given <a href="#idpf-bbcggi21" class="auto internal xref">Section 8.3</a>. The Poplar1 VDAF is
defined in <a href="#poplar1-construction" class="auto internal xref">Section 8.2</a> in terms of a generic IDPF. Finally, a
concrete instantiation of Poplar1 is specified in <a href="#poplar1-inst" class="auto internal xref">Section 8.4</a>;
test vectors can be found in <a href="#test-vectors" class="auto internal xref">Appendix "Test Vectors"</a>.<a href="#section-8-8" class="pilcrow">¶</a></p>
<div id="idpf">
<section id="section-8.1">
        <h3 id="name-incremental-distributed-poi">
<a href="#section-8.1" class="section-number selfRef">8.1. </a><a href="#name-incremental-distributed-poi" class="section-name selfRef">Incremental Distributed Point Functions (IDPFs)</a>
        </h3>
<p id="section-8.1-1">An IDPF is defined over a domain of size <code>2^BITS</code>, where <code>BITS</code> is a constant.
Indices into the IDPF tree are encoded as integers in <code>range(2**BITS)</code>. (In
Poplar1, each Client's bit string is encoded as an index; see
<a href="#poplar1-idpf-index-encoding" class="auto internal xref">Section 8.1.1</a> for details.) The Client specifies an index
<code>alpha</code> and a vector of values <code>beta</code>, one for each "level" <code>L</code> in
<code>range(BITS)</code>. The key generation algorithm generates one IDPF "key" for each
Aggregator. When evaluated at level <code>L</code> and index <code>0 &lt;= prefix &lt; 2^L</code>, each
IDPF key returns an additive share of <code>beta[L]</code> if <code>prefix</code> is the <code>L</code>-bit
prefix of <code>alpha</code> and shares of zero otherwise.<a href="#section-8.1-1" class="pilcrow">¶</a></p>
<p id="section-8.1-2">An index <code>x</code> is defined to be a prefix of another index <code>y</code> as follows. Let
<code>LSB(x, L)</code> denote the least significant <code>L</code> bits of positive integer <code>x</code>. A
positive integer <code>0 &lt;= x &lt; 2^L</code> is defined to be the length-<code>L</code> prefix of
positive integer <code>0 &lt;= y &lt; 2^BITS</code> if <code>LSB(x, L)</code> is equal to the most
significant <code>L</code> bits of <code>LSB(y, BITS)</code>, For example, 6 (110 in binary) is the
length-3 prefix of 25 (11001), but 7 (111) is not.<a href="#section-8.1-2" class="pilcrow">¶</a></p>
<p id="section-8.1-3">Each of the programmed points <code>beta</code> is a vector of elements of some finite
field. We distinguish two types of fields: one for inner nodes (denoted
<code>FieldInner</code>), and one for leaf nodes (<code>FieldLeaf</code>). (Our
instantiation of Poplar1 (<a href="#poplar1-inst" class="auto internal xref">Section 8.4</a>) will use a much larger field for
leaf nodes than for inner nodes. This is to ensure the IDPF is "extractable" as
defined in <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>, Definition 1.)<a href="#section-8.1-3" class="pilcrow">¶</a></p>
<p id="section-8.1-4">A concrete IDPF defines the types and constants enumerated in <a href="#idpf-param" class="auto internal xref">Table 19</a>.
In the remainder we write <code>Output</code> as shorthand for the type
<code>list[list[FieldInner]] | list[list[FieldLeaf]]</code>. (This type
denotes either a vector of inner node field elements or leaf node field
elements.) The scheme is comprised of the following algorithms:<a href="#section-8.1-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-8.1-5.1">
            <p id="section-8.1-5.1.1"><code>idpf.gen(alpha: int, beta_inner: list[list[FieldInner]], beta_leaf:
list[FieldLeaf], nonce: bytes, rand: bytes) -&gt; tuple[PublicShare,
list[bytes]]</code> is the randomized IDPF-key generation algorithm. Its inputs are
the index <code>alpha</code> the values <code>beta</code>, and a nonce string.<a href="#section-8.1-5.1.1" class="pilcrow">¶</a></p>
<p id="section-8.1-5.1.2">
The output is a public part (of type <code>PublicShare</code>) that is sent to all
Aggregators and a vector of private IDPF keys, one for each aggregator. The
binder string is used to derive the key in the underlying XofFixedKeyAes128
XOF that is used for expanding seeds at each level.<a href="#section-8.1-5.1.2" class="pilcrow">¶</a></p>
<p id="section-8.1-5.1.3">
Pre-conditions:<a href="#section-8.1-5.1.3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-8.1-5.1.4.1">
                <p id="section-8.1-5.1.4.1.1"><code>alpha</code> <span class="bcp14">MUST</span> be in <code>range(2**BITS)</code>.<a href="#section-8.1-5.1.4.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-8.1-5.1.4.2">
                <p id="section-8.1-5.1.4.2.1"><code>beta_inner</code> <span class="bcp14">MUST</span> have length <code>BITS - 1</code>.<a href="#section-8.1-5.1.4.2.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-8.1-5.1.4.3">
                <p id="section-8.1-5.1.4.3.1"><code>beta_inner[level]</code> <span class="bcp14">MUST</span> have length <code>VALUE_LEN</code> for each <code>level</code> in
 <code>range(BITS - 1)</code>.<a href="#section-8.1-5.1.4.3.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-8.1-5.1.4.4">
                <p id="section-8.1-5.1.4.4.1"><code>beta_leaf</code> <span class="bcp14">MUST</span> have length <code>VALUE_LEN</code>.<a href="#section-8.1-5.1.4.4.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-8.1-5.1.4.5">
                <p id="section-8.1-5.1.4.5.1"><code>rand</code> <span class="bcp14">MUST</span> be generated by a CSPRNG and have length <code>RAND_SIZE</code>.<a href="#section-8.1-5.1.4.5.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-8.1-5.1.4.6">
                <p id="section-8.1-5.1.4.6.1"><code>nonce</code> <span class="bcp14">MUST</span> be of length <code>Idpf.NONCE_SIZE</code> and chosen uniformly at
random by the Client (see <a href="#nonce-requirements" class="auto internal xref">Section 9.2</a>).<a href="#section-8.1-5.1.4.6.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
          <li class="normal" id="section-8.1-5.2">
            <p id="section-8.1-5.2.1"><code>idpf.eval(agg_id: int, public_share: PublicShare, key: bytes, level: int,
prefixes: tuple[int, ...], nonce: bytes) -&gt; Output</code> is the deterministic,
stateless IDPF-key evaluation algorithm run by each Aggregator. Its inputs
are the Aggregator's unique identifier, the public share distributed to all
of the Aggregators, the Aggregator's IDPF key, the "level" at which to
evaluate the IDPF, the sequence of candidate prefixes, and a nonce string. It
returns the share of the value corresponding to each candidate prefix.<a href="#section-8.1-5.2.1" class="pilcrow">¶</a></p>
<p id="section-8.1-5.2.2">
The output type (i.e., <code>Output</code>) depends on the value of <code>level</code>: if <code>level &lt;
BITS-1</code>, the output is the value for an inner node, which has type
<code>list[list[FieldInner]]</code>; otherwise, if <code>level == BITS-1</code>, then the output is
the value for a leaf node, which has type <code>list[list[FieldLeaf]]</code>.<a href="#section-8.1-5.2.2" class="pilcrow">¶</a></p>
<p id="section-8.1-5.2.3">
Pre-conditions:<a href="#section-8.1-5.2.3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-8.1-5.2.4.1">
                <p id="section-8.1-5.2.4.1.1"><code>agg_id</code> <span class="bcp14">MUST</span> be in <code>range(SHARES)</code> and match the index of <code>key</code> in
the sequence of IDPF keys output by the Client.<a href="#section-8.1-5.2.4.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-8.1-5.2.4.2">
                <p id="section-8.1-5.2.4.2.1"><code>level</code> <span class="bcp14">MUST</span> be in <code>range(0, BITS)</code>.<a href="#section-8.1-5.2.4.2.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-8.1-5.2.4.3">
                <p id="section-8.1-5.2.4.3.1">Each <code>prefix</code> in <code>prefixes</code> <span class="bcp14">MUST</span> be distinct and in <code>range(2**level)</code>.<a href="#section-8.1-5.2.4.3.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
        </ul>
<p id="section-8.1-6">In addition, the following method is derived for each concrete <code>Idpf</code>:<a href="#section-8.1-6" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-8.1-7">
<pre>
def current_field(
        self,
        level: int) -&gt; type[FieldInner] | type[FieldLeaf]:
    if level &lt; self.BITS - 1:
        return self.field_inner
    return self.field_leaf
</pre><a href="#section-8.1-7" class="pilcrow">¶</a>
</div>
<p id="section-8.1-8">Finally, an implementation note. The interface for IDPFs specified here is
stateless, in the sense that there is no state carried between IDPF evaluations.
This is to align the IDPF syntax with the VDAF abstraction boundary, which does
not include shared state across across VDAF evaluations. In practice, of course,
it will often be beneficial to expose a stateful API for IDPFs and carry the
state across evaluations. See <a href="#idpf-bbcggi21" class="auto internal xref">Section 8.3</a> for details.<a href="#section-8.1-8" class="pilcrow">¶</a></p>
<span id="name-constants-and-types-defined-by"></span><div id="idpf-param">
<table class="center" id="table-19">
          <caption>
<a href="#table-19" class="selfRef">Table 19</a>:
<a href="#name-constants-and-types-defined-by" class="selfRef">Constants and types defined by a concrete IDPF.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Parameter</th>
              <th class="text-left" rowspan="1" colspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">SHARES</td>
              <td class="text-left" rowspan="1" colspan="1">Number of IDPF keys output by IDPF-key generator</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">BITS</td>
              <td class="text-left" rowspan="1" colspan="1">Length in bits of each input string</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">VALUE_LEN</td>
              <td class="text-left" rowspan="1" colspan="1">Number of field elements of each output value</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">RAND_SIZE</td>
              <td class="text-left" rowspan="1" colspan="1">Size of the random string consumed by the IDPF-key generator. Equal to twice the XOF's seed size.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">NONCE_SIZE</td>
              <td class="text-left" rowspan="1" colspan="1">Size of the randon nonce generated by the Client.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">KEY_SIZE</td>
              <td class="text-left" rowspan="1" colspan="1">Size in bytes of each IDPF key</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">FieldInner</td>
              <td class="text-left" rowspan="1" colspan="1">Implementation of <code>Field</code> (<a href="#field" class="auto internal xref">Section 6.1</a>) used for values of inner nodes</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">FieldLeaf</td>
              <td class="text-left" rowspan="1" colspan="1">Implementation of <code>Field</code> used for values of leaf nodes</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">PublicShare</td>
              <td class="text-left" rowspan="1" colspan="1">Type of public share for this IDPF</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Output</td>
              <td class="text-left" rowspan="1" colspan="1">Alias of <code>list[list[FieldInner]] | list[list[FieldLeaf]]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">FieldVec</td>
              <td class="text-left" rowspan="1" colspan="1">Alias of <code>list[FieldInner] | list[FieldLeaf]</code>
</td>
            </tr>
          </tbody>
        </table>
</div>
<div id="poplar1-idpf-index-encoding">
<section id="section-8.1.1">
          <h4 id="name-encoding-inputs-as-indices">
<a href="#section-8.1.1" class="section-number selfRef">8.1.1. </a><a href="#name-encoding-inputs-as-indices" class="section-name selfRef">Encoding inputs as indices</a>
          </h4>
<p id="section-8.1.1-1">How data are represented as IDPF indices is up to the application. When the
inputs are fixed-length byte strings, the most natural choice of encoder is
<code>from_be_bytes()</code>. This ensures that, when a string is a prefix of another, so
too is its index. (Index prefixes are defined in <a href="#idpf" class="auto internal xref">Section 8.1</a>). For example,<a href="#section-8.1.1-1" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-8.1.1-2">
<pre>
from_be_bytes(b"\x01\x02") == 0x0102
</pre><a href="#section-8.1.1-2" class="pilcrow">¶</a>
</div>
<p id="section-8.1.1-3">is a prefix of<a href="#section-8.1.1-3" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-8.1.1-4">
<pre>
from_be_bytes(b"\x01\x02\x03") == 0x010203
</pre><a href="#section-8.1.1-4" class="pilcrow">¶</a>
</div>
<p id="section-8.1.1-5">When the inputs are variable length, it is necessary to pad each input to some
fixed length. Further, the padding scheme must be non-ambiguous. For example,
each input could be padded with <code>b"\x01"</code> followed by as many <code>b"\x00"</code> bytes
as needed.<a href="#section-8.1.1-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="poplar1-construction">
<section id="section-8.2">
        <h3 id="name-construction-3">
<a href="#section-8.2" class="section-number selfRef">8.2. </a><a href="#name-construction-3" class="section-name selfRef">Construction</a>
        </h3>
<p id="section-8.2-1">This section specifies <code>Poplar1</code>, an implementation of the <code>Vdaf</code> interface
(<a href="#vdaf" class="auto internal xref">Section 5</a>). It is defined in terms of any <code>Idpf</code> (<a href="#idpf" class="auto internal xref">Section 8.1</a>) for which
<code>SHARES == 2</code> and <code>VALUE_LEN == 2</code> and an implementation of <code>Xof</code>
(<a href="#xof" class="auto internal xref">Section 6.2</a>). The associated constants and types required by the <code>Vdaf</code> interface
are defined in <a href="#poplar1-param" class="auto internal xref">Table 20</a>. The methods required for sharding,
preparation, aggregation, and unsharding are described in the remaining
subsections. These methods make use of constants defined in <a href="#poplar1-const" class="auto internal xref">Table 21</a>.<a href="#section-8.2-1" class="pilcrow">¶</a></p>
<span id="name-vdaf-parameters-for-poplar1"></span><div id="poplar1-param">
<table class="center" id="table-20">
          <caption>
<a href="#table-20" class="selfRef">Table 20</a>:
<a href="#name-vdaf-parameters-for-poplar1" class="selfRef">VDAF parameters for Poplar1.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Parameter</th>
              <th class="text-left" rowspan="1" colspan="1">Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>VERIFY_KEY_SIZE</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Xof.SEED_SIZE</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>RAND_SIZE</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Xof.SEED_SIZE * 3 + Idpf.RAND_SIZE</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>NONCE_SIZE</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>16</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>ROUNDS</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>2</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>SHARES</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>2</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Measurement</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>int</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggParam</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>tuple[int, Sequence[int]]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PublicShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">same as the IDPF</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>InputShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>tuple[bytes, bytes, list[FieldInner], list[FieldLeaf]]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>OutShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>FieldVec</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>FieldVec</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggResult</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>list[int]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PrepState</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>tuple[bytes, int, FieldVec]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PrepShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>FieldVec</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PrepMessage</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Optional[FieldVec]</code>
</td>
            </tr>
          </tbody>
        </table>
</div>
<span id="name-constants-used-by-poplar1"></span><div id="poplar1-const">
<table class="center" id="table-21">
          <caption>
<a href="#table-21" class="selfRef">Table 21</a>:
<a href="#name-constants-used-by-poplar1" class="selfRef">Constants used by Poplar1.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Variable</th>
              <th class="text-left" rowspan="1" colspan="1">Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">USAGE_SHARD_RAND: int</td>
              <td class="text-left" rowspan="1" colspan="1">1</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">USAGE_CORR_INNER: int</td>
              <td class="text-left" rowspan="1" colspan="1">2</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">USAGE_CORR_LEAF: int</td>
              <td class="text-left" rowspan="1" colspan="1">3</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">USAGE_VERIFY_RAND: int</td>
              <td class="text-left" rowspan="1" colspan="1">4</td>
            </tr>
          </tbody>
        </table>
</div>
<div id="sharding-1">
<section id="section-8.2.1">
          <h4 id="name-sharding-4">
<a href="#section-8.2.1" class="section-number selfRef">8.2.1. </a><a href="#name-sharding-4" class="section-name selfRef">Sharding</a>
          </h4>
<p id="section-8.2.1-1">The Client's measurement is an IDPF index, denoted <code>alpha</code>. (See
<a href="#poplar1-idpf-index-encoding" class="auto internal xref">Section 8.1.1</a> for guidelines on index encoding.) The
programmed IDPF values are pairs of field elements <code>(1, k)</code> where each <code>k</code> is
chosen at random. This random value is used as part of the arithmetic sketching
protocol of <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>, Appendix C.4. After evaluating their IDPF key shares
on a given sequence of candidate prefixes, the sketching protocol is used by
the Aggregators to verify that they hold shares of a one-hot vector. In
addition, for each level of the tree, the prover generates random elements <code>a</code>,
<code>b</code>, and <code>c</code> and computes<a href="#section-8.2.1-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-8.2.1-2">
<pre>
    A = -2*a + k
    B = a^2 + b - k*a + c
</pre><a href="#section-8.2.1-2" class="pilcrow">¶</a>
</div>
<p id="section-8.2.1-3">and sends additive shares of <code>a</code>, <code>b</code>, <code>c</code>, <code>A</code> and <code>B</code> to the Aggregators.
Putting everything together, the sharding algorithm is defined as
follows.<a href="#section-8.2.1-3" class="pilcrow">¶</a></p>
<span id="name-the-sharding-algorithm-for-"></span><div id="poplar1-mes2inp">
<figure id="figure-26">
            <div class="breakable lang-python sourcecode" id="section-8.2.1-4.1">
<pre>
def shard(
        self,
        measurement: int,
        nonce: bytes,
        rand: bytes,
    ) -&gt; tuple[Poplar1PublicShare, list[Poplar1InputShare]]:
    if len(nonce) != self.NONCE_SIZE:
        raise ValueError("incorrect nonce size")
    if len(rand) != self.RAND_SIZE:
        raise ValueError("incorrect size of random bytes argument")

    l = self.xof.SEED_SIZE

    # Split the random input into the random input for IDPF key
    # generation, correlated randomness, and sharding.
    if len(rand) != self.RAND_SIZE:
        raise ValueError('incorrect rand size')
    idpf_rand, rand = front(self.idpf.RAND_SIZE, rand)
    seeds = [rand[i:i + l] for i in range(0, 3 * l, l)]
    corr_seed, seeds = front(2, seeds)
    (k_shard,), seeds = front(1, seeds)

    xof = self.xof(
        k_shard,
        self.domain_separation_tag(USAGE_SHARD_RAND),
        nonce,
    )

    # Construct the IDPF values for each level of the IDPF tree.
    # Each "data" value is 1; in addition, the Client generates
    # a random "authenticator" value used by the Aggregators to
    # evaluate the sketch during preparation. This sketch is used
    # to verify the one-hotness of their output shares.
    beta_inner = [
        [self.idpf.field_inner(1), k]
        for k in xof.next_vec(self.idpf.field_inner,
                              self.idpf.BITS - 1)
    ]
    beta_leaf = [self.idpf.field_leaf(1)] + \
        xof.next_vec(self.idpf.field_leaf, 1)

    # Generate the IDPF keys.
    (public_share, keys) = self.idpf.gen(
        measurement,
        beta_inner,
        beta_leaf,
        nonce,
        idpf_rand,
    )

    # Generate correlated randomness used by the Aggregators to
    # evaluate the sketch over their output shares. Seeds are used
    # to encode shares of the `(a, b, c)` triples. (See [BBCGGI21,
    # Appendix C.4].)
    corr_offsets: list[Field] = vec_add(
        self.xof.expand_into_vec(
            self.idpf.field_inner,
            corr_seed[0],
            self.domain_separation_tag(USAGE_CORR_INNER),
            byte(0) + nonce,
            3 * (self.idpf.BITS - 1),
        ),
        self.xof.expand_into_vec(
            self.idpf.field_inner,
            corr_seed[1],
            self.domain_separation_tag(USAGE_CORR_INNER),
            byte(1) + nonce,
            3 * (self.idpf.BITS - 1),
        ),
    )
    corr_offsets += vec_add(
        self.xof.expand_into_vec(
            self.idpf.field_leaf,
            corr_seed[0],
            self.domain_separation_tag(USAGE_CORR_LEAF),
            byte(0) + nonce,
            3,
        ),
        self.xof.expand_into_vec(
            self.idpf.field_leaf,
            corr_seed[1],
            self.domain_separation_tag(USAGE_CORR_LEAF),
            byte(1) + nonce,
            3,
        ),
    )

    # For each level of the IDPF tree, shares of the `(A, B)`
    # pairs are computed from the corresponding `(a, b, c)`
    # triple and authenticator value `k`.
    corr_inner: list[list[Field64]] = [[], []]
    for level in range(self.idpf.BITS):
        field = cast(type[Field], self.idpf.current_field(level))
        k = beta_inner[level][1] if level &lt; self.idpf.BITS - 1 \
            else beta_leaf[1]
        (a, b, c), corr_offsets = corr_offsets[:3], corr_offsets[3:]
        A = -field(2) * a + k
        B = a ** 2 + b - a * k + c
        corr1 = xof.next_vec(field, 2)
        corr0 = vec_sub([A, B], corr1)
        if level &lt; self.idpf.BITS - 1:
            corr_inner[0] += cast(list[Field64], corr0)
            corr_inner[1] += cast(list[Field64], corr1)
        else:
            corr_leaf = [
                cast(list[Field255], corr0),
                cast(list[Field255], corr1),
            ]

    # Each input share consists of the Aggregator's IDPF key
    # and a share of the correlated randomness.
    input_shares = list(zip(keys, corr_seed, corr_inner, corr_leaf))
    return (public_share, input_shares)
</pre>
</div>
<figcaption><a href="#figure-26" class="selfRef">Figure 26</a>:
<a href="#name-the-sharding-algorithm-for-" class="selfRef">The sharding algorithm for Poplar1.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="poplar1-prep">
<section id="section-8.2.2">
          <h4 id="name-preparation-4">
<a href="#section-8.2.2" class="section-number selfRef">8.2.2. </a><a href="#name-preparation-4" class="section-name selfRef">Preparation</a>
          </h4>
<p id="section-8.2.2-1">The aggregation parameter encodes a sequence of candidate prefixes. When an
Aggregator receives an input share from the Client, it begins by evaluating its
IDPF share on each candidate prefix, recovering a <code>data_share</code> and <code>auth_share</code>
for each. The Aggregators use these and the correlation shares provided by the
Client to verify that the sequence of <code>data_share</code> values are additive shares of
a one-hot vector.<a href="#section-8.2.2-1" class="pilcrow">¶</a></p>
<p id="section-8.2.2-2">Aggregators <span class="bcp14">MUST</span> ensure the candidate prefixes are all unique and appear in
lexicographic order. (This is enforced in the definition of <code>prep_init()</code>
below.) Uniqueness is necessary to ensure the refined measurement (i.e., the sum
of the output shares) is in fact a one-hot vector. Otherwise, sketch
verification might fail, causing the Aggregators to erroneously reject a report
that is actually valid. Note that enforcing the order is not strictly necessary,
but this does allow uniqueness to be determined more efficiently.<a href="#section-8.2.2-2" class="pilcrow">¶</a></p>
<span id="name-preparation-state-for-popla"></span><div id="poplar1-prep-state">
<figure id="figure-27">
            <div class="breakable lang-python sourcecode" id="section-8.2.2-3.1">
<pre>
def prep_init(
        self,
        verify_key: bytes,
        agg_id: int,
        agg_param: Poplar1AggParam,
        nonce: bytes,
        public_share: Poplar1PublicShare,
        input_share: Poplar1InputShare) -&gt; tuple[
            Poplar1PrepState,
            FieldVec]:
    (level, prefixes) = agg_param
    (key, corr_seed, corr_inner, corr_leaf) = input_share
    field = self.idpf.current_field(level)

    # Ensure that candidate prefixes are all unique and appear in
    # lexicographic order.
    for i in range(1, len(prefixes)):
        if prefixes[i - 1] &gt;= prefixes[i]:
            raise ValueError('out of order prefix')

    # Evaluate the IDPF key at the given set of prefixes.
    value = self.idpf.eval(
        agg_id, public_share, key, level, prefixes, nonce)

    # Get shares of the correlated randomness for evaluating the
    # Aggregator's share of the sketch.
    if level &lt; self.idpf.BITS - 1:
        corr_xof = self.xof(
            corr_seed,
            self.domain_separation_tag(USAGE_CORR_INNER),
            byte(agg_id) + nonce,
        )
        # Fast-forward the XOF state to the current level.
        corr_xof.next_vec(field, 3 * level)
    else:
        corr_xof = self.xof(
            corr_seed,
            self.domain_separation_tag(USAGE_CORR_LEAF),
            byte(agg_id) + nonce,
        )
    (a_share, b_share, c_share) = corr_xof.next_vec(field, 3)
    if level &lt; self.idpf.BITS - 1:
        (A_share, B_share) = cast(
            list[Field],
            corr_inner[2 * level:2 * (level + 1)],
        )
    else:
        (A_share, B_share) = cast(list[Field], corr_leaf)

    # Evaluate the Aggregator's share of the sketch. These are
    # called the "masked input values" [BBCGGI21, Appendix C.4].
    verify_rand_xof = self.xof(
        verify_key,
        self.domain_separation_tag(USAGE_VERIFY_RAND),
        nonce + to_be_bytes(level, 2),
    )
    verify_rand = cast(
        list[Field],
        verify_rand_xof.next_vec(field, len(prefixes)),
    )
    sketch_share = [a_share, b_share, c_share]
    out_share = []
    for (i, r) in enumerate(verify_rand):
        data_share = cast(Field, value[i][0])
        auth_share = cast(Field, value[i][1])
        sketch_share[0] += data_share * r
        sketch_share[1] += data_share * r ** 2
        sketch_share[2] += auth_share * r
        out_share.append(data_share)

    prep_mem = [A_share, B_share, field(agg_id)] + out_share
    return (
        (
            b'evaluate sketch',
            level,
            cast(FieldVec, prep_mem),
        ),
        cast(FieldVec, sketch_share),
    )

def prep_next(
        self,
        prep_state: Poplar1PrepState,
        prep_msg: Optional[FieldVec]
    ) -&gt; tuple[Poplar1PrepState, FieldVec] | FieldVec:
    prev_sketch = cast(list[Field], prep_msg)
    (step, level, prep_mem) = prep_state

    if step == b'evaluate sketch':
        if prev_sketch is None:
            raise ValueError('expected value, got none')
        elif len(prev_sketch) != 3:
            raise ValueError('incorrect sketch length')
        A_share = cast(Field, prep_mem[0])
        B_share = cast(Field, prep_mem[1])
        agg_id = cast(Field, prep_mem[2])
        prep_mem = prep_mem[3:]
        sketch_share = [
            agg_id * (prev_sketch[0] ** 2
                      - prev_sketch[1]
                      - prev_sketch[2])
            + A_share * prev_sketch[0]
            + B_share
        ]
        return cast(
            tuple[Poplar1PrepState, FieldVec],
            (
                (
                    b'reveal sketch',
                    level,
                    prep_mem,
                ),
                sketch_share,
            )
        )

    elif step == b'reveal sketch':
        if prev_sketch is None:
            return prep_mem  # Output shares
        else:
            raise ValueError('invalid prep message')

    raise ValueError('invalid prep state')

def prep_shares_to_prep(
        self,
        agg_param: Poplar1AggParam,
        prep_shares: list[FieldVec]) -&gt; Optional[FieldVec]:
    if len(prep_shares) != 2:
        raise ValueError('incorrect number of prep shares')
    (level, _) = agg_param
    field = self.idpf.current_field(level)
    sketch = vec_add(
        cast(list[Field], prep_shares[0]),
        cast(list[Field], prep_shares[1]),
    )
    if len(sketch) == 3:
        return cast(FieldVec, sketch)
    elif len(sketch) == 1:
        if sketch == field.zeros(1):
            # In order to reduce communication overhead, let `None`
            # denote a successful sketch verification.
            return None
        else:
            raise ValueError('sketch verification failed')
    else:
        raise ValueError('incorrect sketch length')
</pre>
</div>
<figcaption><a href="#figure-27" class="selfRef">Figure 27</a>:
<a href="#name-preparation-state-for-popla" class="selfRef">Preparation state for Poplar1.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="validity-of-aggregation-parameters-1">
<section id="section-8.2.3">
          <h4 id="name-validity-of-aggregation-paramet">
<a href="#section-8.2.3" class="section-number selfRef">8.2.3. </a><a href="#name-validity-of-aggregation-paramet" class="section-name selfRef">Validity of Aggregation Parameters</a>
          </h4>
<p id="section-8.2.3-1">Aggregation parameters are valid for a given input share if no aggregation
parameter with the same level has been used with the same input share before.
The whole preparation phase <span class="bcp14">MUST NOT</span> be run more than once for a given
combination of input share and level. This function checks that levels are
increasing between calls, and also enforces that the prefixes at each level are
suffixes of the previous level's prefixes.<a href="#section-8.2.3-1" class="pilcrow">¶</a></p>
<span id="name-validity-of-aggregation-paramete"></span><div id="poplar1-validity-scope">
<figure id="figure-28">
            <div class="lang-python sourcecode" id="section-8.2.3-2.1">
<pre>
def get_ancestor(
        index: int,
        this_level: int,
        last_level: int) -&gt; int:
    """
    Helper function to determine the prefix of `index` at
    `last_level`.
    """
    return index &gt;&gt; (this_level - last_level)

def is_valid(
        self,
        agg_param: Poplar1AggParam,
        previous_agg_params: list[Poplar1AggParam]) -&gt; bool:
    """
    Checks that levels are increasing between calls, and also
    enforces that the prefixes at each level are suffixes of the
    previous level's prefixes.
    """
    if len(previous_agg_params) &lt; 1:
        return True

    (level, prefixes) = agg_param
    (last_level, last_prefixes) = previous_agg_params[-1]
    last_prefixes_set = set(last_prefixes)

    # Check that level increased.
    if level &lt;= last_level:
        return False

    # Check that prefixes are suffixes of the last level's prefixes.
    for prefix in prefixes:
        last_prefix = get_ancestor(prefix, level, last_level)
        if last_prefix not in last_prefixes_set:
            # Current prefix not a suffix of last level's prefixes.
            return False
    return True
</pre>
</div>
<figcaption><a href="#figure-28" class="selfRef">Figure 28</a>:
<a href="#name-validity-of-aggregation-paramete" class="selfRef">Validity of aggregation parameters for Poplar1.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="aggregation-2">
<section id="section-8.2.4">
          <h4 id="name-aggregation-5">
<a href="#section-8.2.4" class="section-number selfRef">8.2.4. </a><a href="#name-aggregation-5" class="section-name selfRef">Aggregation</a>
          </h4>
<p id="section-8.2.4-1">Aggregation involves simply adding up the output shares.<a href="#section-8.2.4-1" class="pilcrow">¶</a></p>
<span id="name-aggregation-algorithm-for-po"></span><div id="poplar1-out2agg">
<figure id="figure-29">
            <div class="lang-python sourcecode" id="section-8.2.4-2.1">
<pre>
def aggregate(
        self,
        agg_param: Poplar1AggParam,
        out_shares: list[FieldVec]) -&gt; FieldVec:
    (level, prefixes) = agg_param
    field = self.idpf.current_field(level)
    agg_share = cast(list[Field], field.zeros(len(prefixes)))
    for out_share in out_shares:
        agg_share = vec_add(agg_share, cast(list[Field], out_share))
    return cast(FieldVec, agg_share)
</pre>
</div>
<figcaption><a href="#figure-29" class="selfRef">Figure 29</a>:
<a href="#name-aggregation-algorithm-for-po" class="selfRef">Aggregation algorithm for Poplar1.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="unsharding-1">
<section id="section-8.2.5">
          <h4 id="name-unsharding-4">
<a href="#section-8.2.5" class="section-number selfRef">8.2.5. </a><a href="#name-unsharding-4" class="section-name selfRef">Unsharding</a>
          </h4>
<p id="section-8.2.5-1">Finally, the Collector unshards the aggregate result by adding up the aggregate
shares.<a href="#section-8.2.5-1" class="pilcrow">¶</a></p>
<span id="name-computation-of-the-aggregate"></span><div id="poplar1-agg-output">
<figure id="figure-30">
            <div class="lang-python sourcecode" id="section-8.2.5-2.1">
<pre>
def unshard(
        self,
        agg_param: Poplar1AggParam,
        agg_shares: list[FieldVec],
        _num_measurements: int) -&gt; list[int]:
    (level, prefixes) = agg_param
    field = self.idpf.current_field(level)
    agg = cast(list[Field], field.zeros(len(prefixes)))
    for agg_share in agg_shares:
        agg = vec_add(agg, cast(list[Field], agg_share))
    return [x.as_unsigned() for x in agg]
</pre>
</div>
<figcaption><a href="#figure-30" class="selfRef">Figure 30</a>:
<a href="#name-computation-of-the-aggregate" class="selfRef">Computation of the aggregate result for Poplar1.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="poplar1-encode">
<section id="section-8.2.6">
          <h4 id="name-message-serialization-2">
<a href="#section-8.2.6" class="section-number selfRef">8.2.6. </a><a href="#name-message-serialization-2" class="section-name selfRef">Message Serialization</a>
          </h4>
<p id="section-8.2.6-1">This section defines serialization formats for messages exchanged over the
network while executing <code>Poplar1</code>. It is <span class="bcp14">RECOMMENDED</span> that implementations
provide serialization methods for them.<a href="#section-8.2.6-1" class="pilcrow">¶</a></p>
<p id="section-8.2.6-2">Message structures are defined following <span><a href="https://rfc-editor.org/rfc/rfc8446#section-3" class="relref">Section 3</a> of [<a href="#RFC8446" class="cite xref">RFC8446</a>]</span>). In the
remainder we use <code>Fi</code> as an alias for <code>poplar1.idpf.field_inner.ENCODED_SIZE</code>,
<code>Fl</code> as an alias for <code>poplar1.idpf.field_leaf.ENCODED_SIZE</code>, and <code>B</code> as an
alias for <code>poplar1.idpf.BITS</code>.<a href="#section-8.2.6-2" class="pilcrow">¶</a></p>
<p id="section-8.2.6-3">Elements of the inner field are encoded in little-endian byte order (as defined
in <a href="#field" class="auto internal xref">Section 6.1</a>) and are represented as follows:<a href="#section-8.2.6-3" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6-4">
<pre>
opaque Poplar1FieldInner[Fi];
</pre><a href="#section-8.2.6-4" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6-5">Likewise, elements of the leaf field are encoded in little-endian byte order
(as defined in <a href="#field" class="auto internal xref">Section 6.1</a>) and are represented as follows:<a href="#section-8.2.6-5" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6-6">
<pre>
opaque Poplar1FieldLeaf[Fl];
</pre><a href="#section-8.2.6-6" class="pilcrow">¶</a>
</div>
<div id="public-share-1">
<section id="section-8.2.6.1">
            <h5 id="name-public-share-2">
<a href="#section-8.2.6.1" class="section-number selfRef">8.2.6.1. </a><a href="#name-public-share-2" class="section-name selfRef">Public Share</a>
            </h5>
<p id="section-8.2.6.1-1">The public share of the IDPF scheme in <a href="#idpf-bbcggi21" class="auto internal xref">Section 8.3</a> consists of a sequence
of "correction words". A correction word has three components:<a href="#section-8.2.6.1-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-8.2.6.1-2">
<li id="section-8.2.6.1-2.1">
                <p id="section-8.2.6.1-2.1.1">the XOF seed of type <code>bytes</code>;<a href="#section-8.2.6.1-2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-8.2.6.1-2.2">
                <p id="section-8.2.6.1-2.2.1">the control bits of type <code>tuple[Field2, Field2]</code>; and<a href="#section-8.2.6.1-2.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-8.2.6.1-2.3">
                <p id="section-8.2.6.1-2.3.1">the payload of type <code>list[Field64]</code> for the first <code>BITS-1</code> words and
<code>list[Field255]</code> for the last word.<a href="#section-8.2.6.1-2.3.1" class="pilcrow">¶</a></p>
</li>
            </ol>
<p id="section-8.2.6.1-3">The encoding is a straightforward structure of arrays, except that the control
bits are packed as tightly as possible. The encoded public share is structured
as follows:<a href="#section-8.2.6.1-3" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.1-4">
<pre>
struct {
    opaque packed_control_bits[packed_len];
    opaque seed[poplar1.idpf.KEY_SIZE*B];
    Poplar1FieldInner payload_inner[Fi*poplar1.idpf.VALUE_LEN*(B-1)];
    Poplar1FieldLeaf payload_leaf[Fl*poplar1.idpf.VALUE_LEN];
} Poplar1PublicShare;
</pre><a href="#section-8.2.6.1-4" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.1-5">Here <code>packed_len = (2*B + 7) // 8</code> is the length of the packed control bits.
Field <code>packed_control_bits</code> is encoded with the following function:<a href="#section-8.2.6.1-5" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-8.2.6.1-6">
<pre>
packed_control_buf = [int(0)] * packed_len
for i, bit in enumerate(control_bits):
    packed_control_buf[i // 8] |= bit.as_unsigned() &lt;&lt; (i % 8)
packed_control_bits = bytes(packed_control_buf)
</pre><a href="#section-8.2.6.1-6" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.1-7">It encodes each group of eight bits into a byte, in LSB to MSB order, padding the most
significant bits of the last byte with zeros as necessary, and returns the byte
array. Decoding performs the reverse operation: it takes in a byte array
and a number of bits, and returns a list of bits, extracting eight bits from
each byte in turn, in LSB to MSB order, and stopping after the requested number
of bits. If the byte array has an incorrect length, or if unused bits in the
last bytes are not zero, it throws an error:<a href="#section-8.2.6.1-7" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-8.2.6.1-8">
<pre>
control_bits = []
for i in range(length):
    control_bits.append(Field2(
        (packed_control_bits[i // 8] &gt;&gt; (i % 8)) &amp; 1
    ))
leftover_bits = packed_control_bits[-1] &gt;&gt; (
    (length + 7) % 8 + 1
)
if (length + 7) // 8 != len(packed_control_bits) or \
        leftover_bits != 0:
    raise ValueError('trailing bits')
</pre><a href="#section-8.2.6.1-8" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="input-share-1">
<section id="section-8.2.6.2">
            <h5 id="name-input-share-2">
<a href="#section-8.2.6.2" class="section-number selfRef">8.2.6.2. </a><a href="#name-input-share-2" class="section-name selfRef">Input Share</a>
            </h5>
<p id="section-8.2.6.2-1">Each input share is structured as follows:<a href="#section-8.2.6.2-1" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.2-2">
<pre>
struct {
    opaque idpf_key[poplar1.idpf.KEY_SIZE];
    opaque corr_seed[poplar1.xof.SEED_SIZE];
    Poplar1FieldInner corr_inner[Fi * 2 * (poplar1.idpf.BITS - 1)];
    Poplar1FieldLeaf corr_leaf[Fl * 2];
} Poplar1InputShare;
</pre><a href="#section-8.2.6.2-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="prep-share-1">
<section id="section-8.2.6.3">
            <h5 id="name-prep-share-2">
<a href="#section-8.2.6.3" class="section-number selfRef">8.2.6.3. </a><a href="#name-prep-share-2" class="section-name selfRef">Prep Share</a>
            </h5>
<p id="section-8.2.6.3-1">Encoding of the prep share depends on the round of sketching: if the first
round, then each sketch share has three field elements; if the second round,
then each sketch share has one field element. The field that is used depends on
the level of the IDPF tree specified by the aggregation parameter, either the
inner field or the leaf field.<a href="#section-8.2.6.3-1" class="pilcrow">¶</a></p>
<p id="section-8.2.6.3-2">For the first round and inner field:<a href="#section-8.2.6.3-2" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.3-3">
<pre>
struct {
    Poplar1FieldInner sketch_share[Fi * 3];
} Poplar1PrepShareRoundOneInner;
</pre><a href="#section-8.2.6.3-3" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.3-4">For the first round and leaf field:<a href="#section-8.2.6.3-4" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.3-5">
<pre>
struct {
    Poplar1FieldLeaf sketch_share[Fl * 3];
} Poplar1PrepShareRoundOneLeaf;
</pre><a href="#section-8.2.6.3-5" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.3-6">For the second round and inner field:<a href="#section-8.2.6.3-6" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.3-7">
<pre>
struct {
    Poplar1FieldInner sketch_share;
} Poplar1PrepShareRoundTwoInner;
</pre><a href="#section-8.2.6.3-7" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.3-8">For the second round and leaf field:<a href="#section-8.2.6.3-8" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.3-9">
<pre>
struct {
    Poplar1FieldLeaf sketch_share;
} Poplar1PrepShareRoundTwoLeaf;
</pre><a href="#section-8.2.6.3-9" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="prep-message-1">
<section id="section-8.2.6.4">
            <h5 id="name-prep-message-2">
<a href="#section-8.2.6.4" class="section-number selfRef">8.2.6.4. </a><a href="#name-prep-message-2" class="section-name selfRef">Prep Message</a>
            </h5>
<p id="section-8.2.6.4-1">Likewise, the structure of the prep message for Poplar1 depends on the
sketching round and field. For the first round and inner field:<a href="#section-8.2.6.4-1" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.4-2">
<pre>
struct {
    Poplar1FieldInner[Fi * 3];
} Poplar1PrepMessageRoundOneInner;
</pre><a href="#section-8.2.6.4-2" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.4-3">For the first round and leaf field:<a href="#section-8.2.6.4-3" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.4-4">
<pre>
struct {
    Poplar1FieldLeaf sketch[Fl * 3];
} Poplar1PrepMessageRoundOneLeaf;
</pre><a href="#section-8.2.6.4-4" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.4-5">Note that these messages have the same structures as the prep shares for the
first round.<a href="#section-8.2.6.4-5" class="pilcrow">¶</a></p>
<p id="section-8.2.6.4-6">The second-round prep message is the empty string. This is because the sketch
shares are expected to sum to a particular value if the output shares are
valid; we represent a successful preparation with the empty string and
otherwise return an error.<a href="#section-8.2.6.4-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="aggregate-share">
<section id="section-8.2.6.5">
            <h5 id="name-aggregate-share">
<a href="#section-8.2.6.5" class="section-number selfRef">8.2.6.5. </a><a href="#name-aggregate-share" class="section-name selfRef">Aggregate Share</a>
            </h5>
<p id="section-8.2.6.5-1">The encoding of the aggregate share depends on whether the inner or leaf field
is used, and the number of candidate prefixes. Both of these are determined by
 the aggregation parameter.<a href="#section-8.2.6.5-1" class="pilcrow">¶</a></p>
<p id="section-8.2.6.5-2">Let <code>prefix_count</code> denote the number of candidate prefixes. For the inner field:<a href="#section-8.2.6.5-2" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.5-3">
<pre>
struct {
    Poplar1FieldInner agg_share[Fi * prefix_count];
} Poplar1AggShareInner;
</pre><a href="#section-8.2.6.5-3" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.5-4">For the leaf field:<a href="#section-8.2.6.5-4" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.5-5">
<pre>
struct {
    Poplar1FieldLeaf agg_share[Fl * prefix_count];
} Poplar1AggShareLeaf;
</pre><a href="#section-8.2.6.5-5" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="aggregation-parameter">
<section id="section-8.2.6.6">
            <h5 id="name-aggregation-parameter">
<a href="#section-8.2.6.6" class="section-number selfRef">8.2.6.6. </a><a href="#name-aggregation-parameter" class="section-name selfRef">Aggregation Parameter</a>
            </h5>
<p id="section-8.2.6.6-1">The aggregation parameter is encoded as follows:<a href="#section-8.2.6.6-1" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.6-2">
<pre>
struct {
    uint16_t level;
    uint32_t num_prefixes;
    opaque packed_prefixes[packed_len];
} Poplar1AggParam;
</pre><a href="#section-8.2.6.6-2" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.6-3">The fields in this struct are: <code>level</code>, the level of the IDPF tree of each
prefixes; <code>num_prefixes</code>, the number of prefixes to evaluate; and
<code>packed_prefixes</code>, the sequence of prefixes packed into a byte string of
length <code>packed_len</code>. The prefixes are encoded with the following procedure:<a href="#section-8.2.6.6-3" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-8.2.6.6-4">
<pre>
packed = 0
for (i, prefix) in enumerate(prefixes):
    packed |= prefix &lt;&lt; ((level + 1) * i)
packed_len = ((level + 1) * len(prefixes) + 7) // 8
packed_prefixes = to_be_bytes(packed, packed_len)
</pre><a href="#section-8.2.6.6-4" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.6-5">Decoding involves the following procedure:<a href="#section-8.2.6.6-5" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-8.2.6.6-6">
<pre>
packed = from_be_bytes(packed_prefixes)
prefixes = []
m = 2 ** (level + 1) - 1
for i in range(num_prefixes):
    prefixes.append(packed &gt;&gt; ((level + 1) * i) &amp; m)
</pre><a href="#section-8.2.6.6-6" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.6-7">Implementation note: the aggregation parameter includes the level of the IDPF
tree and the sequence of indices to evaluate. For implementations that perform
per-report caching across executions of the VDAF, this may be more information
than is strictly needed. In particular, it may be sufficient to convey which
indices from the previous execution will have their children included in the
next. This would help reduce communication overhead.<a href="#section-8.2.6.6-7" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="idpf-bbcggi21">
<section id="section-8.3">
        <h3 id="name-the-idpf-scheme-of">
<a href="#section-8.3" class="section-number selfRef">8.3. </a><a href="#name-the-idpf-scheme-of" class="section-name selfRef">The IDPF scheme of <span class="cite xref">[BBCGGI21]</span></a>
        </h3>
<p id="section-8.3-1">In this section we specify a concrete IDPF suitable for instantiating
Poplar1. The scheme gets its name from the name of the protocol of
<span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>.<a href="#section-8.3-1" class="pilcrow">¶</a></p>
<p id="section-8.3-2">The constant and type definitions required by the <code>Idpf</code> interface are given in
<a href="#idpf-bbcggi21-param" class="auto internal xref">Table 22</a>.<a href="#section-8.3-2" class="pilcrow">¶</a></p>
<p id="section-8.3-3">Our IDPF requires an XOF for deriving the output shares, as well as a variety
of other artifacts used internally. For performance reasons, we instantiate
this object using XofFixedKeyAes128 (<a href="#xof-fixed-key-aes128" class="auto internal xref">Section 6.2.2</a>) wherever
possible. See <a href="#xof-vs-ro" class="auto internal xref">Section 9.5</a> for more information.<a href="#section-8.3-3" class="pilcrow">¶</a></p>
<span id="name-constants-and-type-definiti"></span><div id="idpf-bbcggi21-param">
<table class="center" id="table-22">
          <caption>
<a href="#table-22" class="selfRef">Table 22</a>:
<a href="#name-constants-and-type-definiti" class="selfRef">Constants and type definitions for the IDPF of BBCGGI21.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Parameter</th>
              <th class="text-left" rowspan="1" colspan="1">Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">SHARES</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>2</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">BITS</td>
              <td class="text-left" rowspan="1" colspan="1">any positive integer</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">VALUE_LEN</td>
              <td class="text-left" rowspan="1" colspan="1">any positive integer</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">KEY_SIZE</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Xof.SEED_SIZE</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">FieldInner</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Field64</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">FieldLeaf</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Field255</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
            </tr>
          </tbody>
        </table>
</div>
<div id="key-generation">
<section id="section-8.3.1">
          <h4 id="name-key-generation">
<a href="#section-8.3.1" class="section-number selfRef">8.3.1. </a><a href="#name-key-generation" class="section-name selfRef">Key Generation</a>
          </h4>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-8.3.1-1.1">
              <p id="section-8.3.1-1.1.1">TODO Describe the construction in prose, beginning with a gentle introduction
to the high level idea.<a href="#section-8.3.1-1.1.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-8.3.1-2">The description of the IDPF-key generation algorithm makes use of auxiliary
functions <code>extend()</code> and <code>convert()</code> defined in
<a href="#idpf-bbcggi21-helper-functions" class="auto internal xref">Section 8.3.3</a>. In the following, we let <code>Field2</code> denote
the field <code>GF(2)</code>.<a href="#section-8.3.1-2" class="pilcrow">¶</a></p>
<span id="name-idpf-key-generation-algorit"></span><div id="idpf-bbcggi21-gen">
<figure id="figure-31">
            <div class="breakable lang-python sourcecode" id="section-8.3.1-3.1">
<pre>
def gen(
        self,
        alpha: int,
        beta_inner: list[list[Field64]],
        beta_leaf: list[Field255],
        nonce: bytes,
        rand: bytes) -&gt; tuple[list[CorrectionWord], list[bytes]]:
    if alpha not in range(2 ** self.BITS):
        raise ValueError("alpha out of range")
    if len(beta_inner) != self.BITS - 1:
        raise ValueError("incorrect beta_inner length")
    if len(rand) != self.RAND_SIZE:
        raise ValueError("incorrect rand size")
    if len(nonce) != self.NONCE_SIZE:
        raise ValueError("incorrect nonce size")

    key = [
        rand[:XofFixedKeyAes128.SEED_SIZE],
        rand[XofFixedKeyAes128.SEED_SIZE:],
    ]

    seed = key.copy()
    ctrl = [Field2(0), Field2(1)]
    public_share = []
    for level in range(self.BITS):
        keep = (alpha &gt;&gt; (self.BITS - level - 1)) &amp; 1
        lose = 1 - keep
        bit = Field2(keep)

        (s0, t0) = self.extend(level, seed[0], nonce)
        (s1, t1) = self.extend(level, seed[1], nonce)
        seed_cw = xor(s0[lose], s1[lose])
        ctrl_cw = (
            t0[0] + t1[0] + bit + Field2(1),
            t0[1] + t1[1] + bit,
        )

        # Implementation note: these conditional XORs and
        # input-dependent array indices should be replaced with
        # constant-time selects in practice in order to reduce
        # leakage via timing side channels.
        if ctrl[0].as_unsigned():
            x0 = xor(s0[keep], seed_cw)
            ctrl[0] = t0[keep] + ctrl_cw[keep]
        else:
            x0 = s0[keep]
            ctrl[0] = t0[keep]
        if ctrl[1].as_unsigned():
            x1 = xor(s1[keep], seed_cw)
            ctrl[1] = t1[keep] + ctrl_cw[keep]
        else:
            x1 = s1[keep]
            ctrl[1] = t1[keep]
        (seed[0], w0) = self.convert(level, x0, nonce)
        (seed[1], w1) = self.convert(level, x1, nonce)

        if level &lt; self.BITS - 1:
            b = cast(list[Field], beta_inner[level])
        else:
            b = cast(list[Field], beta_leaf)
        if len(b) != self.VALUE_LEN:
            raise ValueError(
                "length of beta must match the value length"
            )

        w_cw = vec_add(vec_sub(b, w0), w1)
        # Implementation note: this conditional negation should be
        # replaced with a constant time select or a constant time
        # multiplication in practice in order to reduce leakage via
        # timing side channels.
        if ctrl[1].as_unsigned():
            for i in range(len(w_cw)):
                w_cw[i] = -w_cw[i]

        public_share.append((seed_cw, ctrl_cw, w_cw))
    return (public_share, key)
</pre>
</div>
<figcaption><a href="#figure-31" class="selfRef">Figure 31</a>:
<a href="#name-idpf-key-generation-algorit" class="selfRef">IDPF-key generation algorithm of BBCGGI21.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="key-evaluation">
<section id="section-8.3.2">
          <h4 id="name-key-evaluation">
<a href="#section-8.3.2" class="section-number selfRef">8.3.2. </a><a href="#name-key-evaluation" class="section-name selfRef">Key Evaluation</a>
          </h4>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-8.3.2-1.1">
              <p id="section-8.3.2-1.1.1">TODO Describe in prose how IDPF-key evaluation algorithm works.<a href="#section-8.3.2-1.1.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-8.3.2-2">The description of the IDPF-evaluation algorithm makes use of auxiliary
functions <code>extend()</code> and <code>convert()</code> defined in
<a href="#idpf-bbcggi21-helper-functions" class="auto internal xref">Section 8.3.3</a>.<a href="#section-8.3.2-2" class="pilcrow">¶</a></p>
<span id="name-idpf-evaluation-generation-"></span><div id="idpf-bbcggi21-eval">
<figure id="figure-32">
            <div class="breakable lang-python sourcecode" id="section-8.3.2-3.1">
<pre>
def eval(
        self,
        agg_id: int,
        public_share: list[CorrectionWord],
        key: bytes,
        level: int,
        prefixes: Sequence[int],
        nonce: bytes) -&gt; list[list[Field64]] | list[list[Field255]]:
    if agg_id not in range(self.SHARES):
        raise ValueError('aggregator id out of range')
    if level not in range(self.BITS):
        raise ValueError('level out of range')
    if len(set(prefixes)) != len(prefixes):
        raise ValueError('prefixes must be unique')

    out_share = []
    for prefix in prefixes:
        if prefix not in range(2 ** (level + 1)):
            raise ValueError('prefix out of range')

        # The Aggregator's output share is the value of a node of
        # the IDPF tree at the given `level`. The node's value is
        # computed by traversing the path defined by the candidate
        # `prefix`. Each node in the tree is represented by a seed
        # (`seed`) and a control bit (`ctrl`).
        seed = key
        ctrl = Field2(agg_id)
        y: FieldVec
        for current_level in range(level + 1):
            bit = (prefix &gt;&gt; (level - current_level)) &amp; 1

            # Implementation note: typically the current round of
            # candidate prefixes would have been derived from
            # aggregate results computed during previous rounds.
            # For example, when using the IDPF to compute heavy
            # hitters, a string whose hit count exceeded the
            # given threshold in the last round would be the
            # prefix of each `prefix` in the current round. (See
            # [BBCGGI21, Section 5.1].) In this case, part of the
            # path would have already been traversed.
            #
            # Re-computing nodes along previously traversed paths is
            # wasteful. Implementations can eliminate this added
            # complexity by caching nodes (i.e., `(seed, ctrl)`
            # pairs) output by previous calls to `eval_next()`.
            (seed, ctrl, y) = self.eval_next(
                seed,
                ctrl,
                public_share[current_level],
                current_level,
                bit,
                nonce,
            )
        if agg_id == 0:
            out_share.append(cast(list[Field], y))
        else:
            out_share.append(vec_neg(cast(list[Field], y)))
    return cast(
        list[list[Field64]] | list[list[Field255]],
        out_share,
    )

def eval_next(
        self,
        prev_seed: bytes,
        prev_ctrl: Field2,
        correction_word: CorrectionWord,
        level: int,
        bit: int,
        nonce: bytes) -&gt; tuple[bytes, Field2, FieldVec]:
    """
    Compute the next node in the IDPF tree along the path determined
    by a candidate prefix. The next node is determined by `bit`, the
    bit of the prefix corresponding to the next level of the tree.
    """

    seed_cw = correction_word[0]
    ctrl_cw = correction_word[1]
    w_cw = cast(list[Field], correction_word[2])
    (s, t) = self.extend(level, prev_seed, nonce)

    # Implementation note: these conditional operations and
    # input-dependent array indices should be replaced with
    # constant-time selects in practice in order to reduce leakage
    # via timing side channels.
    if prev_ctrl.as_unsigned():
        s[0] = xor(s[0], seed_cw)
        s[1] = xor(s[1], seed_cw)
        t[0] += ctrl_cw[0]
        t[1] += ctrl_cw[1]

    next_ctrl = t[bit]
    convert_output = self.convert(level, s[bit], nonce)
    next_seed = convert_output[0]
    y = cast(list[Field], convert_output[1])
    # Implementation note: this conditional addition should be
    # replaced with a constant-time select in practice in order to
    # reduce leakage via timing side channels.
    if next_ctrl.as_unsigned():
        for i in range(len(y)):
            y[i] += w_cw[i]

    return (next_seed, next_ctrl, cast(FieldVec, y))
</pre>
</div>
<figcaption><a href="#figure-32" class="selfRef">Figure 32</a>:
<a href="#name-idpf-evaluation-generation-" class="selfRef">IDPF-evaluation generation algorithm of BBCGGI21.</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="idpf-bbcggi21-helper-functions">
<section id="section-8.3.3">
          <h4 id="name-auxiliary-functions-3">
<a href="#section-8.3.3" class="section-number selfRef">8.3.3. </a><a href="#name-auxiliary-functions-3" class="section-name selfRef">Auxiliary Functions</a>
          </h4>
<span id="name-helper-functions-for-the-id"></span><div id="idpf-bbcggi21-helpers">
<figure id="figure-33">
            <div class="lang-python sourcecode" id="section-8.3.3-1.1">
<pre>
def extend(
        self,
        level: int,
        seed: bytes,
        nonce: bytes) -&gt; tuple[list[bytes], list[Field2]]:
    xof = self.current_xof(level, seed, format_dst(1, 0, 0), nonce)
    s = [
        bytearray(xof.next(self.KEY_SIZE)),
        bytearray(xof.next(self.KEY_SIZE)),
    ]
    # Use the least significant bits as the control bit correction,
    # and then zero it out. This gives effectively 127 bits of
    # security, but reduces the number of AES calls needed by 1/3.
    t = [Field2(s[0][0] &amp; 1), Field2(s[1][0] &amp; 1)]
    s[0][0] &amp;= 0xFE
    s[1][0] &amp;= 0xFE
    return ([bytes(s[0]), bytes(s[1])], t)

def convert(
        self,
        level: int,
        seed: bytes,
        nonce: bytes) -&gt; tuple[bytes, FieldVec]:
    xof = self.current_xof(level, seed, format_dst(1, 0, 1), nonce)
    next_seed = xof.next(self.KEY_SIZE)
    field = self.current_field(level)
    w = xof.next_vec(field, self.VALUE_LEN)
    return (next_seed, cast(FieldVec, w))

def current_xof(self,
                level: int,
                seed: bytes,
                dst: bytes,
                nonce: bytes) -&gt; Xof:
    if level &lt; self.BITS-1:
        return XofFixedKeyAes128(seed, dst, nonce)
    return XofTurboShake128(seed, dst, nonce)
</pre>
</div>
<figcaption><a href="#figure-33" class="selfRef">Figure 33</a>:
<a href="#name-helper-functions-for-the-id" class="selfRef">Helper functions for the IDPF.</a>
            </figcaption></figure>
</div>
</section>
</div>
</section>
</div>
<div id="poplar1-inst">
<section id="section-8.4">
        <h3 id="name-instantiation">
<a href="#section-8.4" class="section-number selfRef">8.4. </a><a href="#name-instantiation" class="section-name selfRef">Instantiation</a>
        </h3>
<p id="section-8.4-1">By default, Poplar1 is instantiated with the IDPF in <a href="#idpf-bbcggi21" class="auto internal xref">Section 8.3</a> (<code>VALUE_LEN
== 2</code>) and XofTurboShake128 (<a href="#xof-turboshake128" class="auto internal xref">Section 6.2.1</a>). This VDAF is suitable for
any positive value of <code>BITS</code>. Test vectors can be found in <a href="#test-vectors" class="auto internal xref">Appendix "Test Vectors"</a>.<a href="#section-8.4-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="security">
<section id="section-9">
      <h2 id="name-security-considerations">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-9-1">VDAFs (<a href="#vdaf" class="auto internal xref">Section 5</a>) have two essential security goals:<a href="#section-9-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-9-2">
<li id="section-9-2.1">
          <p id="section-9-2.1.1">Privacy: an attacker that controls the Collector and a subset of Clients and
Aggregators learns nothing about the measurements of honest Clients beyond
what it can deduce from the aggregate result. We assume the attacker
controls the entire network except for channels between honest Clients and
honest Aggregators. In particular, it cannot forge or prevent transmission
of messages on these channels.<a href="#section-9-2.1.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-9-2.2">
          <p id="section-9-2.2.1">Robustness: an attacker that controls a subset of Clients cannot cause the
Collector to compute anything other than the aggregate of the measurements
of honest Clients. We assume the attacker eavesdrops on the network but does
not control transmission of messages between honest parties.<a href="#section-9-2.2.1" class="pilcrow">¶</a></p>
</li>
      </ol>
<p id="section-9-3">Formal definitions of privacy and robustness can be found in <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>. A VDAF
is the core cryptographic primitive of a protocol that achieves the above
privacy and robustness goals. It is not sufficient on its own, however. The
application will need to assure a few security properties, for example:<a href="#section-9-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-9-4.1">
          <p id="section-9-4.1.1">Securely distributing the long-lived parameters, in particular the
verification key.<a href="#section-9-4.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-9-4.2">
          <p id="section-9-4.2.1">Establishing secure channels:<a href="#section-9-4.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-9-4.2.2.1">
              <p id="section-9-4.2.2.1.1">Confidential and authentic channels among Aggregators, and between the
Aggregators and the Collector; and<a href="#section-9-4.2.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-9-4.2.2.2">
              <p id="section-9-4.2.2.2.1">Confidential and Aggregator-authenticated channels between Clients and
Aggregators.<a href="#section-9-4.2.2.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</li>
        <li class="normal" id="section-9-4.3">
          <p id="section-9-4.3.1">Enforcing the non-collusion properties required of the specific VDAF in use.<a href="#section-9-4.3.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-9-5">In such an environment, a VDAF provides the high-level privacy property
described above: the Collector learns only the aggregate measurement, and
nothing about individual measurements aside from what can be inferred from the
aggregate result.  The Aggregators learn neither individual measurements nor the
aggregate result.  The Collector is assured that the aggregate statistic
accurately reflects the inputs as long as the Aggregators correctly executed
their role in the VDAF.<a href="#section-9-5" class="pilcrow">¶</a></p>
<p id="section-9-6">On their own, VDAFs do not provide:<a href="#section-9-6" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-9-7">
<li id="section-9-7.1">
          <p id="section-9-7.1.1">Mitigation of Sybil attacks <span>[<a href="#Dou02" class="cite xref">Dou02</a>]</span>. In this attack, the adversary
observes a subset of input shares transmitted by a Client it is interested
in. It allows the input shares to be processed, but corrupts and picks bogus
measurements for the remaining Clients.  Applications can guard against
these risks by adding additional controls on report submission, such as
Client authentication and rate limits.<a href="#section-9-7.1.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-9-7.2">
          <p id="section-9-7.2.1">Differential privacy <span>[<a href="#Dwo06" class="cite xref">Dwo06</a>]</span>. Depending on the distribution of the
measurements, the aggregate result itself can still leak a significant
amount of information about an individual measurement or the person that
generated it.<a href="#section-9-7.2.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-9-7.3">
          <p id="section-9-7.3.1">Robustness in the presence of a malicious Aggregator. An Aggregator can,
without detection, manipulate the aggregate result by modifying its own
aggregate share.<a href="#section-9-7.3.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-9-7.4">
          <p id="section-9-7.4.1">Guaranteed output delivery <span>[<a href="#GSZ20" class="cite xref">GSZ20</a>]</span>. An attacker that controls transmission
of messages between honest parties can prevent computation of the aggregate
result by dropping messages.<a href="#section-9-7.4.1" class="pilcrow">¶</a></p>
</li>
      </ol>
<div id="requirements-for-the-verification-key">
<section id="section-9.1">
        <h3 id="name-requirements-for-the-verifi">
<a href="#section-9.1" class="section-number selfRef">9.1. </a><a href="#name-requirements-for-the-verifi" class="section-name selfRef">Requirements for the Verification Key</a>
        </h3>
<p id="section-9.1-1">The Aggregators are responsible for exchanging the verification key in advance
of executing the VDAF. Any procedure is acceptable as long as the following
conditions are met:<a href="#section-9.1-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-9.1-2">
<li id="section-9.1-2.1">
            <p id="section-9.1-2.1.1">To ensure robustness of the computation, the Aggregators <span class="bcp14">MUST NOT</span> reveal the
verification key to the Clients. Otherwise, a malicious Client might be able
to exploit knowledge of this key to craft an invalid report that would be
accepted by the Aggregators.<a href="#section-9.1-2.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-9.1-2.2">
            <p id="section-9.1-2.2.1">To ensure privacy of the measurements, the Aggregators <span class="bcp14">MUST</span> commit to the
verification key prior to processing reports generated by Clients. Otherwise,
a malicious Aggregator may be able to craft a verification key that, for a
given report, causes an honest Aggregator to leak information about the
measurement during preparation.<a href="#section-9.1-2.2.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<p id="section-9.1-3">Meeting these conditions is required in order to leverage security analysis in
the framework of <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>. Their definition of robustness allows the attacker,
playing the role of a cohort of malicious Clients, to submit arbitrary reports
to the Aggregators and eavesdrop on their communications as they process them.
Security in this model is achievable as long as the verification key is kept
secret from the attacker.<a href="#section-9.1-3" class="pilcrow">¶</a></p>
<p id="section-9.1-4">The privacy definition of <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span> considers an active attacker that controls
the network and a subset of Aggregators; in addition, the attacker is allowed to
choose the verification key used by each honest Aggregator over the course of
the experiment. Security is achievable in this model as long as the key is
picked at the start of the experiment, prior to any reports being generated.
(The model also requires nonces to be generated at random; see
<a href="#nonce-requirements" class="auto internal xref">Section 9.2</a> below.)<a href="#section-9.1-4" class="pilcrow">¶</a></p>
<p id="section-9.1-5">Meeting these requirements is relatively straightforward. For example, the
Aggregators may designate one of their peers to generate the verification key
and distribute it to the others. To assure Clients of key commitment, the
Clients and (honest) Aggregators could bind reports to a shared context string
derived from the key. For instance, the "task ID" of DAP <span>[<a href="#DAP" class="cite xref">DAP</a>]</span> could be set to
the hash of the verification key; then as long as honest Aggregators only
consume reports for the task indicated by the Client, forging a new key after
the fact would reduce to finding collisions in the underlying hash function.
(Keeping the key secret from the Clients would require the hash function to be
one-way.) However, since rotating the key implies rotating the task ID, this
scheme would not allow key rotation over the lifetime of a task.<a href="#section-9.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="nonce-requirements">
<section id="section-9.2">
        <h3 id="name-requirements-for-the-nonce">
<a href="#section-9.2" class="section-number selfRef">9.2. </a><a href="#name-requirements-for-the-nonce" class="section-name selfRef">Requirements for the Nonce</a>
        </h3>
<p id="section-9.2-1">The sharding and preparation steps of VDAF execution depend on a nonce
associated with the Client's report. To ensure privacy of the underlying
measurement, the Client <span class="bcp14">MUST</span> generate this nonce using a CSPRNG. This is
required in order to leverage security analysis for the privacy definition of
<span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>, which assumes the nonce is chosen at random prior to generating the
report.<a href="#section-9.2-1" class="pilcrow">¶</a></p>
<p id="section-9.2-2">Other security considerations may require the nonce to be non-repeating. For
example, to achieve differential privacy it is necessary to avoid "over
exposing" a report by including it too many times in a single batch or across
multiple batches. It is <span class="bcp14">RECOMMENDED</span> that the nonce generated by the Client be
used by the Aggregators for replay protection.<a href="#section-9.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="requirements-for-the-public-share">
<section id="section-9.3">
        <h3 id="name-requirements-for-the-public">
<a href="#section-9.3" class="section-number selfRef">9.3. </a><a href="#name-requirements-for-the-public" class="section-name selfRef">Requirements for the Public Share</a>
        </h3>
<p id="section-9.3-1">The Aggregators <span class="bcp14">MUST</span> ensure they have both received the same public share from
the Client. It is sufficient, for example, to exchange a hash of the public
share over a secure channel.<a href="#section-9.3-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="requirements-for-aggregation-parameters">
<section id="section-9.4">
        <h3 id="name-requirements-for-aggregatio">
<a href="#section-9.4" class="section-number selfRef">9.4. </a><a href="#name-requirements-for-aggregatio" class="section-name selfRef">Requirements for Aggregation Parameters</a>
        </h3>
<p id="section-9.4-1">As described in <a href="#sec-daf-validity-scopes" class="auto internal xref">Section 4.3</a> and <a href="#sec-vdaf-validity-scopes" class="auto internal xref">Section 5.3</a>
respectively, DAFs and VDAFs may impose restrictions on the re-use of input
shares. This is to ensure that correlated randomness provided by the Client
through the input share is not used more than once, which might compromise
confidentiality of the Client's measurements.<a href="#section-9.4-1" class="pilcrow">¶</a></p>
<p id="section-9.4-2">Protocols that make use of VDAFs therefore <span class="bcp14">MUST</span> call <code>vdaf.is_valid</code>
on the set of all aggregation parameters used for a Client's input share, and
only proceed with the preparation and aggregation phases if that function call
returns <code>True</code>.<a href="#section-9.4-2" class="pilcrow">¶</a></p>
<div id="agg-param-privacy">
<section id="section-9.4.1">
          <h4 id="name-additional-privacy-consider">
<a href="#section-9.4.1" class="section-number selfRef">9.4.1. </a><a href="#name-additional-privacy-consider" class="section-name selfRef">Additional Privacy Considerations</a>
          </h4>
<p id="section-9.4.1-1">Aggregating a batch of reports multiple times, each time with a different
aggregation parameter, could result in information leakage beyond what is used
by the application.<a href="#section-9.4.1-1" class="pilcrow">¶</a></p>
<p id="section-9.4.1-2">For example, when Poplar1 is used for heavy hitters, the Aggregators learn not
only the heavy hitters themselves, but also the prefix tree (as defined in
<a href="#poplar1" class="auto internal xref">Section 8</a>) computed along the way. Indeed, this leakage is inherent to any
construction that uses an IDPF (<a href="#idpf" class="auto internal xref">Section 8.1</a>) in the same way. Depending on the
distribution of the measurements, the prefix tree can leak a significant amount
of information about unpopular inputs. For instance, it is possible (though
perhaps unlikely) for a large set of non-heavy-hitter values to share a common
prefix, which would be leaked by a prefix tree with a sufficiently small
threshold.<a href="#section-9.4.1-2" class="pilcrow">¶</a></p>
<p id="section-9.4.1-3">A malicious adversary controlling the Collector and one of the Aggregators can
further turn arbitrary non-heavy prefixes into heavy ones by tampering with the
IDPF output at any position. While our construction ensures that the nodes
evaluated at one level are children of the nodes evaluated at the previous
level, this still may allow an adversary to discover individual non-heavy
strings.<a href="#section-9.4.1-3" class="pilcrow">¶</a></p>
<p id="section-9.4.1-4">The only practical, general-purpose approach to mitigating these leakages is via
differential privacy, which is <span class="bcp14">RECOMMENDED</span> for all protocols using Poplar1 for
heavy-hitter type applications.<a href="#section-9.4.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="safe-usage-of-idpf-outputs">
<section id="section-9.4.2">
          <h4 id="name-safe-usage-of-idpf-outputs">
<a href="#section-9.4.2" class="section-number selfRef">9.4.2. </a><a href="#name-safe-usage-of-idpf-outputs" class="section-name selfRef">Safe Usage of IDPF Outputs</a>
          </h4>
<p id="section-9.4.2-1">The arithmetic sketch described in <a href="#poplar1" class="auto internal xref">Section 8</a> is used by the Aggregators to check
that the shares of the vector obtained by evaluating a Client's IDPF at a
sequence of candidate prefixes has at most one non-zero value, and that the
non-zero value is <code>1</code>. Depending on how the values are used, the arithmetic sketch
on its own may not be sufficient for robustness of the application. In
particular, a malicious Client may attempt to influence the computation by
choosing an IDPF that evaluates to <code>1</code> at more than one node at a given
level of the tree.<a href="#section-9.4.2-1" class="pilcrow">¶</a></p>
<p id="section-9.4.2-2">This issue can be mitigated by using an IDPF that is extractable as defined in
in Appendix D of <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>. Extractability ensures that, for a particular
level of the tree, it is infeasible for an attacker to control values of the
IDPF such that it takes on chosen non-zero values at more than one node. (It
can practically only achieve the zero function, a point function, or a
pseudorandom function.)<a href="#section-9.4.2-2" class="pilcrow">¶</a></p>
<p id="section-9.4.2-3">The IDPF specified in <a href="#idpf" class="auto internal xref">Section 8.1</a> only guarantees extractability at the last level
of the tree. (This is by virtue of using a larger field for the leaves than for
inner nodes and using an XOF to derive leaves that is safe to model as a random
oracle (see <a href="#xof-vs-ro" class="auto internal xref">Section 9.5</a>).) For intermediate levels, it is feasible for a
client to produce IDPF shares with two controlled non-zero nodes.<a href="#section-9.4.2-3" class="pilcrow">¶</a></p>
<p id="section-9.4.2-4">This is not an issue for running heavy hitters, since (1) each node in the
prefix tree is a child of a previously traversed node, (2) the arithmetic sketch
would detect double voting at every level of the prefix tree, and (3) the IDPF
is extractable at the last level of the tree. However, the lack of
extractability at intermediate levels may result in attacks on the robustness
of certain applications.<a href="#section-9.4.2-4" class="pilcrow">¶</a></p>
<p id="section-9.4.2-5">Thus applications <span class="bcp14">SHOULD NOT</span> use prefix counts for intermediate levels for any
purpose beyond the heavy-hitters tree traversal.<a href="#section-9.4.2-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="xof-vs-ro">
<section id="section-9.5">
        <h3 id="name-requirements-for-xofs">
<a href="#section-9.5" class="section-number selfRef">9.5. </a><a href="#name-requirements-for-xofs" class="section-name selfRef">Requirements for XOFs</a>
        </h3>
<p id="section-9.5-1">As described in <a href="#xof" class="auto internal xref">Section 6.2</a>, our constructions rely on eXtendable Output Functions
(XOFs). In the security analyses of our protocols, these are usually modeled as
random oracles. XofTurboShake128 is designed to be indifferentiable from a
random oracle <span>[<a href="#MRH04" class="cite xref">MRH04</a>]</span>, making it a suitable choice for most situations.<a href="#section-9.5-1" class="pilcrow">¶</a></p>
<p id="section-9.5-2">The one exception is the IDPF of <a href="#idpf-bbcggi21" class="auto internal xref">Section 8.3</a>. Here, a random oracle is not
needed to prove privacy, since the analysis of <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>, Proposition 1, only
requires a Pseudorandom Generator (PRG). As observed in <span>[<a href="#GKWY20" class="cite xref">GKWY20</a>]</span>, a PRG can be
instantiated from a correlation-robust hash function <code>H</code>. Informally,
correlation robustness requires that for a random <code>r</code>, <code>H(xor(r, x))</code> is
computationally indistinguishable from a random function of <code>x</code>. A PRG can
therefore be constructed as<a href="#section-9.5-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-9.5-3">
<pre>
PRG(r) = H(xor(r, 1)) || H(xor(r, 2)) || ...
</pre><a href="#section-9.5-3" class="pilcrow">¶</a>
</div>
<p id="section-9.5-4">since each individual hash function evaluation is indistinguishable from a random
function.<a href="#section-9.5-4" class="pilcrow">¶</a></p>
<p id="section-9.5-5">Our construction at <a href="#xof-fixed-key-aes128" class="auto internal xref">Section 6.2.2</a> implements a correlation-robust
hash function using fixed-key AES. For security, it assumes that AES with a
fixed key can be modeled as a random permutation <span>[<a href="#GKWY20" class="cite xref">GKWY20</a>]</span>. Additionally, we
use a different AES key for every client, which in the ideal cipher model leads
to better concrete security <span>[<a href="#GKWWY20" class="cite xref">GKWWY20</a>]</span>.<a href="#section-9.5-5" class="pilcrow">¶</a></p>
<p id="section-9.5-6">We note that for robustness, the analysis of <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span> still assumes a
random oracle to make the IDPF extractable. We therefore use XofTurboShake128
instead for the last level of the tree. It is important that XofTurboShake128
supports 16 byte seeds, as this is the seed size for the inner levels.<a href="#section-9.5-6" class="pilcrow">¶</a></p>
<p id="section-9.5-7">While XofFixedKeyAes128 has been shown to be differentiable from a random
oracle <span>[<a href="#GKWWY20" class="cite xref">GKWWY20</a>]</span>, there are no known attacks exploiting this difference. We
also stress that even if the IDPF is not extractable, Poplar1 guarantees that
every client can contribute to at most one prefix among the ones being
evaluated by the helpers.<a href="#section-9.5-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="security-multiproof">
<section id="section-9.6">
        <h3 id="name-choosing-the-field-size">
<a href="#section-9.6" class="section-number selfRef">9.6. </a><a href="#name-choosing-the-field-size" class="section-name selfRef">Choosing the Field Size</a>
        </h3>
<p id="section-9.6-1">Prio3 and other systems built from FLPs (<a href="#flp-bbcggi19" class="auto internal xref">Section 7.3</a> in particular) may
benefit from choosing a field size that is as small as possible. Generally
speaking, a smaller field results in lower communication and storage costs.
Care must be taken, however, since a smaller field also results in degraded (or
even vacuous) robustness.<a href="#section-9.6-1" class="pilcrow">¶</a></p>
<p id="section-9.6-2">Different variants of Prio3 (<a href="#prio3" class="auto internal xref">Section 7</a>) use different field sizes: Prio3Count
and Prio3Sum use Field64; but Prio3SumVec, Prio3Histogram, and
Prio3MultihotCountVec all use Field128, a field that is twice as large as
Field64. This is due to the use of joint randomness (<a href="#flp" class="auto internal xref">Section 7.1</a>) in the latter
variants. Joint randomness allows for more flexible circuit design (see
<a href="#flp-bbcggi19-overview-extensions" class="auto internal xref">Section 7.3.1.1</a>), but opens up Prio3 to offline attacks in
which the attacker searches for input shares for an invalid measurement that
derive joint randomness that causes the circuit to accept. Choosing a large
enough field ensures this computation is too expensive to be feasible. (See
<span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>, Theorem 1.) Note that privacy is not susceptible to such attacks.<a href="#section-9.6-2" class="pilcrow">¶</a></p>
<p id="section-9.6-3">Another way to mitigate this issue (or improve robustness in general) is to
generate and verify multiple, independent proofs. (See <a href="#multiproofs" class="auto internal xref">Section 7.1.2</a>.) For
Prio3, the <code>PROOFS</code> parameter controls the number of proofs (at least one) that
are generated and verified.<a href="#section-9.6-3" class="pilcrow">¶</a></p>
<p id="section-9.6-4">In general, Field128 is <span class="bcp14">RECOMMENDED</span> for use in Prio3 when the circuit uses
joint randomness (<code>JOINT_RAND_LEN &gt; 0</code>) and <code>PROOFS == 1</code>. Field64 <span class="bcp14">MAY</span> be used
instead, but <code>PROOFS</code> <span class="bcp14">MUST</span> be set to at least <code>3</code>. Breaking robustness for
<code>PROOFS == 2</code> is feasible, if impractical; but <code>PROOFS == 1</code> is completely
broken for such a small field.<a href="#section-9.6-4" class="pilcrow">¶</a></p>
<p id="section-9.6-5">We stress that weak parameters (too small a field, too few proofs, or both) can
be exploited to attack any aggregation task using those parameters. To
mitigate offline attacks, it is necessary to disable all tasks that use the
weak parameters.<a href="#section-9.6-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="num-aggregators">
<section id="section-9.7">
        <h3 id="name-choosing-the-number-of-aggr">
<a href="#section-9.7" class="section-number selfRef">9.7. </a><a href="#name-choosing-the-number-of-aggr" class="section-name selfRef">Choosing the Number of Aggregators</a>
        </h3>
<p id="section-9.7-1">Two Aggregators are required for privacy in our threat model, but some (V)DAFs,
including Prio3 (<a href="#prio3" class="auto internal xref">Section 7</a>), allow for any number of Aggregators, only one of
which needs to be trusted in order for the computation to be private. To hedge
against corruptions that happen during the course of the attack, deployments
may consider involving more than two Aggregators as described for example in
<a href="#star-topo" class="auto internal xref">Section 5.9</a>. Note however that some schemes are not compatible with this mode
of operation, such as Poplar1.<a href="#section-9.7-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="defense-in-depth-measures">
<section id="section-9.8">
        <h3 id="name-defense-in-depth-measures">
<a href="#section-9.8" class="section-number selfRef">9.8. </a><a href="#name-defense-in-depth-measures" class="section-name selfRef">Defense-in-Depth Measures</a>
        </h3>
<p id="section-9.8-1">Prio3 and Poplar1 are designed to resist some attacks that fall outside the
main threat model for VDAFs.<a href="#section-9.8-1" class="pilcrow">¶</a></p>
<p id="section-9.8-2">Broadly speaking, domain separation is used to prevent cross protocol attacks,
in which data from evaluation of one VDAF translates to an attack against another.
For example:<a href="#section-9.8-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-9.8-3">
<li id="section-9.8-3.1">
            <p id="section-9.8-3.1.1">Weak entropy sources: the VDAF algorithm ID is bound to each XOF invocation,
thereby ensuring the outputs are different between VDAF invocations, even if
the underlying randomness is the same. For example, two different instances
of Prio3 would compute different measurement shares.<a href="#section-9.8-3.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-9.8-3.2">
            <p id="section-9.8-3.2.1">Weak parameters: Prio3 variants that require joint randomness are subject to
offline attacks against robustness. These attacks are feasible if the field
size or number of proofs is sufficiently small. (See
<a href="#security-multiproof" class="auto internal xref">Section 9.6</a>.) The joint randomness derivation is bound to both
the field (via the algorithm ID) and the number of proofs, thereby ensuring
that joint randomness derived for weak parameters is not reused for stronger
parameters.<a href="#section-9.8-3.2.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<p id="section-9.8-4">There are also some important limitations to be aware of. For example, Prio3
provides domain separation between families of circuits, but does not provide
domain separation between instances of a circuit. Concretely, it is possible
for Aggregators to accept a report for Prio3SumVec from a Client who disagrees
with them on the value of <code>bits</code> and <code>length</code>. This is because there is no
binding of the circuit parameters to the computation.<a href="#section-9.8-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="iana-considerations">
<section id="section-10">
      <h2 id="name-iana-considerations">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-10-1">IANA is requested to make one new registry:<a href="#section-10-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-10-2.1">
          <p id="section-10-2.1.1">DAF and VDAF Identifiers<a href="#section-10-2.1.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-10-3">This registry should be created under the heading "Verifiable Distributed
Aggregation Functions (VDAF)", and administered under the Specification Required
policy <span>[<a href="#RFC8126" class="cite xref">RFC8126</a>]</span>.<a href="#section-10-3" class="pilcrow">¶</a></p>
<p id="section-10-4">The "VDAF Identifiers" registry lists identifiers for Distributed Aggregation
Functions (DAFs) and Verifiable Distributed Aggregation Functions (VDAFs). These
identifiers are four-byte values, so the minimum possible value is 0x00000000
and the maximum possible value is 0xffffffff.<a href="#section-10-4" class="pilcrow">¶</a></p>
<p id="section-10-5">Template:<a href="#section-10-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-10-6.1">
          <p id="section-10-6.1.1">Value: The four-byte identifier for the DAF or VDAF<a href="#section-10-6.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-10-6.2">
          <p id="section-10-6.2.1">Scheme: The name of the DAF or VDAF<a href="#section-10-6.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-10-6.3">
          <p id="section-10-6.3.1">Type: Either "DAF" for a Distributed Aggregation Function or "VDAF" for a
Verifiable Distributed Aggregation Function<a href="#section-10-6.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-10-6.4">
          <p id="section-10-6.4.1">Reference: Where the algorithm is defined<a href="#section-10-6.4.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-10-7">The initial contents of the registry are as follows:<a href="#section-10-7" class="pilcrow">¶</a></p>
<span id="name-verifiable-distributed-aggr"></span><div id="codepoints">
<table class="center" id="table-23">
        <caption>
<a href="#table-23" class="selfRef">Table 23</a>:
<a href="#name-verifiable-distributed-aggr" class="selfRef">Verifiable Distributed Aggregation Function Identifiers Registry</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Value</th>
            <th class="text-left" rowspan="1" colspan="1">Scheme</th>
            <th class="text-left" rowspan="1" colspan="1">Type</th>
            <th class="text-left" rowspan="1" colspan="1">Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00000000</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Reserved</td>
            <td class="text-left" rowspan="1" colspan="1">n/a</td>
            <td class="text-left" rowspan="1" colspan="1">RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00000001</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Prio3Count</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#prio3count" class="auto internal xref">Section 7.4.1</a> of RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00000002</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Prio3Sum</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#prio3sum" class="auto internal xref">Section 7.4.2</a> of RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00000003</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Prio3SumVec</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#prio3sumvec" class="auto internal xref">Section 7.4.3</a> of RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00000004</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Prio3Histogram</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#prio3histogram" class="auto internal xref">Section 7.4.4</a> of RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00000005</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Prio3MultihotCountVec</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#prio3multihotcountvec" class="auto internal xref">Section 7.4.5</a> of RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00000006</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Poplar1</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#poplar1-inst" class="auto internal xref">Section 8.4</a> of RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0xFFFF0000</code> to <code>0xFFFFFFFF</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Reserved for Private Use</td>
            <td class="text-left" rowspan="1" colspan="1">n/a</td>
            <td class="text-left" rowspan="1" colspan="1">n/a</td>
          </tr>
        </tbody>
      </table>
</div>
<p id="section-10-9">(RFC EDITOR: Please replace "RFC XXXX" above with the RFC number assigned to
this document.)<a href="#section-10-9" class="pilcrow">¶</a></p>
<p id="section-10-10">VDAF identifiers are used for domain separation, as described in <a href="#dst-binder" class="auto internal xref">Section 6.2.3</a>.
Domain separation guards against failures of entropy sources, by ensuring that
invocations of different VDAFs use different derived values, even if they are
invoked with the same underlying random data.<a href="#section-10-10" class="pilcrow">¶</a></p>
<p id="section-10-11">The benefits of domain separation are undermined if different VDAFs are used
with the same VDAF Identifier.  The "Reserved for Private Use" code points
should thus be used judiciously, because they provide no defense against such
collisions.  Applications <span class="bcp14">SHOULD</span> prefer the use of registered code points.<a href="#section-10-11" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-combined-references">
<section id="section-11">
      <h2 id="name-references">
<a href="#section-11" class="section-number selfRef">11. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<div id="sec-normative-references">
<section id="section-11.1">
        <h3 id="name-normative-references">
<a href="#section-11.1" class="section-number selfRef">11.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc2119">https://www.rfc-editor.org/rfc/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8126">[RFC8126]</dt>
        <dd>
<span class="refAuthor">Cotton, M.</span>, <span class="refAuthor">Leiba, B.</span>, and <span class="refAuthor">T. Narten</span>, <span class="refTitle">"Guidelines for Writing an IANA Considerations Section in RFCs"</span>, <span class="seriesInfo">BCP 26</span>, <span class="seriesInfo">RFC 8126</span>, <span class="seriesInfo">DOI 10.17487/RFC8126</span>, <time datetime="2017-06" class="refDate">June 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc8126">https://www.rfc-editor.org/rfc/rfc8126</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
        <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc8174">https://www.rfc-editor.org/rfc/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8446">[RFC8446]</dt>
        <dd>
<span class="refAuthor">Rescorla, E.</span>, <span class="refTitle">"The Transport Layer Security (TLS) Protocol Version 1.3"</span>, <span class="seriesInfo">RFC 8446</span>, <span class="seriesInfo">DOI 10.17487/RFC8446</span>, <time datetime="2018-08" class="refDate">August 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc8446">https://www.rfc-editor.org/rfc/rfc8446</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="TurboSHAKE">[TurboSHAKE]</dt>
      <dd>
<span class="refAuthor">Viguier, B.</span>, <span class="refAuthor">Wong, D.</span>, <span class="refAuthor">Van Assche, G.</span>, <span class="refAuthor">Dang, Q.</span>, and <span class="refAuthor">J. Daemen</span>, <span class="refTitle">"KangarooTwelve and TurboSHAKE"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-irtf-cfrg-kangarootwelve-14</span>, <time datetime="2024-05-09" class="refDate">9 May 2024</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-kangarootwelve-14">https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-kangarootwelve-14</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</div>
<div id="sec-informative-references">
<section id="section-11.2">
        <h3 id="name-informative-references">
<a href="#section-11.2" class="section-number selfRef">11.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="AGJOP21">[AGJOP21]</dt>
        <dd>
<span class="refAuthor">Addanki, S.</span>, <span class="refAuthor">Garbe, K.</span>, <span class="refAuthor">Jaffe, E.</span>, <span class="refAuthor">Ostrovsky, R.</span>, and <span class="refAuthor">A. Polychroniadou</span>, <span class="refTitle">"Prio+: Privacy Preserving Aggregate Statistics via Boolean Shares"</span>, <time datetime="2021" class="refDate">2021</time>, <span>&lt;<a href="https://ia.cr/2021/576">https://ia.cr/2021/576</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="BBCGGI19">[BBCGGI19]</dt>
        <dd>
<span class="refAuthor">Boneh, D.</span>, <span class="refAuthor">Boyle, E.</span>, <span class="refAuthor">Corrigan-Gibbs, H.</span>, <span class="refAuthor">Gilboa, N.</span>, and <span class="refAuthor">Y. Ishai</span>, <span class="refTitle">"Zero-Knowledge Proofs on Secret-Shared Data via Fully Linear PCPs"</span>, <span class="seriesInfo">CRYPTO 2019 </span>, <time datetime="2019" class="refDate">2019</time>, <span>&lt;<a href="https://ia.cr/2019/188">https://ia.cr/2019/188</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="BBCGGI21">[BBCGGI21]</dt>
        <dd>
<span class="refAuthor">Boneh, D.</span>, <span class="refAuthor">Boyle, E.</span>, <span class="refAuthor">Corrigan-Gibbs, H.</span>, <span class="refAuthor">Gilboa, N.</span>, and <span class="refAuthor">Y. Ishai</span>, <span class="refTitle">"Lightweight Techniques for Private Heavy Hitters"</span>, <span class="seriesInfo">IEEE S&amp;P 2021 </span>, <time datetime="2021" class="refDate">2021</time>, <span>&lt;<a href="https://ia.cr/2021/017">https://ia.cr/2021/017</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="BBCGGI23">[BBCGGI23]</dt>
        <dd>
<span class="refAuthor">Boneh, D.</span>, <span class="refAuthor">Boyle, E.</span>, <span class="refAuthor">Corrigan-Gibbs, H.</span>, <span class="refAuthor">Gilboa, N.</span>, and <span class="refAuthor">Y. Ishai</span>, <span class="refTitle">"Arithmetic Sketching"</span>, <span class="seriesInfo">CRYPTO 2023 </span>, <time datetime="2023" class="refDate">2023</time>, <span>&lt;<a href="https://ia.cr/2023/1012">https://ia.cr/2023/1012</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="BGI15">[BGI15]</dt>
        <dd>
<span class="refAuthor">Boyle, E.</span>, <span class="refAuthor">Gilboa, N.</span>, and <span class="refAuthor">Y. Ishai</span>, <span class="refTitle">"Function Secret Sharing"</span>, <span class="seriesInfo">EUROCRYPT 2015 </span>, <time datetime="2015" class="refDate">2015</time>, <span>&lt;<a href="https://www.iacr.org/archive/eurocrypt2015/90560300/90560300.pdf">https://www.iacr.org/archive/eurocrypt2015/90560300/90560300.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="CGB17">[CGB17]</dt>
        <dd>
<span class="refAuthor">Corrigan-Gibbs, H.</span> and <span class="refAuthor">D. Boneh</span>, <span class="refTitle">"Prio: Private, Robust, and Scalable Computation of Aggregate Statistics"</span>, <span class="seriesInfo">NSDI 2017 </span>, <time datetime="2017" class="refDate">2017</time>, <span>&lt;<a href="https://dl.acm.org/doi/10.5555/3154630.3154652">https://dl.acm.org/doi/10.5555/3154630.3154652</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="DAP">[DAP]</dt>
        <dd>
<span class="refAuthor">Geoghegan, T.</span>, <span class="refAuthor">Patton, C.</span>, <span class="refAuthor">Pitman, B.</span>, <span class="refAuthor">Rescorla, E.</span>, and <span class="refAuthor">C. A. Wood</span>, <span class="refTitle">"Distributed Aggregation Protocol for Privacy Preserving Measurement"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-ppm-dap-11</span>, <time datetime="2024-05-21" class="refDate">21 May 2024</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-ppm-dap-11">https://datatracker.ietf.org/doc/html/draft-ietf-ppm-dap-11</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Dou02">[Dou02]</dt>
        <dd>
<span class="refAuthor">Douceur, J.</span>, <span class="refTitle">"The Sybil Attack"</span>, <span class="seriesInfo">IPTPS 2002 </span>, <time datetime="2002" class="refDate">2002</time>, <span>&lt;<a href="https://doi.org/10.1007/3-540-45748-8_24">https://doi.org/10.1007/3-540-45748-8_24</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="DPRS23">[DPRS23]</dt>
        <dd>
<span class="refAuthor">Davis, H.</span>, <span class="refAuthor">Patton, C.</span>, <span class="refAuthor">Rosulek, M.</span>, and <span class="refAuthor">P. Schoppmann</span>, <span class="refTitle">"Verifiable Distributed Aggregation Functions"</span>, <span class="seriesInfo">PETS 2023 </span>, <time datetime="2023" class="refDate">2023</time>, <span>&lt;<a href="https://ia.cr/2023/130">https://ia.cr/2023/130</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Dwo06">[Dwo06]</dt>
        <dd>
<span class="refAuthor">Dwork, C.</span>, <span class="refTitle">"Differential Privacy"</span>, <span class="seriesInfo">ICALP 2006 </span>, <time datetime="2006" class="refDate">2006</time>, <span>&lt;<a href="https://link.springer.com/chapter/10.1007/11787006_1">https://link.springer.com/chapter/10.1007/11787006_1</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="ENPA">[ENPA]</dt>
        <dd>
<span class="refTitle">"Exposure Notification Privacy-preserving Analytics (ENPA) White Paper"</span>, <time datetime="2021" class="refDate">2021</time>, <span>&lt;<a href="https://covid19-static.cdn-apple.com/applications/covid19/current/static/contact-tracing/pdf/ENPA_White_Paper.pdf">https://covid19-static.cdn-apple.com/applications/covid19/current/static/contact-tracing/pdf/ENPA_White_Paper.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="EPK14">[EPK14]</dt>
        <dd>
<span class="refAuthor">Erlingsson, Ú.</span>, <span class="refAuthor">Pihur, V.</span>, and <span class="refAuthor">A. Korolova</span>, <span class="refTitle">"RAPPOR: Randomized Aggregatable Privacy-Preserving Ordinal Response"</span>, <span class="seriesInfo">CCS 2014 </span>, <time datetime="2014" class="refDate">2014</time>, <span>&lt;<a href="https://dl.acm.org/doi/10.1145/2660267.2660348">https://dl.acm.org/doi/10.1145/2660267.2660348</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="GI14">[GI14]</dt>
        <dd>
<span class="refAuthor">Gilboa, N.</span> and <span class="refAuthor">Y. Ishai</span>, <span class="refTitle">"Distributed Point Functions and Their Applications"</span>, <span class="seriesInfo">EUROCRYPT 2014 </span>, <time datetime="2014" class="refDate">2014</time>, <span>&lt;<a href="https://link.springer.com/chapter/10.1007/978-3-642-55220-5_35">https://link.springer.com/chapter/10.1007/978-3-642-55220-5_35</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="GKWWY20">[GKWWY20]</dt>
        <dd>
<span class="refAuthor">Guo, C.</span>, <span class="refAuthor">Katz, J.</span>, <span class="refAuthor">Wang, X.</span>, <span class="refAuthor">Weng, C.</span>, and <span class="refAuthor">Y. Yu</span>, <span class="refTitle">"Better concrete security for half-gates garbling (in the multi-instance setting)"</span>, <span class="seriesInfo">CRYPTO 2020 </span>, <time datetime="2020" class="refDate">2020</time>, <span>&lt;<a href="https://link.springer.com/chapter/10.1007/978-3-030-56880-1_28">https://link.springer.com/chapter/10.1007/978-3-030-56880-1_28</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="GKWY20">[GKWY20]</dt>
        <dd>
<span class="refAuthor">Guo, C.</span>, <span class="refAuthor">Katz, J.</span>, <span class="refAuthor">Wang, X.</span>, and <span class="refAuthor">Y. Yu</span>, <span class="refTitle">"Efficient and Secure Multiparty Computation from Fixed-Key Block Ciphers"</span>, <span class="seriesInfo">S&amp;P 2020 </span>, <time datetime="2020" class="refDate">2020</time>, <span>&lt;<a href="https://eprint.iacr.org/2019/074">https://eprint.iacr.org/2019/074</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="GSZ20">[GSZ20]</dt>
        <dd>
<span class="refAuthor">Goyal, V.</span>, <span class="refAuthor">Song, Y.</span>, and <span class="refAuthor">C. Zhu</span>, <span class="refTitle">"Guaranteed Output Delivery Comes Free in Honest Majority MPC"</span>, <span class="seriesInfo">CRYPTO 2020 </span>, <time datetime="2020" class="refDate">2020</time>, <span>&lt;<a href="https://link.springer.com/chapter/10.1007/978-3-030-56880-1_22">https://link.springer.com/chapter/10.1007/978-3-030-56880-1_22</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="MPDST25">[MPDST25]</dt>
        <dd>
<span class="refAuthor">Mouris, D.</span>, <span class="refAuthor">Patton, C.</span>, <span class="refAuthor">Davis, H.</span>, <span class="refAuthor">Sarkar, P.</span>, and <span class="refAuthor">N. G. Tsoutsos</span>, <span class="refTitle">"Mastic: Private Weighted Heavy-Hitters and Attribute-Based Metrics"</span>, <span class="seriesInfo">PETS 2025 </span>, <time datetime="2025" class="refDate">2025</time>, <span>&lt;<a href="https://eprint.iacr.org/2024/221">https://eprint.iacr.org/2024/221</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="MPRV09">[MPRV09]</dt>
        <dd>
<span class="refAuthor">Mironov, I.</span>, <span class="refAuthor">Pandey, O.</span>, <span class="refAuthor">Reingold, O.</span>, and <span class="refAuthor">S. Vadhan</span>, <span class="refTitle">"Computational Differential Privacy"</span>, <span class="seriesInfo">CRYPTO 2009 </span>, <span>n.d.</span>, <span>&lt;<a href="https://link.springer.com/chapter/10.1007/978-3-642-03356-8_8">https://link.springer.com/chapter/10.1007/978-3-642-03356-8_8</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="MRH04">[MRH04]</dt>
        <dd>
<span class="refAuthor">Maurer, U.</span>, <span class="refAuthor">Renner, R.</span>, and <span class="refAuthor">C. Holenstein</span>, <span class="refTitle">"Indifferentiability, impossibility results on reductions, and applications to the random oracle methodology"</span>, <span class="seriesInfo">In TCC 2004: Theory of Cryptography</span>, <span class="seriesInfo">pages 21-39</span>, <span class="seriesInfo">DOI 10.1007/978-3-540-24638-1_2</span>, <time datetime="2004-02" class="refDate">February 2004</time>, <span>&lt;<a href="https://doi.org/10.1007/978-3-540-24638-1_2">https://doi.org/10.1007/978-3-540-24638-1_2</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="OriginTelemetry">[OriginTelemetry]</dt>
        <dd>
<span class="refTitle">"Origin Telemetry"</span>, <time datetime="2020" class="refDate">2020</time>, <span>&lt;<a href="https://web.archive.org/web/20221025174046/https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/collection/origin.html">https://web.archive.org/web/20221025174046/https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/collection/origin.html</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="SML24">[SML24]</dt>
        <dd>
<span class="refAuthor">Satriawan, A.</span>, <span class="refAuthor">Mareta, R.</span>, and <span class="refAuthor">H. Lee</span>, <span class="refTitle">"A Complete Beginner Guide to the Number Theoretic Transform (NTT)"</span>, <time datetime="2024" class="refDate">2024</time>, <span>&lt;<a href="https://eprint.iacr.org/2024/585">https://eprint.iacr.org/2024/585</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="TestVectors">[TestVectors]</dt>
      <dd>
<span class="refTitle">"Test vectors for Prio3 and Poplar1"</span>, <span class="seriesInfo">commit hash &lt;TODO&gt; </span>, <time datetime="2024-09" class="refDate">September 2024</time>, <span>&lt;<a href="https://github.com/cfrg/draft-irtf-cfrg-vdaf/tree/main/test_vec/vdaf">https://github.com/cfrg/draft-irtf-cfrg-vdaf/tree/main/test_vec/vdaf</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</div>
</section>
</div>
<div id="acknowledgments">
<section id="appendix-A">
      <h2 id="name-acknowledgments">
<a href="#name-acknowledgments" class="section-name selfRef">Acknowledgments</a>
      </h2>
<p id="appendix-A-1">The impetus of this work is the success of recent deployments of predecessors
of Prio3. The Mozilla Origin Telemetry project <span>[<a href="#OriginTelemetry" class="cite xref">OriginTelemetry</a>]</span> and the
Exposure Notification Private Analytics collaboration among the Internet
Security Research Group (ISRG), Google, Apple, and others <span>[<a href="#ENPA" class="cite xref">ENPA</a>]</span> have
together aggregated data from hundreds of millions of users.<a href="#appendix-A-1" class="pilcrow">¶</a></p>
<p id="appendix-A-2">As the name implies, Prio3 is a descendant of the original Prio construction
<span>[<a href="#CGB17" class="cite xref">CGB17</a>]</span>. A second iteration was deployed in the <span>[<a href="#ENPA" class="cite xref">ENPA</a>]</span> system, and like the
VDAF described here, the ENPA system was built from techniques introduced in
<span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span> that significantly improve communication cost. That system was
specialized for a particular aggregation function; the goal of Prio3 is to
provide the same level of generality as the original construction.<a href="#appendix-A-2" class="pilcrow">¶</a></p>
<p id="appendix-A-3">The security considerations in <a href="#security" class="auto internal xref">Section 9</a> are based largely on the security
analysis of <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>. Thanks to Hannah Davis and Mike Rosulek, who lent their
time to developing definitions and security proofs.<a href="#appendix-A-3" class="pilcrow">¶</a></p>
<p id="appendix-A-4">Thanks to Junye Chen, Henry Corrigan-Gibbs, Armando Faz-Hernández, Simon
Friedberger, Tim Geoghegan, Albert Liu, Brandon Pitman, Mariana Raykova, Jacob
Rothstein, Shan Wang, Xiao Wang, Bas Westerbaan, and Christopher Wood for
useful feedback on and contributions to the spec.<a href="#appendix-A-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="test-vectors">
<section id="appendix-B">
      <h2 id="name-test-vectors">
<a href="#name-test-vectors" class="section-name selfRef">Test Vectors</a>
      </h2>
<p id="appendix-B-1">(RFC EDITOR: Update the reference in <span>[<a href="#TestVectors" class="cite xref">TestVectors</a>]</span> by replacing <code>&lt;TODO&gt;</code> with
the commit hash with the final version of the test vectors.)<a href="#appendix-B-1" class="pilcrow">¶</a></p>
<p id="appendix-B-2">The test vectors are available at <span>[<a href="#TestVectors" class="cite xref">TestVectors</a>]</span>. The directory contains a set
of JSON files. Each file contains a test vector for an instance of <code>Vdaf</code>
(<a href="#vdaf" class="auto internal xref">Section 5</a>). A test vector covers sharding, preparation, aggregation, and
unsharding of each of several measurements. The test vector schema is defined
below.<a href="#appendix-B-2" class="pilcrow">¶</a></p>
<div id="schema">
<section id="appendix-B.1">
        <h3 id="name-schema">
<a href="#name-schema" class="section-name selfRef">Schema</a>
        </h3>
<span class="break"></span><dl class="dlParallel" id="appendix-B.1-1">
          <dt id="appendix-B.1-1.1">"verify_key":</dt>
          <dd style="margin-left: 1.5em" id="appendix-B.1-1.2">
            <p id="appendix-B.1-1.2.1">The verification key encoded in hexadecimal.<a href="#appendix-B.1-1.2.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="appendix-B.1-1.3">"agg_param":</dt>
          <dd style="margin-left: 1.5em" id="appendix-B.1-1.4">
            <p id="appendix-B.1-1.4.1">The aggregation parameter of type <code>Vdaf.AggParam</code>.<a href="#appendix-B.1-1.4.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="appendix-B.1-1.5">"prep":</dt>
          <dd style="margin-left: 1.5em" id="appendix-B.1-1.6">
            <p id="appendix-B.1-1.6.1">A list of objects with the following schema:<a href="#appendix-B.1-1.6.1" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="appendix-B.1-1.6.2">
              <dt id="appendix-B.1-1.6.2.1">"measurement":</dt>
              <dd style="margin-left: 1.5em" id="appendix-B.1-1.6.2.2">
                <p id="appendix-B.1-1.6.2.2.1">The measurement of type <code>Vdaf.Measurement</code>.<a href="#appendix-B.1-1.6.2.2.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="appendix-B.1-1.6.2.3">"nonce":</dt>
              <dd style="margin-left: 1.5em" id="appendix-B.1-1.6.2.4">
                <p id="appendix-B.1-1.6.2.4.1">The nonce encoded in hexadecimal.<a href="#appendix-B.1-1.6.2.4.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="appendix-B.1-1.6.2.5">"rand":</dt>
              <dd style="margin-left: 1.5em" id="appendix-B.1-1.6.2.6">
                <p id="appendix-B.1-1.6.2.6.1">The sharding randomness encoded in hexadecimal.<a href="#appendix-B.1-1.6.2.6.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="appendix-B.1-1.6.2.7">"public_share":</dt>
              <dd style="margin-left: 1.5em" id="appendix-B.1-1.6.2.8">
                <p id="appendix-B.1-1.6.2.8.1">The expected public share encoded in hexadecimal.<a href="#appendix-B.1-1.6.2.8.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="appendix-B.1-1.6.2.9">"input_shares":</dt>
              <dd style="margin-left: 1.5em" id="appendix-B.1-1.6.2.10">
                <p id="appendix-B.1-1.6.2.10.1">The expected list of input shares, each incoded in hexadecimal.<a href="#appendix-B.1-1.6.2.10.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="appendix-B.1-1.6.2.11">"prep_shares":</dt>
              <dd style="margin-left: 1.5em" id="appendix-B.1-1.6.2.12">
                <p id="appendix-B.1-1.6.2.12.1">The expected list of prep shares generated by each Aggregator at each
round of preparation, encoded in hexadecimal.<a href="#appendix-B.1-1.6.2.12.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="appendix-B.1-1.6.2.13">"prep_messages":</dt>
              <dd style="margin-left: 1.5em" id="appendix-B.1-1.6.2.14">
                <p id="appendix-B.1-1.6.2.14.1">The expected list of prep messages for each round of preparation, encoded
in hexadecimal.<a href="#appendix-B.1-1.6.2.14.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="appendix-B.1-1.6.2.15">"out_shares":</dt>
              <dd style="margin-left: 1.5em" id="appendix-B.1-1.6.2.16">
                <p id="appendix-B.1-1.6.2.16.1">The expected list of output shares, encoded in hexadecimal.<a href="#appendix-B.1-1.6.2.16.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
</dl>
</dd>
          <dd class="break"></dd>
<dt id="appendix-B.1-1.7">"agg_shares":</dt>
          <dd style="margin-left: 1.5em" id="appendix-B.1-1.8">
            <p id="appendix-B.1-1.8.1">The expected aggregate shares encoded in hexadecimal.<a href="#appendix-B.1-1.8.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="appendix-B.1-1.9">"agg_result"`</dt>
          <dd style="margin-left: 1.5em" id="appendix-B.1-1.10">
            <p id="appendix-B.1-1.10.1">The expected aggregate result of type <code>Vdaf.AggResult</code>.<a href="#appendix-B.1-1.10.1" class="pilcrow">¶</a></p>
</dd>
        <dd class="break"></dd>
</dl>
<p id="appendix-B.1-2">The scehma also includes whatever parameters are required to instantiate the
VDAF. These are listed in the subsections below.<a href="#appendix-B.1-2" class="pilcrow">¶</a></p>
<div id="prio3count-1">
<section id="appendix-B.1.1">
          <h4 id="name-prio3count-2">
<a href="#name-prio3count-2" class="section-name selfRef">Prio3Count</a>
          </h4>
<span class="break"></span><dl class="dlParallel" id="appendix-B.1.1-1">
            <dt id="appendix-B.1.1-1.1">"shares":</dt>
            <dd style="margin-left: 1.5em" id="appendix-B.1.1-1.2">
              <p id="appendix-B.1.1-1.2.1">The number of shares, an integer.<a href="#appendix-B.1.1-1.2.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
<div id="prio3sum-1">
<section id="appendix-B.1.2">
          <h4 id="name-prio3sum-2">
<a href="#name-prio3sum-2" class="section-name selfRef">Prio3Sum</a>
          </h4>
<span class="break"></span><dl class="dlParallel" id="appendix-B.1.2-1">
            <dt id="appendix-B.1.2-1.1">"shares":</dt>
            <dd style="margin-left: 1.5em" id="appendix-B.1.2-1.2">
              <p id="appendix-B.1.2-1.2.1">The number of shares, an integer.<a href="#appendix-B.1.2-1.2.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="appendix-B.1.2-1.3">"max_measurement":</dt>
            <dd style="margin-left: 1.5em" id="appendix-B.1.2-1.4">
              <p id="appendix-B.1.2-1.4.1">The largest measurement, an integer. Each element is in range
<code>range(max_measurement+1)</code>.<a href="#appendix-B.1.2-1.4.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
<div id="prio3sumvec-1">
<section id="appendix-B.1.3">
          <h4 id="name-prio3sumvec-2">
<a href="#name-prio3sumvec-2" class="section-name selfRef">Prio3SumVec</a>
          </h4>
<span class="break"></span><dl class="dlParallel" id="appendix-B.1.3-1">
            <dt id="appendix-B.1.3-1.1">"shares":</dt>
            <dd style="margin-left: 1.5em" id="appendix-B.1.3-1.2">
              <p id="appendix-B.1.3-1.2.1">The number of shares, an integer.<a href="#appendix-B.1.3-1.2.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="appendix-B.1.3-1.3">"length":</dt>
            <dd style="margin-left: 1.5em" id="appendix-B.1.3-1.4">
              <p id="appendix-B.1.3-1.4.1">The lengh of the vector, an integer.<a href="#appendix-B.1.3-1.4.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="appendix-B.1.3-1.5">"chunk_length":</dt>
            <dd style="margin-left: 1.5em" id="appendix-B.1.3-1.6">
              <p id="appendix-B.1.3-1.6.1">the length of each vector chunk, an integer.<a href="#appendix-B.1.3-1.6.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="appendix-B.1.3-1.7">"bits":</dt>
            <dd style="margin-left: 1.5em" id="appendix-B.1.3-1.8">
              <p id="appendix-B.1.3-1.8.1">the bit length of each element of the vector, an integer. each element is in
<code>range(2 ** bits)</code>.<a href="#appendix-B.1.3-1.8.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
<div id="prio3histogram-1">
<section id="appendix-B.1.4">
          <h4 id="name-prio3histogram-2">
<a href="#name-prio3histogram-2" class="section-name selfRef">Prio3Histogram</a>
          </h4>
<span class="break"></span><dl class="dlParallel" id="appendix-B.1.4-1">
            <dt id="appendix-B.1.4-1.1">"shares":</dt>
            <dd style="margin-left: 1.5em" id="appendix-B.1.4-1.2">
              <p id="appendix-B.1.4-1.2.1">The number of shares, an integer.<a href="#appendix-B.1.4-1.2.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="appendix-B.1.4-1.3">"length":</dt>
            <dd style="margin-left: 1.5em" id="appendix-B.1.4-1.4">
              <p id="appendix-B.1.4-1.4.1">The lengh of the vector, an integer.<a href="#appendix-B.1.4-1.4.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="appendix-B.1.4-1.5">"chunk_length":</dt>
            <dd style="margin-left: 1.5em" id="appendix-B.1.4-1.6">
              <p id="appendix-B.1.4-1.6.1">the length of each vector chunk, an integer.<a href="#appendix-B.1.4-1.6.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
<div id="prio3multihotcountvec-1">
<section id="appendix-B.1.5">
          <h4 id="name-prio3multihotcountvec-2">
<a href="#name-prio3multihotcountvec-2" class="section-name selfRef">Prio3MultihotCountVec</a>
          </h4>
<span class="break"></span><dl class="dlParallel" id="appendix-B.1.5-1">
            <dt id="appendix-B.1.5-1.1">"shares":</dt>
            <dd style="margin-left: 1.5em" id="appendix-B.1.5-1.2">
              <p id="appendix-B.1.5-1.2.1">The number of shares, an integer.<a href="#appendix-B.1.5-1.2.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="appendix-B.1.5-1.3">"length":</dt>
            <dd style="margin-left: 1.5em" id="appendix-B.1.5-1.4">
              <p id="appendix-B.1.5-1.4.1">The lengh of the vector, an integer.<a href="#appendix-B.1.5-1.4.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="appendix-B.1.5-1.5">"chunk_length":</dt>
            <dd style="margin-left: 1.5em" id="appendix-B.1.5-1.6">
              <p id="appendix-B.1.5-1.6.1">the length of each vector chunk, an integer.<a href="#appendix-B.1.5-1.6.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="appendix-B.1.5-1.7">"max_weight":</dt>
            <dd style="margin-left: 1.5em" id="appendix-B.1.5-1.8">
              <p id="appendix-B.1.5-1.8.1">The largest vector weight, an integer. The sum of the elements must be in
<code>range(max_weight+1)</code>.<a href="#appendix-B.1.5-1.8.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
<div id="poplar1-test-vec-param">
<section id="appendix-B.1.6">
          <h4 id="name-poplar1-2">
<a href="#name-poplar1-2" class="section-name selfRef">Poplar1</a>
          </h4>
<span class="break"></span><dl class="dlParallel" id="appendix-B.1.6-1">
            <dt id="appendix-B.1.6-1.1">"bits":</dt>
            <dd style="margin-left: 1.5em" id="appendix-B.1.6-1.2">
              <p id="appendix-B.1.6-1.2.1">The length of each input, an integer.<a href="#appendix-B.1.6-1.2.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="authors-addresses">
<section id="appendix-C">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Richard L. Barnes</span></div>
<div dir="auto" class="left"><span class="org">Cisco</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:rlb@ipv.sx" class="email">rlb@ipv.sx</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">David Cook</span></div>
<div dir="auto" class="left"><span class="org">ISRG</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:divergentdave@gmail.com" class="email">divergentdave@gmail.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Christopher Patton</span></div>
<div dir="auto" class="left"><span class="org">Cloudflare</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:chrispatton+ietf@gmail.com" class="email">chrispatton+ietf@gmail.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Phillipp Schoppmann</span></div>
<div dir="auto" class="left"><span class="org">Google</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:schoppmann@google.com" class="email">schoppmann@google.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
