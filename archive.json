{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-08-25T00:54:07.576029+00:00",
  "repo": "cfrg/draft-irtf-cfrg-vdaf",
  "labels": [
    {
      "name": "draft-01",
      "description": "",
      "color": "F6C11D"
    },
    {
      "name": "draft-02",
      "description": "",
      "color": "019C33"
    },
    {
      "name": "draft-03",
      "description": "",
      "color": "5C9ACE"
    },
    {
      "name": "editorial",
      "description": "",
      "color": "F2C540"
    },
    {
      "name": "draft-04",
      "description": "",
      "color": "CF20F6"
    },
    {
      "name": "draft-05",
      "description": "",
      "color": "F6D769"
    },
    {
      "name": "feature",
      "description": "",
      "color": "112811"
    },
    {
      "name": "wire change",
      "description": "",
      "color": "CC5338"
    },
    {
      "name": "needs security analysis",
      "description": "",
      "color": "BE7968"
    },
    {
      "name": "draft-07",
      "description": "",
      "color": "ADDF8E"
    },
    {
      "name": "idea",
      "description": "",
      "color": "74C1F6"
    },
    {
      "name": "ietf118",
      "description": "",
      "color": "467D12"
    },
    {
      "name": "security consideration",
      "description": "",
      "color": "633F8E"
    },
    {
      "name": "poc",
      "description": "",
      "color": "270AF8"
    },
    {
      "name": "draft-09",
      "description": "",
      "color": "6D7BB8"
    },
    {
      "name": "draft-10",
      "description": "",
      "color": "133CD6"
    },
    {
      "name": "pre-RGLC",
      "description": "",
      "color": "8E22CC"
    },
    {
      "name": "draft-11",
      "description": "",
      "color": "D10E5A"
    },
    {
      "name": "draft-12",
      "description": "",
      "color": "36D415"
    }
  ],
  "issues": [
    {
      "number": 8,
      "id": "I_kwDOGKuqOc4-qH_-",
      "title": "Syntax: Use agg parameter for prepare-init only",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/8",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This aggregation parameter isn't used anywhere but during the preparation phase. We may wind up wanting to specify a scheme that needs this, at which point we can add this back in. For now, removing this unnecessary joint will simplify the syntax.",
      "createdAt": "2021-11-11T18:01:23Z",
      "updatedAt": "2021-12-28T17:43:25Z",
      "closedAt": "2021-12-28T17:43:25Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "The aggregation parameter is used in hits in order to decode output shares and aggregate shares. Upon further reflection, it seems like we'll need something like this going forward.",
          "createdAt": "2021-12-28T17:43:25Z",
          "updatedAt": "2021-12-28T17:43:25Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOGKuqOc4-qq61",
      "title": "Can / should VDAF support DP shufflers?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/9",
      "state": "CLOSED",
      "author": "csharrison",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "idea"
      ],
      "body": "Shuffle differential privacy (https://arxiv.org/pdf/1811.12469.pdf and many other papers) is a type of differential privacy where the privacy mechanism can be thought of as a composition of two pieces:\r\n1. A local randomizer applying some local noise to data (and stripping identifiers, etc)\r\n2. A central curator that takes as input a batch of client data and simply applies a permutation on it\r\n\r\nThe power of the shuffle DP is that the server-side mechanism is _simple_ and _general purpose_. The exact same shuffler can be used for different applications measuring different kinds of things. Privacy guarantees are based on two things:\r\n\r\n1. The level of local noise added to the data\r\n2. The number of clients that participate in a shuffle\r\n\r\nAt an intuitive level, the more reports you have, and the more noise is injected into the reports, the more a given client's input is \"hidden in the crowd\".\r\n\r\nIs this a good fit for VDAFs? Shuffling is conceptually a very simple task to ask a 2-party MPC protocol to do. I could imagine slotting this into the VDAF structure like:\r\n\r\n- Clients split their local data D into \"shares\" where Helper 1 gets Enc2(D) and Helper 2 gets Enc1(null). (Which helper gets the real message can be randomized). Note that nested encryption is used so that no helper can see any raw data before it is shuffled.\r\n- When each helper gets its batch of data, it will run it through a shuffle step, and send the shuffle results to the other helper\r\n- After the exchange, the helpers shuffle the exchanged batches one more time (ensuring all data is shuffled twice, once by each helper).\r\n- Helpers can then decrypt the data and share each shuffled batch to the collector\r\n\r\nPossible concerns:\r\n\r\n- In the simple example above, helpers learn a shuffled version of the true data (i.e. a DP release). The protocol is not zero-knowledge. This could probably be fixed, there is no need for helpers to learn any raw data.\r\n- We rely exclusively on DP for the protection. Whether this can be called \"aggregation\" is maybe subject for debate. Certainly you can say that (if the batches are large enough, with enough noise), that no individual's data can be learned\r\n- The splitting of shares and helpers independently shuffling partial batches is a bit awkward. Probably the ideal mechanism would be for clients to send all data to Helper 1, which shuffles and sends to Helper 2, which sends data to the collector. Parallel shuffling buys us nothing.\r\n- Some shuffle protocols may want some kind of \"label\" in the clear, with minimum batch sizes per label.\r\n\r\nAnyways, thoughts appreciated! Shuffling can be a simple and effective way to achieve good privacy with very simple mechanisms, but it doesn't fit so well into VDAFs.\r\n\r\ncc @schoppmp ",
      "createdAt": "2021-11-11T21:24:52Z",
      "updatedAt": "2024-06-10T16:17:00Z",
      "closedAt": "2023-03-02T17:39:23Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Interesting idea! This does indeed sound like a practical way to get good privacy. Even without DP, you get unlinkability of measurements to the client that sent them. This is basically what a mixnet does.\r\n\r\n* From a syntax perspective, this kind of construction doesn't fit because it requires the aggregation phase to be interactive. Currently the VDAF syntax permits interaction only during the preparation phase. More to the point, shuffling requires `O(n)` space to compute the aggregate result, where `n` is the number of measurements. On the other hand, evaluating the prio3 or hits VDAF requires just `O(1)` space.\r\n* From a security perspective, unlinkability of measurements to senders is useful, but is weaker than what we hope to achieve for, say, prio3 or hits, which is that they learn only the aggregate result. Perhaps there's a way to patch the scheme to prevent leaking the set of measurements, as you suggest. But suppose we manage to ensure that all the aggregators learn is the aggregate result: then what does shuffling buy us?\r\n* Broadening our perspective a bit, consider that VDAFs are *special purpose*  in the sense that a particular VDAF is only suitable for as particular (class of) aggregation functions. On the other hand, the shuffling scheme you're proposing is *general purpose*: pretty much any aggregation function can be computed this way, you just need to be able to define a \"null\" input. I think the purpose of this document should be to standardize an interface between general purpose \"wrapper\" protocols, like PPM, to special purpose schemes that are all ensure some baseline notion of security.\r\n\r\nMy own conclusion is that this protocol shape isn't appropriate for the VDAF document, however this may well be in-scope for what the PPM working group does.\r\n\r\nWhat do you think @bifurcation?",
          "createdAt": "2021-11-15T17:55:34Z",
          "updatedAt": "2021-11-15T17:55:34Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "By the way, I'm reading https://eprint.iacr.org/2021/1490.pdf right now. This protocol seems to have some shuffling, but also seems to aim for a security property stronger than unlinkability. I think if we can achieve the same security for this protocol as for prio3/hits, I think it's worth considering including it here.",
          "createdAt": "2021-11-15T19:42:22Z",
          "updatedAt": "2021-11-15T19:42:22Z"
        },
        {
          "author": "csharrison",
          "authorAssociation": "NONE",
          "body": "Thanks @cjpatton , this makes sense to me. A few quick responses below:\r\n\r\n> From a security perspective, unlinkability of measurements to senders is useful, but is weaker than what we hope to achieve for, say, prio3 or hits, which is that they learn only the aggregate result. Perhaps there's a way to patch the scheme to prevent leaking the set of measurements, as you suggest. But suppose we manage to ensure that all the aggregators learn is the aggregate result: then what does shuffling buy us?\r\n\r\nOne thing shuffling buys you is flexibility. Let's say all my users input data in [0, 10]. You could imagine a couple of different ways of aggregating this data, e.g. reporting the sum, median, percentiles, etc. With a shuffled version of the data, you can compute all of these on the collector side without embedding the computations in the aggregators.\r\n\r\nThere is also flexibility in terms of data used. In principle (as long as you trust the clients), the aggregators can just be shuffling opaque bytes. Clients could update to submit different kinds of data without any behavior update needed on the aggregator side. For instance, rather than shuffling integers they could shuffle sketches or some other data structure.\r\n\r\n> By the way, I'm reading https://eprint.iacr.org/2021/1490.pdf right now. This protocol seems to have some shuffling, but also seems to aim for a security property stronger than unlinkability. I think if we can achieve the same security for this protocol as for prio3/hits, I think it's worth considering including it here.\r\n\r\nThis proposal is interesting but it isn't the same kind of general purpose shuffling I'm discussing here. That paper only discusses computing histograms.",
          "createdAt": "2021-11-15T20:27:02Z",
          "updatedAt": "2021-11-15T20:27:02Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree the flexibility is attractive. My point about shuffling alone doesn't prevent aggregators from learning the set of measurements. Indeed, this is what makes it so flexible!",
          "createdAt": "2021-11-15T21:30:45Z",
          "updatedAt": "2021-11-15T21:30:45Z"
        },
        {
          "author": "csharrison",
          "authorAssociation": "NONE",
          "body": "> I agree the flexibility is attractive. My point about shuffling alone doesn't prevent aggregators from learning the set of measurements. Indeed, this is what makes it so flexible!\r\n\r\nOh sorry I missed this point. It should be easy to ensure that the shuffled data is not visible to the aggregators if they don't collude with the collector - just ensure all the data is also encrypted to the collector's key. The requirement is just that the MPC shuffles opaque blobs.",
          "createdAt": "2021-11-15T21:58:47Z",
          "updatedAt": "2021-11-15T21:58:47Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, but the collector would see the set of measurements in the clear, right? All the aggregators have done is permuted them.",
          "createdAt": "2021-11-15T22:18:58Z",
          "updatedAt": "2021-11-15T22:18:58Z"
        },
        {
          "author": "csharrison",
          "authorAssociation": "NONE",
          "body": "The collector sees the set of measurements \"in the clear\", but the technique is designed to be combined with local noise so it isn't really accurate to say that the final release contains the all of the original measurements.\r\n\r\n",
          "createdAt": "2021-11-16T18:29:12Z",
          "updatedAt": "2021-11-16T18:29:12Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, true enough!",
          "createdAt": "2021-11-16T18:36:01Z",
          "updatedAt": "2021-11-16T18:36:01Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "We are beginning to see the emergence of MPC techniques that involve some sort of in-MPC \"shuffling\" or \"ordering\" of the reports being aggregated. Example:\r\n* IPA: https://github.com/private-attribution/ipa\r\n* @schoppmp's shuffling protocol for sparse histograms: https://eprint.iacr.org/2022/920\r\n\r\nI think where we're landing is that this architecture is sufficiently different from VDAFs that we should not try to shoe-horn them into this particular document.",
          "createdAt": "2023-03-02T17:39:23Z",
          "updatedAt": "2023-03-02T17:39:23Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOGKuqOc4-1Uh5",
      "title": "Is Masked LARk a (V)DAF?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/10",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "idea"
      ],
      "body": "[This paper](https://arxiv.org/pdf/2110.14794.pdf) describes a distributed computation of a gradient descent. We're given a set of `(x[i], y[i])` pairs, where `x[i]` is client `i`'s *feature* and `y[i]` is the corresponding *label*. From skimming the paper, my understanding is that stochastic gradient descent is computed iteratively as\r\n```\r\n\\theta_{j+1} = \\theta_j - \\eta * (f(x[1], y[1], \\theta_j) + ... + f(x[n], y[n], \\theta_j))\r\n```\r\nuntil we find a (locally) optimal model `\\theta_j`.  for a particular function `f`. (`\\eta` is a constant called the \"learning rate\".) What the paper shows is that each iteration can be computed by two aggregators who hold the plaintext features `x[1], ..., x[n]`, but only secret shares of the labels `y[1], ..., y[n]`. The features are kept privacy by adding DP.\r\n\r\nThis looks an awful lot like a distributed aggregation function:\r\n* measurement is a feature and label\r\n* aggregation parameter is the model `\\theta_j` from the previous step.\r\n* aggregate result is the model `\\theta_{j+1}` for the next step.\r\n\r\nAnd yet there are two important differences:\r\n1. The label is secret shared, but the feature is not. We can certainly formalize security in the usual way --- the aggregators learn nothing about the measurements beyond what they can deduce from their view of the protocol. But this definition isn't all that meaningful if the feature leaks a lot of information about the label.\r\n2. The output isn't verifiable. In particular, the current protocol appears to allow a client to submit bogus input shares and garble the output without being detected.\r\n\r\nAdding verifiability (i.e., solving (2)) seems quite feasible. I'm not sure how best to address (1). It might be worth reaching out to the papers' authors to see if they considered how they might keep the features secret.\r\n\r\n@csharrison I'm curious if you have thoughts here.",
      "createdAt": "2021-11-15T22:17:30Z",
      "updatedAt": "2023-08-17T01:34:56Z",
      "closedAt": "2023-08-17T01:34:56Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Another reference to drop here: https://eprint.iacr.org/2018/442.pdf",
          "createdAt": "2022-04-06T20:34:51Z",
          "updatedAt": "2022-04-06T20:34:51Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "One answer to this question is that Prio3 can be used to do an L2-norm check, which is something that's needed for federated learning: https://docs.rs/prio/latest/prio/vdaf/prio3/type.Prio3FixedPointBoundedL2VecSum.html\r\n\r\nI think the question I was more after is whether this \"apply model to measurement\" step can be modeled as (and instantiated with) functional secret sharing.",
          "createdAt": "2023-08-17T01:29:33Z",
          "updatedAt": "2023-08-17T01:29:33Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOGKuqOc4-5xna",
      "title": "Syntax: Public preprocessing during the preparation phase",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/11",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For both prio3 and hits, each round of the preparation phase consists of a step of \"preprocessing\" of the previous round's messages. This preprocessing step is identical for all of the aggregators. In hits, for example, each aggregator begins each round by summing up the messages from the previous round. From Figure 15 in https://cjpatton.github.io/vdaf/draft-patton-cfrg-vdaf.html#name-preparation-3:\r\n```\r\n    ...\r\n    elif self.step == \"sketch round 1\" and len(inbound) == 2:\r\n      verifier_1 = Field[l].deocde_vec(inbound[0]) + \\             # ADD UP INPUT MESSAGES\r\n                   Field[l].deocde_vec(inbound[1])\r\n\r\n      verifier_share_2 = [\r\n        (verifier_1[0] * verifier_1[0] \\\r\n         - verifier_1[1] \\\r\n         - verifier_1[2]) * self.party_id \\\r\n        + A_share * verifer_1[0] \\\r\n        + B_share\r\n      ]\r\n\r\n      self.step = \"sketch round 2\"\r\n      return Field[l].encode_vec(verifier_share_2)\r\n\r\n    elif self.step == \"sketch round 2\" and len(inbound) == 2:\r\n      verifier_2 = Field[l].decode_vec(inbound[0]) + \\             # ADD UP INPUT MESSAGES\r\n                   Field[l].decode_vec(inbound[1])\r\n\r\n      if verifier_2 != 0: raise ERR_INVALID\r\n      return Field[l].encode_vec(self.output_share)\r\n   ...\r\n```\r\nThe essence of what's happening here is that, in each round, the aggregators are exchanging additive shares of a single message. prio3 is similar, although each message consists of an XOR-share of as byte string and an additive share of the FLP verifier. From Figure 10:\r\n```\r\n   ...\r\n   elif self.step == \"waiting\" and len(inbound) == SHARES:\r\n      k_joint_rand = zeros(KEY_SIZE)\r\n      verifier = vec_zeros(VERIFIER_LEN)\r\n      for r_share in inbound:\r\n        (k_joint_rand_share,\r\n         verifier_share) = decode_verifier_share(r_share)\r\n\r\n        k_joint_rand ^= k_joint_rand_share                           # ADD UP xor SHARES\r\n        verifer += verifier_share                                    # ADD UP ADDITIVE SHARES\r\n\r\n      if k_joint_rand != self.k_joint_rand: raise ERR_INVALID\r\n      if not flp_decide(verifier): raise ERR_INVALID\r\n      return Field.encode_vec(self.output_share)\r\n   ...\r\n```\r\nWhat we're likely to do in the PPM protocol is have one aggregator -- the Leader -- collect the verifier messages at each round and relay them to the other aggregators. We could save on communication cost if we have the Leader perform this public preprocessing step itself and disseminate the result.\r\n\r\nTo make this optimization generic, I'd like to propose that we lift the public processing step to an explicit part of the syntax. In particular, we'd change the preparation phase as follows (from Figure 6):\r\n```\r\n   # Each aggregator initializes its preparation state.\r\n    prep_states = []\r\n    for j in range(SHARES):\r\n      prep_states.append(PrepState(\r\n          verify_params[j], agg_param, nonce, input_shares[j]))\r\n\r\n    # Aggregators recover their output shares.\r\n-   inbound = []\r\n+   inbound = \"\"\r\n    for i in range(ROUNDS+1):\r\n      outbound = []\r\n      for j in range(SHARES):\r\n        outbound.append(prep_states[j].next(inbound))\r\n      # This is where we would send messages over the network\r\n      # in a distributed VDAF computation.\r\n-     inbound = outbound\r\n+     inbound = prep_preprocess(j, outbound)\r\n\r\n    # The final outputs of validation are the output shares\r\n    # for this input.\r\n    output_shares.append(outbound)\r\n```\r\n\r\nI don't think this syntactic change would decrease generality, but I also don't want it to be a nuisance. Maybe it makes sense to not call this out explicitly?",
      "createdAt": "2021-11-16T21:12:25Z",
      "updatedAt": "2022-01-19T17:44:43Z",
      "closedAt": "2022-01-19T17:44:43Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I actually think this could *increase* generality, since we're adding a stage that transforms outbound shares to some inbound parameter.  In the current framing, that stage has to be the identity transformation, such that the inbound parameter is the set of outbound shares.\r\n\r\nThe only real trouble I see here is that we don't currently have a name for the actor who would perform this transformation.  And just to confirm -- is this actor really untrusted in the examples we have today?  Or are they trusted in some limited way?",
          "createdAt": "2021-11-17T16:03:32Z",
          "updatedAt": "2021-11-17T16:03:32Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Who performs this transform will depend on how the VDAF is mapped to a protocol. It ought to be the case that *anyone* can perform this transform without impacting privacy. (We'll need to make this clear in security considerations.)",
          "createdAt": "2021-11-17T17:09:01Z",
          "updatedAt": "2021-11-17T17:09:01Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">What we're likely to do in the PPM protocol is have one aggregator -- the Leader -- collect the verifier messages at each round and relay them to the other aggregators. We could save on communication cost if we have the Leader perform this public preprocessing step itself and disseminate the result.\r\n\r\nI think this is a good optimization but IIUC it requires that the PPM leader be able to see all the verifier messages (i.e., Prio proof shares) in the clear, which isn't currently possible because the helper's proof share is inside the HPKE encrypted envelope. So does this change require corresponding PPM changes to move verifier shares out of the encryption envelope, or am I misunderstanding?",
          "createdAt": "2022-01-04T22:38:55Z",
          "updatedAt": "2022-01-04T22:38:55Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "What is being preprocessed is the set of messages passed between the Aggregators, which is not the proof shares. The proof shares are sent by the Clients to the Aggregators. If the Aggregators were to exchanges the proof shares themselves, this would result in a security violation.",
          "createdAt": "2022-01-04T23:06:11Z",
          "updatedAt": "2022-01-04T23:06:11Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The important thing is that this only reduces the complexity of communication if there are more than two aggregators, which is not currently the case in PPM. It's nevertheless a good change.",
          "createdAt": "2022-01-05T01:47:38Z",
          "updatedAt": "2022-01-05T01:47:38Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOGKuqOc4-98yb",
      "title": "VDAF for quantiles?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/12",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial",
        "security consideration",
        "draft-09"
      ],
      "body": "With `prio3` it's straightforward to roughly estimate quantiles using a histogram (cf https://docs.rs/prio/0.6.1/prio/vdaf/prio3/type.Prio3Histogram64.html). But what if you wanted to precisely compute, say, the 50th percentile (i.e., the median) or the 95th percentile? Prio isn't well-suited for this (cf [[CGB17], Appendix G]).\r\n\r\nIf your application allows for multiple rounds of interaction with the clients, maybe you could do a kind of binary search to find the quantile you're after. Suppose the client measurements are arbitrary 32-bit integers and you want to compute the median. Suppose there are `N` measurements in all. Let `buckets = [2^31]`. Have the clients shard their measurements using `buckets` as the bucket boundaries. Execute the VDAF over the set of input shares, getting bucket counts `agg` as the aggregate result. `agg[0]` is equal to the number of measurements less than or equal to `2^31`, and `agg[1] <= N/2`, then the median must be less than `2^31`. On the other hand, if `agg[1] > N/2` then you know the median must greater than `2^31`. You then repeat the process, adjusting the bucket boundaries based on the previous result: if the median is less than `2^31`, then let `buckets = [2^31 - 2^30]`; otherwise let `buckets = [2^31 + 2^30]`.\r\n\r\nI'm not sure how many iterations would be needed, or how precisely you could compute quantiles this way. Regardless, ideally there would be a VDAF that allows for computing quantiles without interacting with clients more than once.\r\n\r\n\r\n\r\n\r\n\r\n[CGB17]: https://crypto.stanford.edu/prio/paper.pdf",
      "createdAt": "2021-11-17T17:58:28Z",
      "updatedAt": "2024-05-07T14:05:53Z",
      "closedAt": "2024-05-07T14:05:53Z",
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "In addition to histograms, Prio3 could be used to estimate quantiles by constructing a CountMin sketch. (See section 5.1 here https://dsf.berkeley.edu/cs286/papers/countmin-latin2004.pdf) I think this would also require some tuning based on expected measurement ranges and precision. The underlying FLP validity condition would be equivalent to running multiple independent histograms.\r\n\r\nPoplar1 could be used to exactly compute quantiles, at a higher computational cost. Assuming the measurements are already integers, you could directly shard the measurements with Poplar1, and then run the Poplar1 aggregation process several times with a new tree-walking algorithm to arrive at the quantile. This algorithm would do a binary search to find the tree node where the number of measurements to the left, divided by the total number of measurements, is the closest to the target quantile level.",
          "createdAt": "2022-07-11T22:24:52Z",
          "updatedAt": "2022-07-11T22:24:52Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Hey @divergentdave, what do you think about resolving this issue by describing how to use Poplar1 for quantilies in the draft? ",
          "createdAt": "2023-03-02T17:31:29Z",
          "updatedAt": "2023-03-02T17:31:29Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, that sounds good. We could lay out how to use Poplar1 for each of chosen prefixes, heavy hitters, and quantiles.",
          "createdAt": "2023-03-02T17:36:55Z",
          "updatedAt": "2023-03-02T17:36:55Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Great. I'll label this \"editorial\" and assign it to you. Take your time ... we don't need needs this for 05.",
          "createdAt": "2023-03-02T17:40:48Z",
          "updatedAt": "2023-03-02T17:40:48Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Thinking about this some more, the algorithm described above would go against what I wrote in #273, because it would rely on prefix counts from inner tree nodes, and never check some of them all the way down to the leaf node. This would leave us with significantly worse robustness bounds for this application.\r\n\r\nHere's an example of what the quantile algorithm would query and receive as it traverses a small tree, looking for the median.\r\n\r\n```mermaid\r\ngraph\r\nroot[root\\ncount: 187]\r\nroot --> 0 & 1\r\n0[0\\ncount: 115]\r\n1[1\\ncount: 72]\r\n0 --> 00 & 01\r\n1 --> 10 & 11\r\n00[00\\ncount: 50]\r\n01[01\\ncount: 65]\r\n00 --> 000 & 001\r\n01 --> 010 & 011\r\n10 --> 100 & 101\r\n11 --> 110 & 111\r\n010[010\\ncount: 39]\r\n011[011\\ncount: 26\\nMedian]\r\n```\r\n\r\nTo sharpen my description of the algorithm above, we know this is the median measurement because the count of all measurements less than or equal to 0b011 is greater than 50% of the total, and the count of all measurements greater than or equal to 0b011 is greater than 100% - 50% = 50% of the total. We get 50 + 39 + 26 > 187 / 2, and 26 + 72 > 187 / 2.\r\n\r\nIn this example, we only evaluated two nodes at the leaf level of the tree. Unlike with the heavy hitters algorithm, prefix counts from inner nodes do get used in determining the final quantile result -- an attack on extractability with the smaller field elements could do worse than merely trick us into adding more candidate prefixes to explore. With heavy hitters, the leaf level offers a chance to identify and reject dishonestly generated reports. For sufficiently high precision integer measurements, it would be impractical to evaluate every possible measurement at the leaf level of the tree.\r\n\r\nWith all that said, the quantile tree walking algorithm could work well with Mastic, since the concrete security of the robustness property doesn't depend so drastically on the tree level. Perhaps we should just write up the \"heavy hitters\" and \"chosen prefixes\" modes of operation in this draft for now, and leave it at that.",
          "createdAt": "2023-12-12T23:19:57Z",
          "updatedAt": "2023-12-12T23:19:57Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the analysis here, @divergentdave. This issue is no longer purely editorial, since resolving it probably requires a warning for Popplar1. On the other hand, it seems like we should be able to use Mastic for this use case without running into the same extractability issue (https://github.com/jimouris/draft-mouris-cfrg-mastic/issues/53).",
          "createdAt": "2024-01-25T17:51:21Z",
          "updatedAt": "2024-01-25T17:51:21Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOGKuqOc4_1qX5",
      "title": "Specify method for generating field elements (was \"Proposal: use hash to field to generate field elements from a seed\")",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/13",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "> TODO This functionality closely resembles what people usually think of as an extract-then-expand KDF, but differs somewhat in its syntax and, also, its required security properties. Can we get the same functionality from something that's more commonplace? HKDF doesn't fit the bill, unfortunately, because keys can only be expanded to a fairly short length. Our application requires a rather long key stream.\r\n\r\nand\r\n>    *  Field.rand_vec(len: Unsigned) -> output: Vec[Field] returns a\r\n      vector of random field elements.  The length of output MUST be\r\n      len.\r\n>\r\n>         NOTE In reality this would be achieved by generating a random\r\n         key and expanding it into a sequence of field elements using a\r\n         key derivation scheme.  This should probably be made explicit.\r\n\r\n\r\nIn hash to curve draft, there is a method to derive an arbitrary number of field elements from a seed source.\r\nThis is called a Expander, and there are two types: one based on Merkle-Damgard functions and the other based on eXtendable Output functions.\r\nSee section 5.3 : https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve#section-5.3\r\n\r\n",
      "createdAt": "2021-12-03T22:53:51Z",
      "updatedAt": "2022-02-25T19:42:16Z",
      "closedAt": "2022-02-25T19:42:16Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I definitely like the idea of reusing a functionality from an existing draft.",
          "createdAt": "2021-12-04T00:02:20Z",
          "updatedAt": "2021-12-04T00:02:20Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Update based on discussion I had with @armfazh offline: We currently use rejection sampling for mapping bit strings to field elements. This has the advantage of inducing no bias, but it has the distinct disadvantage of making the runtime very slow for some fraction of the time. We hope that a constant-time algorithm will have better worst-case, or even average-case, performance. @armfazh is working on a performance evaluation.\r\n\r\nhash-to-field is quite simple: just take a hash function `H: \\bits^* \\to \\bits^n`, interpret the output as a `2^n`-bit integer, and reduce the integer mod `p`. The question is how much bias this modular reduction induces.\r\n\r\nOr more precisely: What's the statistical distance between a random variable chosen uniformly from `[0, p)` and a random variable chosen by sampling `[0, 2^n)` for some `2^n > p` and reducing the sampled number mod `p`? Intuitively, this depends on how large is `b = 2^n % p`: the smaller the `b`, the fewer outputs there are due to the modular reduction. In fact, it's not hard to show that the statistical distance can be bounded, fairly tightly, by `O(2^(log2(p) - n)`. This suggests that for `n \\approx 2*log(p)` the statistical distance is about `O(1/2^log(p))`.\r\n\r\nWhat does this mean for security? In our analysis of prio3 it'll be helpful to model the function that maps a seed to a sequence of field elements as a random oracle. Our hope would be that hash-to-field is indifferentiable from such an RO when the underlying hash function `H` is modeled as an RO. This ought to be the case for sufficiently large `n`.\r\n\r\nWe also observed that there are primes `p` for which there is an optimal `n`. For example, libprio uses `p = 18446744069414584321` for its 64-bit prime. It turns out that `2^192 % p == 1`, so picking `n=192` would make the distributions very close indeed. Ideally we could find a 128-bit prime with this property, too.",
          "createdAt": "2022-02-02T00:28:54Z",
          "updatedAt": "2022-02-02T00:28:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@schoppmp made an excellent point, which we ought to take into account: hash_to_field appears to be designed for entropy extraction. (@armfazh can you confirm?). However for our application we don't need an entropy extractor because we're starting with a (pseuo)random seed. Thus using SHA-2 or SHAKE for instantiating hash_to_field would be overkill: AES in CTR-mode would suite our needs perfectly fine.",
          "createdAt": "2022-02-03T18:43:38Z",
          "updatedAt": "2022-02-03T18:43:38Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Certainly, any SHA or SHAKE will be slower than AES (provided machine has hardware support for it). \r\nHash to field just receives seeds as input, and is not used for key expansion.",
          "createdAt": "2022-02-03T21:36:38Z",
          "updatedAt": "2022-02-03T21:36:38Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, and given how much randomness we consume in our applications, I think it would be worthwhile providing a mapping a seed-to-field-vector expansion function that is based purely on AES. I'll put together a PR with a proposal.",
          "createdAt": "2022-02-04T17:05:54Z",
          "updatedAt": "2022-02-04T17:05:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Ok, before sending a PR, I want to get y'all's take on the over all shape of the solution. Here's my proposal:\r\n1. Add a parameter `EXPANDED_SIZE` to `Field` that specifies the number of random bytes that are sampled per field element.\r\n2. Adopt a modified version of `hash_to_field` in which we replace `expand_message` with the key stream output by AES-CTR (or some other, compatible primitive).\r\n\r\nThis could look something like this (quoting from https://github.com/cjpatton/vdaf/pull/24):\r\n```python\r\n# The base class for PRGs.\r\nclass Prg:\r\n    # Size of the seed.\r\n    SEED_SIZE: int\r\n\r\n    # Derive a fresh seed from an existing `seed`. The `info` input is used for\r\n    # domain sepration.\r\n    @classmethod\r\n    def derive(cls, seed: bytes, info: bytes) -> bytes:\r\n        raise Error(\"not implemented\")\r\n\r\n    # Expand the input `seed` into the number of bytes requested.\r\n    @classmethod\r\n    def expand(cls, seed: bytes, length: int) -> bytes:\r\n        raise Error(\"not implemented\")\r\n\r\n    # Expand the input `seed` into vector of `length` field elements. This\r\n    # algorithm is based on \"hash_to_field\" in draft-irtf-cfrg-hash-to-curve13.\r\n    @classmethod\r\n    def expand_into_vec(cls, Field, seed: bytes, length: int):\r\n        L = Field.EXPANDED_SIZE\r\n        len_in_bytes = length * L\r\n        uniform_bytes = cls.expand(seed, len_in_bytes)\r\n\r\n        vec = []\r\n        for i in range(length):\r\n            tv = uniform_bytes[L*i:L*(i+1)]\r\n            u_i = OS2IP(tv) # Decode `tv` into an integer.\r\n            vec.append(Field(u_i))\r\n        return vec\r\n```\r\n\r\n@schoppmp what do you think of this proposal? Of course, we wouldn't literally plop down this Python into the spec :) A concrete PRG would implement `derive` and `expand`. For example:\r\n\r\n```python\r\n# A pseudorandom generator based on AES128. CMAC {{!RFC4493}} is used for seed\r\n# derivation and CTR mode is used for seed expansion.\r\nclass PrgAes128(Prg):\r\n    # Associated parameters\r\n    SEED_SIZE = 16\r\n\r\n    @classmethod\r\n    def derive(cls, seed, info) -> bytes:\r\n        hasher = CMAC.new(seed, ciphermod=AES)\r\n        return hasher.update(info).digest()\r\n\r\n    @classmethod\r\n    def expand(cls, seed, length):\r\n        counter = Counter.new(128, initial_value=bytes_to_long(zeros(16)))\r\n        cipher = AES.new(seed, AES.MODE_CTR, counter=counter)\r\n        # CTR-mode encryption of the all-zero string of the specified length and using\r\n        # the all-zero block as the IV.\r\n        cipher_stream = cipher.encrypt(zeros(length))\r\n        return cipher_stream\r\n```\r\n\r\nCMAC is a somewhat unconventional choice. A more conventional choice might be HMAC-SHA256, however in that case we might want to increase `SEED_SIZE` to `32`.",
          "createdAt": "2022-02-06T01:36:45Z",
          "updatedAt": "2022-02-06T01:57:22Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "PR #25 addresses the issue raised here. I ended up going in a slightly different direction with the API:\r\n```python\r\nclass Prg:\r\n    # Size of the seed.\r\n    SEED_SIZE: int\r\n\r\n    # Number of bytes sampled per pseudorandom field element.\r\n    EXPANDED_SIZE: int\r\n\r\n    # Expand the input `seed` into the number of bytes requested.\r\n    @classmethod\r\n    def expand(cls, seed: bytes, info: bytes, length: int) -> bytes:\r\n        raise Error(\"not implemented\")\r\n\r\n    # Derive a fresh seed from an existing one.\r\n    @classmethod\r\n    def derive(cls, seed: bytes, info: bytes) -> bytes:\r\n        return cls.expand(seed, info, cls.SEED_SIZE)\r\n\r\n    # Expand the input `seed` into vector of `length` field elements. This\r\n    # algorithm is based on \"hash_to_field\" in draft-irtf-cfrg-hash-to-curve13.\r\n    @classmethod\r\n    def expand_into_vec(cls, Field, seed: bytes, info: bytes, length: int):\r\n        L = Field.EXPANDED_SIZE\r\n        len_in_bytes = length * L\r\n        uniform_bytes = cls.expand(seed, info, len_in_bytes)\r\n\r\n        vec = []\r\n        for i in range(0, len(uniform_bytes), L):\r\n            tv = uniform_bytes[i:i+L]\r\n            x = OS2IP(tv)\r\n            vec.append(Field(x))\r\n        return vec\r\n```",
          "createdAt": "2022-02-08T01:21:33Z",
          "updatedAt": "2022-02-08T01:24:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "> @schoppmp made an excellent point, which we ought to take into account: hash_to_field appears to be designed for entropy extraction.\r\n\r\nFWIW, I don't think this is correct. ",
          "createdAt": "2022-02-08T13:54:36Z",
          "updatedAt": "2022-02-08T13:54:36Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton I don't think this approach works directly as you describe it. The reason is that if the field modulus p is small-ish (e.g., 32 bits), then just taking 32 uniform bits and reducing them mod p will result in something far from uniform. This is what hash_to_curve fixes by increasing L by the security parameter k. \r\n\r\nMy point was twofold: \r\n1. If we want to sample n prime field elements from a single seed, we don't need log(p) + k uniform bits for *every* element we sample, but something more on the order of log(p) * n + k + log(n) for *all* n samples. (Edit: Fixed the formula)\r\n2. If our seed is uniform, then using AES (either in counter mode or as a [hash function](https://eprint.iacr.org/2019/074.pdf)) might be cheaper than SHA(KE).\r\n\r\n@chris-wood Could you elaborate with which part you disagree?",
          "createdAt": "2022-02-08T17:13:43Z",
          "updatedAt": "2022-02-08T17:26:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "> @chris-wood Could you elaborate with which part you disagree?\r\n\r\nWith one exception, I don't disagree with anything you wrote in that comment. I was merely responding to the \"entropy extraction\" point, which is not an explicit goal of hash-to-field.\r\n\r\n> If our seed is uniform, then using AES (either in counter mode or as a [hash function](https://eprint.iacr.org/2019/074.pdf)) might be cheaper than SHA(KE).\r\n\r\nI may be misunderstanding you, but this seems like a non sequitur since `expand_message` will work for any input, regardless of its distribution. In any case, I think it's reasonable to require the seed to be uniformly distributed. And using a stream cipher instead of hash-based `expand_message` certainly seems like an improvement. (In fact, we should consider adding such variant to the hash-to-curve draft!)",
          "createdAt": "2022-02-08T17:18:44Z",
          "updatedAt": "2022-02-08T17:18:44Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> @schoppmp     1. If we want to sample n prime field elements from a single seed, we don't need log(p) + k uniform bits for _every_ element \r\nwe sample, but something more on the order of log(p) + n * k + log(n) for _all_ n samples.\r\n\r\nDo you mean `(log(p) + n) * k + log(n)` or `log(p) + (n * k) + log(n)`?\r\n",
          "createdAt": "2022-02-08T17:23:14Z",
          "updatedAt": "2022-02-08T17:23:14Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> I may be misunderstanding you, but this seems like a non sequitur since expand_message will work for any input, regardless of its distribution.\r\n\r\nIf we want pseudorandom outputs, then the seed needs to be be pseudorandom as well, or, alternatively, have high entropy so we can use a hash function (e.g. SHA) to reduce it to a uniform pseudorandom seed. I think the second part is what @cjpatton meant by entropy extraction.\r\n\r\n> Do you mean (log(p) + n) * k + log(n) or log(p) + (n * k) + log(n)?\r\n\r\nI actually meant `(log(p) * n) + k + log(n)` :smile: . I'll fix the comment above.\r\n",
          "createdAt": "2022-02-08T17:25:09Z",
          "updatedAt": "2022-02-08T17:25:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "@schoppmp right -- it doesn't extract entropy. Garbage in means garbage out. =) In any case, I think we're aligned now.",
          "createdAt": "2022-02-08T17:27:20Z",
          "updatedAt": "2022-02-08T17:27:20Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@schoppmp Very interesting. Would you mind writing down the algorithm for mapping a `(log(p) * n) + k + log(n)` bits to `n` field elements? I'm curious how the extra `k + log(n)` bits are used. (You can also refer me to the IDPF code base.)",
          "createdAt": "2022-02-08T17:34:41Z",
          "updatedAt": "2022-02-08T17:34:41Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, you can have a look [here](https://github.com/google/distributed_point_functions/blob/master/dpf/int_mod_n.h#L155). Note that the current implementation only works on 128-bit blocks, which limits the maximum `k` supported.",
          "createdAt": "2022-02-08T17:56:06Z",
          "updatedAt": "2022-02-08T17:56:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Alright, this is super neat. Me and @armfazh are going to work on benchmarking (in libprio) rejection sampling vs pad-then-reduce (a la hash_to_field) vs @schoppmp's algorithm. We should have this done today. \r\n\r\nIn the meantime, @schoppmp: Would you mind working on an alternative PR to #25 that specifies your algorithm?\r\n\r\nEDIT: By the way, I think it would make sense to fix the same \"security parameter\" (say, 64) for all fields, and possibly exclude fields that are too small for this sampling method to be statistically close to uniform (e.g., less than 64 bits). See also #22.",
          "createdAt": "2022-02-08T18:20:25Z",
          "updatedAt": "2022-02-08T18:52:12Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I've implemented both approaches PRs (linked to this issue).",
          "createdAt": "2022-02-14T21:40:23Z",
          "updatedAt": "2022-02-14T21:40:23Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A comparison of three methods can be found at: https://github.com/abetterinternet/libprio-rs/compare/main...armfazh:prg/bench?expand=1\r\n\r\n|Method|N=10|N=100|N=1000|\r\n|:---|---:|---:|---:|\r\n| Rejection Sampling | 5.2 |  7.8 |  38.1 |\r\n| Pad-and-reduce     | 4.8 | 15.1 | 115.8 |\r\n| Borrow-and-reduce  | 4.5 | 12.7 |  83.7 |\r\n\r\n\\* Timings are \u00b5s measured in Core i7-8650U CPU @ 1.90GHz.\r\n\r\n\r\n",
          "createdAt": "2022-02-23T17:45:37Z",
          "updatedAt": "2022-02-23T17:45:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @armfazh. Based on this assessment, I think that we should specify rejection sampling. @schoppmp do you object?\r\n",
          "createdAt": "2022-02-24T01:01:02Z",
          "updatedAt": "2022-02-24T01:01:02Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "An issue with rejection sampling is that it's hard to do with a constant-time implementation, which was also observed in the [hash-to-curve](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve#section-5) draft. Is your implementation returning early after the required number of finite field elements have been sampled? Or is it always sampling enough times to ensure the probability of rejecting too many samples is small enough (wrt. the security parameter)?",
          "createdAt": "2022-02-24T12:19:16Z",
          "updatedAt": "2022-02-24T12:19:29Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "libprio-rs currently generates samples until it reaches the number of field elements requested. This means the runtime is not bounded (in particular it's *definitely* not constant time!): \ufeffhttps://github.com/abetterinternet/libprio-rs/blob/main/src/prng.rs#L56-L82\r\n\r\nIncidentally, @armfazh noted that the current IDPF implementation is also not constant time, due to the division by the modulus here: https://github.com/abetterinternet/libprio-rs/blob/main/src/prng.rs#L56-L82. Though this should be easy enough to fix.\r\n\r\nTaking a step back, do we actually care if the algorithm that computes the mapping from pseudorandom byte strings to field elements is constant time? Take rejection sampling, for instance: assuming the underlying PRG is constant-time (i.e., AES-CTR is implemented in constant time) It seems to me that all that can be leaked by a non-constant-time implementation is the value of the bits that are rejected.",
          "createdAt": "2022-02-24T16:11:48Z",
          "updatedAt": "2022-02-24T16:11:48Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> Incidentally, @armfazh noted that the current IDPF implementation is also not constant time, due to the division by the modulus here: https://github.com/abetterinternet/libprio-rs/blob/main/src/prng.rs#L56-L82. Though this should be easy enough to fix.\r\n\r\nNot sure what you mean, the link goes to libprio-rs. AFAICT all branches in the [DPF sampling function](https://github.com/google/distributed_point_functions/blob/master/dpf/int_mod_n.h#L155) are based on loop variables or compile-time constants.\r\n\r\n> Taking a step back, do we actually care if the algorithm that computes the mapping from pseudorandom byte strings to field elements is constant time? Take rejection sampling, for instance: assuming the underlying PRG is constant-time (i.e., AES-CTR is implemented in constant time) It seems to me that all that can be leaked by a non-constant-time implementation is the value of the bits that are rejected.\r\n\r\nMaybe you are right and that leakage is fine (in that it can be simulated in a proof). @chris-wood, do you have an insight as to why constant-time is required for hash-to-curve and thus rejection sampling is ruled out?",
          "createdAt": "2022-02-24T17:27:07Z",
          "updatedAt": "2022-02-24T17:27:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "> Maybe you are right and that leakage is fine (in that it can be simulated in a proof). @chris-wood, do you have an insight as to why constant-time is required for hash-to-curve and thus rejection sampling is ruled out?\r\n\r\nYeah -- some applications of hash-to-curve operate on secret input, and thus any side channels may leak the secret. [Dragonblood](https://papers.mathyvanhoef.com/wac2019-slides.pdf) is one famous example of this that motivated the hash-to-curve standard.",
          "createdAt": "2022-02-24T17:32:03Z",
          "updatedAt": "2022-02-24T17:32:03Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Ugh, sorry I copied the wrong link. I'm on a Mac and feel wayyy out of my depth :) Here's the link: https://github.com/google/distributed_point_functions/blob/master/dpf/int_mod_n.h#L170. I'm not sure this is guaranteed to be constant-time, i.e., the runtime of the division operation might depend on the value of `r`. I think this depends on the CPU arch.\r\n\r\n\r\n\r\n",
          "createdAt": "2022-02-24T17:34:25Z",
          "updatedAt": "2022-02-24T17:34:25Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton Ah got it. Yeah, I was assuming arithmetic operations are constant-time, but they might not be. In that case the fix should still be easy as you pointed out.\r\n\r\n@chris-wood So it seems that the number of iterations needed for many hashes of the same password + different auxiliary information (MAC, counter, ...) can be used to find the password. On the other hand, revealing even full blocks of an AES-CTR output shouldn't reveal anything about the key or any other blocks in the output. So is the issue in Dragonblood that the password is low-entropy?",
          "createdAt": "2022-02-24T18:15:06Z",
          "updatedAt": "2022-02-24T18:15:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems like we may have consensus for rejection sampling. Here's a PR: https://github.com/cjpatton/vdaf/pull/31. @schoppmp if you're happy with this outcome then please review at your convenience :)",
          "createdAt": "2022-02-25T00:51:38Z",
          "updatedAt": "2022-02-25T00:51:38Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "SGTM, provided we emphasize that the seed MUST be high-entropy, i.e., not derived from a password using a KDF or similar. I'll take a look at #31.",
          "createdAt": "2022-02-25T13:30:13Z",
          "updatedAt": "2022-02-25T13:30:13Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually I think high entropy (or, to be more precise, high min-entropy) won't be sufficient for all PRG constructions. See comments on the PR.",
          "createdAt": "2022-02-25T15:43:24Z",
          "updatedAt": "2022-02-25T15:43:24Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOGKuqOc5A-WhR",
      "title": "prio3: Make joint randomness optional",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/15",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Not all FLPs take joint randomness as input, in particular those for which `JOINT_RAND_LEN == 0`. For these FLPs we can reduce the bandwidth overhead by removing the `k_blind` and `k_hint` fields from the input share and the `k_joint_rand_share` from the prepare message.",
      "createdAt": "2021-12-28T19:27:29Z",
      "updatedAt": "2022-02-09T04:35:39Z",
      "closedAt": "2022-02-09T04:35:39Z",
      "comments": []
    },
    {
      "number": 18,
      "id": "I_kwDOGKuqOc5CXBsP",
      "title": "Threat model and protocol for distributed setup",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/18",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The \"setup\" algorithm defined in the spec specifies the generation of the public parameter used by the clients and verification parameter of each of the aggregators. This algorithm is said to run \"out-of-band\", effectively punting this consideration to applications. In particular, this is a problem that PPM will have to solve: see https://github.com/abetterinternet/ppm-specification/issues/161.\r\n\r\nWe know that the setup algorithm being run securely is crucial correctness, however it's not clear how important it is for privacy. As a strawman, suppose that we have one aggregator run the setup algorithm and distribute the output among the parties such that the clients never learn or control the value of the verification parameters. This ought to be good enough for correctness. What's less clear (to me, at least) is whether the aggregator, by choosing the verification parameters maliciously, can force an honest aggregator into revealing something that leads to a privacy violation.\r\n\r\nIf this strawman is not sufficient and we end up needing to do something fancier, then it may prudent to revisit the \"setup algorithm\" abstraction. What we woiuld want for prio3 and poplar1 is a protocol for exchanging a shared secret. (The properties we need from this key exchange are TBD, but note that something like a DH key exchange might not suffice. See https://github.com/abetterinternet/ppm-specification/issues/161 for discussion.)",
      "createdAt": "2022-01-25T01:53:41Z",
      "updatedAt": "2023-02-08T01:07:04Z",
      "closedAt": "2023-02-08T01:07:04Z",
      "comments": [
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "One thing to keep in mind is that the randomness used in the verification protocol (at least for Poplar) must be independent of the client keys. If a (semi-honest) helper server colludes with a (malicious) client, the client could use the randomness known to the helper server to generate an invalid share that still passes the verification. So I would propose running the setup phase only after all client shares have been collected and agreed on by the helper servers.\r\n\r\nRegarding maliciously generated randomness, are we considering malicious security for the helpers at all? If so, what exact formalization? For example, Poplar only provides malicious security with respect to privacy (but not correctness). Not sure we want to hard-code this threat model or instead leave it up to implementations.",
          "createdAt": "2022-01-25T10:32:56Z",
          "updatedAt": "2022-01-25T10:33:57Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> One thing to keep in mind is that the randomness used in the verification protocol (at least for Poplar) must be independent of the client keys. If a (semi-honest) helper server colludes with a (malicious) client, the client could use the randomness known to the helper server to generate an invalid share that still passes the verification.\r\n\r\nMost definitely. In fact, this is likely going to be true for most, if not all, VDAFs. \r\n\r\n> So I would propose running the setup phase only after all client shares have been collected and agreed on by the helper servers.\r\n\r\nThis isn't going to feasible for all deployments for PPM. In particular, a deployment of prio3 might throw report shares away as soon as they're aggregated, in order to limit storage overhead. Regardless, I think the main requirement is that the randomness is kept secret from the clients, which is definitely feasible.\r\n\r\n> Regarding maliciously generated randomness, are we considering malicious security for the helpers at all? If so, what exact formalization? For example, Poplar only provides malicious security with respect to privacy (but not correctness). Not sure we want to hard-code this threat model or instead leave it up to implementations.\r\n\r\nYes, as stated in our security considerations: for privacy we're concerned with malicious aggregators, but for correctness we assume the aggregators are honest. This amounts to the clients only needing to trust at least one aggregator for privacy, however the collector needs to trust that the aggregators compute the protocol correctly.\r\n\r\nThe main point raised in https://github.com/abetterinternet/ppm-specification/issues/161 is that there is a gap in the thread model not addressed by [BBCGGI19] or [BBCGGI21] (Poplar): The shared randomness used for verification may be controlled by the attacker. [BBCGGI19] and [BBCGGI21] side-step this by assuming an ideal \"coin-flipping\" functionality in the protocol. In practice, this coin-flipping functionality needs to be realized by some interaction among the aggregators.\r\n\r\nThus the main question I'm asking here is what properties do we actually need from the coin-flipping protocol. In particular: If we allow the attacker to control the honest aggregators' long lived randomness, are `poplar1` and `prio3` still private? This was discussed a bit in https://github.com/abetterinternet/ppm-specification/issues/161, but I'm not sure we have a definitive answer (at least for prio3).\r\n   * If yes, then the strawman setup procedure described above will suffice and we're done.\r\n   * If no, then we'll have to decide whether to consider an alternative here or leave this to applications like PPM.",
          "createdAt": "2022-01-25T15:57:21Z",
          "updatedAt": "2022-01-25T15:57:21Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "I think there are two questions here:\r\n1. How do we handle collusions between one of the servers and a subset of clients with respect to correctness? \r\n2. (Your question) Does a maliciously chosen randomness affect the privacy of the protocols?\r\n\r\nRegarding (1): Even though we don't care about correctness for malicious server behavior, a semi-honest server colluding with malicious clients might still be a problem. For example, in reality, we could enforce semi-honest helper servers using some form of binary attestation. But that wouldn't stop a malicious admin from reading out the verification randomness and then running a client with an invalid input that still passes verification with that randomness.\r\n> Regardless, I think the main requirement is that the randomness is kept secret from the clients, which is definitely feasible.\r\n\r\nGiven the example above, I'm not sure it is always realistic to assume that the randomness is kept secret from all clients. So I would like to at least keep the option to only generate the randomness once the client shares are agreed on. If we want to allow Fiat-Shamir as discussed in abetterinternet/ppm-specification#161, this would be required anyway.\r\n\r\nRegarding (2): I had a brief look at Poplar, and it doesn't seem like adversary-chosen randomness can break privacy. In particular, Proposition 2 in [Appendix C.4.1](https://eprint.iacr.org/2021/017.pdf#page=19&zoom=100,417,856) still holds (the simulator does not require r to be random). Maybe @henrycg has some insights for Prio?",
          "createdAt": "2022-01-26T14:05:00Z",
          "updatedAt": "2022-01-26T14:05:00Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> But that wouldn't stop a malicious admin from reading out the verification randomness and then running a client with an invalid input that still passes verification with that randomness.\r\n\r\nSince this involves sharing information with the client -- or, equivalently, acting as a client itself -- I would consider this malicious (i.e., active) behavior on the part of the server and, therefore, out of scope.\r\n\r\n>  So I would like to at least keep the option to only generate the randomness once the client shares are agreed on.\r\n\r\nI think keeping this option is reasonable. One question though: Is this a matter to be considered by the VDAF spec or by applications? We could discuss the attack you described above in security considerations and recommend setting up the verification parameters only after the input shares have been ingested.\r\n\r\n> If we want to allow Fiat-Shamir as discussed in abetterinternet/ppm-specification#161, this would be required anyway.\r\n\r\nCan you provide more detail here? We use Fiat-Shamir in prio3 for the \"joint randomness\", but not the \"query randomness\". I agree that there's an attack if the client knows the shared secret used to derive query randomness, but I don't see an attack if the shared secret is generated before the client generates its input shares (as long as it doesn't see it). Am I missing something?",
          "createdAt": "2022-01-26T15:38:19Z",
          "updatedAt": "2022-01-26T16:43:24Z"
        },
        {
          "author": "henrycg",
          "authorAssociation": "NONE",
          "body": "> Regarding (2): I had a brief look at Poplar, and it doesn't seem like adversary-chosen randomness can break privacy. In particular, Proposition 2 in [Appendix C.4.1](https://eprint.iacr.org/2021/017.pdf#page=19&zoom=100,417,856) still holds (the simulator does not require r to be random). Maybe @henrycg has some insights for Prio?\r\n\r\nYes, the same should be true for Prio, provided that the servers' random challenge is chosen, as in the Crypto'19 paper, to avoid the certain set of \"bad\" challenge points.",
          "createdAt": "2022-01-26T16:02:41Z",
          "updatedAt": "2022-01-26T16:02:41Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can you provide more detail here? We use Fiat-Shamir in prio3 for the \"joint randomness\", but not the \"query randomness\". I agree that there's an attack if the client knows the shared secret used to derive query randomness, but I don't see an attack if the shared secret is generated before the client generates its input shares (as long as it doesn't see it). Am I missing something?\r\n\r\nOkay, so this means that you use fiat-shamir to derive the randomness used in each client's proof share, but not the randomness that is sampled independently by the servers using coin-flipping? In that case you are right, we don't need to wait until we know all client shares.\r\n\r\nStill, the issue regarding a server colluding with a malicious client stands. I'm not sure we can simply discount it for being \"out of scope\", given the example attack scenario I gave above. Or, to put it in more formal terms, I don't see why we should require the adversary to corrupt all parties in the same way, given that some (clients) are more easy to corrupt maliciously than others (helper servers).",
          "createdAt": "2022-01-26T16:59:20Z",
          "updatedAt": "2022-01-26T16:59:28Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is this a matter to be considered by the VDAF spec or by applications? We could discuss the attack you described above in security considerations and recommend setting up the verification parameters only after the input shares have been ingested.\r\n\r\nDo you think we should discuss this in the PPM spec as well (e.g. in abetterinternet/ppm-specification#161)?",
          "createdAt": "2022-01-26T17:02:26Z",
          "updatedAt": "2022-01-26T17:02:26Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "That's an interesting point, and I agree that there's no reason to think of all parties as being corrupted in the same way. Definitely worth thinking about.\r\n\r\nI'll just add this thought: If a malicious aggregator wants to break correctness, there's a much simpler attack than corrupting or acting as a client: all it has to do is make up a bogus aggregate share. The collector would have no way to detect this, at least for prio3 or poplar1.",
          "createdAt": "2022-01-28T03:15:28Z",
          "updatedAt": "2022-01-28T03:15:28Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'll just add this thought: If a malicious aggregator wants to break correctness, there's a much simpler attack than corrupting or acting as a client: all it has to do is make up a bogus aggregate share. The collector would have no way to detect this, at least for prio3 or poplar1.\r\n\r\nI assume you mean a malicious admin or similar insider would run this simpler attack at the aggregator service? Then it wouldn't work any more if there are additional measurements (e.g., binary attestation) to enforce semi-honest behavior of the aggregator process, whereas reading out the verification randomness and then uwing it with a maliciously crafted client message would still work. \r\n\r\nOverall, even if we only consider outside attackers, I believe leaking some secret value from one of the aggregator servers is easier (requires less severe vulnerabilities or exploits) than triggering a remote code execution to cheat during the aggregation protocol.",
          "createdAt": "2022-01-28T11:38:51Z",
          "updatedAt": "2022-01-28T11:38:51Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> I assume you mean a malicious admin or similar insider would run this simpler attack at the aggregator service? Then it wouldn't work any more if there are additional measurements (e.g., binary attestation) to enforce semi-honest behavior of the aggregator process, whereas reading out the verification randomness and then uwing it with a maliciously crafted client message would still work.\r\n\r\nBinary attestation would be super useful, but I don't think it will be used in all applications of VDAFs.\r\n\r\nRegardless, I think the threat you're describing is worth discussing in security considerations, and we could even RECOMMEND that, where feasible, the setup algorithm be run only after the batch of input shares has arrived. However I would not go so far as to say deployments MUST or even SHOULD do this. Do you think this would be a reasonable outcome?",
          "createdAt": "2022-01-28T16:05:45Z",
          "updatedAt": "2022-01-28T16:05:45Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "That sounds good to me. I opened #21 for that, PTAL.",
          "createdAt": "2022-01-31T11:28:59Z",
          "updatedAt": "2022-01-31T11:28:59Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "The recommendation from [this analysis](https://mailarchive.ietf.org/arch/msg/cfrg/-errBjFRvCqi7KuAxoZwH6iY4Vc/) is that we can leave it up to the application to decide how to pick the verification key, as long as it is picked prior to reports being processed. We will need to revise the text in security considerations  (see https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/140), but I think we can close this issue.",
          "createdAt": "2023-02-08T01:07:04Z",
          "updatedAt": "2023-02-08T01:07:04Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDOGKuqOc5CXDUr",
      "title": "VDAFs that use the public parameter?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/19",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-01"
      ],
      "body": "The \"setup\" algorithm outputs a public parameter used by the clients to shard their measurement into input shares. This was added to the syntax in anticipation of VDAFs that might make use of public-key cryptography in some way. For example, in the appendix, [BBCGGI19] describes alternative applications for FLPs, e.g., using homomorphic encryption. One can imagine a VDAF that uses homomorphic encryption in order to save a round trip for input validation. (This is basically what [AdScale](https://isi.jhu.edu/~mgreen/advertising.pdf) does, as I understand.)\r\n\r\nThis is a bit of a pain for PPM, since it means that rotating the verification parameter also requires re-configuring the clients with the new public parameter. (See https://github.com/abetterinternet/ppm-specification/issues/161.) Since we don't yet have a VDAF that makes use of the public parameter, it might be preferable to drop it from the syntax.",
      "createdAt": "2022-01-25T02:06:43Z",
      "updatedAt": "2022-05-18T23:12:33Z",
      "closedAt": "2022-05-18T23:12:33Z",
      "comments": []
    },
    {
      "number": 20,
      "id": "I_kwDOGKuqOc5CbTK5",
      "title": "What to do about DAFs (VDAFs w/o verifiability)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/20",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The syntax is compatible with schemes that forego verifiability altogether, but calling such a scheme a \"VDAF\" would be misleading. It's probably a good idea to make this distinction explicit, i.e., define \"DAFs\" as 0-round VDAFs that provide no verifiability. Should we make room for this in this document, or does it make sense to kick this to a different document?\r\n\r\nNote that this question came up previously in the context of PPM: https://github.com/abetterinternet/ppm-specification/issues/45.",
      "createdAt": "2022-01-25T23:10:00Z",
      "updatedAt": "2022-05-13T15:20:06Z",
      "closedAt": "2022-05-13T15:20:06Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "In case it helps, the [VOPRF document](https://cfrg.github.io/draft-irtf-cfrg-voprf/draft-irtf-cfrg-voprf.html) includes OPRFs with and without verifiability. I think it makes sense to include DAFs in this document, especially for deployments that don't need verifiability.",
          "createdAt": "2022-01-25T23:52:10Z",
          "updatedAt": "2022-01-25T23:52:10Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "One example of something that's close to a DAF: https://eprint.iacr.org/2018/442.pdf",
          "createdAt": "2022-04-06T20:33:59Z",
          "updatedAt": "2022-04-06T20:33:59Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "One thing @chris-wood and I noted today is that \"DAFs\" will have no need for a verification parameter, making them syntactically somewhat different.",
          "createdAt": "2022-04-28T21:24:13Z",
          "updatedAt": "2022-04-28T21:24:13Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOGKuqOc5C4vjo",
      "title": "Specify fields for poplar1 (was \"Specify fields for prio3 and poplar1\")",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/22",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-02"
      ],
      "body": "At this point we have fairly clear criteria for choosing fields for Prio. Namely, the prime modulus `p` should be of the form `2^k * q + 1`, where `k` is large enough to support proof sizes we're interested in. The fact that the multiplicative group has a subgroup of order `2^k` is exploited for fast polynomial interpolation. `k` should also be chosen to align with the word size of the machine, e.g., `32` or `64` so that fast arithmetic can be generated for it (cc/ @armfazh).\r\n\r\nThe requirements are different for Poplar, though any field we choose for Prio ought to be suitable for Poplar as well. The main difference I see is that we'll need a much larger field for the leaves of the IPDF tree than we need for the inner nodes. I wonder if the leaves could use `GF(2^255 - 19)`, since there are already fast, heavily vetted implementation of this field (namely for X25519 and ed25519)? @schoppmp do you have any other thoughts here?",
      "createdAt": "2022-02-02T16:59:10Z",
      "updatedAt": "2022-06-22T15:19:37Z",
      "closedAt": "2022-06-22T15:19:37Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "As far as how big the primes ought to be, I think we ought to aim for a soundness error of around 1/2^64 for any VDAF. Higher security levels can be targeted as desired.\r\n\r\nFor prio3, we should have:\r\n* a 64-bit field. This would only be appropriate for instantiations that don't do Fiat-Shamir.\r\n* a 96-bit field. Similarly, this would not be appropriate for Fiat-Shamir.\r\n* a 128-bit field. This would be suitable for Fiat-Shamir.\r\n\r\nFor poplar1 we might reuse these fields, or pick new ones if the fields we pick for prio3 aren't suitable. We will also need:\r\n* a 256-bit field (or close to it). It may be worthwhile to pick something suitable for prio3.",
          "createdAt": "2022-02-02T17:58:50Z",
          "updatedAt": "2022-02-02T18:02:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "The document now specifies a 64-bit and a 128-bit field suitable for prio3.",
          "createdAt": "2022-03-04T01:45:53Z",
          "updatedAt": "2022-03-04T01:45:53Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOGKuqOc5El_DQ",
      "title": "PRG: Fixed-key AES",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/32",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "schoppmp"
      ],
      "labels": [
        "draft-05"
      ],
      "body": "Our initial PRG construction is based on AES: https://github.com/cjpatton/vdaf/pull/28. @schoppmp points out that there may alternative AES-based constructions that are better suited to our application. In addition, there may be alternative primitives, like an XOF hash function, that are well suited for VDAFs. This issue is for tracking this discussion.",
      "createdAt": "2022-02-25T19:49:52Z",
      "updatedAt": "2023-03-13T16:11:56Z",
      "closedAt": "2023-03-13T15:16:21Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's the paper Phillipp referenced: https://eprint.iacr.org/2019/074.pdf",
          "createdAt": "2022-03-09T18:04:39Z",
          "updatedAt": "2022-03-09T18:04:39Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "The text you added to the draft suggests that fixed-key AES (as it is called in the paper) might be something to move to.  The paper suggests that you don't get correlation robustness in that case, so maybe that isn't the best choice.\r\n\r\nA PRG based on AES does seem to be a sensible choice here from a performance perspective if nothing else, and the idea of using a counter seems reasonable.  Maybe consider using $\\mathsf{MMO}^\\pi$ or $\\widehat{\\mathsf{MMO}}_\\sigma^\\pi$ from that paper instead.  The added cost is modest, but it would appear that the properties they provide are superior.",
          "createdAt": "2022-08-12T05:09:42Z",
          "updatedAt": "2022-08-12T05:09:42Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "Oh, I should add https://eprint.iacr.org/2022/080 describes another variant that adds a tweak.  The tweak looks like $H(m,t) = \\pi(m\\otimes t)\\oplus (m\\otimes t)$, which is a little slower overall, but probably still in line with what you are looking for.  The only trick there is in deciding the tweak.",
          "createdAt": "2022-08-12T05:13:54Z",
          "updatedAt": "2022-08-12T05:14:16Z"
        },
        {
          "author": "wangxiao1254",
          "authorAssociation": "NONE",
          "body": "I was contacted by Phillipp @schoppmp about this issue and we had some discussion. Briefly, letting each client pick a uniform AES key seems the best option. The underlying reasoning would be based on https://eprint.iacr.org/2019/1168.pdf, MiTCCR, in the ideal cipher model. The loss of concrete security would be minimal.",
          "createdAt": "2023-03-13T02:55:06Z",
          "updatedAt": "2023-03-13T02:55:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @wangxiao1254 for your feedback and contribution to the design of VDAF!",
          "createdAt": "2023-03-13T16:11:55Z",
          "updatedAt": "2023-03-13T16:11:55Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "I_kwDOGKuqOc5FZnLF",
      "title": "Serializaiton of the verification parameter",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/38",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-01"
      ],
      "body": "As @tgeoghegan pointed out in https://github.com/abetterinternet/libprio-rs/pull/192#issuecomment-1062483035, some applications will require transmitting verification parameters over a secure channel. To support these, we we ought to require that VDAFs specify an encoding.",
      "createdAt": "2022-03-09T19:20:51Z",
      "updatedAt": "2022-05-18T23:15:36Z",
      "closedAt": "2022-05-18T23:15:35Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "One way to resolve this issue is to codify the \"aggregator ID\" in the syntax and make the verification parameter simply a shared secret. This would be compatible with at least Prio3 and Poplar1.",
          "createdAt": "2022-05-10T01:05:18Z",
          "updatedAt": "2022-05-10T01:05:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #62.",
          "createdAt": "2022-05-18T23:15:35Z",
          "updatedAt": "2022-05-18T23:15:35Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "I_kwDOGKuqOc5FxJ2w",
      "title": "Prio3: Shorten the prepare message",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/39",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-01"
      ],
      "body": "By moving `decide()` into `prep_shares_to_prep()` we can avoid sending the unsharded verifier message over the network.",
      "createdAt": "2022-03-16T04:05:40Z",
      "updatedAt": "2022-05-18T23:13:52Z",
      "closedAt": "2022-05-18T23:13:52Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed via #64.",
          "createdAt": "2022-05-18T23:13:52Z",
          "updatedAt": "2022-05-18T23:13:52Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "I_kwDOGKuqOc5GLehI",
      "title": "Does VDAF need a notion of leader?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/40",
      "state": "CLOSED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "PPM has a notion of a distinguished aggregator called the \"leader\". Wherever messages contain a sequence of objects, that protocol insists that the leader's share always be the first element (e.g. [`Report.encrypted_input_shares`](https://www.ietf.org/archive/id/draft-gpew-priv-ppm-01.html#section-4.2.2-4.4)).\r\n\r\nVDAF only references the notion of a leader in its specification of `Prio3`, [whose input sharding algorithm does specify that the leader's share appears first](https://www.ietf.org/archive/id/draft-patton-cfrg-vdaf-01.html#section-6.2.2).\r\n\r\nHowever that constraint isn't articulated generically for all VDAFs, which leaves things ambiguous for implementations. Consider the current generic declaration of [`prio::vdaf::Client::shard`](https://docs.rs/prio/latest/prio/vdaf/trait.Client.html):\r\n```\r\n    /// Shards a measurement into a sequence of input shares, one for each Aggregator.\r\n    fn shard(\r\n        &self,\r\n        public_param: &Self::PublicParam,\r\n        measurement: &Self::Measurement,\r\n    ) -> Result<Vec<Self::InputShare>, VdafError>;\r\n```\r\nPPM implementations have to guess that the 0th element in the returned `Vec` is the leader's share. Should the [VDAF-level definition of `shard`](https://www.ietf.org/archive/id/draft-patton-cfrg-vdaf-01.html#section-4.2) discuss the notion of a leader share, and require that the 0-th value returned from `Vdaf.measurement_to_input_shares` be the leader's?\r\n",
      "createdAt": "2022-03-22T23:31:13Z",
      "updatedAt": "2023-02-08T22:13:04Z",
      "closedAt": "2023-02-08T22:13:04Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree this ambiguity matters to PPM -- or, more generally, the Leader/Model architecture -- insofar that it makes sense to send the \"big\" share to the leader in order to decrease communication cost for the helpers. It's also true that this asymmetry --- i.e., the existence of a distinguished \"big\" share -- exists for Prio3 and, to a lesser extend, Poplar1; but it's worth pointing out that the asymmetry doesn't necessarily exist for all VDAFs.\r\n\r\nFor this reason, my view here is that it's not worth making a syntactic change to the VDAF spec in order to accommodate this. What I would go for is adding guidance somewhere in the spec to nudge things in the right direction. In particular: would it be sufficient to RECOMMEND that future VDAFs put the \"big\" share first (if it exists)?",
          "createdAt": "2022-03-22T23:47:23Z",
          "updatedAt": "2022-03-22T23:48:11Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure that a recommendation will suffice. If there's a difference in the encoding of one share vs. the others, then a PPM implementation needs to able to tell which one is different so it can be sent to the aggregator that is configured to handle that kind of share.\r\n\r\nAlternatively, an encoded input share could include some indication of how it is encoded (e.g. whether or not it's compressed in prio3) and then `Vdaf.prep_init` could use that inline information to decide how to decode the input share.",
          "createdAt": "2022-03-22T23:57:26Z",
          "updatedAt": "2022-03-22T23:57:26Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm not sure that a recommendation will suffice. If there's a difference in the encoding of one share vs. the others, then a PPM implementation needs to able to tell which one is different so it can be sent to the aggregator that is configured to handle that kind of share.\r\n\r\nTrue enough. Right now the information needed to decode (and indeed to prepare an input) is encoded by the verification parameter: https://www.ietf.org/archive/id/draft-patton-cfrg-vdaf-01.html#name-setup-2. This seems sufficient, but  perhaps there's a better way to expose this?\r\n\r\nBy the way, to decode a Prio3 input share, you need to know more than whether the share is for the \"leader\" or a \"helper\". You also need the \"aggregator ID\", which is used in an essential way to compute the joint randomness. For Prio3 this is encoded by the verification parameter.\r\n\r\n> Alternatively, an encoded input share could include some indication of how it is encoded (e.g. whether or not it's compressed in prio3) and then `Vdaf.prep_init` could use that inline information to decide how to decode the input share.\r\n\r\nSeems reasonable, though it would cost a few bits of communication.",
          "createdAt": "2022-03-23T00:03:22Z",
          "updatedAt": "2022-03-23T00:04:02Z"
        },
        {
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think VDAFs need the notion of a leader -- but I do think that the VDAF spec should consider specifying that for the various per-aggregator parameters, values are correlated by index (so e.g. `verify_params` index 0 is always used with `input_shares` index 0). The only text I can find suggesting this is in the `run_vdaf` pseudocode in Section 4.6, but I am not sure this is normative.\r\n\r\nSeparately, PPM should specify that the leader uses VDAF index 0, helper uses index 1 (or vice versa).",
          "createdAt": "2022-04-14T23:33:07Z",
          "updatedAt": "2022-04-14T23:33:07Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, there is currently no normative text regarding which server gets which share. I also don't think there should be, at least not in the VDAF spec. On the other hand, I agree we need language here to make sure that\r\n(1) it's possible for PPM to specify which server gets which share.\r\n(2) Users are guided towards making sensible choices which servers consume the \"big\" shares (when applicable).\r\n\r\nI welcome suggestions for ways to solve each of these :)",
          "createdAt": "2022-04-19T17:50:11Z",
          "updatedAt": "2022-04-19T17:50:11Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@tgeoghegan, @branlwyd: Where are you two on this issue? Are you OK with me closing without a fix, or is there more you'd like to do here?",
          "createdAt": "2023-02-08T01:08:53Z",
          "updatedAt": "2023-02-08T01:08:53Z"
        },
        {
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm OK with closing this issue -- I don't think there's anything to be done against the VDAF spec. (FWIW, I think the DAP spec defines things appropriately at this point, as well.)",
          "createdAt": "2023-02-08T20:25:32Z",
          "updatedAt": "2023-02-08T20:25:32Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, it seems like Daphne and Janus both figured it out. I suppose there's nothing to be done here until we hear that implementors find this confusing enough that it's worth clarifying.",
          "createdAt": "2023-02-08T20:55:40Z",
          "updatedAt": "2023-02-08T20:55:40Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDOGKuqOc5GkD62",
      "title": "Representing 'linear state machine' requirement in pseudocode",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/42",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial",
        "draft-09"
      ],
      "body": "The following currently appears in section 4.3.\r\n\r\n> TODO Consider how to bake this \"linear state machine\" condition into the syntax. Given that Python 3 is used as our pseudocode, it's easier to specify the preparation state using a class.",
      "createdAt": "2022-03-28T19:00:08Z",
      "updatedAt": "2024-05-02T14:56:44Z",
      "closedAt": "2024-05-02T14:56:44Z",
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "My suggestion: If we augment our pseudocode with dependent types, then we could parameterize the type of `Prep` by how many rounds are left before the output share is recovered. Making up some syntax, this would look like:\r\n\r\n```\r\nVdaf.prep_init(verify_param: VerifyParam, agg_param: AggParam, nonce: Bytes, input_share: Bytes) -> Prep[ROUNDS]\r\n\r\nVdaf.prep_next(prep: Prep[ROUNDS], inbound: None) -> If[ROUNDS == 0, OutShare, Tuple[Prep[ROUNDS - 1], Bytes]]\r\nVdaf.prep_next(prep: Prep[R such that R < ROUNDS], inbound: Bytes) -> If[R == 0, OutShare, Tuple[Prep[R - 1], Bytes]]\r\n```",
          "createdAt": "2022-03-28T19:00:13Z",
          "updatedAt": "2022-03-28T21:55:48Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "That's an interesting idea. It would be great to see a PR with this idea implemented. Two constraints I'd like to keep top of mind:\r\n(1) If possible, our \"pseudocode\" ishould syntactically correct Python3 (well, Sage really.)\r\n(2) Readability is more important than rigorous type semantics.",
          "createdAt": "2022-04-06T19:20:43Z",
          "updatedAt": "2022-04-06T19:20:43Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, I'll noodle on that. I'm not sure Python typing can express the concept directly, but maybe we could show ~3 `@overload`s with `Literal[1]`, `Literal[2]`, `Literal[3]`, as parameters, etc.",
          "createdAt": "2022-04-06T20:25:53Z",
          "updatedAt": "2022-04-06T20:25:53Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "I_kwDOGKuqOc5HO1SU",
      "title": "Poplar1: `k_verify_rand` should be derived from agg param",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/44",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-02"
      ],
      "body": "Currently only the nonce is used to derive the shared verification randomness. This should also depend on the aggregation parameter so that the verification randomness is unique for each aggregation parameter.",
      "createdAt": "2022-04-06T19:23:33Z",
      "updatedAt": "2022-07-11T21:00:31Z",
      "closedAt": "2022-07-11T21:00:31Z",
      "comments": []
    },
    {
      "number": 45,
      "id": "I_kwDOGKuqOc5H9Pb0",
      "title": "Combined state machine and output extraction",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/45",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Right now, `prep_next` returns one of two types: a final output share, or a new state and output message. Why not split these two into separate functions, e.g., `prep_next` for advancing the state machine and then `prep_finish` for producing the final output?",
      "createdAt": "2022-04-18T16:56:44Z",
      "updatedAt": "2024-04-30T23:02:28Z",
      "closedAt": "2024-04-30T23:02:27Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "We had this separation at some point, then decided to merge them into the same function. IIRC the thinking was that a particular VDAF might have a variable number of rounds, where the number of rounds depends on the inputs to the preparation phase. In this case the user would not know whether it should call `prep_next` or `prep_finish` at a particular step.\r\n\r\nThe VDAFs we have so far are all constant-round, and I think we're unlikely to have such a variable-round VDAF in the future. However, there are ways to extend your suggestion to allow the user to check if the current round is the last.\r\n\r\nI would be in favor the change you suggest, since it reduces a bit of API complexity. However, note that this complexity is, arguably, inherent to the pseudocode and is not shared by languages like Rust that have rich enum support. E.g.: \r\nhttps://github.com/divviup/libprio-rs/blob/main/src/vdaf.rs#L223.) \r\n\r\nThoughts, @schoppmp and @bifurcation?\r\n\r\n\r\n",
          "createdAt": "2022-04-19T17:43:55Z",
          "updatedAt": "2022-04-19T17:43:55Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To pile onto cjpatton's point: when we had a distinct `prepare_finish` method in `libprio`, we found that all it did was introduce the possibility of disagreement between client's tracking of the round of the prepare protocol we're on (which it has to do in order to choose whether to call `prepare_next` or `prepare_finish`) and `libprio`'s tracking of the round (which is encoded into the prepare state for all the VDAFs we've got). So `libprio` had to write extra code to handle `prepare_finish` being called at the wrong time, and clients of `libprio` had to write extra code to handle having their `prepare_next` call being rejected.\r\n\r\nAnother possibility that absolves the client of the VDAF from tracking rounds is to add a method on prepare state so you can query whether you are on the last round, and then do:\r\n\r\n```\r\nif prepare_state.is_last_round() {\r\n    let output_share = prepare_finish(prepare_state, messages);\r\n} else {\r\n    let (new_state, next_message) = prepare_next(prepare_state, messages);\r\n}\r\n```\r\n\r\nI agree with Chris P. that returning sum types make abstracting all this away behind a single `prepare_next` really nice in Rust (and I would think even in Python, tuple returns make this not so bad), but maybe `is_last_round` is an appropriate way to define VDAF to make it usable regardless of programming language features? Especially since we're free to define the interface of our Rust implementation however we like, regardless of how VDAF spells out `prepare_next` or `prepare_finish`.",
          "createdAt": "2022-04-19T21:03:49Z",
          "updatedAt": "2022-04-19T21:06:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "@tgeoghegan's suggestion seems fine, but I would name `is_las_round` to something like `is_finished`. This seems _purely_ an editorial change, I think, since one could use type system in Rust like @cjpatton suggests to fold `is_finished` into the `prep_next`.",
          "createdAt": "2022-04-20T13:59:36Z",
          "updatedAt": "2022-04-20T13:59:36Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, this is pretty much editorial.",
          "createdAt": "2022-04-21T01:13:00Z",
          "updatedAt": "2022-04-21T01:13:00Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "As of this writing, preparation is now:\r\n* prep_init() -> (prep_state, prep_share)\r\n* prep_shares_to_prep(prep_shares) -> prep_msg\r\n* prep_next(prep_state, prep_msg) -> (prep_state, prep_share) / out_share\r\n\r\nThus we still have the problem that @chris-wood pointed out: the output type of the last API call (either the next prep state or a completed output share) is ambiguous if there is a variable number of rounds. However this is still hypothetical, as all existing VDAFs have a constant number of rounds.\r\n\r\nNevertheless, it is arguably \"cleaner\" from an API perspective to add a method on `PrepState`, call it `is_finished()`, which returns a `bool` indicating whether the next call to `prep_next()` is the last. I\"d be fine with this change, but we would need to make sure to actually use it somewhere, otherwise we'll just end up with code rot.\r\n\r\nOne way we could use it here is to modify `run_vdaf()` by replacing the `for`-loop with a `while` loop once all of the aggregators are finished. Personally, I think this would be messier than what we have.\r\n\r\nI'm going to close this issue with no action. If someone wants to see a change here, please feel free to re-open and send a PR.",
          "createdAt": "2024-04-30T23:02:27Z",
          "updatedAt": "2024-04-30T23:02:27Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "I_kwDOGKuqOc5IguuL",
      "title": "Define a method for merging multiple aggregate shares into an aggregate share",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/47",
      "state": "CLOSED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "A VDAF must define a few [associated types](https://github.com/cjpatton/vdaf/blob/15c6abadc46d760a2b39a5708492a195fb4ee2e9/draft-patton-cfrg-vdaf.md?plain=1#L400):\r\n\r\n```\r\n| `OutShare`    | Type of each output share     |\r\n| `AggShare`    | Type of each aggregate share  |\r\n| `AggResult`   | Type of the aggregate result  |\r\n```\r\n\r\nVDAF defines a method for combining multiple output shares into an aggregate share: [`Vdaf.out_shares_to_agg_share(agg_param: AggParam, output_shares: Vec[OutShare]) -> agg_share: AggShare`](https://github.com/cjpatton/vdaf/blob/15c6abadc46d760a2b39a5708492a195fb4ee2e9/draft-patton-cfrg-vdaf.md?plain=1#L590). That's implemented in libprio as [`prio::vdaf::Aggregator::aggregate`](https://github.com/divviup/libprio-rs/blob/1bd54185d01110ff4486b8d71ed8f17f1ea77b78/src/vdaf.rs#L201).\r\n\r\nVDAF also defines a method for combining multiple aggregate shares into an aggregate result: [`Vdaf.agg_shares_to_result(agg_param: AggParam, agg_shares: Vec[AggShare]) -> AggResult`](https://github.com/cjpatton/vdaf/blob/15c6abadc46d760a2b39a5708492a195fb4ee2e9/draft-patton-cfrg-vdaf.md?plain=1#L627). That's implemented in libprio as [`prio::vdaf::Collector::unshard`](https://github.com/divviup/libprio-rs/blob/1bd54185d01110ff4486b8d71ed8f17f1ea77b78/src/vdaf.rs#L214).\r\n\r\nlibprio's trait [`prio::vdaf::Aggregatable`](https://github.com/divviup/libprio-rs/blob/1bd54185d01110ff4486b8d71ed8f17f1ea77b78/src/vdaf.rs#L236) is meant to correspond to a VDAF `AggShare` and also provides the method `Aggregatable:merge(&self, other: &Self) -> Result<(), VdafError>`. This method is extremely useful if not required for PPM implementations which will want to implement a map-reduce strategy for constructing aggregate shares. VDAF should define a method that corresponds to libprio's `merge`, and perhaps require that the combination of VDAF output shares into aggregate shares should not depend on order of the output shares.",
      "createdAt": "2022-04-26T22:20:43Z",
      "updatedAt": "2023-02-28T23:19:39Z",
      "closedAt": "2023-02-28T23:19:39Z",
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "libprio also has `Aggregatable::accumulate(&mut self, output_share: &Self::OutputShare) -> Result<(), VdafError>`, for accumulating an output share into an existing `AggShare`. VDAF may also want to define that method.",
          "createdAt": "2022-04-26T22:21:17Z",
          "updatedAt": "2022-04-26T22:21:17Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Besides the concrete mapping of VDAF methods to the libprio interface, we came across another interesting ambiguity in #53 ([link](https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/53#discussion_r868486690)).\r\n\r\nThe current draft discusses \"one-shot\" vs. \"streaming\" aggregation. \"Streaming\" means that it's possible to accumulate output shares into an aggregate one at a time, and that you don't have to keep all the output shares around. Such an aggregation is enabled by the `Aggregatable::merge` method libprio defines, and makes sense for the current Prio3 and Poplar1 VDAFs. \"One-shot\" means that you can't combine output shares into an aggregate until you have every output share that will go into that aggregate. @divergentdave's example is a median.\r\n\r\nI, at least, got confused about what \"one shot\" vs. \"streaming\" means and conflated it with the distinction between VDAFs that have an aggregation parameter (so you can't prepare any input shares until the collector provides `agg_param`; Poplar1 is such a VDAF)) and ones where the aggregation parameter is implicit or empty, and aggregators can prepare inputs as soon as they're uploaded (Prio3 VDAFs are like this). We should consider adding text to VDAF and/or DAP to clarify these two features of a VDAF and their implications on input preparation, assuming that I'm not the only person confused by these two things.",
          "createdAt": "2022-05-10T00:33:01Z",
          "updatedAt": "2022-05-10T00:33:01Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@tgeoghegan where are we on this? Do you think we should still define this?",
          "createdAt": "2023-02-28T16:27:11Z",
          "updatedAt": "2023-02-28T16:27:11Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "I_kwDOGKuqOc5IlhvL",
      "title": "Rename Prepare",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/48",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "While prepare seems to make sense in the context of the whole VDAF flow -- \"prepare a thing to be aggregated\" -- it's where most of the interesting VDAF work takes place. Maybe \"process\" or something would be better?",
      "createdAt": "2022-04-27T19:33:58Z",
      "updatedAt": "2023-12-05T22:25:18Z",
      "closedAt": "2023-12-05T22:25:17Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "\"process\" works for me.",
          "createdAt": "2022-04-27T19:48:31Z",
          "updatedAt": "2022-04-27T19:48:31Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think either \"prepare\" or \"process\" are particularly good (both are too generic) but \"prepare\" at least implies that something else is going to be done to the value (namely, being aggregated). The verb \"process\" carries even less information than \"prepare\".\r\n\r\nIf we look at Prio3 and Poplar1, what actually is happening is proof verification. Did we previously reject \"verify\" as the verb to use here? Is the idea that there might be some future VDAF that either doesn't verify anything or does stuff besides verification?",
          "createdAt": "2022-04-27T20:18:28Z",
          "updatedAt": "2022-04-27T20:18:28Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "The reason I'm not sure \"verify\" is suitable is because it implies a particular MPC technique. There other possibilities, like OT-extensions + Boolean-to-Arithmetic conversion (a la Prio+) that I would like to continue to make room for.",
          "createdAt": "2022-04-27T21:18:15Z",
          "updatedAt": "2022-04-27T21:18:15Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@hannahdaviscrypto has suggested the term \"refine\", as in \"to refine the input shares into refined shares\".",
          "createdAt": "2023-01-31T14:54:38Z",
          "updatedAt": "2023-01-31T14:54:38Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "When I've discussed this issue with the DAP/VDAF editors, no one is particularly enthusiastic about this change at this point. I think the ship has sailed. If anyone feels strongly about changing it (best suggestion so far is \"refine\"), then feel free to re-open.",
          "createdAt": "2023-12-05T22:25:18Z",
          "updatedAt": "2023-12-05T22:25:18Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "I_kwDOGKuqOc5ImX8-",
      "title": "sage poc: JOINT_RAND_LEN duplicated accidentally",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/51",
      "state": "CLOSED",
      "author": "jbr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The second and third fields [here](https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/poc/flp.sage#L15-L22) should likely be `PROVE_RAND_LEN` and `QUERY_RAND_LEN`",
      "createdAt": "2022-04-28T00:26:34Z",
      "updatedAt": "2022-04-28T03:38:05Z",
      "closedAt": "2022-04-28T03:38:05Z",
      "comments": []
    },
    {
      "number": 58,
      "id": "I_kwDOGKuqOc5JVUC1",
      "title": "Should the draft be prescriptive about encoding? (was \"Serialization of aggregate shares needs to be specified\")",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/58",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "`Vdaf` implementations need to define a type`Vdaf.AggShare` for the aggregate shares. Because the aggregate share are transmitted over the network, their encoding needs to be specified. There are two solutions to consider:\r\n(1) Replace `Vdaf.AggShare` with `Bytes`\r\n(2) Add methods on `Vdaf.AggShare` for encoding/decoding\r\n\r\nThe other quantities written to the network are input shares, prepare message shares, and the combined prepare message for each round. If we do (2), then for consistency we should also consider defining separate encoding/decoding methods for these. Currently the methods are implicit, since the type of each of these values is `Bytes`.",
      "createdAt": "2022-05-09T22:39:52Z",
      "updatedAt": "2023-08-16T01:39:08Z",
      "closedAt": "2023-08-16T01:39:08Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "My view here is that, as a general rule, the spec shouldn't expose the encoding to the user unless doing so simplifies the spec. Implementations are of course free to follow a different rule. Following this rule to the letter, we would pick (1). I'm interested to hear other takes here.",
          "createdAt": "2022-05-10T01:36:04Z",
          "updatedAt": "2022-05-10T01:36:04Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "Does the encoding need to be part of the VDAF spec? I.e., couldn't this be defined by the user / the spec of the protocol that wraps a given VDAF? The same holds for input shares, which currently are given as `Bytes`, but where I'd also prefer having a dedicated type, the serialization of which is defined by the outer protocol.",
          "createdAt": "2022-05-10T17:14:05Z",
          "updatedAt": "2022-05-10T17:14:05Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Good question. I don't think there is consensus in the CFRG: some drafts aim to be perspective about encoding, others don't. Thus far this draft has been prescriptive.\r\n\r\nMy personal view is that the specification of a cryptographic algorithm should be as prescriptive as possible. The goal of being prescriptive is to eliminate classes of bugs that occur when two different implementations of the same algorithm try to interoperate. (See https://eprint.iacr.org/2021/923 for a recent example.) Certainly the manner by which VDAF messages are encoded falls into this category. Imagine, for example, that you had a DAF (al a #53) for which one implementation chose big endian encoding of field elements and the other chose little endian.",
          "createdAt": "2022-05-10T19:53:24Z",
          "updatedAt": "2022-05-10T19:53:24Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't want to cut off the discussion on this thread, but I would at least like to ensure that the next draft specifies an encoding of agg shares. This is accomplished by https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/75. There are two questions raised here, which the PR explicitly punts on:\r\n(1) Should all quantities have an explicit type, regardless of whether the type needs to be encoded?\r\n(2) Should the document be prescriptive about encoding?",
          "createdAt": "2022-05-19T22:57:01Z",
          "updatedAt": "2022-05-19T22:57:01Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> (2) Should the document be prescriptive about encoding?\r\n\r\nI'm okay with ensuring that our current VDAF candidates (Prio3 & Poplar1) specify encodings (so all implementations use the same endianness etc.), but I wouldn't prescribe anything at the VDAF level, and instead leave this to the specs for particular VDAFs.",
          "createdAt": "2022-05-23T16:22:50Z",
          "updatedAt": "2022-05-23T16:22:50Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "I_kwDOGKuqOc5JV1lu",
      "title": "poc: Enforce types",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/59",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "poc"
      ],
      "body": "Type annotations are used in the reference implementation in order to generate a more readable spec. Currently these type annotations aren't for correctness. For instance, in https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/57, @jbr noticed that type for the verification parameter for Prio3 is not defined.\r\n\r\nIn python3 it's possible to use a static type checker, like https://mypy.readthedocs.io/en/stable/, for this purpose. At the very least, we should extend the unit tests to check that class attributes that are expected to be non-`None` have a value.\r\n\r\nNote that, for the verification parameter in particular, a solution to https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/38 might make this a moot point. However there are many situations for which this would be useful.\r\n",
      "createdAt": "2022-05-10T01:11:18Z",
      "updatedAt": "2024-06-12T21:21:57Z",
      "closedAt": "2024-06-12T21:21:56Z",
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "One other example: GEN_ORDER has a type hint that says \"Unsigned\", but it is actually sage.rings.integer.Integer. This matters because there's a place it is used in single-slash division, and the result is used as an exponent. If it were Unsigned, this would be raising an element to a power of a floating point number, but in reality, the power is a sage rational number, with no fractional part, which is OK. (Thanks to @jbr for catching this)",
          "createdAt": "2022-05-10T02:20:01Z",
          "updatedAt": "2022-05-10T02:20:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Ugh, yeah the fact that Sage is effectively \"compiled\" to Python3 makes this issue quite hairy. Then intended semantics of `__div__(self, other)` for `Field` is indeed `self * other.inv()`.\r\n\r\nStill unclear as to whether Sage is really the best choice for the reference implementation/spec. @chris-wood had prepared [a rant for IETF 113](https://datatracker.ietf.org/meeting/113/materials/slides-113-cfrg-cfrg-specifications-in-theory-and-practice-00) that touches on this very question, but we unfortunately ran out of time to give him a full hearing.",
          "createdAt": "2022-05-10T02:29:08Z",
          "updatedAt": "2022-05-10T02:30:02Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see an obvious way to enforce these types:\r\nhttps://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/6684fcca6995e080e10bf852d68f3671bc568dca/poc/vdaf_prio3.py#L37-L54",
          "createdAt": "2024-06-11T22:19:19Z",
          "updatedAt": "2024-06-11T22:19:19Z"
        }
      ]
    },
    {
      "number": 60,
      "id": "I_kwDOGKuqOc5JV33O",
      "title": "syntax: Have `prep_init()` output the first-round prepare-message share",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/60",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Assuming we:\r\n(1) merge https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/53\r\n(2) resolve https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/19 by removing the public parameter\r\n\r\nthere will be no possibility of a 0-round VDAF. In this case we should consider modifying the VDAF syntax so that `prep_init()` outputs the first prepare-message share. This would resolve some ugliness in the state machine of implementations. For Prio3 for instance, we need to distinguish between a \"Ready\" state and a \"Waiting\" state, where the only difference is whether the prepare-message share has been sent. For example, see libprio-rs: https://github.com/divviup/libprio-rs/blob/main/src/vdaf/prio3.rs#L942-L946\r\n\r\n@tgeoghegan, @divergentdave, I'd love to have your thoughts here. Note that this change would go in the next draft.\r\n",
      "createdAt": "2022-05-10T01:29:40Z",
      "updatedAt": "2022-05-25T17:29:06Z",
      "closedAt": "2022-05-25T17:29:06Z",
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I buy that this would enable 0-round VDAFs (is a 0-round VDAF the same as a DAF?). Can you sketch out how it affects one-or-more round VDAFs? Would the leader still gather up each helper's prepare message share to then join them and broadcast them back out, or would we take the opportunity to have leader send its prepare message to helper in the first message?",
          "createdAt": "2022-05-10T22:44:30Z",
          "updatedAt": "2022-05-10T22:44:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's what I had in mind: https://github.com/cfrg/draft-irtf-cfrg-vdaf/commit/ad5ad030bbe6be7a4ecd109686569fb9b2bbb665\r\n\r\nBasically the main difference is that `prep_next()` always takes in a prepare message, whereas before in the first round the input would be `None`.",
          "createdAt": "2022-05-13T19:21:24Z",
          "updatedAt": "2022-05-13T19:21:24Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems like the options here are isomorphic.\r\n\r\nNew->Old: Since the share contents are defined by the concrete protocol, if a protocol couldn't generate a real share in the first instance, it could send an empty value.\r\n\r\nOld->New: Similarly, in a zero-round VDAF, the protocol could specify that any putatively non-local inputs to `prep_next()` actually have some value that can be computed locally.  Then an aggregator implementing said protocol could just call `prep_init()` and `prep_next()` together to simulate the proposed modification to `prep_init()`.\r\n\r\nAssuming I've got that right, it seems like it doesn't really matter and we should just pick the one that is most natural for the cases we have in hand.",
          "createdAt": "2022-05-18T19:29:08Z",
          "updatedAt": "2022-05-18T19:29:08Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a good way of looking at it, yeah. And I agree they're isomorphic. I think the new syntax would be more natural for the [DAP spec](https://ietf-wg-ppm.github.io/draft-ietf-ppm-dap/draft-ietf-ppm-dap.html#name-input-share-preparation). In particular it would allow us to rewrite\r\n> ```\r\n> prep_state = VDAF.prep_init(vdaf_verify_param, agg_param, nonce, input_share)\r\n> out = VDAF.prep_next(prep_state, None)\r\n> ```\r\n>\r\n> vdaf_verify_param is the public VDAF parameter, and agg_param is the opaque aggregation parameter. If either step fails, the aggregator marks the report as invalid with error vdaf-prep-error.\r\n>\r\n> Otherwise, the value out is interpreted as follows. If this is the last round of the VDAF, then out is the aggregator's output share. Otherwise, out is the pair (prep_state, prep_msg).\r\n\r\nas\r\n\r\n> ```\r\n> (prep_state, prep_msg) = VDAF.prep_init(vdaf_verify_key, agg_id, agg_param, nonce, input_share)\r\n> ```\r\n>\r\n> vdaf_verify_key is the secret VDAF verification key shared by both aggregators, agg_id is equal to `0` for the leader and `1` for the helper, and agg_param is the opaque aggregation parameter. If this step fails, the aggregator marks the report as invalid with error vdaf-prep-error.",
          "createdAt": "2022-05-18T23:31:58Z",
          "updatedAt": "2022-05-18T23:32:14Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure why GH decided to close this based on a PR from libprio getting merged. In any case, I've reopened this because we decided not to merge #73 for draft-01. @schoppmp pointed out that this may end up being a regression if we end up having a 0-round VDAF one day. In particular, in order to account for schemes with public keys we will need to either modify the VDAF syntax (basically revert #62) or define a new object (\"PK-VDAF\" for example). See discussion on #73 for details.",
          "createdAt": "2022-05-25T16:28:01Z",
          "updatedAt": "2022-05-25T16:28:01Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "I_kwDOGKuqOc5JZptR",
      "title": "Split share verification out of preparation phase.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/61",
      "state": "CLOSED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From [previous discussion](https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/53#pullrequestreview-966895328):\r\n\r\nI think it makes sense to split up the preparation (as in, turning an input share into an output share), and the verification.\r\nThe reason is that the outer protocol using a VDAF might want to \"opportunistically\" aggregate shares, in particular for Poplar, where there are many rounds of Preparation, Aggregation, and Unsharding. This would save communication rounds, since the verification on one layer (of the Poplar tree) can be done in parallel with computing the aggregation shares on the next layer. In case a share turns out to be invalid, the corresponding aggregation shares can just be subtracted from the aggregated result.",
      "createdAt": "2022-05-10T17:15:59Z",
      "updatedAt": "2023-08-17T01:32:22Z",
      "closedAt": "2023-08-17T01:32:22Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "If I understand correctly, this suggestion entails a syntactic change where by we allow a VDAF to release unverified output shares early. This gets addressed in Section 4.3](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-00#section-4.3):\r\n\r\n> The preparation-state update accomplishes two tasks: recovery of\r\n   output shares from the input shares and ensuring that the recovered\r\n   output shares are valid.  The abstraction boundary is drawn so that\r\n   an Aggregator only recovers an output share if it is deemed valid (at\r\n   least, based on the Aggregator's view of the protocol).  Another way\r\n   to draw this boundary would be to have the Aggregators recover output\r\n   shares first, then verify that they are valid.  However, this would\r\n   allow the possibility of misusing the API by, say, aggregating an\r\n   invalid output share. Moreover, in protocols like Prio+ [[AGJOP21](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-00#ref-AGJOP21)]\r\n   based on oblivious transfer, it is necessary for the Aggregators to\r\n   interact in order to recover aggregatable output shares at all.\r\n\r\nBasically this paragraph boils down to two potential objections to this change:\r\n(1) Releasing unverified output shares is unsafe (it's up to the wrapper protocol to ensure correctness)\r\n(2) There may be interesting schemes that are syntactically incompatible with this change (i.e., not all VDAFs an explicit notion of \"verification\").\r\n\r\nPerhaps the key question to address here is whether all schemes we want to deploy *need* to have the same syntax. The [DAP protocol (formerly known as PPM)](https://datatracker.ietf.org/doc/draft-ietf-ppm-dap/) expects that all VDAFs have the same interface so that one can be swapped out for another and re-use the same protocol bits. This is useful for reducing code complexity, but is arguably not essential.\r\n\r\nOne more point to take into account: The purpose of the VDAF syntax in the draft is to (1) guide API design for implementations and (2) define the object of study for security analysis. Ideally our guidance on APIs makes it easy for applications to use VDAFs securely, but there is no reason why the syntax needs to prescribe a particular API. That said, the spec should make clear about the responsibilities that applications take on when they don't follow that guidance.\r\n\r\nWith that in mind, I think there are a few options for accommodating this change:\r\n(a) Adapt the VDAF syntax to accommodate release of unverified output shares and adapt Prio3 and Poplar1 to the new syntax.\r\n(b) Define a new primitive that supports this use case and specify Poplar1 as an instance.\r\n(c) Do noting, but describe this alternative way of implementing Poplar1 and discuss the security considerations for this implementation.\r\n\r\n\r\n\r\n",
          "createdAt": "2022-05-10T20:34:28Z",
          "updatedAt": "2022-05-10T20:34:28Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that (a) would require changes to DAP (formerly known as PPM). We would also want to consider adapting DAP for (c).",
          "createdAt": "2022-05-13T16:00:40Z",
          "updatedAt": "2022-05-17T18:47:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "@schoppmp how much work would it be to produce data indicating the cost of Poplar _without_ this change (released of unverified shares)? I wonder how much of this is premature optimization.",
          "createdAt": "2022-05-17T18:57:54Z",
          "updatedAt": "2022-05-17T18:57:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Update from 2023/3/2: This \"optimistic\" approach to running Poplar1 only has value because preparation requires two rounds: If we had a one-round variant, then it doesn't really help. Once we get https://eprint.iacr.org/2023/080 (or even Doplar from https://eprint.iacr.org/2023/130), we won't need this.",
          "createdAt": "2023-03-02T20:45:34Z",
          "updatedAt": "2023-03-02T20:45:34Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "I_kwDOGKuqOc5JpX4n",
      "title": "Prio3: Investigate eliminating FFT by switching polynomial bases",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/63",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "divergentdave"
      ],
      "labels": [
        "idea"
      ],
      "body": "We may be able to eliminate FFT polynomial interpolation from sharding and preparation, possibly reducing computational requirements, by switching our polynomials from the monomial basis to the Lagrange basis. See [this post](https://ethresear.ch/t/kate-commitments-from-the-lagrange-basis-without-ffts/6950) for an application of the same trick to pairing-based polynomial commitments. Construction of the wire polynomials in the Lagrange basis would be trivial, `poly_wire_i[j-1](x) = w[0]L0(x) + w[1]L1(x) + ... w[n]Ln(x)`. Given a polynomial in the Lagrange basis and an evaluation point, the evaluation of that polynomial at the given point can be computed with the \"barycentric formula\", see the post above. This is competitive with straightforward monomial basis polynomial evaluation, as it takes one field inversion and a linear number of field multiplications. The rest of the FLP scheme would have to be adapted, but I'm optimistic that this could work.\r\n\r\nIf this is feasible, it would constitute a huge change, but I think it would be good to investigate it eventually.\r\n\r\nRegarding the value of replacing FFT: the input size dependent part of the computational complexity is dominated by the FFT, but how much does it contribute for typical concrete sizes? In the proof-of-concept Sage implementation, for example, FFT sizes range from 2 to 16. Interpolation is measurable, but by and large lost in other overheads. Perhaps the difference will be appreciable if we specify a construction like \"CountVec\", which has many more gadget calls.",
      "createdAt": "2022-05-13T18:59:01Z",
      "updatedAt": "2023-10-20T16:15:04Z",
      "closedAt": "2023-10-20T16:15:04Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Very interesting idea! If I understand correctly, this would be an alternative FLP to `FlpGeneric`, correct? Would any changes to `Prio3` be required?",
          "createdAt": "2022-05-13T19:24:57Z",
          "updatedAt": "2022-05-13T19:24:57Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "That sounds right, I think this would only be a change at the FLP level.",
          "createdAt": "2022-05-13T20:13:56Z",
          "updatedAt": "2022-05-13T20:13:56Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "If I were you I would go prototype it in libprio. If we see a significant improvement in prove time and/or proof size (FFT requires us to pad the wire polynomials to the nearest power of 2), then we should 100% consider adding it to the VDAF draft. However I don't think we should consider it a replacement for `FlpGeneric`, at least not until we've had a chance to do a security proof. ",
          "createdAt": "2022-05-13T20:18:14Z",
          "updatedAt": "2022-05-13T20:26:04Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm happy to learn the math and review the code :)",
          "createdAt": "2022-05-13T20:18:39Z",
          "updatedAt": "2022-05-13T20:18:39Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Assigned to you @divergentdave! Based on https://github.com/divviup/libprio-rs/issues/571 it seems like we should close this without action.",
          "createdAt": "2023-08-17T01:34:39Z",
          "updatedAt": "2023-08-17T01:34:39Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, the break-even point is high enough that we will want to stick with interpolating polynomials with FFT, then evaluating those polynomials the traditional way. Division is expensive enough that doing O(n log n) multiplications comes out ahead of O(n) divisions, for our typical values of n.",
          "createdAt": "2023-10-20T16:15:04Z",
          "updatedAt": "2023-10-20T16:15:04Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "I_kwDOGKuqOc5J62_r",
      "title": "Define `VERSION` constant for building DSTs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/67",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-01"
      ],
      "body": "DSTs throughout the spec are likely to share a common prefix identifying the version of spec (e.g., \"vdaf-00\"). This common prefix could be defined in Section 2 so that it can be referenced from VDAF definitions. See discussion on #65 for motivation.\r\n\r\ncc/ @tgeoghegan ",
      "createdAt": "2022-05-18T15:51:17Z",
      "updatedAt": "2022-05-19T00:41:45Z",
      "closedAt": "2022-05-19T00:41:45Z",
      "comments": []
    },
    {
      "number": 68,
      "id": "I_kwDOGKuqOc5J65MZ",
      "title": "Add aggregator ID to DAP syntax",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/68",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-01"
      ],
      "body": "This is likely needed to distinguish \"big\" input shares from \"small\" input shares. This would align with https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/62.",
      "createdAt": "2022-05-18T15:57:30Z",
      "updatedAt": "2022-05-19T20:45:59Z",
      "closedAt": "2022-05-19T20:45:59Z",
      "comments": []
    },
    {
      "number": 72,
      "id": "I_kwDOGKuqOc5J9d1v",
      "title": "Miscellaneous tasks before cutting draft-01",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/72",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "draft-01"
      ],
      "body": "* Update test vectors\r\n* Add Change Log section enumerating non-editorial changes from draft-00\r\n* Update VERSION",
      "createdAt": "2022-05-19T00:46:46Z",
      "updatedAt": "2022-05-26T14:09:46Z",
      "closedAt": "2022-05-26T14:09:46Z",
      "comments": []
    },
    {
      "number": 77,
      "id": "I_kwDOGKuqOc5KaRon",
      "title": "Scope Questions: Public-key, Shuffling-based, and Zero-round VDAFs?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/77",
      "state": "CLOSED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There have been a couple of issues around features in hyptothetical VDAFs that are needed by neither Prio3 nor Poplar1.\r\nTwo examples are public-key encryption based VDAFs (which are currently hard to support after the [removal of public parameters ](https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/62)), or [zero-round verification](https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/73). A third would be support for multi-round aggregation protocols that might include shuffling of individual records, to enable something like [IPA](https://docs.google.com/document/u/1/d/1KpdSKD8-Rn0bWPTu4UtK54ks0yv2j22pA5SrAD9av4s/edit).\r\n\r\nAll of these are not supported with the current VDAF syntax, and would require explicit accommodations in higher-level protocols such as [DAP](https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/). The goal of this issue is to discuss and align on the question how much flexibility we want to allow in the VDAF syntax.\r\n\r\nSome preliminary thoughts from a discussion with @cjpatton:\r\n- In general, providing too many options to choose from in protocols leads to security issues due to increased complexity, attack surface, possibility of downgrades, and so forth. If we want to provide flexibility here, we have to ensure that we don't introduce these issues.\r\n- We can't think of all possible syntax needs for hypothetical future constructions that semantically still fit a \"verifiable distributed aggregation function\". How can we extend the VDAF syntax in such cases? Do we instead want to require a new kind of object (e.g., a PK-VDAF that supports public keys), at the risk of not being compatible with higher-level protocols?",
      "createdAt": "2022-05-25T16:58:41Z",
      "updatedAt": "2023-07-11T17:04:33Z",
      "closedAt": "2023-07-11T17:04:21Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": ">    In general, providing too many options to choose from in protocols leads to security issues due to increased complexity, attack surface, possibility of downgrades, and so forth. If we want to provide flexibility here, we have to ensure that we don't introduce these issues.\r\n\r\nI don't think this is a very strong argument in this case. This is not a situation of negotiation but rather where there is a single explicit and verified configuration, but each VDAF (or whatever) runs effectively in parallel.\r\n\r\n> We can't think of all possible syntax needs for hypothetical future constructions that semantically still fit a \"verifiable distributed aggregation function\". How can we extend the VDAF syntax in such cases? Do we instead want to require a new kind of object (e.g., a PK-VDAF that supports public keys), at the risk of not being compatible with higher-level protocols?\r\n\r\nThere are two ways to extend DAP:\r\n\r\n1. Add new VDAFs\r\n2. Extend it to support new non-VDAF constructions\r\n\r\nIf there are new primitives that don't make sense as VDAFs but do make sense in DAP (for instance, IPA, or an ElGamal-based system like that in Adnostic), then we should do that by extending DAP.",
          "createdAt": "2022-05-25T17:15:18Z",
          "updatedAt": "2022-05-25T17:15:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "FTR, Adnostic is https://crypto.stanford.edu/adnostic/. There is also AdScale, which is follow-on work: https://isi.jhu.edu/~mgreen/advertising.pdf\r\n\r\nI (currently) agree with EKR, especially in light of our recent experience working VDAFs into DAP. But @schoppmp made one more point, which convinced me that we may not know yet what the best path forward is here.\r\n\r\nIn protocol design it's typical to treat symmetric-key primitives differently from their public-key analogues. For example, a protocol built around symmetric encryption is going to be different from one built around public-key encryption.\r\n\r\nThe current VDAF syntax is specialized for a specific class of schemes. In particular, it does not admit public keys. Following the design principle above, we would want to treat schemes that do (e.g., Adnostic or AdScale) as a different kind of primitive, e.g., a PK-VDAF. However, @schoppmp pointed out that, in the MPC literature, the boundaries between different classes of constructions are more blurry than \"public-key\" versus \"symmetric\".\r\n\r\nBefore making a decision here, it will be helpful to first try to flesh out those classes of constructions that intersect with the PPM working group (and maybe PATCG).",
          "createdAt": "2022-05-25T17:43:49Z",
          "updatedAt": "2022-05-25T17:47:17Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that it's better to keep the VDAF spec narrow in focus, and leave my above suggestions out of scope. As ekr said, we can still extend DAP if needed by adding support for non-VDAF constructions.",
          "createdAt": "2023-07-11T17:04:21Z",
          "updatedAt": "2023-07-11T17:04:21Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "I_kwDOGKuqOc5KwZJN",
      "title": "Specify agg_param details",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/82",
      "state": "CLOSED",
      "author": "simon-friedberger",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "draft-02"
      ],
      "body": "It should be clear what the type of agg_param is and how it should be handled.\r\nFor specific VDAFs it should probably be clarified when the agg_param needs to be available and how it is distributed.\r\n\r\nSee also ietf-wg-ppm/draft-ietf-ppm-dap/issues/267",
      "createdAt": "2022-05-31T17:54:50Z",
      "updatedAt": "2022-07-09T23:58:22Z",
      "closedAt": "2022-07-09T23:58:22Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you be a bit more specific? My take on https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/issues/267 is that DAP treats the agg param as an opaque byte string, but the VDAF does not specify an encoding of this byte string.\r\n\r\nNote that this also relates to https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/58.",
          "createdAt": "2022-05-31T18:12:39Z",
          "updatedAt": "2022-05-31T18:12:39Z"
        },
        {
          "author": "simon-friedberger",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The VDAFs only specify the contents of agg_params globally, e.g. in 7.2 in Table 6.\r\n\r\nDAP could be optimized by precalculating the validation step if it does not need agg_param for this step.\r\n\r\nSo - IIUC - not everything that is called agg_param in DAP will contain the thing that is called agg_param here. The VDAFs should be explicit about which agg_params are needed and for which steps.",
          "createdAt": "2022-05-31T19:58:53Z",
          "updatedAt": "2022-05-31T19:58:53Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Perhaps this is the misunderstanding: In DAP wherever there is a struct with a field `agg_param`, the type of that field is `opaque <0..2^16-1>`.  This is a length-prefixed byte string. There will always be here, even if it's just an empty string. For Prio3 for example, this field would simply be empty (That is, the encoding of `None` as a byte string would simply the empty string. To be clear, this is currently not specified at all.)\r\n\r\nFor some deployments the agg param may be \"predictable\". For Prio3 in particular, the only valid agg param is `None` (i.e., the empty string).",
          "createdAt": "2022-05-31T21:30:47Z",
          "updatedAt": "2022-05-31T21:30:47Z"
        },
        {
          "author": "simon-friedberger",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let me see if I got this right now....\r\n\r\n`run_vdaf` in Figure 7 uses `agg_param` in\r\n* `prep_init`\r\n* `prep_shares_to_prep`\r\n* `out_shares_to_agg_share`\r\n* `agg_shares_to_result`\r\nbut there is no statement about how `agg_param` would get distributed in a system like DAP. If some of the functions only need parts of `agg_param`, or some of them can be empty, the specific VDAF (so Chapter 7 and Chapter 8) should specify that.\r\n\r\n1. Prio3\r\nIn Prio3 `agg_param` is empty so it's simple because it can be defined task wide in DAP and sending empty messages is the cheapest anyway.\r\n* `task.agg_param = None`\r\n* `CollectReq.agg_param = None`\r\n* `AggregateInitializeReq.agg_param = None`\r\n* `AggregateShareReq.agg_param = None`\r\nWhich conveniently makes them all the same and the same as in the VDAF.\r\n\r\n2. Poplar1\r\nIn Poplar1 `agg_param` contains the candidate prefixes and, iiuc, needs to be provided by the DAP collector in `CollectReq.agg_param`.\r\nSo here we would end up with something like\r\n* `task.agg_param = None`\r\n* `CollectReq.agg_param = candidate_prefixes`\r\n* `AggregateInitializeReq.agg_param = CollectReq.agg_param`\r\n* `AggregateShareReq.agg_param = None`\r\nespecially, they are not all the same.\r\n\r\nImho, since the field in DAP is opaque this is okay, but we should clarify in DAP that the `agg_params` are not all the same.\r\nAnd for the VDAF examples, we should specify how to get the different AggParams for the different steps.",
          "createdAt": "2022-06-01T08:09:04Z",
          "updatedAt": "2022-06-01T08:09:04Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "* What is `task.agg_param`?\r\n* The value of `AggregateShareReq.agg_param` is supposed to match `CollectReq.agg_param`. Does the DAP spec say otherwise?",
          "createdAt": "2022-06-01T14:23:32Z",
          "updatedAt": "2022-06-01T14:23:32Z"
        },
        {
          "author": "simon-friedberger",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`task.agg_param` is just a name I gave it. The spec lists it here: \r\n\r\n> The basic unit of DAP is the \"task\" which represents a single measurement\r\n(though potentially taken over multiple time windows). The definition of a task\r\nincludes the following parameters:\r\n> * The type of each measurement.\r\n> * The aggregation function to compute (e.g., sum, mean, etc.) and an optional\r\n  aggregation parameter.\r\n\r\n`AggregateShareReq.agg_param` might be the same as `CollectReq.agg_param`. The spec says nothing on the topic.\r\n\r\nWas your intention that all the `agg_param`s in DAP should also be the same?",
          "createdAt": "2022-06-01T14:29:32Z",
          "updatedAt": "2022-06-01T14:29:32Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Ohh ok, this text is at least misleading, if not flat out wrong:\r\n```\r\nThe aggregation function to compute (e.g., sum, mean, etc.) and an optional\r\naggregation parameter.\r\n```\r\n\r\nIt's not as if there is a single agg param that's used for every collect request for a given task. The Collector is supposed to be able to choose each agg param based on previous agg results.\r\n\r\nWhat we are trying to get at here is that some agg functions have an an additional input that we call the \"agg param\".\r\n\r\n> AggregateShareReq.agg_param might be the same as CollectReq.agg_param. The spec says nothing on the topic.\r\n\r\nThen this needs to be fixed. Please send a PR! \r\n\r\n> Was your intention that all the agg_params in DAP should also be the same?\r\n\r\nYes.",
          "createdAt": "2022-06-01T14:36:25Z",
          "updatedAt": "2022-06-01T14:36:38Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I suspect this issue is solved in DAP by https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/pull/282, so I will close this. @simon-friedberger, feel free to re-open if you think there is something else that needs to be done.",
          "createdAt": "2022-07-09T23:58:22Z",
          "updatedAt": "2022-07-09T23:58:22Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "I_kwDOGKuqOc5LadY5",
      "title": "Can we support Prio3Aes128CountVec?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/83",
      "state": "CLOSED",
      "author": "qiuxiangcassie",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "feature"
      ],
      "body": "### Why\r\nWith Prio3Aes128CountVec, each measurement is a vector of integers in `[0,2)` and the aggregate is the element-wise sum. This is very helpful for supporting some use cases, e.g., checkbox survey question.\r\n\r\n### Discussions\r\nBased on discussions in the chat group, there are some potential concerns with the trade-off between proof generation time and proof size. \r\n\r\n- If the circuit has arithmetic degree 3. The proof generation will be expensive. The proof size is O(sqrt(N)).\r\n- If the circuit has arithmetic degree 2. The proof generation is faster but the proof size is O(N)",
      "createdAt": "2022-06-08T19:54:09Z",
      "updatedAt": "2023-07-14T15:00:47Z",
      "closedAt": "2023-07-14T15:00:47Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "For context, `Prio3Aes128CountVec` refers to a Prio3 variant implemented in libprio-rs.\r\n\r\nI've added some benchmarks to libprio-rs that allow us to roughly compare these two proof systems. (See https://github.com/divviup/libprio-rs/pull/243.) The latter, which has degree 2 and proof size O(N), is very similar to what's used in ENPA today. I'll call this `Prio2`. `Prio3Aeas128CountVecMultithreaded` is a variant of `Prio3Aes128CountVec` that implements the same proof system but parallelizes part of the computation. The field used for each is `Field128`.\r\n\r\nReported times are from my 2.6 GHz 6-Core Intel Core i7 laptop.\r\n\r\ninput size: 10 (number of field elements)\r\n| System | proof size | generation time | query time |\r\n| ------- | ------ | ----- | ----- |\r\n| Prio2 | 29 | 10us | 12us |\r\n| Prio3Aes128CountVec | 28 | 21us | 15us |\r\n| Prio3Aes128CountVecMultithreaded | 28 | 67us | 15us |\r\n\r\ninput size: 100\r\n| System | proof size | generation time | query time |\r\n| ------- | ------ | ----- | ----- |\r\n| Prio2 | 231 | 76us | 58us |\r\n| Prio3Aes128CountVec | 66 | 121us | 39us |\r\n| Prio3Aes128CountVecMultithreaded | 66 | 146us | 37us |\r\n\r\ninput size: 1,000\r\n| System | proof size | generation time | query time |\r\n| ------- | ------ | ----- | ----- |\r\n| Prio2 | 2,027 | 678us | 528us |\r\n| Prio3Aes128CountVec | 252 | 3020us | 375us |\r\n| Prio3Aes128CountVecMultithreaded | 252 | 1001us | 366us |\r\n\r\ninput size: 10,000\r\n| System | proof size | generation time | query time |\r\n| ------- | ------ | ----- | ----- |\r\n| Prio2 | 26,387 | 14.9ms | 10.7ms |\r\n| Prio3Aes128CountVec | 582 | 21.4ms | 2.5ms |\r\n| Prio3Aes128CountVecMultithreaded | 582 | 6.3ms | 2.5ms |",
          "createdAt": "2022-06-08T21:34:20Z",
          "updatedAt": "2022-06-09T00:59:40Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "I noticed that the libprio-rs implementation of Prio3SumVec uses a floating point square root operation to compute its chunk size. To avoid interoperability headaches, I think the standardized version of this should avoid floating point operations, and instead say something like \"chunk_len is the largest integer such that chunk_len squared is less than or equal to total_len\". Taking the floating point square root and truncating is probably good enough for most lengths, but just in case, we could recommend starting there and iterating in an implementation note. Better that than specifying square root precision or rounding behavior.",
          "createdAt": "2023-04-26T16:23:07Z",
          "updatedAt": "2023-04-26T16:23:07Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed about avoiding floating point arithmetic in the spec. In fact, we might just make `chunk_len` a parameter and RECOMMEND it be set to the square root of the input size.",
          "createdAt": "2023-04-28T22:42:44Z",
          "updatedAt": "2023-04-28T22:42:44Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/124.",
          "createdAt": "2023-07-14T15:00:47Z",
          "updatedAt": "2023-07-14T15:00:47Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "I_kwDOGKuqOc5LftGp",
      "title": "Specify Poplar1 VDAF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/84",
      "state": "CLOSED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "draft-02"
      ],
      "body": "An upcoming draft-irtf-cfrg-vdaf should fully specify Poplar1.",
      "createdAt": "2022-06-09T20:10:19Z",
      "updatedAt": "2022-07-11T21:00:31Z",
      "closedAt": "2022-07-11T21:00:31Z",
      "comments": []
    },
    {
      "number": 89,
      "id": "I_kwDOGKuqOc5L9DhU",
      "title": "Field element decoding: check that the inputs are fully reduced",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/89",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "draft-02"
      ],
      "body": "@armfazh pointed this out here: https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/88#discussion_r899660677",
      "createdAt": "2022-06-17T00:39:37Z",
      "updatedAt": "2022-07-11T21:13:02Z",
      "closedAt": "2022-07-11T21:13:02Z",
      "comments": []
    },
    {
      "number": 90,
      "id": "I_kwDOGKuqOc5MP7Qf",
      "title": "Field element encoding: Accommodations for `GF(2^255-19)`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/90",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "draft-05"
      ],
      "body": "As of #88, we'll use `GF(2^255-19)` for the leaf node field for `IdpfPoplar`. This field is a natural choice because it is close to the security level cited by [the paper](https://eprint.iacr.org/2021/017) and there are already a number of implementations of it already. (E.g., https://github.com/cloudflare/circl/tree/master/math/fp25519.) However, this choice surfaces an issue related to field element encoding that needs discussion.\r\n\r\nFirst, the manner in which field elements are represented as byte strings matters for two reasons:\r\n1. In `Prio3`, vectors of field elements are encoded and used for key derivation. In general, it's likely that the VDAF draft will have cryptographic computations that depend on encoded field elements.\r\n2. So far we have opted to be prescriptive about the encoding of any value that would be written to the network by some application. For example, input shares and prep messages all have a fully-specified encoding. For additional discussion, see #58.\r\n\r\n@armfazh [points out](https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/88#discussion_r899660677) that implementations of `GF(2^255-19)` typically operate directly on little-endian byte-strings (https://github.com/cloudflare/circl/blob/master/math/fp25519/fp.go#L14). The current draft uses `I2OSP()` from RFC 3447 for encoding field elements, which is big-endian. This is makes it inconvenient to use these implementations for `IdpfPoplar`, as they will be required to re-order the byte strings in order to encode them properly. This is unlikely to be a performance issue, but is potentially a source of bugs.\r\n\r\nA related question raised by this issue is whether little-endian is somehow \"better\" for optimized finite field arithmetic. Perhaps using `I2OSP()` is an anti-pattern, given current trends in cryptographic code design?\r\n\r\nHere are a few ways we might resolve this issue:\r\n\r\n1. Keep the current big-endian encoding for all fields. In order to be compatible with the draft, an implementation of `IdpfPoplar` that uses an existing implementation of `GF(2^255-19)` may need to adjust the encoding.\r\n2. Use little-endian for all fields. This would make it convenient to use existing implementations of `GF(2^255-19)`. Of course, this would require changing the other fields defined in the draft. However, these fields are new and there are no optimized implementations of them yet. (For what it's worth, the choice to use `I2SOP()` was somewhat arbitrary.  We noticed that it was used for other drafts, like [hash-to-curve](https://datatracker.ietf.org/doc/draft-irtf-cfrg-hash-to-curve/), and it seemed like a good idea to crib on prior work.)\r\n3. Allow each field to specify its own encoding. The potential downside here is code complexity. (It's nice when there is only one way to do a thing.)\r\n4. If we decide not to be prescriptive about encoding (cf. #58), then this is issue is somewhat less relevant. However we would still need to specify how to encode field elements that are used as inputs to other cryptographic operations. This may or may not end up mattering for `GF(2^255-19)`.",
      "createdAt": "2022-06-21T23:41:24Z",
      "updatedAt": "2023-03-01T16:18:17Z",
      "closedAt": "2023-03-01T16:18:17Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Currently I'm inclined to take option (2.), but I would like to understand better why `I2SOP()` was designed the way it is. As it comes from [RFC 3447](https://datatracker.ietf.org/doc/html/rfc3447), we can infer that it was developed in a world in which all keys read from the wire are RSA moduli. In this world, big-endian probably seems sensible because it would allow you consume the RSA modulus from the wire one byte a time without buffering it. This is less relevant to us because we need to decode numbers whose sizes are constant (cf. `Field.ENCODED_SIZE`) and relatively small (<=32 bytes).",
          "createdAt": "2022-06-21T23:47:08Z",
          "updatedAt": "2022-06-21T23:47:08Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here are my two cents,\r\nI think is better do not to specify any encodings, unless they are part of the _cryptographic protocol_ (and not of the communication protocol).\r\nFor example, if some element needs to be serialized because it will be an input of a hash function, then an encoding should be explicitly enforced. (here it does not matter which on is used).\r\n\r\nApplications could be free to choose the encoding for the communication protocol. For interoperability between applications an encoding could be recommended, but not enforced.\r\nFor test vectors, an encoding could be chosen only for the test code.",
          "createdAt": "2022-06-22T01:41:32Z",
          "updatedAt": "2022-06-22T01:41:32Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I2OSP seems to be omnipresent in all crypto libraries, mainly due to RSA and friends.\r\n\r\nThe little-endian seems to be relevant for Fp25519 and other optimized implementations. But in fact, optimized implementations actually represent field elements with multiple words and with redundancy, so the byte representation is not so important and it is only used at transport.\r\n",
          "createdAt": "2022-06-22T01:46:35Z",
          "updatedAt": "2022-06-22T01:46:35Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> Here are my two cents, I think is better do not to specify any encodings, unless they are part of the _cryptographic protocol_ (and not of the communication protocol). For example, if some element needs to be serialized because it will be an input of a hash function, then an encoding should be explicitly enforced. (here it does not matter which on is used).\r\n\r\nAs I mentioned at the top, in Prio3, vectors of field elements are used as input for a hash function.\r\n\r\n\r\n",
          "createdAt": "2022-06-22T03:45:23Z",
          "updatedAt": "2022-06-22T05:46:10Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Consensus from meeting today: Let's go with little endian.",
          "createdAt": "2023-02-16T21:06:07Z",
          "updatedAt": "2023-02-16T21:06:07Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "I_kwDOGKuqOc5MmB6-",
      "title": "Pass the number of reports to agg_shares_to_result()",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/92",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "divergentdave"
      ],
      "labels": [
        "draft-02"
      ],
      "body": "Inspired by the discussion on divviup/libprio-rs#256, I propose that the number of reports should be added as an argument to `agg_shares_to_result()` for DAFs and VDAFs. This would be useful in Prio for any AFE where the encoding does not preserve the additive identity. (or doesn't map some other identity to the additive identity) In such cases, then the unsharding algorithm could cancel out whatever constant term got added by every client's input. Any application using VDAF should already know how many reports contributed to one aggregate, we just need to expose it back down to the VDAF layer.\r\n\r\nNote that this would also enable computing an average \"inside the VDAF\" rather than computing a sum and leaving it to the application to compute the average from that. This is more trivial than remapping [-1, 1] to [0, 2^n], as in the example that motivated this.\r\n\r\nWhile it would be technically possible for an application to reverse the [-1, 1] to [0, 2^n] mapping, if given just a raw sum from Prio and a priori knowledge of the number of reports (by dividing by 2^(n-1) and subtracting num_reports), I think it would be more user-friendly if we made it possible for the unsharding step to do so. The postprocessing necessary for the averaging use case is easy enough to write out by hand, this fixed-point with offset encoding is slightly more difficult, but generally, AFE encodings could include multiple such encoded numbers, or even nonlinear functions composed with affine remappings. (The Prio paper includes examples of calculating a product or geometric mean. This would be done by taking a logarithm of the input, and this logarithm would most likely need to be encoded as a fixed point number with an offset.) For this reason, I think we should provide this number of reports to `agg_shares_to_result()`, so that unsharding can be \"as powerful as\" sharding, and applications won't have to concern themselves as much with the encoding details of particular more complicated VDAFs.\r\n\r\ncc @MxmUrw",
      "createdAt": "2022-06-26T21:35:47Z",
      "updatedAt": "2022-07-10T00:13:06Z",
      "closedAt": "2022-07-10T00:13:05Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "This sounds like a reasonable change to me. My only worry would be scope creep, however a (V)DAF already explicitly defines the type of aggregate result, so I don't this actually changes the scope of the draft. It seems like this is likely to be useful for other types as well.\r\n\r\nBarring objections from @schoppmp or @bifurcation, I think this is a clear win. Would either @divergentdave or @MxmUrw care to start working on a PR? Ideally this PR would also make the corresponding change to the reference implementation.",
          "createdAt": "2022-06-27T18:32:04Z",
          "updatedAt": "2022-06-27T18:32:04Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, I can write one up later this week",
          "createdAt": "2022-06-27T18:45:33Z",
          "updatedAt": "2022-06-27T18:45:33Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good, no objection from my side.",
          "createdAt": "2022-06-28T11:27:46Z",
          "updatedAt": "2022-06-28T11:27:46Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #95.",
          "createdAt": "2022-07-10T00:13:05Z",
          "updatedAt": "2022-07-10T00:13:05Z"
        }
      ]
    },
    {
      "number": 94,
      "id": "I_kwDOGKuqOc5MvfOB",
      "title": "Accommodations for differential privacy",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/94",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial",
        "draft-09"
      ],
      "body": "We wish for the VDAF draft to have first-class support for schemes that are amendable to differential privacy (DP). The task for this issue is to identify what changes need to be made, if any, to accommodate DP. In addition, we should consider adding guidance to the draft about best practices.",
      "createdAt": "2022-06-28T15:22:45Z",
      "updatedAt": "2024-05-06T13:36:26Z",
      "closedAt": "2024-05-06T13:36:26Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "At a minimum, I imagine we will need a way for:\r\n(a) an Aggregator to add noise to its aggregate share\r\n(b) a Client to add noise to its measurement\r\n\r\n(a) is straight-forward for both Prio3 and Poplar1 since the aggregate shares are vectors over some finite field. In general, I think all we'll need syntactically is that the set of all aggregate shares form a (semi-)group. The mechanism for (b) seems like it'll depend somewhat on the measurement type.\r\n",
          "createdAt": "2022-06-28T15:28:20Z",
          "updatedAt": "2022-06-28T15:28:20Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My intuition is that (b) would be out of scope for [V]DAF or DAP since the DP would be applied before `Vdaf.measurement_to_input_shares` and removed after `Vdaf.agg_shares_to_result`. So long as a noised input is still a valid encoding of a measurement, VDAF doesn't need to know about the DP, right?",
          "createdAt": "2022-06-28T17:20:26Z",
          "updatedAt": "2022-06-28T17:20:26Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that's probably right, except it may be desirable to add noise to the aggregate shares (a).",
          "createdAt": "2022-06-28T17:22:32Z",
          "updatedAt": "2022-06-28T17:24:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "Yeah, I think I agree with @tgeoghegan here. I think it makes sense to add discussion to this draft as to how clients might add local DP, and how, for example, deployments might use shuffling to amplify that DP effect, but both seem outside the scope of the draft. In contrast, (a) being an application of central DP seems like something squarely in scope?",
          "createdAt": "2022-06-28T17:33:45Z",
          "updatedAt": "2022-06-28T17:33:45Z"
        },
        {
          "author": "simon-friedberger",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe I am misunderstanding but I think for heavy hitters the distribution complicates things. Some of the finite field vector values are just too unlikely.\r\n\r\nIf I flip a bit in \"https://www.facebook.com\" I might end up with \"https://www.fa{ebook.com\" which doesn't add meaningful privacy from a client point of view and makes the value almost useless from a collector point of view.\r\n\r\nTo clarify: The client has no good way of adding DP randomness here for (b). For (a) the servers could still adjust the count for \"https://www.facebook.com\" by random +/-10 when computing the Private Subset Histogram solution for that string. So, doing (b) would also be difficult here.",
          "createdAt": "2022-06-29T12:16:29Z",
          "updatedAt": "2022-06-29T12:23:35Z"
        },
        {
          "author": "csharrison",
          "authorAssociation": "NONE",
          "body": "Note I wrote a bit of my thoughts on how we might want to do this in the DAP repo at https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/issues/19#issuecomment-1118837160.\r\n\r\nA few relevant points from that discussion:\r\n- Do we even want to add noise addition to VDAF vs. specify it in DAP (my preference is to do it in VDAF)\r\n- Are we concerned about malicious helpers adding \"bad\" noise shares such that we would want to \"verify\" the noise shares (I think we don't need this given our threat model)\r\n\r\n@simon-friedberger I agree for the heavy hitters problem the client side noise addition is difficult. Your observation that a single bit flip in \"facebook.com\" doesn't add privacy is correct, the DP analysis would agree with you. You need to flip many bits in the entire (high entropy) output domain. However, remember that the privacy that we get is stronger than just the noise from a single client, we just want to achieve good privacy after aggregation (when everything is back in cleartext).\r\n\r\nThe biggest problem I see with client-side noise is that the poplar protocol (as far as I can tell) only really works with one-hot input vectors. This means that a RAPPOR-like randomizer similar to [ENPAs](https://covid19-static.cdn-apple.com/applications/covid19/current/static/contact-tracing/pdf/ENPA_White_Paper.pdf) which randomly flips many bits independently in the whole domain would mean constructing tons of dpf keys (scaling linearly with the domain size) on the client for each noisy \"1\", leading to large communication and processing overhead.\r\n\r\nThere may be solutions here using different local randomizers, but I think it's hard to get around the domain size problem (e.g. regular randomized response will guarantee you that you only send a one-hot vector, but then the _noise_ scales with the domain size)",
          "createdAt": "2022-06-29T13:47:27Z",
          "updatedAt": "2022-06-29T13:47:27Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "For what it's worth, the [Poplar paper](https://arxiv.org/pdf/2012.14884.pdf) describes how to add noise for (a) in Appendix E. It may be the case that this is sufficient for reasonable measures of privacy, without requiring the client to do anything.",
          "createdAt": "2022-06-29T15:05:24Z",
          "updatedAt": "2022-06-29T15:05:34Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for bumping that thread, @csharrison.\r\n\r\n> * Do we even want to add noise addition to VDAF vs. specify it in DAP (my preference is to do it in VDAF)\r\n\r\nI agree, I think the mechanism needs to live in VDAF-land. However, ideally this would require only minimal syntax changes (e.g., as suggested for (a) here: https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/94#issuecomment-1168872702) and would leave it up to applications (like a DAP deployment) to tune noise as needed. The VDAF draft could also provide detailed recommendations for adding local DP, or central DP, or both (if applicable) to the VDAFs it specifies.\r\n\r\n> * Are we concerned about malicious helpers adding \"bad\" noise shares such that we would want to \"verify\" the noise shares (I think we don't need this given our threat model)\r\n\r\nI think this threat model only matters insofar as it impacts privacy. For correctness, we already concede that all of the Aggregators are trusted to execute the protocol correctly.\r\n\r\n",
          "createdAt": "2022-06-29T15:07:52Z",
          "updatedAt": "2022-06-29T15:10:54Z"
        },
        {
          "author": "csharrison",
          "authorAssociation": "NONE",
          "body": "> For what it's worth, the [Poplar paper](https://arxiv.org/pdf/2012.14884.pdf) describes how to add noise for (a) in Appendix E. It may be the case that this is sufficient for reasonable measures of privacy, without requiring the client to do anything.\r\n\r\nYeah this is the standard way we'd add DP in the central model. I think there may be ways to optimize the noise in that section with (discretized) gaussian/skellam noise instead of Laplace too (see https://desfontain.es/privacy/gaussian-noise.html for an intro). \r\n\r\nI also think that section assumes each noisy prefix is published publicly, which I don't think is necessarily the view of the collector in the poplar vdaf (would need to double check that).",
          "createdAt": "2022-06-29T16:04:22Z",
          "updatedAt": "2022-06-29T16:06:46Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@schoppmp and I have been working on completing the spec for Poplar1 (#84). Once that's done, I think a great first step would be to add a subsection that spells out recommendations for adding DP to the heavy hitters computation. @csharrison would you be willing to spend time on this?\r\n\r\nAlternatively, we could get cracking on Prio3 right away.",
          "createdAt": "2022-06-29T16:24:15Z",
          "updatedAt": "2022-06-29T16:33:15Z"
        },
        {
          "author": "csharrison",
          "authorAssociation": "NONE",
          "body": "> @schoppmp and I have been working on completing the spec for Poplar1 (#84). Once that's done, I think a great first step would be to add a subsection that spells out recommendations for adding DP to the heavy hitters computation. @csharrison would you be willing to spend time on this?\r\n\r\nI am actually on pat leave right now until late Aug so unfortunately I can't spend much time on this (just enough free time to bug ya'll on issues \ud83d\ude04 )  . Let's just make sure what's specified in the poplar paper is possible and I might be able to help out when I get back. In general, I think we want to consider:\r\n- Alternative noise mechanisms other than Laplace (this should be pretty simple)\r\n- Configurations where noise is only added at the last step of the heavy hitters protocol, vs. adding it to every prefix and publishing those prefixes publicly (this means that a malicious server could publish non-DP prefix counts, which may be OK in some deployments).",
          "createdAt": "2022-06-29T17:16:51Z",
          "updatedAt": "2022-06-29T17:20:54Z"
        },
        {
          "author": "kunal-talwar",
          "authorAssociation": "NONE",
          "body": "I think it would be worth supporting both (a) and (b). \r\nFor (a), having an option to add central DP noise to the aggregate makes sense, and can perhaps be implemented as part of Daf.out_shares_to_agg_share() and this can be specified in each VDAF.\r\nFor (b): there are many ways of doing local randomization which are compatible with prio/poplar. In particular, for frequency estimation / heavy hitters, when working over a small universe, RAPPOR can be used in conjunction with pro. Over larger universes, PI-RAPPOR (https://arxiv.org/abs/2102.12099) and ProjectiveResponse (https://arxiv.org/abs/2203.00194) can be used to randomize to a one-hot vector over a smaller domain. This makes these well-compatible with prio or poplar, and I could imagine, for example, pi-rappor+poplar to be a useful VDAF.\r\nThe shuffling/aggregation based privacy amplification results though depend on a the batch over which we are summing to be large enough. This application therefore would make a strong case to have the min_batch_size be a natively supported feature in DAP. E.g. it would be great to have a way for the task parameter to specify just the minimum batch size and have the servers agree on a batch boundary that is close to getting this minimum batch size, without having to predict the batch interval in advance.",
          "createdAt": "2022-06-29T21:24:37Z",
          "updatedAt": "2022-06-29T21:24:37Z"
        },
        {
          "author": "csharrison",
          "authorAssociation": "NONE",
          "body": "@kunal-talwar I would love to hear more about how concretely we could compose e.g. pi-rappor with poplar. It seems very non-obvious to me but I might be missing something. In pi-rappor we're sending some seed to the server, are you saying we'd encode this seed as a one-hot vector and aggregate over seeds in the VDAF?\r\n\r\nI hadn't seen the paper on ProjectiveReponse, will need to read it \ud83d\ude04 . In general though I agree with you about supporting both (a) and (b). The most obvious candidate requiring (b) support is the existing ENPA system.",
          "createdAt": "2022-06-30T03:15:00Z",
          "updatedAt": "2022-06-30T03:15:00Z"
        },
        {
          "author": "kunal-talwar",
          "authorAssociation": "NONE",
          "body": "It is indeed not obvious (or at least wasn't obvious to me at first). But an approach along the lines you suggested works. We send the seed using poplar, and can either aggregate the seeds, or decode each seed to a vector in the original domain and aggregate those. The generalized version of PI-RAPPOR can allow additional efficiencies on top of this basic approach. We have a write-up that should be on the arxiv in a couple of weeks.",
          "createdAt": "2022-06-30T15:30:44Z",
          "updatedAt": "2022-06-30T15:30:44Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Great discussion, I'm very happy to see engagement on this draft from folks who are deep in differential privacy. Something to keep in mind here is that this document will be developed by the CFRG (\"Cryptography Forum Research Group\"), which, to my knowledge, has not done a lot with DP as of yet. Thus I think a useful goal would be to ensure that (V)DAFs are compatible with a variety of mechanisms for (a) and (b), but without being too prescriptive about a particular mechanism.\r\n\r\nThat said, @kunal-talwar we would welcome text in the document that describes how some of these methods might be applied to either Prio3 or Poplar1. Such text would be maximally useful if it also provided a gentle introduction to the method described.",
          "createdAt": "2022-07-08T14:47:22Z",
          "updatedAt": "2022-07-08T14:47:22Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Just to follow up here: It's very likely that the VDAF draft is going to say nothing about DP. Our idea right now is to encapsulate the details of composing DP with a VDAF into a \"DP policy\" that would be used by DAP. We're working on a draft for PPM: https://github.com/wangshan/draft-wang-ppm-differential-privacy/\r\n\r\nIf adopted, I'll close this issue.",
          "createdAt": "2023-10-17T01:16:57Z",
          "updatedAt": "2023-10-17T01:16:57Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "As of this writing, PPM has not reached consensus about adopting https://github.com/wangshan/draft-wang-ppm-differential-privacy/. It's clear however that folks think there is something to be done about differential privacy, and that PPM is the right place to do it. It also seems fairly clear that whatever needs to be specified for DP is orthogonal to the VDAF draft.\r\n\r\nI'm going to close this issue after clarifying in the draft that DP is out-of-scope and emphasizing that VDAFs can be made differentially private.",
          "createdAt": "2024-01-25T17:48:35Z",
          "updatedAt": "2024-01-25T17:48:35Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi folks, I've put up a PR to resolve this issue. Basically it says that VDAFs SHOULD be composed with a DP mechanism, but leaves it to the application. We don't need any changes to this draft.",
          "createdAt": "2024-05-01T21:18:50Z",
          "updatedAt": "2024-05-01T21:18:50Z"
        }
      ]
    },
    {
      "number": 101,
      "id": "I_kwDOGKuqOc5Nj8Zm",
      "title": "Guidance for encoding IDPF index",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/101",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial",
        "draft-10"
      ],
      "body": "IDPFs (and Poplar1 by extension) take in an \"index\" `alpha` represented as an `Unsigned`. @bifurcation pointed out in https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/97#discussion_r918280713 that we also call this a \"bit-string\", which is ambiguous. The draft needs guidance on how applications should represent bit strings as IDPF indexes.",
      "createdAt": "2022-07-11T21:48:30Z",
      "updatedAt": "2024-06-06T21:22:38Z",
      "closedAt": "2024-06-06T21:22:38Z",
      "comments": []
    },
    {
      "number": 102,
      "id": "I_kwDOGKuqOc5OxfY4",
      "title": "Review: Henry Corrigan-Gibbs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/102",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "draft-05"
      ],
      "body": "@henrycg reviewed draft 02 and sent his feedback privately via an email. \r\n\r\n- [x] In the introduction, point out that VDAF can provide DP in addition to MPC-style security. (See also #94.)\r\n- [x] Section 6.1.2: \"Large subgroup\": Say exactly how large the group needs to be. (2^20-ish is going to be sufficient, I think.)\r\n- [x] Section 7.2.2: There is an attack on the soundness of Prio3 stemming from a bug in [the paper](https://eprint.iacr.org/2019/188). The paper has been updated with a patch.\r\n- [x] #177\r\n- [x] Fiat-Shamir: Use circuit codepoints for domain separation.\r\n- [x] Section 8: We should flag early on in this section that, when used multiple times, Poplar1 has leakage (via prefix hit counts) that other VDAFs don't necessarily suffer from in the same way.\r\n- [x] #179",
      "createdAt": "2022-07-28T23:38:49Z",
      "updatedAt": "2023-03-10T16:58:14Z",
      "closedAt": "2023-03-10T16:58:14Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "All tasks for VDAF-03 are complete. What remains are editorial changes and additional security considerations for Poplar1.",
          "createdAt": "2022-08-24T22:10:44Z",
          "updatedAt": "2022-08-24T22:10:44Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Remaining work is purely editorial; let's try to land by 05.",
          "createdAt": "2023-02-28T20:57:08Z",
          "updatedAt": "2023-02-28T20:57:08Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "I_kwDOGKuqOc5PCdG0",
      "title": "Prio3: Use circuit ID for domain separation.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/103",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-08-02T15:40:58Z",
      "updatedAt": "2022-08-02T15:41:12Z",
      "closedAt": "2022-08-02T15:41:12Z",
      "comments": []
    },
    {
      "number": 106,
      "id": "I_kwDOGKuqOc5P6OQM",
      "title": "Securely instantiating the PRG",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/106",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "draft-04"
      ],
      "body": "In Prio3, `PrgAes128.derive_seed()` is used with a fixed seed for the Fiat-Shamir heuristic. We need to decide if this is safe. It would be sufficient to prove, say, that this function is indifferentiable from a random oracle when modeling AES as an ideal cipher.\r\n\r\nNote that we might end up picking a PRG in #32 that is already safe a safe choice here, in which case we should just replace `PrgAes128`.",
      "createdAt": "2022-08-16T17:24:49Z",
      "updatedAt": "2023-02-09T02:58:50Z",
      "closedAt": "2023-02-09T02:58:50Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "TODO:\r\n- [ ] Add Prg variant based on SHA-3 (SHAKE)\r\n- [ ] Either dump PrgAes128 or replace it with a is fixed-key alternative and can instantiate Prg.",
          "createdAt": "2022-12-02T18:39:49Z",
          "updatedAt": "2022-12-02T18:53:52Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "https://eprint.iacr.org/2019/074.pdf\r\nhttps://eprint.iacr.org/2022/1431.pdf",
          "createdAt": "2022-12-02T19:06:28Z",
          "updatedAt": "2022-12-02T19:06:28Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I put together a couple prototypes of PRG alternatives in libprio: https://github.com/divviup/libprio-rs/compare/cjpatton/prg-prototypes\r\n\r\nOne is based on KangarooTwelve (a CFRG spec) and the other is based on SHA-3 (SHAKE128). Initial benchmarks are encouraging. The following table shows Prio3CountVec shard time on my laptop for various input lengths with no multithreading:\r\n\r\n| PRG | 100 | 1000 | 10,000 |\r\n| - | - | - | - | \r\n| PrgAes128 (status quo) | 149.72 us | 3.13 ms | 22.6 ms |\r\n| PrgK12 (KangarooTwelve) | 156.69 us | 3.15 ms | 22.7 ms | \r\n| PrgSha3 (SHA-3) | 171.14 us | 3.21 ms | 23.6 ms |\r\n\r\nWe still need to benchmark Poplar1. The implementation is WIP: https://github.com/divviup/libprio-rs/pull/381\r\n\r\n\r\n",
          "createdAt": "2023-01-05T02:12:53Z",
          "updatedAt": "2023-01-05T02:12:53Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Per @simon-friedberger's request, I've updated the benchmark branch of libprio with a PRG based on HKDF-SHA256. I played around with a few variants, all are roughly as performant:\r\n\r\n| PRG | 100 | 1000 | 10,000 | \r\n| - | - | - | - | \r\n| PrgHkdfSha256 | 465.88 us | n/a | n/a |\r\n\r\n(Note that input sizes of 1000 and 10,000 exceed the the maximum output length for HKDF-SHA256.)\r\n\r\nThe performance is quite bad compared to the other algorithms. I'm not sure if we're using a software implementation of SHA-256, but if we are, these numbers aren't too surprising given how much hashing is involved in HKDF. ",
          "createdAt": "2023-01-19T19:25:30Z",
          "updatedAt": "2023-01-19T19:25:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@divergentdave and I have been working on Poplar1 in libprio: https://github.com/divviup/libprio-rs/pull/434\r\n\r\nWe're still working on benchmarks, but so far it looks like SHA-3 is up to 40% more expensive than `PrgAes128`. This confirms @schoppmp's hypothesis that Prio is arithmetic-bound and Poplar is PRG-bound.",
          "createdAt": "2023-01-30T23:35:18Z",
          "updatedAt": "2023-01-30T23:35:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "We have merged the basic functionality for Poplar1 into libprio (\ud83c\udf89). I have also updated my PRG prototypes branch (https://github.com/divviup/libprio-rs/compare/cjpatton/prg-prototypes) with benchmarks with Poplar1 using the current `PrgAes128` and the alternative `PrgSha3`. The table below summarizes shard and preparation timings for both variants and for various bit lengths.\r\n\r\n| PRG | 16 bits | 64 bits | 128 bits | 256 |\r\n|-|-|-|-|-|\r\n| PrgAes128 shard time | 49.4 us | 143.8 us | 270.6 us | 519.5 us |\r\n| PrgSha3 shard time | 49.2 us | 143.8 us | 268.9 us | 518.2 us |\r\n| PrgAes128 prep time | 438.2 us | 1.4 ms | 2.7 ms | 5.3 ms |\r\n| PrgSha3 prep time | 667.0 us | 2.4 ms | 4.5 ms | 8.9 ms |\r\n\r\n(*) For prep time, we're measuring the time it takes for an Aggregator to evaluate an IDPF share and compute its sketch share. We are evaluating at the last level the three, which exhibits worst case performance. Prep time is sensitive not only to the the number of candidate prefixes, but the distribution. This is because the IDPF evaluation caches intermediate results. To compute the candidate prefixes, we sample 1000 measurements from a Zipf distribution (as suggested by the original Poplar paper) and compute the prefix tree for threshold = 10.\r\n\r\nObservations:\r\n1. There is no significant difference between the shard times, regardless of the input length. (Good news for the Client.)\r\n2. For the range of bit lengths tested, prep time regresses by as much as 67%.\r\n\r\nCaveats:\r\n1.  We are still investigating the best caching strategy for IDPF evaluation (https://github.com/divviup/libprio-rs/issues/441). We expect we will be able to improve performance, at least somewhat, across the board.\r\n2. If the application can cache per-report IDPF state, then much of this runtime would be amortized across all of the levels.",
          "createdAt": "2023-02-03T06:59:40Z",
          "updatedAt": "2023-02-03T06:59:40Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "**Conclusion:** SHA-3 performs well enough in all situations except IDPF evaluation. There the performance hit is significant enough to warrant investigating an alternative that has hardware support.I propose focusing #32 on this question. Further, there is no need to design to the `Prg` API; something designed specifically for IDPF would make sense.\r\n\r\nIn the meantime, I propose we go ahead with replacing `PrgAes128` with something based on SHA-3. Here is my proposal: https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/136",
          "createdAt": "2023-02-03T07:02:21Z",
          "updatedAt": "2023-02-03T07:02:21Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "I_kwDOGKuqOc5QRUbq",
      "title": "Poplar1 aggregation parameters reveal information about submitted measurements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/109",
      "state": "CLOSED",
      "author": "branlwyd",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I believe that Poplar1 aggregation values are sensitive in the sense that they are prefixes of the most common values reported by clients. This makes them the only data exposed to aggregators which directly reveals information about the set of measurements being aggregated.\r\n\r\nAssuming the above is accurate, I think it would be nicer if the aggregators were not exposed to measurement information. Would this be a realistically feasible change?\r\n\r\n(edit: this fell out of discussion on https://github.com/divviup/janus/pull/417)",
      "createdAt": "2022-08-22T16:54:35Z",
      "updatedAt": "2022-08-23T17:17:25Z",
      "closedAt": "2022-08-23T17:10:40Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Unfortunately this problem is inherent to the construction. See the \"Limitations\" subsection from the intro of [the paper](https://eprint.iacr.org/2021/017.pdf).\r\n\r\nIt's possible that there is a different VDAF that doesn't have this issue, but we don't have one today.\r\n\r\n[STAR](https://datatracker.ietf.org/doc/draft-dss-star/) is an alternative to DAP/Poplar1 for computing heavy hitters. It doesn't have the problem of leaking intermediate data to Aggregators, however the trust model is different.",
          "createdAt": "2022-08-23T16:24:19Z",
          "updatedAt": "2022-08-23T16:24:19Z"
        },
        {
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, given that this is a known limitation of poplar1, I don't think leaving an open-but-unresolved/unresolvable issue around is useful. A different VDAF would be nice, but that is a far larger change (and wouldn't be tracked through this issue anyway).",
          "createdAt": "2022-08-23T17:10:40Z",
          "updatedAt": "2022-08-23T17:10:40Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "I_kwDOGKuqOc5QW-a7",
      "title": "Complete IANA considerations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/110",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "pre-RGLC"
      ],
      "body": "As of VDAF-03, the draft has codepoints intended to be used by other drafts (e.g., DAP). These are currently summarized in a table `{{codepoints}}`. This is good enough for now, but eventually we'll need to flesh this out into a section that IANA can actually use. @bifurcation points to an example of how to do this properly:  https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/104#discussion_r948280200_",
      "createdAt": "2022-08-23T16:14:29Z",
      "updatedAt": "2024-06-06T22:42:00Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 113,
      "id": "I_kwDOGKuqOc5QeaxT",
      "title": "Merge field parameters into one table",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/113",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial",
        "draft-05"
      ],
      "body": "",
      "createdAt": "2022-08-25T00:15:28Z",
      "updatedAt": "2023-02-27T19:57:52Z",
      "closedAt": "2023-02-27T19:57:52Z",
      "comments": []
    },
    {
      "number": 114,
      "id": "I_kwDOGKuqOc5RsQ7N",
      "title": "Note: in Prio3, clients duplicate hints",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/114",
      "state": "CLOSED",
      "author": "hannahdaviscrypto",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "draft-04"
      ],
      "body": "In Prio3, the client generates a \"hint\" for each aggregator to help derive the joint randomness. These hints need to be communicated to all aggregators in the start of preparation, so the sharding algorithm encodes the entire list into each input share. If there are s aggregators, the client's message length will be quadratic in s: s hints * s input shares. This seems fine for s=2, but if applications where s > 2 are targeted, we may want to consider other encodings.",
      "createdAt": "2022-09-12T21:49:56Z",
      "updatedAt": "2023-01-09T23:57:36Z",
      "closedAt": "2023-01-09T23:57:36Z",
      "comments": [
        {
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A possible alternative for s>2: VDAF already supports a \"public share\" that the leader broadcasts to all aggregators, and Prio3 currently leaves this empty. We could have clients encode the hints in the public share so they are only sent once by the client. If authentication of the hints is needed, the client could encode some part of its joint randomness within each input share as a confirmation, which would preserve linear communcation  in s between the client and leader.",
          "createdAt": "2022-09-12T21:52:07Z",
          "updatedAt": "2022-09-12T21:52:07Z"
        },
        {
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As I step away from my internship project, these are the two outstanding proposed changes for Prio3:\r\n\r\n1. Put the joint randomness hints into the public share instead of duplicating them in the aggregators' input shares, for the reasons described above. Additional authentication is unnecessary because in DAP, the public share is authenticated by HPKE.\r\n2. Follow every domain separation tag in a PRG call with a 1-byte domain separation value between 249 and 255. The existing domain separation tag performs domain separation between Prio3 and external uses of its PRG. In contrast, the new value separates domains between internal uses of the PRG in different parts of the scheme,. e.g., for generating joint vs query randomness. This value performs domain separation between the different uses of the PRG.",
          "createdAt": "2022-11-04T22:25:13Z",
          "updatedAt": "2022-11-04T22:25:13Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Solved by #121.",
          "createdAt": "2023-01-09T23:57:36Z",
          "updatedAt": "2023-01-09T23:57:36Z"
        }
      ]
    },
    {
      "number": 115,
      "id": "I_kwDOGKuqOc5RtGvM",
      "title": "Robustness against malicious Aggregators",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/115",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the early days of DAP (prior to the PPM working group forming) we kicked around using Shamir secret sharing to achieve robustness in the presence of malicious Aggregators. (See https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/issues/22.)  Although not in our current threat model, this is an interesting consideration for VDAFs. We might consider variant of Prio3 that achieves this, perhaps using Shamir, or perhaps using techniques described by [BBCGGI19].",
      "createdAt": "2022-09-13T02:55:56Z",
      "updatedAt": "2023-10-17T01:12:43Z",
      "closedAt": "2023-10-17T01:12:43Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Out-of-scope for us, but may be considered by other (modes of operation for) VDAFs, e.g., https://github.com/jimouris/draft-mouris-cfrg-mastic.",
          "createdAt": "2023-10-17T01:12:43Z",
          "updatedAt": "2023-10-17T01:12:43Z"
        }
      ]
    },
    {
      "number": 116,
      "id": "I_kwDOGKuqOc5RyKfv",
      "title": "Integers in test vectors are not encoded properly",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/116",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@divergentdave points out in https://github.com/cloudflare/daphne/issues/82#issuecomment-1246012727 that JSON libraries do not always parse large integers properly. Our test vectors have lots of large numbers (specifically the output shares), so there's a good chance that some implementation will misinterpret these. We will need to change the encoding so that they don't.\r\n\r\nThe tack taken in [the interop testing draft](https://github.com/divergentdave/draft-dcook-ppm-dap-interop-test-design) is to encode these as strings, and have the implementation convert to a big num.",
      "createdAt": "2022-09-13T23:11:46Z",
      "updatedAt": "2022-11-03T00:04:23Z",
      "closedAt": "2022-11-03T00:04:23Z",
      "comments": []
    },
    {
      "number": 118,
      "id": "I_kwDOGKuqOc5R4B97",
      "title": "Review: Hannah Davis",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/118",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc/ @hannahdaviscrypto\r\n\r\n- [ ] Prio3: Current construction admits an attack on robustness that results in at least a quadratic loss in security. This can be (provably) fixed by incorporating the nonce into the joint randomness computation: https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/117",
      "createdAt": "2022-09-14T22:11:39Z",
      "updatedAt": "2022-09-14T22:17:47Z",
      "closedAt": "2022-09-14T22:17:47Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Please copy this into a new issue so that you can track your changes.",
          "createdAt": "2022-09-14T22:15:18Z",
          "updatedAt": "2022-09-14T22:15:18Z"
        }
      ]
    },
    {
      "number": 119,
      "id": "I_kwDOGKuqOc5R7_Ny",
      "title": "Review: Hannah Davis: Potential for joint randomness repetition in Prio3",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/119",
      "state": "CLOSED",
      "author": "hannahdaviscrypto",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Prio3 uses a variant of the Fiat-Shamir transform to derive random coins for its underlying proof system from the inputs to each aggregator. However, this derivation doesn't include the nonce, which means that a malicious client can submit the same set of input shares multiple times under different nonces and they will be processed with the same joint randomness. This introduces a threat to robustness. As a toy example, there is a degenerate FLP that is sound with L bits of security when each set of input shares is submitted at most once, but is vulnerable to an 2^(L/2)-query attack if they can be submitted under many nonces.",
      "createdAt": "2022-09-15T15:05:48Z",
      "updatedAt": "2022-09-30T21:17:25Z",
      "closedAt": "2022-09-30T21:17:25Z",
      "comments": [
        {
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "body": "- [ ] Prio3: Current construction admits an attack on robustness that results in at least a quadratic loss in security. This can be (provably) fixed by incorporating the nonce into the joint randomness computation: https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/117",
          "createdAt": "2022-09-15T15:11:32Z",
          "updatedAt": "2022-09-15T15:11:32Z"
        }
      ]
    },
    {
      "number": 122,
      "id": "I_kwDOGKuqOc5TiWLX",
      "title": "Performance and usability improvements for Poplar1",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/122",
      "state": "CLOSED",
      "author": "hannahdaviscrypto",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "hannahdaviscrypto"
      ],
      "labels": [
        "draft-04"
      ],
      "body": "The current Poplar1 algorithm requires two rounds of communication between the aggregators (leader and helpers) to verify that the client's input has the correct format. We may be able to reduce the number of rounds to 1 and the size of the messages in each round by replacing the malicious-secure sketching portion of the algorithm with a more lightweight MPC technique. This technique can also expand the set of supported formats from one-hot binary vectors to one-hot vectors with a small bound on the nonzero element.",
      "createdAt": "2022-10-07T18:04:49Z",
      "updatedAt": "2023-01-27T23:09:48Z",
      "closedAt": "2023-01-27T23:09:48Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue is basically about specifying Doplar, which we're not going to do in this document. (At least not for now.) ",
          "createdAt": "2023-01-27T23:09:48Z",
          "updatedAt": "2023-01-27T23:09:48Z"
        }
      ]
    },
    {
      "number": 124,
      "id": "I_kwDOGKuqOc5XJZ-u",
      "title": "Sum of vectors with Prio3",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/124",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "divergentdave"
      ],
      "labels": [
        "feature"
      ],
      "body": "I think it would be useful to have a VDAF instantiation to sum vectors of integers. This has come up a few times in conversations as a useful primitive. We could define it with two parameters: the length of the vector in elements, and the bit width of each element, so that their range would be $[0, 2^{bits}-1)$. I presume that we'd be able to make similar improvements to proving time or proof size here as with the proposed [Prio3Aes128CountVec](https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/83), compared to running multiple independent `Prio3Aes128Sum` VDAF instances.",
      "createdAt": "2022-11-23T16:46:27Z",
      "updatedAt": "2023-08-17T22:29:24Z",
      "closedAt": "2023-08-16T01:51:58Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "SGTM! Queued for the next draft.",
          "createdAt": "2022-11-28T15:40:33Z",
          "updatedAt": "2022-11-28T15:40:33Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is [`Prio3Aes128SumVec`](https://github.com/divviup/libprio-rs/pull/420), right?",
          "createdAt": "2023-01-23T16:42:38Z",
          "updatedAt": "2023-01-23T16:42:38Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes. Question here: Are we OK with not landing this in VDAF-04? Since everyone who is using it in the foreseeable future is using libprio, there is not an immediate need to specify it here.",
          "createdAt": "2023-02-02T15:00:13Z",
          "updatedAt": "2023-02-02T15:00:13Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that's reasonable. Plus it'd be good to get some practical experience with it before we specify it.",
          "createdAt": "2023-02-02T16:27:53Z",
          "updatedAt": "2023-02-02T16:27:53Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "From offline discussion: we plan to make the parallel sum gadget \"chunk size\" an explicit parameter of the VDAF. This choice avoids having to specify an integer square root algorithm, plus it's possible that using a chunk size a bit above or below the square root of the total arity may be more optimal. See previous discussion starting at https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/83#issuecomment-1523703307.",
          "createdAt": "2023-07-13T15:04:24Z",
          "updatedAt": "2023-07-13T15:04:24Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "I was looking at the Prio3SumVec implementation currently in libprio-rs, to line it up with tactics from the BBCGGI19 paper, and I think we can further improve on its proof size. The validation circuit calculates $\\sum_i {r^{i+1}m_i}$, where r is a joint randomness value, and m is the measurement, in \u221an chunks of size \u221an, where n is the total number of bits in the measurement vector. It does so using a parallel sum gadget on the sub-circuit $C(x, y)=x(x-1)y$, assigning $x_i=m_i$ and $y_i=r^{i+1}$. To be more precise, this is done by setting the additive share of $y_i$ on each aggregator to $r^{i+1}s^{-1}$, where s is the number of shares. While this works, it is not necessary to use a degree of the sub-circuit to perform this multiplication by the joint randomness value. It is known by all parties, and can included with an affine constant multiplication gate (for free). We just have to entangle it with the $x^2-x$ polynomial evaluation differently.\r\n\r\nThe alternate circuit structure I'm proposing can be equivalently thought of in two ways, either as an inner product, to efficiently compute a degree-two relation (see section 4.3 of BBCGGI19), or as an optimization of a parallel-sum circuit, (see section 4.4) where the sub-circuit is just the Mul gate. As before, the circuit will output $\\sum_i {r^{i+1}m_i}$, and it will be split up into \u221an chunks of size \u221an. We let the sub-circuit be $C(x,y)=xy$, and then use affine gates to assign $x_i=r^{i-1}m_i$ and $y_i=m_i-1$. Note that the constant -1 will have to be split up between aggregators, either into 0 and -1, or into $-s^-1$ on each. This gets us the same circuit result, with a lower degree gadget polynomial, and thus shorter proofs. (Once this is done, it may be worth applying a similar optimization to the range check part of the Prio3Histogram circuit as well, now that we know we don't need to trade off a higher circuit degree for the more compact arrangement of wires and gadgets)\r\n\r\nI think it would make the most sense to describe the optimization for parallel-sum circuits, and then use it on Mul, as it is more general, and we would only skip the linear algebra part of section 4.3 (which is not even necessary for SumVec, since the circuit is already in an inner product form).",
          "createdAt": "2023-07-29T14:20:05Z",
          "updatedAt": "2023-07-29T14:20:05Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "This is an excellent idea! How do we generalize to vectors of integers in range `[0, 2^k)`, and not just bit-vectors?",
          "createdAt": "2023-08-01T19:04:54Z",
          "updatedAt": "2023-08-01T19:04:54Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is an excellent idea! How do we generalize to vectors of integers in range `[0, 2^k)`, and not just bit-vectors?\r\n\r\nThat mainly changes the encoding and decoding steps. (compared to the Prio3CountVec case) Encoding a vector of integers requires concatenating the bit-vector representation of each vector element, and decoding partitions the field vector in groups as long as the bit width, then does the powers-of-two weighted sum within each partition. At the validation circuit level, we're still checking that a vector of field elements are all either zero or one, so that part is unchanged.",
          "createdAt": "2023-08-01T19:12:14Z",
          "updatedAt": "2023-08-01T19:12:14Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes indeed. Let's do it.",
          "createdAt": "2023-08-01T19:39:09Z",
          "updatedAt": "2023-08-01T19:39:09Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's a notebook that demonstrates choosing an optimal parallel sum gadget chunk size for any given measurement size. Note that the optimal chunk size zigzags around the square root we RECOMMEND in the text. The second chart shows the resulting proof sizes.\r\n\r\nhttps://gist.github.com/divergentdave/a89fccd6375d9ac3d03cf5571709862d",
          "createdAt": "2023-08-17T21:57:41Z",
          "updatedAt": "2023-08-17T21:57:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's worth figuring out a way to convey this in an \"implementation\" note for the ParallelSum gadget.",
          "createdAt": "2023-08-17T22:29:24Z",
          "updatedAt": "2023-08-17T22:29:24Z"
        }
      ]
    },
    {
      "number": 125,
      "id": "I_kwDOGKuqOc5X0F4_",
      "title": "Improvements to IDPF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/125",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "feature"
      ],
      "body": "1. Richer output types (not just vectors of field elements, but field elements mixed with bitstrings)\r\n2. Level skipping",
      "createdAt": "2022-12-02T18:20:57Z",
      "updatedAt": "2023-10-25T18:48:14Z",
      "closedAt": "2023-10-25T18:48:13Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "This isn't needed immediately, so delay until the next draft.",
          "createdAt": "2023-02-08T00:57:46Z",
          "updatedAt": "2023-02-08T00:57:46Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "1. Doesn't seem necessary anymore.\r\n2. This would be an improvement in communication cost (shorter public share), but the savings aren't all that much.",
          "createdAt": "2023-10-25T18:48:13Z",
          "updatedAt": "2023-10-25T18:48:13Z"
        }
      ]
    },
    {
      "number": 127,
      "id": "I_kwDOGKuqOc5aaF0r",
      "title": "Specify nonce length",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/127",
      "state": "CLOSED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "draft-04"
      ],
      "body": "VDAF specifies a sharding algorithm [`VDAF.measurement_to_input_shares(measurement: Measurement, nonce: Bytes) -> (Bytes, Vec[Bytes])`](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-03#name-sharding-2). In practice, `nonce` is always 16 bytes (see the test vectors and the poc in this repo, as well as the implementation in `libprio-rs`), but this isn't spelled out anywhere in VDAF. The same way they specify the verify key length, VDAFs will need to specify the expected nonce length.",
      "createdAt": "2023-01-02T23:16:07Z",
      "updatedAt": "2023-02-21T17:07:33Z",
      "closedAt": "2023-02-21T17:07:33Z",
      "comments": []
    },
    {
      "number": 134,
      "id": "I_kwDOGKuqOc5dBFVL",
      "title": "Poplar1 improvements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/134",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "draft-04"
      ],
      "body": "After doing the VDAF security analysis and implementing Poplar1 in libprio, there are a few minor changes I think we should make to Poplar1:\r\n\r\n- [x] Don't mix field types for PRGs; use a different PRG for each field instead. This leads to some awkwardness in the implementation: https://github.com/divviup/libprio-rs/pull/429. **Closed by https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/137**\r\n- [ ] Consider using a distinct PRG instance for deriving correlated randomness shares at each level of the tree. That way the Aggregators don't have to \"fast-forward\" the PRG state for inner nodes. (We should only consider this if performance doesn't degrade on the Client side.) **WON'T FIX:** This turns out to be a performance hit for the Client. The difference on the server side is negligible.\r\n- [x] Don't incorporate aggregation parameter into verifier randomness computation; the level and nonce should suffice. **Closed by https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/138**\r\n- [x] Relabel domain separation bits along the lines of Prio3.\r\n- [x] Require candidate prefixes to be unique. (Mayble also require them to be in lexicographic order, to make this check easier to implement.) **Closed by https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/139**\r\n- [x] The encoded aggregation parameter includes the number of prefixes, which is limited to <2^16. Is this enough? **Closed by https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/143**\r\n- [x] Encoding of aggregation parameter is optional. We should emphasize a different approach, which would be more efficient for implementations that can cache per-report state: Just serialize \"prefix updates\". **Closed by https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/145**",
      "createdAt": "2023-01-27T23:40:04Z",
      "updatedAt": "2023-02-14T16:13:59Z",
      "closedAt": "2023-02-14T16:13:59Z",
      "comments": []
    },
    {
      "number": 140,
      "id": "I_kwDOGKuqOc5d5MUq",
      "title": "Security: Revise RECOMENDATION for picking verification key",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/140",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "draft-04"
      ],
      "body": "As pointed out [here](https://mailarchive.ietf.org/arch/msg/cfrg/-errBjFRvCqi7KuAxoZwH6iY4Vc/):\r\n\r\n> Some care is required in choosing the VDAF verification key. The\r\n> Aggregators may use any strategy they wish to exchange this key, but the\r\n> application MUST ensure that the key that is picked independently of the\r\n> reports. For DAP in particular, this means it is safe for the Leader to\r\n> pick the key and distribute it, but the Aggregators need to \"commit\" to the\r\n> verification key used for a given task and use the same key for the\r\n> duration of the task. (Rotation requires rolling the task configuration.)\r\n>\r\n> Unfortunately, this contradicts a current recommendation. From [1, Section\r\n> 9]:\r\n>\r\n> \"It is also possible to consider a stronger form of robustness, where the\r\n> attacker also controls a subset of Aggregators (see [BBCGGI19], Section\r\n> 6.3). To satisfy this stronger notion of robustness, it is necessary to\r\n> prevent the attacker from sharing the verification key with the Clients. It\r\n> is therefore RECOMMENDED that the Aggregators generate verify_key only\r\n> after a set of Client inputs has been collected for verification, and\r\n> re-generate them for each such set of inputs.\"",
      "createdAt": "2023-02-08T00:56:57Z",
      "updatedAt": "2023-02-21T17:54:15Z",
      "closedAt": "2023-02-21T17:54:15Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Another random here: We should pass `verify_key` to `run_vdaf()` in order to emphasize that the key must be picked before the measurements.",
          "createdAt": "2023-02-15T22:28:36Z",
          "updatedAt": "2023-02-15T22:28:36Z"
        }
      ]
    },
    {
      "number": 141,
      "id": "I_kwDOGKuqOc5d5NGv",
      "title": "Security: Clients MUST choose the nonce at random",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/141",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "draft-04"
      ],
      "body": "From [this post](https://mailarchive.ietf.org/arch/msg/cfrg/-errBjFRvCqi7KuAxoZwH6iY4Vc/):\r\n\r\n> Clients MUST choose the report nonce at random. This ensures the nonce is\r\n> unpredictable to a privacy attacker; and it reduces the chance of\r\n> collisions, which is required for robustness.\r\n\r\n",
      "createdAt": "2023-02-08T00:59:23Z",
      "updatedAt": "2023-02-21T17:38:26Z",
      "closedAt": "2023-02-21T17:38:26Z",
      "comments": []
    },
    {
      "number": 142,
      "id": "I_kwDOGKuqOc5d5Npj",
      "title": "Security: Poplar1: Do not aggregate at a report at a given level more than once",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/142",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "schoppmp"
      ],
      "labels": [
        "draft-04"
      ],
      "body": "This suggestion comes from [the analysis posted here](https://mailarchive.ietf.org/arch/msg/cfrg/-errBjFRvCqi7KuAxoZwH6iY4Vc/).",
      "createdAt": "2023-02-08T01:01:48Z",
      "updatedAt": "2023-02-24T22:34:32Z",
      "closedAt": "2023-02-24T22:34:32Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Consensus from meeting: Define \"equivalence classes\" for agg param and disallow use of the same class more than once\r\n\\",
          "createdAt": "2023-02-16T21:00:36Z",
          "updatedAt": "2023-02-16T21:00:36Z"
        }
      ]
    },
    {
      "number": 147,
      "id": "I_kwDOGKuqOc5eFPbA",
      "title": "Byte ordering of encoded bit strings",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/147",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "divergentdave"
      ],
      "labels": [
        "draft-04"
      ],
      "body": "There are two places where the document currently deals with encoding and decoding of bit strings, in IdpfPoplar's public share, which packs control bits, and the optional serialization of Poplar1's aggregation parameter, which contains many bit string prefixes packed together. In both cases, the encoding is phrased in terms of using `I2OSP` on an arbitrary precision integer. In the case of IDPF pubilc share correction word control bits, the integer is formed from the control bits in LSB-to-MSB order. In the case of Poplar1, the algorithm's measurement and aggregation parameter inputs are both defined as integers, ~~though it's apparent that the least significant bit is semantically first in this case as well~~. This serialization is confusing to the eye, and requires some extra effort from implementors to accommodate (typically, reversing the order of a byte array). I think we should switch the byte-endianness of these encodings to simplify implementations. It might be worthwhile to drop the arbitrary precision integer representation altogether, and instead describe the algorithms in terms of bit strings or boolean arrays.\r\n\r\nAs a concrete example, here's how twelve bits currently get encoded:\r\n\r\n```\r\nsage: binascii.hexlify(sagelib.idpf_poplar.IdpfPoplar.with_bits(6).encode_public_share([(b\"\", [Field2(0), Field2(1)], []), (b\"\", [Field2(1), Field2(0)], []), (b\"\", [Field2(0), Field2(0)], []), (b\"\", [Field2(1), Field2(1)], []), (b\"\", [Field2(1), Field2(0)], []), (b\"\", [Field2(0), Field2(1)], [])]))\r\nb'09c6'\r\n```\r\n\r\n|Level|Control bit index|Value|Encoded byte offset|Encoded bit position (LSB=0)|\r\n|---|---|---|---|---|\r\n|0|0|0|1|0|\r\n|0|1|1|1|1|\r\n|1|0|1|1|2|\r\n|1|1|0|1|3|\r\n|2|0|0|1|4|\r\n|2|1|0|1|5|\r\n|3|0|1|1|6|\r\n|3|1|1|1|7|\r\n|4|0|1|0|0|\r\n|4|1|0|0|1|\r\n|5|0|0|0|2|\r\n|5|1|1|0|3|",
      "createdAt": "2023-02-09T18:59:58Z",
      "updatedAt": "2023-02-21T22:16:58Z",
      "closedAt": "2023-02-21T22:16:58Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd be happy with this change, though I'm less certain about moving away from the representation of IPDF indices as integers.",
          "createdAt": "2023-02-09T19:13:19Z",
          "updatedAt": "2023-02-09T19:13:19Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": " I think we should use integers only if the particular integer type supports all methods we need (e.g., accessing individual bits), and if we need their semantics (e.g., we use them as indices, for counting, or similar). That might be the case for the IDPF index, which can correspond to an array index into the (fully evaluated) output domain. For control bits I'm less certain, and in my [C++ implementation](https://github.com/google/distributed_point_functions/blob/master/dpf/distributed_point_function.proto#L114) I actually just saved them as individual booleans.",
          "createdAt": "2023-02-10T18:19:41Z",
          "updatedAt": "2023-02-10T18:19:41Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Above, I said that the Poplar1 measurement and aggregation parameter use the same bit ordering as the packed control bits. This is incorrect, measurements have the first bits in the most significant part of the integer, while packed control bits have the first bits in the least significant part of the integer.\r\n\r\nIn `IdpfPoplar.gen()`, bits are extracted with `keep = (alpha >> (IdpfPoplar.BITS - level - 1)) & 1`. Similarly, in `IdpfPoplar.eval()`, bits are extracted with `bit = (prefix >> (level - current_level)) & 1`.\r\n\r\nIn `IdpfPoplar.encode_public_share()`, bits are combined with `packed_ctrl |= ctrl_cw[0].as_unsigned() << (2*level)`, etc. In `IdpfPoplar.decode_public_share()`, bits are extracted with `packed_ctrl & 1` and `(packed_ctrl >> 1) & ` followed by `packed_ctrl >>= 2`.",
          "createdAt": "2023-02-13T16:55:09Z",
          "updatedAt": "2023-02-13T16:55:09Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "I opened #151 to flip the IdpfPoplar public share's control bits around. I think there's no need to make any changes to the measurement or aggregation parameter based on the discussion here.",
          "createdAt": "2023-02-16T19:56:59Z",
          "updatedAt": "2023-02-16T19:56:59Z"
        }
      ]
    },
    {
      "number": 156,
      "id": "I_kwDOGKuqOc5fAZ0d",
      "title": "VDAF-04 chores",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/156",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "divergentdave"
      ],
      "labels": [
        "draft-04"
      ],
      "body": "- [x] Update change log\r\n- [x] Bump `VERSION`\r\n- [x] Regenerate test vectors\r\n- [x] Run spell checker",
      "createdAt": "2023-02-21T18:37:45Z",
      "updatedAt": "2023-02-24T21:15:17Z",
      "closedAt": "2023-02-24T21:15:17Z",
      "comments": []
    },
    {
      "number": 159,
      "id": "I_kwDOGKuqOc5fN-gB",
      "title": "Distinguish between PRGs and Random Oracles",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/159",
      "state": "CLOSED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "schoppmp"
      ],
      "labels": [
        "editorial"
      ],
      "body": "We currently have a single Prg interface, but we use it in places where either a PRG (in the cryptographic sense) or a Random Oracle is required. We should make clear which of these we need where.",
      "createdAt": "2023-02-23T20:40:59Z",
      "updatedAt": "2023-08-29T17:33:40Z",
      "closedAt": "2023-08-29T17:33:40Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "One potential solution is to dump the `Prg` API altogether and just hard-code SHA-3 in Prio3 and Poplar1 verification (we will have something else for IDPF; see #32). I think @bifurcation suggested this route might make sense? If SHA-3 is \"good enough\", then perhaps we don't need agility?",
          "createdAt": "2023-02-23T21:05:22Z",
          "updatedAt": "2023-02-23T21:05:22Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "Eventually hard-coding would make sense, yes. Should we make an effort though to limit it to where we actually need a random oracle? For example, the Prio version from ENPA uses an [AES-CTR based PRG](https://github.com/google/libprio-cc/tree/master/prio/prng), and I'm not sure if a random oracle / an XOF is actually needed there. Same for the places where we essentially extend a short random seed to a longer pseudorandom string.",
          "createdAt": "2023-02-23T21:59:34Z",
          "updatedAt": "2023-02-23T21:59:34Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Ideally we would -- admittedly our analysis in {{DPRS23}} is a bit heavy-handed with ROs :)\r\n\r\nI think the right way to prioritize changes here is based on performance evaluation. From what I've seen so far (see https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/106) it seems like the cost of SHA-3 over AES for Prio3 is negligible. This makes sense because the cost is dominated by FF arithmetic, not the PRG. My hunch is that the same is true for ENPA-Prio (aka [Prio2](https://github.com/divviup/libprio-rs/blob/main/src/vdaf/prio2.rs)), but I haven't actually looked closely at this.",
          "createdAt": "2023-02-23T23:49:42Z",
          "updatedAt": "2023-02-23T23:49:42Z"
        }
      ]
    },
    {
      "number": 163,
      "id": "I_kwDOGKuqOc5fTJa8",
      "title": "poc: copy.deepcopy does not work on class objects",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/163",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Various classes in the Sage implementation have class methods that pass the class object through `copy.deepcopy()`, and then modify the resulting object. This does not work as intended, because `cls` and `new_cls` both reference the same class object. (The `copy` module documentation says it \"does 'copy' functions and classes (shallow and deeply), by returning the original object unchanged; this is compatible with the way these are treated by the pickle module.\") I think we largely get away with this because the tests don't operate on more than one VDAF/PRG/IDPF at once. Some parts of the Prio3 test only work due to this issue, because they forget to call `.with_prg(...)`, and instead inadvertently use `cls.VERIFY_KEY_SIZE` set by a previous invocation.\r\n\r\nThere are a few ways we could fix this, and I think we'll want to use a combination, depending on the different parameters.\r\n\r\n* Reimplement these class methods to declare a class inline and return it, or dynamically create a class with the three-argument form of `type()`.\r\n* Drop these methods and move their inputs to constructor arguments.\r\n* Declare subclasses the normal way, and set class attributes on each subclass.",
      "createdAt": "2023-02-24T15:31:41Z",
      "updatedAt": "2023-03-16T19:42:09Z",
      "closedAt": "2023-03-16T19:42:09Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for digging into this. (I sort of hate Python for this purpose \ud83d\ude2c.) The thing we want to optimize for, I think, is to make it as easy as possible to copy-paste the reference code into the document. Secondarily, the reader should be able to understand the algorithm definitions without having to have background in Python semantics.\r\n\r\nWith these objectives in mind, I wonder if subclassing is the right way to go.",
          "createdAt": "2023-02-24T16:12:13Z",
          "updatedAt": "2023-02-24T16:12:13Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "I think subclassing makes sense for `with_prg()`, while for `with_bits()` and the like, I think constructor arguments would be better.",
          "createdAt": "2023-02-24T17:19:56Z",
          "updatedAt": "2023-02-24T17:19:56Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh yeah definitely :)",
          "createdAt": "2023-02-24T17:22:41Z",
          "updatedAt": "2023-02-24T17:22:41Z"
        }
      ]
    },
    {
      "number": 168,
      "id": "I_kwDOGKuqOc5fVeu5",
      "title": "`format_custom()` function signature is too long for ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/168",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial",
        "draft-05"
      ],
      "body": "<img width=\"774\" alt=\"image\" src=\"https://user-images.githubusercontent.com/3453007/221327722-5f39ae3e-287c-4334-8922-04e297967362.png\">\r\n",
      "createdAt": "2023-02-25T01:11:30Z",
      "updatedAt": "2023-02-27T19:57:52Z",
      "closedAt": "2023-02-27T19:57:52Z",
      "comments": []
    },
    {
      "number": 169,
      "id": "I_kwDOGKuqOc5fVgdN",
      "title": "Poplar1: Hoist decision from prep_next to prep_shares_to_prep",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/169",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "divergentdave"
      ],
      "labels": [
        "draft-05"
      ],
      "body": "Currently, the final sketch validity check is done in `prep_next()` on round 2. This check only depends on the prepare message, so we could hoist it into `prep_shares_to_prep()`, as we previously did for Prio3. If we made this change, and dropped the optimization that substitutes the empty string instead of zero vectors, this would simplify implementations by making prepare message lengths predictable from knowledge of any aggregator's prepare state.",
      "createdAt": "2023-02-25T01:24:27Z",
      "updatedAt": "2023-02-28T21:12:49Z",
      "closedAt": "2023-02-28T21:12:49Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds like a good change to me, but we do need to match the spec here I think. What does the spec say?",
          "createdAt": "2023-02-25T02:23:31Z",
          "updatedAt": "2023-02-25T02:23:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Oops, I thought you posted this to divviup/libprio-rs. SGTM.",
          "createdAt": "2023-02-25T02:24:22Z",
          "updatedAt": "2023-02-25T02:24:22Z"
        }
      ]
    },
    {
      "number": 173,
      "id": "I_kwDOGKuqOc5fkVH3",
      "title": "Specify randomness used for test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/173",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "draft-05"
      ],
      "body": "              Here is my pitch for fixing up the test vectors.\r\n\r\nUpdate the `Vdaf` API so that `measurement_to_input_shares` takes in `rand: Bytes[Vdaf.RAND_SIZE]`. Normally we would pick this value by calling `gen_rand(Vdaf.RAND_SIZE]`; but for test vectors, we fix the value.\r\n\r\nThis would allow us to exercise what we need for the IDPF correction words. It's not the *minimal* change required for this I think, but it's the easiest to understand.\r\n\r\nHow does this sound?\r\n\r\nIf you agree, let's close this PR and I'll open up a new one. (You can also handle it if you'd like to, but no pressure. I think your time is better spent updating libprio.)\r\n\r\n_Originally posted by @cjpatton in https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/162#issuecomment-1448413761_\r\n            ",
      "createdAt": "2023-02-28T16:06:11Z",
      "updatedAt": "2023-03-03T18:28:24Z",
      "closedAt": "2023-03-03T18:28:24Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Once the current PR stack is merged, all that remains is to propagate the changes to the draft.",
          "createdAt": "2023-03-02T15:56:38Z",
          "updatedAt": "2023-03-02T15:56:38Z"
        }
      ]
    },
    {
      "number": 176,
      "id": "I_kwDOGKuqOc5fluqC",
      "title": "poc: Use `Field64` to generate rejection test case",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/176",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This test is meant to help implementers validate their `Prg` implementations: https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/10249a87c17454e0bce52efc3cf2ddc608f5184f/poc/prg.sage#L132-L142\r\n\r\nIt uses a 96-bit field which is not used for any VDAF. Ideally the test would use a field that has to be implemented anyway.\r\n\r\nUse `Field64` for this test, as the modulus for this field is further away from the nearest bit boundary than either `Field128` or `Field255`, making it easier to find a test case through brute force search.\r\n\r\n",
      "createdAt": "2023-02-28T20:02:47Z",
      "updatedAt": "2023-03-02T00:14:12Z",
      "closedAt": "2023-03-02T00:14:11Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #182.",
          "createdAt": "2023-03-02T00:14:11Z",
          "updatedAt": "2023-03-02T00:14:11Z"
        }
      ]
    },
    {
      "number": 177,
      "id": "I_kwDOGKuqOc5fl_-q",
      "title": "Prio3: Consider using a smaller field and re-running the proof verification multiple times",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/177",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "albertpl"
      ],
      "labels": [
        "feature",
        "wire change"
      ],
      "body": "This would trade communication cost for CPU time.",
      "createdAt": "2023-02-28T20:55:36Z",
      "updatedAt": "2023-11-16T14:36:53Z",
      "closedAt": "2023-11-16T14:36:52Z",
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Summarizing some offline discussions: Running verification multiple times to improve soundness should work straightforwardly if there is no joint randomness. Once the report is fixed, the only coin that the soundness probabilities are evaluated over is the query randomness, and checking the polynomials at multiple points gives us independent events, so the protocol's overall soundness error would look something like the product of the soundness error from each query run.\r\n\r\nHowever, once we re-introduce joint randomness, the joint randomness values would be constant across each proof verification re-run, and thus the probability of repeated FLP verification detecting a dishonest submission is correlated. There's now another coin involved, and repeatedly running proof verification doesn't re-flip it. Thus, the soundness error you get from running proof verification repeatedly would be dominated by the terms that come from the joint randomness, and the overall soundness would not get exponentially better with more verifications. The query randomness values are used in polynomial identity tests that show that gadget input and output values are consistent, while the joint randomness values are used by validity circuits to compress intermediate values from multiple gadgets into a single field element. (typically, by computing a random linear combination of polynomials that are each zero for valid inputs) Concretely, a dishonest verifier could choose an invalid measurement, honestly evaluate all the gadgets in the validity circuit, and adversarially choose joint randomness blinds such that the circuit output is zero through cancellation. If they wanted to attack Prio3Sum, they could submit a measurement with, say, 2 in every \"bit\", and search until they find a joint randomness value that satisfies $x + x^2 + x^3 + ... + x^n = 0$. This would take an average of $\\approx(2^{32}/n)/2$ tries with Field32, which is feasible.\r\n\r\nWe could achieve reasonable soundness with smaller fields if we re-ran the validity circuit (and thus proof generation) multiple times with different joint randomness values, but this would cancel out the client-to-aggregator communication benefits of using a smaller field.\r\n\r\nFor each circuit that currently uses joint randomness, we could imagine dropping the compression step, and having validity circuits output a vector of field elements. This would increase both client-to-aggregator and aggregator-to-aggregator communication, but the tradeoff for using smaller fields might be worth it with moderately-sized circuits (i.e., only a few gadget evaluations).\r\n\r\nThose are the only tricks I can think of at the moment to get around this. Of course, they'd need further analysis.",
          "createdAt": "2023-03-02T23:18:09Z",
          "updatedAt": "2023-03-02T23:18:09Z"
        },
        {
          "author": "simon-friedberger",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@divergentdave Can we construct a new joint randomness for each verification using the iteration of the check as input? (Or just iteratively rehashing the joint randomness.)\r\n\r\nIIUC that should make no difference to an honest client while for a cheating client the $\\approx 2^{16}$ tries would multiply.",
          "createdAt": "2023-03-06T09:56:40Z",
          "updatedAt": "2023-03-06T09:56:52Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, deriving additional joint randomness values would not be an issue. The issue is what you do with the resulting values, because there's a soundness versus report size tradeoff. If you re-run proof generation multiple times and send a new set of proof shares for each joint randomness, then the shorter field elements and repeated proof shares cancel out, so that the report size is about the same as when you started. If you somehow sum up proof shares from each run to compress them, i.e. by checking a circuit that evaluates a sub-circuit at multiple points, then that leaves a lone 1/|F| term in the soundness error.",
          "createdAt": "2023-03-06T13:41:32Z",
          "updatedAt": "2023-03-06T13:41:32Z"
        },
        {
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@divergentdave we notice that, for some use cases, e.g. `SumVec`, the communication cost between clients/aggregators is dominated by the measurement shares, not proof shares. Since, in such case, the size of the measurement shares is $O(n)$, while the size of proof share is roughly $O(\\sqrt{n})$, where $n$ is the measurement length. Therefore, for such use cases, multiple proofs in smaller field can still lead to significantly smaller input shares (`Prio3InputShare`).\r\n\r\nHere is our proposal. \r\n\r\n\r\n## Proposal \r\nThe basic idea is similar to what you said above, i.e., to construct multiple independent proofs, using distinct set of prover randomness and joint randomness and accept the inputs only after all proofs are validated. Here we explain this idea by describing the changes from section 7.2 in [draft-irtf-cfrg-vdaf-06](https://datatracker.ietf.org/doc/draft-irtf-cfrg-vdaf/06/).\r\n1. We introduce a new optional parameter to represent the number of proofs, denoted as `PROOFS`, which is defaulted to one if not set.\r\n2. In `measurement_to_input_shares`, clients produce `PROOFS` proofs, each with a distinct set of prover randomness and joint randomness. \r\n    1. Clients create `PROOFS` number of prover randomness by deriving `PROVE_RAND_LEN * PROOFS` field elements, from the same seed\r\n    ```\r\n    prove_rands = Prio3.Prg.expand_into_vec(\r\n              Prio3.Flp.Field,\r\n              k_prove,\r\n              Prio3.domain_separation_tag(USAGE_PROVE_RANDOMNESS),\r\n              b'',\r\n              Prio3.Flp.PROVE_RAND_LEN * PROOFS,\r\n            )\r\n    ```\r\n    2. Clients create `PROOFS` joint randomness by deriving `JOINT_RAND_LEN * PROOFS` field elements, from the same seed, if `use_joint_rand` is set\r\n    ```\r\n    joint_rands = Prio3.Prg.expand_into_vec(\r\n      Prio3.Flp.Field,\r\n      Prio3.joint_rand(k_joint_rand_parts),\r\n      Prio3.domain_separation_tag(USAGE_JOINT_RANDOMNESS),\r\n      b'',\r\n      Prio3.Flp.JOINT_RAND_LEN * PROOFS,\r\n    )\r\n    ```\r\n    3. Clients invoke  `prove`  `PROOFS` times, using distinct set of prover randomness and joint randomness, and then concatenate all proofs into one message.\r\n    ```\r\n    proofs = []\r\n    for i in range(PROOFS):\r\n      if use_joint_rand:\r\n        joint_rand, joint_rands = front(Prio3.Flp.JOINT_RAND_LEN, joint_rands)\r\n      else:\r\n        joint_rand = []\r\n      prove_rand, prove_rands = front(Prio3.Flp.PROVE_RAND_LEN, prove_rands)\r\n      proofs.append(Prio3.Flp.prove(inp, prove_rand, joint_rand))\r\n    leader_proof_share = concat(proofs)\r\n    ```\r\n    4. This message is split into `SHARES` shares, as before. Each new share has `PROOF_LEN * PROOFS` field elements.\r\n    ```\r\n    helper_proof_share = Prio3.Prg.expand_into_vec(\r\n      Prio3.Flp.Field,\r\n      k_helper_proof_shares[j],\r\n      Prio3.domain_separation_tag(USAGE_PROOF_SHARE),\r\n      byte(j+1),\r\n      Prio3.Flp.PROOF_LEN * PROOFS,\r\n    )\r\n    ```\r\n3. In `decode_leader_share`, each leader decodes proof share with correct size.\r\n    ```\r\n    l = Prio3.Flp.Field.ENCODED_SIZE * Prio3.Flp.PROOF_LEN * PROOFS \r\n    ```\r\n4. In `decode_helper_share`, each helper recreates proof share, similar to step 2.iv.\r\n    ```\r\n    proof_shares = Prio3.Prg.expand_into_vec(\r\n      Prio3.Flp.Field,\r\n      k_proof_share,\r\n      c_proof_share,\r\n      byte(agg_id),\r\n      Prio3.Flp.PROOF_LEN * PROOFS)\r\n    ```\r\n5.  In `prep_init`, aggregators compute `PROOFS` verifier messages, one for each proof.\r\n    1. Each aggregator recreates  `PROOFS` joint randomness, as in step 2.ii\r\n    2. Each aggregator creates `PROOFS` query randomness\r\n    ```\r\n    query_rands = Prio3.Prg.expand_into_vec(\r\n       Prio3.Flp.Field,\r\n       verify_key,\r\n       Prio3.domain_separation_tag(USAGE_QUERY_RANDOMNESS),\r\n       nonce,\r\n       Prio3.Flp.QUERY_RAND_LEN * PROOFS,\r\n     )\r\n    ```\r\n    3. Each aggregator splits the proof share into `PROOFS` parts evenly, each with `PROOF_LEN` field elements. Then the aggregator invokes `query` `PROOFS` times, each time using the corresponding joint randomness and one distinct query randomness, and then concatenates all returns into one verifier share\r\n    ```\r\n    verifier_shares = []\r\n    for i in range(PROOFS):\r\n      proof_share, proof_shares = front(Prio3.Flp.PROOF_LEN, proof_shares)\r\n      if use_joint_rand:\r\n        joint_rand, joint_rands = front(Prio3.Flp.JOINT_RAND_LEN, joint_rands)\r\n      else:\r\n        joint_rand = []\r\n      query_rand, query_rands = front(Prio3.Flp.QUERY_RAND_LEN, query_rands)\r\n      verifier_shares.append(Prio3.Flp.query(meas_share,\r\n                                        proof_share,\r\n                                        query_rand,\r\n                                        joint_rand,\r\n                                        Prio3.SHARES)\r\n    verifier_share = concat(verifiers_shares)\r\n    ```\r\n6. In `decode_prep_share`, \r\n    ```\r\n    l = Prio3.Flp.Field.ENCODED_SIZE * Prio3.Flp.VERIFIER_LEN * PROOFS\r\n    ```\r\n7.  In `prep_shares_to_prep`, each leader sums up all verifier shares, as before, and splits it into `PROOFS` parts evenly, with `VERIFIER_LEN` field elements for each part.  Then the leader invokes `decide` on each part. If any part is invalid, the leader should bail out.\r\n    ```\r\n    verifiers = Prio3.Flp.Field.zeros(Prio3.Flp.VERIFIER_LEN * PROOFS)\r\n    ...          \r\n    for i in range(PROOFS):\r\n      verifier, verifiers = front(Prio3.Flp.VERIFIER_LEN, verifiers)\r\n      if not Prio3.Flp.decide(verifier):\r\n        raise ERR_VERIFY # proof verifier check failed\r\n    ...\r\n    ```\r\n",
          "createdAt": "2023-09-25T23:08:54Z",
          "updatedAt": "2023-09-25T23:08:54Z"
        },
        {
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## Soundness Error\r\n\r\nAdversaries have to find `PROOFS` valid proofs, using distinct joint randomness, before the aggregators can accept the input. Therefore we decrease the possibility of violating soundness with single iteration, to, $\\varepsilon^t$, if we model each PRG as random oracle, where the underlying FLP is $\\varepsilon$-sound and  $t$ = `PROOFS`.",
          "createdAt": "2023-09-25T23:11:27Z",
          "updatedAt": "2023-09-25T23:11:27Z"
        },
        {
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## Communication Cost\r\n\r\nHere are some preliminary results to compare clients/aggregators communication costs.\r\n\r\n* Based on [draft-irtf-cfrg-vdaf-06](https://datatracker.ietf.org/doc/draft-irtf-cfrg-vdaf/06/) with commit [\u201cAdd Prio3SumVec (#276)\u201d (e4478dd)](https://github.com/cfrg/draft-irtf-cfrg-vdaf/commit/e4478dd31a611a40a2ffbcde398b41906f3c1d9f).\r\n* All number is computed for leader share.\r\n* Size is in number of bytes for serialized share.\r\n* For Prio3, the FLP is `SumVec` with `num_aggregators=2`, `bits=1`, and `len` is shown as the \u201cMeasurement dimension\u201d (x-axis) in the diagrams.\r\n<img width=\"1578\" alt=\"image\" src=\"https://github.com/cfrg/draft-irtf-cfrg-vdaf/assets/27188803/89d356be-6b8e-48b6-af99-b6a98897d7ca\">\r\n",
          "createdAt": "2023-09-25T23:17:40Z",
          "updatedAt": "2023-09-25T23:18:18Z"
        },
        {
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## Computation time\r\n\r\nWe benchmark the Rust implementation, with the following setup\r\n\r\n*  Based on [libprio-rust](https://github.com/divviup/libprio-rs) with release tag: [v0.14.0](https://github.com/divviup/libprio-rs/releases/tag/v0.14.0)\r\n* `SumVec`  with `num_aggregators=2, bits=1, len=100_000`\r\n* [MBP 2021 (M1 Max)](https://support.apple.com/kb/SP858?locale=en_US).\r\n* CPU time w.r.t number of proofs for `Prio3.shard, Prio3.prepare_init, Prio3.prepare_preprocess, Prio3.prepare_step`.\r\n\r\n\r\n\r\n<img width=\"998\" alt=\"PrepareStepHelper\" src=\"https://github.com/cfrg/draft-irtf-cfrg-vdaf/assets/27188803/ddb57866-2ecc-476f-8718-8fbfb4457290\">\r\n<img width=\"1001\" alt=\"PrepareStepLeader\" src=\"https://github.com/cfrg/draft-irtf-cfrg-vdaf/assets/27188803/1a22812e-614e-4b07-ace4-35045c2669fe\">\r\n<img width=\"989\" alt=\"PrepareProcess\" src=\"https://github.com/cfrg/draft-irtf-cfrg-vdaf/assets/27188803/24551491-77af-4137-8f33-033dd91352ee\">\r\n<img width=\"976\" alt=\"PrepInitHelper\" src=\"https://github.com/cfrg/draft-irtf-cfrg-vdaf/assets/27188803/d8544ad8-87c8-413f-9ae1-ac9b9170a938\">\r\n<img width=\"988\" alt=\"PrepInitLeader\" src=\"https://github.com/cfrg/draft-irtf-cfrg-vdaf/assets/27188803/c457b0dc-8654-40a9-8d78-5ef0aa01b34a\">\r\n<img width=\"1010\" alt=\"Shard\" src=\"https://github.com/cfrg/draft-irtf-cfrg-vdaf/assets/27188803/7339e2f2-cb85-495b-ad7f-269ec546c694\">\r\n",
          "createdAt": "2023-09-25T23:25:58Z",
          "updatedAt": "2023-09-25T23:26:43Z"
        },
        {
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cjpatton @divergentdave what do you think? \r\nSpecially does it make senses to generate the prover/joint/query randomness this way? Any better way to plug this idea into current protocol?",
          "createdAt": "2023-09-26T17:03:14Z",
          "updatedAt": "2023-09-26T17:03:14Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, I think this is a promising idea! I hadn't considered the effect on measurement size previously, and as you point out, it's the more important component here. It looks like we can get pretty significant report size wins with this, so I think it would be worth the extra complexity and bookkeeping. Concatenating and splitting proof and verifier messages as you show makes sense to me.\r\n\r\nCurrently we specify which field each Prio3 instance uses. We would need to provide more guidance on soundness error, and either give users some choices for combinations of field size and number of proofs, or give formulas and thresholds for choosing such combinations.\r\n\r\nWhen considering lowering the field size, it's worth noting we have a lower bound constraint from the FFT interpolation we do. With `Field32`, we use a subgroup of order $2^{20}$, so we can handle calling a gadget about a million times. This should be fine for our purposes, especially since the `ParallelSum` gadget lets us scale gadget calls sublinearly with input sizes.\r\n\r\nWe'll also need to satisfy ourselves that the security analysis hangs together, and that the repeated proofs don't introduce soundness or zero-knowledge issues. I'll defer to Chris on what's needed there.",
          "createdAt": "2023-09-26T19:49:11Z",
          "updatedAt": "2023-09-26T19:49:24Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I also support this idea. It seems useful to provide users a trade-off between communication cost and CPU time. As far as the security implementations of this change:\r\n\r\n**Privacy**: I don't think privacy is impacted. The only thing to keep in mind is that using a smaller field increases the chance that proof generation fails: https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/poc/flp_generic.py#L242. But I don't think this is a big deal.\r\n\r\n**Robustness**: As you point out, we can achieve the same soundness error for the FLP with a smaller field by repeating the proof enough times. This is only true if the joint randomness is derived correctly, i.e., the changes to Fiat-Shamir you propose matter for security. I agree that the change seems intuitively safe, but we'd need to think through the security reduction to confirm this intuition.\r\n\r\nWhat Fiat-Shamir does is take an interactive protocol and make it non-interactive. Generally we think of this protocol as being sequential: the verifier sends a challenge, the prover responds; the verifier sends the next challenge, the prover sends the next response, and so on. In the interactive version of \"multi-proof Prio3\" (i.e., your proposal), it seems like all of these challenge-response steps are done concurrently.  I'm not sure if/how this feature would impact the usual security reduction. It may be that we need to derive each joint randomness such that it depends on the previously generated proof.\r\n\r\nGenerally speaking, messing up Fiat-Shamir is a well-known source of bugs in practical ZKP systems. When need to be very careful about how we apply it.\r\n\r\nAll of that said, I would support extending Prio3 as you suggest in order to unblock anyone who may want to implement/experiment with it. I'd like to suggest the following requirements for the change:\r\n1. Ensure \"multi-proof Prio3\" is backwards compatible with \"single-proof Prio3\" (it looks to me like it is)\r\n1. Let's not modify any of the existing VDAFs (Prio3SumVec et al.) until we're more confident in the scheme's robustness. In the meantime, private codepoints can be used (i.e., those prefixed by 0xFFFF)\r\n2. We could add a 32-bit field to the spec, but I think it would be good to avoid adding more bloat to the spec than we need. Do you think using `Field64`, say with `PROOFS==2`, would be good enough? Of course, a private codepoint cuuld be used for, say, Prio3SumVec with a 32-bit field and 4 proofs.\r\n\r\n",
          "createdAt": "2023-09-27T17:51:11Z",
          "updatedAt": "2023-09-27T17:51:49Z"
        },
        {
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you very much your inputs!\r\n\r\n> Do you think using Field64, say with PROOFS==2, would be good enough? \r\n\r\nThis is a little bit tricky. Theorem 4.3 in [BBCGGI19](https://eprint.iacr.org/2019/188.pdf) states that the the soundness error $\\varepsilon = \\frac{M * \\text{degG}}{(|F| - M)} $. \r\n\r\nIf we follow Theorem 1 in [DPRS23](https://ia.cr/2023/130) and simply replace $\\varepsilon$ with $\\varepsilon^{\\text{PROOFS}}$, then assume, $q_{\\text{RG}} \\gg q_{\\text{prep}}$, the soundness error ratio of two `Field64` proofs over one `Field128` proof is roughly  $M * \\text{degG}$, i.e. \"number of gadget calls\" times \"degree of the gadget\". \r\n\r\nFor `SumVector` with `len=100_000`, this is about 630. \r\n\r\nI am wondering if it makes sense to make `PROOFS` a configurable parameter.\r\n\r\n",
          "createdAt": "2023-09-28T01:53:18Z",
          "updatedAt": "2023-09-28T01:53:18Z"
        },
        {
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One more clarification. Shall I continue with PR for this draft or PR for libprio-rs?",
          "createdAt": "2023-09-28T01:56:13Z",
          "updatedAt": "2023-09-28T01:56:13Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is a little bit tricky. Theorem 4.3 in [BBCGGI19](https://eprint.iacr.org/2019/188.pdf) states that the the soundness error \u03b5=M\u2217degG(|F|\u2212M).\r\n> \r\n> If we follow Theorem 1 in [DPRS23](https://ia.cr/2023/130) and simply replace \u03b5 with \u03b5PROOFS, then assume, qRG\u226bqprep, the soundness error ratio of two `Field64` proofs over one `Field128` proof is roughly M\u2217degG, i.e. \"number of gadget calls\" times \"degree of the gadget\".\r\n\r\nI'm a bit lost here. Can you clarify how you expect the bound to change? Let's let $\\epsilon_b$ be the soundness for the FLP with field size $b$ (in bits, so $\\epsilon_{128}$ is for `Field128`), $q_\\text{RG}$ the number of random oracle queries, and $q_\\text{Prep}$ the number of tries the attacker gets to break robustness. (Assuming $q_\\text{RO} >> q_\\text{Prep}$ is fine.)\r\n\r\nNote that we can't apply [DPRS23, Theorem 1] directly here because we're tweaking the construction.\r\n\r\n\r\n> For `SumVector` with `len=100_000`, this is about 630.\r\n> \r\n> I am wondering if it makes sense to make `PROOFS` a configurable parameter.\r\n\r\nDo you mean that `PROOF == 630`?  Does `PROOF` depend on the number of gadget calls? If so, why?\r\n\r\nI think what we'd hope is that we can get roughly the same level of robustness at the cost of $O(b_1 / b_0)$ additional proofs, where $b_1$ is the size of thee large field (`Field128`) and $b_0$  is the size of the small field.\r\n\r\nFor what it's worth, I don't think 630 proofs is ever going to be feasible, especially since prove/query time for SumVec with dimension 100,000 is already on the order of milliseconds.\r\n\r\n\r\n\r\n> One more clarification. Shall I continue with PR for this draft or PR for libprio-rs?\r\n\r\nLet's start by extending the reference implementation: https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/poc/vdaf_prio3.py\r\n\r\nOnce that's done we can move on to the draft itself. As far as libprio-rs goes, you'll have to ask the maintainers if they're willing to implement this change. (@divergentdave is one of them.) I'd hold off on this until we've settled more of the open questions.",
          "createdAt": "2023-09-28T03:31:26Z",
          "updatedAt": "2023-09-28T03:34:18Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "> What Fiat-Shamir does is take an interactive protocol and make it non-interactive. Generally we think of this protocol as being sequential: the verifier sends a challenge, the prover responds; the verifier sends the next challenge, the prover sends the next response, and so on. In the interactive version of \"multi-proof Prio3\" (i.e., your proposal), it seems like all of these challenge-response steps are done concurrently. I'm not sure if/how this feature would impact the usual security reduction. It may be that we need to derive each joint randomness such that it depends on the previously generated proof.\r\n> \r\n> Generally speaking, messing up Fiat-Shamir is a well-known source of bugs in practical ZKP systems. When need to be very careful about how we apply it.\r\n\r\nI don't think this will be an issue, because we can still write the FLIOP as having three half-rounds of communication. First, the prover sends all measurement shares to the verifier, second, the verifier sends `PROOFS` many sets of public coin field elements to the verifier, and third, the prover sends all proof shares to the verifier. Both the computation of each proof and the verification of each proof do not depend on other proofs, so it's okay to treat them all as happening in the same FLIOP round.\r\n\r\nOn a related note, we will need to assume that the algorithm identifier commits to the choice of field and choice of `PROOFS`, in addition to the Prio3 circuit, in order to have those parameters covered by the transcript.",
          "createdAt": "2023-09-28T16:24:23Z",
          "updatedAt": "2023-09-28T16:24:23Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "> > For `SumVector` with `len=100_000`, this is about 630.\r\n> > I am wondering if it makes sense to make `PROOFS` a configurable parameter.\r\n> \r\n> Do you mean that `PROOF == 630`? Does `PROOF` depend on the number of gadget calls? If so, why?\r\n\r\nThe 630 number was for $M * \\textrm{deg G}$. The degree of the gadget (Mul) is two, and using the square root heuristic on a measurement length of 100,000 gets you chunk lengths and gadget calls both approximately equal to 315.\r\n\r\nI think the upshot of this is that we can't gloss over the impact of gadget calls (and gadget degree) when we start stacking up many proofs over smaller fields, especially when measurements are large. For this choice of parameters, and with the existing single proof over Field128, we get a soundness error of roughly $2^{-128 + 9.3} = 2^{-118.7}$. If we cut the field size by a factor of about four, and use `PROOFS=4`, then the soundness error for one proof would be around $2^{-32 + 9.3} = 2^{-22.7}$. Four such proofs, each independent, gets us only up to $(2^{-22.7})^4 = 2^{-90.8}$. That ratio of soundness errors of \"two Field64 proofs over one Field128 proof\" stacks up with each proof we add.",
          "createdAt": "2023-09-28T16:56:26Z",
          "updatedAt": "2023-09-28T16:56:26Z"
        },
        {
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cjpatton @divergentdave what are acceptable soundness errors in practise? If I understand correctly, the soundness error needs to be small enough so a brute force attack of `1/soundness` time is infeasible. If so then I think anything < `2^-64` should be sufficient? ",
          "createdAt": "2023-09-29T14:20:18Z",
          "updatedAt": "2023-09-29T14:20:18Z"
        },
        {
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank @divergentdave for clarifying up. . \r\n\r\n@cjpatton, sorry to confusion. \r\n> Do you mean that PROOF == 630? Does PROOF depend on the number of gadget calls? If so, why?\r\n\r\nI mean 630 is roughly $\\varepsilon_{64}^2/ \\varepsilon_{128}$ for `SumVector` with `len=100_000` (using the method I described above, which may not be appropriate).\r\n\r\nI am not sure we can assume $O(b_1/b_0)$ number of proofs will give us robustness parity, without further clarification on the soundness error for multiproof construct.\r\n\r\n>Let's start by extending the reference implementation: https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/poc/vdaf_prio3.py\r\n\r\nSounds good.\r\n",
          "createdAt": "2023-09-29T15:28:26Z",
          "updatedAt": "2023-09-29T15:30:21Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "(Sorry for the late response - I'm at a conference this week.)\r\n\r\n> @divergentdave  I don't think this will be an issue, because we can still write the FLIOP as having three half-rounds of communication. First, the prover sends all measurement shares to the verifier, second, the verifier sends `PROOFS` many sets of public coin field elements to the verifier, and third, the prover sends all proof shares to the verifier. Both the computation of each proof and the verification of each proof do not depend on other proofs, so it's okay to treat them all as happening in the same FLIOP round.\r\n>\r\n> The 630 number was for M\u2217deg G. The degree of the gadget (Mul) is two, and using the square root heuristic on a measurement length of 100,000 gets you chunk lengths and gadget calls both approximately equal to 315.\r\n> \r\n> I think the upshot of this is that we can't gloss over the impact of gadget calls (and gadget degree) when we start stacking up many proofs over smaller fields, especially when measurements are large. For this choice of parameters, and with the existing single proof over Field128, we get a soundness error of roughly 2\u2212128+9.3=2\u2212118.7. If we cut the field size by a factor of about four, and use `PROOFS=4`, then the soundness error for one proof would be around 2\u221232+9.3=2\u221222.7. Four such proofs, each independent, gets us only up to (2\u221222.7)4=2\u221290.8. That ratio of soundness errors of \"two Field64 proofs over one Field128 proof\" stacks up with each proof we add.\r\n\r\nYeah this sounds about right. (And good catch on including `PROOFS` in the transcript.) if we view Prio3 as a kind of generic compiler from an FLP, and we can view this thing as a kind of \"multi-proof FLP\", then [DPRS23, Theorem 1] probably covers this as well, obtaining the bound that @albertpl expects. Though I wonder if the bound we would get is looser than necessary: can anyone think of a matching attack? My intuition is that we should be able to prove a tighter robustness bound, but I could be wrong.\r\n\r\n> @wangshan what are acceptable soundness errors in practise? If I understand correctly, the soundness error needs to be small enough so a brute force attack of `1/soundness` time is infeasible. If so then I think anything < `2^-64` should be sufficient?\r\n\r\nThere is another thing to consider, which is **robustness**. The soundness of the base FLP is part of this, but if our circuit needs joint randomness, then random oracle (RO) queries can weaken robustness well below the base soundness bound.\r\n\r\nI have been thinking in terms of allowing the attacker up to $2^{64}$ RO queries. So if you want a robustness bound of about $2^{-64}$, you would need a base soundness of about $2^{-128}$ (according to [DPRS23, Theorem 1]).\r\n\r\nThis is why we picked a 128-bit field for Prio3 variants that use joint randomness. However, we actually get weaker robustness as the input size increases. If we want robustness of **at most** $2^{-64}$, then we'd need a slightly bigger field, depending on the time. For SumVec, say, if input length is 100,000, then we would a field that has something like $\\log_2(100,000)$ more bits.\r\n\r\nIn my opinion, it's OK for robustness to be weaker than $2^{-64}$ (assuming $2^{64}$ RO queries). That is, it's up to the application to decide whether they can tolerate a weaker bound bound as a result of doing multi-proof with a smaller field.\r\n\r\nHowever, I don't think we should weaken the bounds we currently get, i.e., we should only change the existing Prio3 variants if we find that we can preserve the same level of security without adding too many extra proofs.\r\n\r\n\r\n",
          "createdAt": "2023-10-03T15:54:23Z",
          "updatedAt": "2023-10-03T15:54:23Z"
        },
        {
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I put up [this](https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/298) PR and appreciate your review. \r\nSpecifically I am not sure how we allocate algorithm IDS and specify parameters constrains for these variants.",
          "createdAt": "2023-10-03T23:26:58Z",
          "updatedAt": "2023-10-03T23:26:58Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @albertpl for the PR, I'm reviewing now. But before we merge this, I would like us to have a better idea of what value of `PROOFS` we expect to see in practice so that we have a better sense of the communication/CPU trade-off. Can you say a bit more about your use case?\r\n\r\n1. You mentioned `Prio3SumVec`. What parameters are you using? You mentioned input length of about 100k; is that indeed the target we should be evaluating? Do you want a value for `bits` other than `1`?\r\n2. What field do you want to use? `Field64`, or do you intend to use a smaller one? (I would not recommend this.)\r\n3. What robustness bound are you hoping for? I can help you assess this if you'd like. Note that, if a Client succeeds in breaking robustness, then it can ruin an aggregate result. Perhaps your OK with this happening \"once in a while\", but rarely?",
          "createdAt": "2023-10-05T00:01:04Z",
          "updatedAt": "2023-10-05T00:01:04Z"
        },
        {
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have one comment about soundness error of SumVec, or any circuit that uses random linear combination: there should be an additive factor of `(len * bits) / |F|` because of random linear combination of the 0/1 bit checks, per Remark 4.8 of [BBCGGI19](https://eprint.iacr.org/2019/188.pdf).\r\n\r\nStill using `len=100,000`, `bits=1` as an example, the soundness should be $\\frac{2*\\lceil \\sqrt{len} \\rceil }{|F|-\\lceil \\sqrt{len} \\rceil} + (len*bits)/|F|$. For Field128, using $|F|=2^{128}$, this gives $2^{-118} + 2^{-111}$. The latter term seems to be dominant, so we should take it into account.\r\n\r\n> This is why we picked a 128-bit field for Prio3 variants that use joint randomness. However, we actually get weaker robustness as the input size increases. If we want robustness of at most , then we'd need a slightly bigger field, depending on the time. For SumVec, say, if input length is 100,000, then we would a field that has something like  more bits.\r\n\r\n@cjpatton can you elaborate this part? I don\u2019t quite understand it\u2026",
          "createdAt": "2023-10-05T18:33:10Z",
          "updatedAt": "2023-10-05T18:34:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@junyechen1996: Basically, for a fixed robustness bound, as your circuit gets more complex (i.e., more gadget calls), you need to compensate by increasing the size of the field (or the number of proofs).",
          "createdAt": "2023-10-05T23:33:09Z",
          "updatedAt": "2023-10-05T23:33:09Z"
        },
        {
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> You mentioned Prio3SumVec. What parameters are you using? You mentioned input length of about 100k; is that indeed the target we should be evaluating? Do you want a value for bits other than 1?\r\n\r\nYeah. `len=100_000, bit=1` is our current target. Appreciate that we can evaluate with this set of parameters first.\r\n\r\n> What field do you want to use? Field64, or do you intend to use a smaller one? (I would not recommend this.)\r\n\r\nField64 is our first choice too. \r\n\r\n> I can help you assess this if you'd like. \r\n\r\nYeah. That would be great!\r\n\r\n> What robustness bound are you hoping for?  Note that, if a Client succeeds in breaking robustness, then it can ruin an aggregate result. Perhaps you're OK with this happening \"once in a while\", but rarely?\r\n\r\nI suppose some reasonable tradeoff between communication/computation cost and robustness is  acceptable.  Some guidance  on robustness would be very helpful.",
          "createdAt": "2023-10-06T17:51:50Z",
          "updatedAt": "2023-10-06T17:51:50Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I think of robustness as follows. If your robustness bound is $2^{-32}$, then after consuming $2^{32}$ reports it's highly likely that one of those reports is invalid. How \"bad\" this robustness failure is depends on how use Prio3: Assuming you're using DAP(https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/), then think your tolerance for robustness failure depends on the expected batch size, since this is the blast radius of a a single invalid report. If you're batch size is $1000$, then you should expect at most one in every $2^{32} / 1000$ batches to get ruined.\r\n\r\nEDIT: Take this analysis with a grain of salt, as the robustness depends somewhat on how well-resourced the adversary is. First, random oracle queries amount to doing pre-computation with the underlying XOF. Second, it depends partially on how many of the reports the attacker controls. In practice we'd observe a high rejection rate before we get to the point of a batch getting ruined.",
          "createdAt": "2023-10-10T20:05:54Z",
          "updatedAt": "2023-10-11T17:32:14Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Great first PR, @albertpl! I think we're ready to start propagating the changes into the actual draft. While at it, please add yourself to the list of contributors in the acknowledgement section :)",
          "createdAt": "2023-10-16T14:54:54Z",
          "updatedAt": "2023-10-16T14:54:54Z"
        },
        {
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Great. Do you think we should wait for the robustness analysis? i.e. shall we quantify the robustness for the multiproof?",
          "createdAt": "2023-10-17T15:38:32Z",
          "updatedAt": "2023-10-17T15:38:32Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "The scheme is flexibile enough to \"bump\" robustness as needed (by adding more proofs or using a larger field), so I don't think we need to block on that. On the other hand, we don't want there to be a difference between the reference code and the draft.",
          "createdAt": "2023-10-17T15:56:48Z",
          "updatedAt": "2023-10-17T15:56:48Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think we need to block aligning the draft. (On the other hand, we don't want there to be a difference between the reference implementation and the draft for very long.) I think we need to come up with recommendations for choosing parameters, but his can wait for a later PR. For now, let's focus on nuts and bolts.",
          "createdAt": "2023-10-17T16:34:23Z",
          "updatedAt": "2023-10-17T16:34:23Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Any progress on updating the text, @albertpl? Note that we are blocking the next draft on this. If you can't get to it within the couple of weeks, let us know.",
          "createdAt": "2023-10-23T15:34:49Z",
          "updatedAt": "2023-10-23T15:34:49Z"
        },
        {
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cjpatton sorry. let me work on it this week.",
          "createdAt": "2023-10-23T16:40:06Z",
          "updatedAt": "2023-10-23T16:40:06Z"
        },
        {
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have aligned the draft with the POC. [Here](https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/305#pullrequestreview-1695611696) is the PR.",
          "createdAt": "2023-10-24T18:24:19Z",
          "updatedAt": "2023-10-24T18:24:19Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "We've implemented the core feature; all that's left here is to provide guidance in the draft for choosing the parameters. I've opened a new issue to focus on this remaining work and am closing this issue.",
          "createdAt": "2023-11-16T14:36:52Z",
          "updatedAt": "2023-11-16T14:36:52Z"
        }
      ]
    },
    {
      "number": 179,
      "id": "I_kwDOGKuqOc5fmtFz",
      "title": "IDPF: Supporting very long inputs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/179",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "idea"
      ],
      "body": "If the distribution of input lengths has a long tail, then IDPFs are not going to perform very well for heavy hitters. If we have a use case where this becomes an issue, then we should consider investigating a solution.\r\n\r\nOne suggestion for improving performance is the hashing construction from {{BBCGGI21}}, Appendix B. The basic idea is to compute prefix tree for the *hashes* of the input strings, then encode in the outputs of the leaves the strings themselves. This would reduce round complexity from `O(Idpf.BITS)` to `O(HASH_SIZE)`, where `HASH_BITS` is the number of bits of the hash output (typically `256)`. This is worth it if `Idpf.BITS >> HASH_BITS`.\r\n\r\nMaking this work in the VDAF framework is a bit fiddly, since it requires some interaction at the end to recover the strings themselves after aggregating the hit counts.",
      "createdAt": "2023-02-28T23:41:53Z",
      "updatedAt": "2024-06-06T22:36:54Z",
      "closedAt": "2024-06-06T22:36:54Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue is over a year old. Since we don't have any use cases for it right now, I'm going to close. If someone wanted to in the future, IDPF could be extended to support this.",
          "createdAt": "2024-06-06T22:36:54Z",
          "updatedAt": "2024-06-06T22:36:54Z"
        }
      ]
    },
    {
      "number": 185,
      "id": "I_kwDOGKuqOc5fuOco",
      "title": "Prio3: Consider merging helper shares and blinds into a single seed",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/185",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wire change",
        "needs security analysis",
        "draft-12"
      ],
      "body": "We currently use separate seeds for the helper's measurement share, proof share, and blind. It is likely safe to use the same PRG seed for all three.\r\n\r\nThe upshot is that this reduce bandwdith and simplify the Prio3 spec. However, it is not immediately clear how this change would impact known security analysis. See comments on https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/129 for discussion.\r\n",
      "createdAt": "2023-03-02T01:19:20Z",
      "updatedAt": "2024-08-14T15:45:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "\"likely\" safe?  If you are able to use a PRG for any of them, then the same seed will work for all of them equally well.  You just need very clear rules for separation.",
          "createdAt": "2024-08-07T02:00:44Z",
          "updatedAt": "2024-08-07T02:00:44Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah I think that's right, though @hannahdaviscrypto, who did the privacy analysis for Prio3, [points out that this probably weakens the concrete security somewhat](https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/129#issuecomment-1382428426). ",
          "createdAt": "2024-08-07T15:19:17Z",
          "updatedAt": "2024-08-07T15:19:17Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm inclined to not make this change unless folks are strongly motivated by the bandwidth savings.",
          "createdAt": "2024-08-07T15:23:27Z",
          "updatedAt": "2024-08-07T15:23:27Z"
        }
      ]
    },
    {
      "number": 190,
      "id": "I_kwDOGKuqOc5f56kx",
      "title": "draft-05 chores",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/190",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "draft-05"
      ],
      "body": "- [x] Bump VERSION\r\n- [x] Regenerate test vectors\r\n- [x]  Update Change Log",
      "createdAt": "2023-03-03T17:33:11Z",
      "updatedAt": "2023-03-13T15:45:36Z",
      "closedAt": "2023-03-13T15:45:36Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Waiting to re-generate test vectors until we've closed #32. We'll also need to update the CL.",
          "createdAt": "2023-03-07T22:57:36Z",
          "updatedAt": "2023-03-07T22:57:36Z"
        }
      ]
    },
    {
      "number": 200,
      "id": "I_kwDOGKuqOc5hBDv8",
      "title": "Martin Thomson: Editorial improvements for PrgFixedKeyAes128 spec",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/200",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "As pointed out by @martinthomson:\r\n- [x] https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/193#discussion_r1134724615: Rename \"sigma\" to \"sigma_block\", since sigma is a function in the paper.\r\n- [x] https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/193#discussion_r1134724615: \"concat()\" would be more clear than \"+\" for concatenation of \"hi\" and \"lo\".\r\n- [x] https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/193#discussion_r1134725074: Clarify what the \"tweak\" is in the hash construction.",
      "createdAt": "2023-03-16T14:46:59Z",
      "updatedAt": "2023-03-16T16:59:35Z",
      "closedAt": "2023-03-16T16:59:35Z",
      "comments": []
    },
    {
      "number": 204,
      "id": "I_kwDOGKuqOc5hIzLl",
      "title": "Convert proof of concept to Sage-flavored-Python",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/204",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "divergentdave"
      ],
      "labels": [],
      "body": "We'd like to rework the proof of concept to be written in Python syntax, and import parts of Sage as library modules. The syntactic sugar of Sage syntax is not worth it when compared to the hurdles it imposes on code reuse through importing. Numeric literals being Sage objects instead of Python primitive types has caused a lot of small issues, because so much of the code is traditional imperative programming rather than algebraic. We can replace .sage files with .py files, and then run them with `sage -python filename.py` so we still get access to Sage's various libraries, which aren't otherwise available in plain Python interpreters. Once we have finished this conversion, we can start using traditional Python code quality tools, as well.",
      "createdAt": "2023-03-17T17:40:50Z",
      "updatedAt": "2023-06-07T22:30:23Z",
      "closedAt": "2023-06-07T22:30:23Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Before we decide to do this, it would be useful to get some insight from folks in the CFRG who have developed reference code in Sage. I'm looking at you, @armfazh and @chris-wood!",
          "createdAt": "2023-03-20T15:59:41Z",
          "updatedAt": "2023-03-20T15:59:41Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "you can get some inspiration from this setup:\r\nhttps://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/blob/main/poc/Makefile\r\nBasically, it's possible to combine files written in pure python with others written in Sage.",
          "createdAt": "2023-03-20T17:08:40Z",
          "updatedAt": "2023-03-20T17:09:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "@divergentdave this is a _great_ idea. I think it has the same benefits as using Sage natively, but brings the added benefits of using existing tooling to improve the code. ",
          "createdAt": "2023-03-20T19:07:14Z",
          "updatedAt": "2023-03-20T19:07:14Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "We should set up a `format` Makefile target to run Python files through `autopep8` and `isort`.",
          "createdAt": "2023-03-21T19:33:44Z",
          "updatedAt": "2023-03-21T19:33:44Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(A different task, but related) it's worth to investigate the ability to run Sage in CI.\r\nIn github actions, you can run a docker image containing Sage. ",
          "createdAt": "2023-03-21T22:05:25Z",
          "updatedAt": "2023-03-21T22:05:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "@dconnolly did this for [FROST](https://github.com/cfrg/draft-irtf-cfrg-frost/blob/master/.github/workflows/poc.yml) =)",
          "createdAt": "2023-03-21T22:57:27Z",
          "updatedAt": "2023-03-21T22:57:27Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "body": "> @dconnolly did this for [FROST](https://github.com/cfrg/draft-irtf-cfrg-frost/blob/master/.github/workflows/poc.yml) =)\n\nThe Sage in homebrew is generally up to date with latest and was a quick and simple set up",
          "createdAt": "2023-03-21T23:07:00Z",
          "updatedAt": "2023-03-21T23:07:00Z"
        }
      ]
    },
    {
      "number": 209,
      "id": "I_kwDOGKuqOc5heFB7",
      "title": "Reconsider PRG choice",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/209",
      "state": "CLOSED",
      "author": "simon-friedberger",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "If we reconsider our choice of PRG we should take into account that:\r\n\r\n- The RNG is modeled as a random oracle in the proofs but this does not necessarily mean that we need a XOF. It might be more efficient to create a seed using something like SHA-3 (or -2) and then applying a fast AES based stream derivation.\r\n- cSHAKE (which we are currently using) was only defined in NIST SP 800-185 not the original SHA-3 standard (FIPS 202) so it might not be available in some implementations. FIPS 202 has SHAKE which is also a XOF and we are already defining how to encode the binding string. We could simply define something similar to cSHAKE based on SHAKE. (Exact match is not possible due to non-matching constants.)\r\n",
      "createdAt": "2023-03-22T08:25:11Z",
      "updatedAt": "2023-10-17T01:07:40Z",
      "closedAt": "2023-10-17T01:07:40Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for kicking off this discussion, Simon! Here are my personal views on these points at the moment.\r\n\r\n>     * The RNG is modeled as a random oracle in the proofs but this does not necessarily mean that we need a XOF. It might be more efficient to create a seed using something like SHA-3 (or -2) and then applying a fast AES based stream derivation.\r\n\r\nIn my opinion, more security analysis is required before we consider this change. I think it would be sufficient to prove that `PrgFixedKeyAes128` is [indifferentiable](https://blog.cryptographyengineering.com/2012/07/17/indifferentiability/) from a random oracle when SHA-3 (or SHA-2) is modeled as a random oracle and fixed-key AES is modeled as a random permutation (or perhaps ideal cipher). Currently this is is only known to be correlation-robust (see Section 7.4 of [this paper](https://eprint.iacr.org/2019/074.pdf)). Alternatively, we could revisit the security proofs for Prio3 and see if we can push through the reduction with a function that is only correlation-robust.\r\n\r\nRegarding performance: `PrgFixedKeyAes128` is much faster than `PrgSha3`. (Incidentally, @divergentdave it would be great to have libprio benchmarks for this, if we don't already!) However, whether we need this speed up depends on how we use the PRG: for `Prio3` the sharding/prep times are very similar with both, since the runtime is dominated by finite finite arithmetic; but for things that use the IDPF, like `Poplar1`, the performance difference is quite significant, since the runtime is dominated by the PRG. (See preliminary benchmarks in #106 for details.) In fact, this is exactly why we wanted `FixedKeyAes128`. (See #32.)\r\n\r\n>     * cSHAKE (which we are currently using) was only defined in NIST SP 800-185 not the original SHA-3 standard (FIPS 202) so it might not be available in some implementations. FIPS 202 has SHAKE which is also a XOF and we are already defining how to encode the binding string. We could simply define something similar to cSHAKE based on SHAKE. (Exact match is not possible due to non-matching constants.)\r\n\r\nThis sounds reasonable. We used cSHAKE128 because (1) we need an XOF and (2) there is baked in domain separation for the customization and binder strings. All we would need to do to go to SHAKE128 is roll this domain separation bit ourselves. \r\n\r\n",
          "createdAt": "2023-03-22T17:22:23Z",
          "updatedAt": "2023-03-22T17:23:33Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "A couple of additional options to flag here:\r\n1. David Benjamin reminded me of `expand_message_xmd` from the hash-to-curve draft, which seems fine at least from a security perspective: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.1\r\n2. TurboSHAKE has recently been endorsed for use in Kyber. If this becomes the standard, then most, if not all, cryptographic libraries are going to need first class support for it: https://mailarchive.ietf.org/arch/msg/cfrg/bwSH21YPUgdten9ztsuNrL7XfZI/",
          "createdAt": "2023-05-22T21:47:33Z",
          "updatedAt": "2023-05-22T21:47:33Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to plan to replace cSHAKE128 with SHAKE128 in the next draft (draft-07). I think I'd like to get feedback from CFRG on whether to use SHA2 (via `expand_message_xmd`), stick with SHA3, or use TurboSHAKE.",
          "createdAt": "2023-08-17T01:20:10Z",
          "updatedAt": "2023-08-17T01:20:10Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "This is superseded by #299.",
          "createdAt": "2023-10-17T01:07:40Z",
          "updatedAt": "2023-10-17T01:07:40Z"
        }
      ]
    },
    {
      "number": 215,
      "id": "I_kwDOGKuqOc5in2B-",
      "title": "Review: 05: Chris Wood: Branching in Prio3 reduces readability",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/215",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "In particular, the sharding and preparation algorithms have lots of branching for generating joint randomness or not (depending on if `JOINT_RAND_LEN == 0`). Figure out how to refactor these algorithms so that the branching logic is handled by auxiliary functions.",
      "createdAt": "2023-04-04T21:35:22Z",
      "updatedAt": "2023-08-29T20:09:30Z",
      "closedAt": "2023-08-29T20:09:30Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "The sharding algorithm is now much more clear. While technically we could add variants for preparation with and without joint randomness, I think the gains here would be less significant, as the code is already pretty short.\r\n\r\nClosing this as completed.",
          "createdAt": "2023-08-29T20:09:30Z",
          "updatedAt": "2023-08-29T20:09:30Z"
        }
      ]
    },
    {
      "number": 216,
      "id": "I_kwDOGKuqOc5in-Mq",
      "title": "Review: 05: Chris Wood: Security implications of using PrgFixedKeyAes128 for IDPF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/216",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "schoppmp"
      ],
      "labels": [],
      "body": "A correlation-robust hash function is a new primitive for the CFRG. What do we need from it for IDPF, and why does it achieve this?\r\n\r\n> Have the PRG constructions seen security analysis? Some of them seem straightforward, but I think it would be helpful to sketch proofs in the security considerations. We did this in hash-to-curve for the benefit of future readers who might ask. (I ask this because I saw \"The multi-instance tweakable circular correlation-robust hash function of\" and thought to myself, \"gee, this seems new!\")",
      "createdAt": "2023-04-04T22:10:37Z",
      "updatedAt": "2023-10-11T18:30:04Z",
      "closedAt": "2023-10-11T18:30:04Z",
      "comments": []
    },
    {
      "number": 217,
      "id": "I_kwDOGKuqOc5in-mE",
      "title": "Review: 05: Chris Wood: Ambiguous usage of \"input\" and \"measurement\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/217",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "> There was some inconsistent use of \"input\" and \"measurement\", so I started trying to make them uniform in usage throughout. Then I got to the DAF description where we have the function `measurement_to_input_shares`, which accepts values of type `Measurement` as input. To me, I think using `input` consistently here would be and let the reader piece things together. I'd suggest converging on \"input,\" since the values being aggregated over",
      "createdAt": "2023-04-04T22:12:18Z",
      "updatedAt": "2023-07-19T22:59:45Z",
      "closedAt": "2023-07-19T22:59:45Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to fixing ambiguity. I would propose converging on measurement instead, for two reasons:\r\n1. We use \"measurement\" in DAP\r\n2. We have used the term \"measurement\" in an number of presentations in a number of venues\r\n3. In Prio3 we use the term \"input\" to mean the \"encoded measurement\" (of course we can fix this problem a different way!)",
          "createdAt": "2023-04-04T22:14:18Z",
          "updatedAt": "2023-04-04T22:14:18Z"
        }
      ]
    },
    {
      "number": 218,
      "id": "I_kwDOGKuqOc5ioAIu",
      "title": "Review: 05: Chris Wood: Ensure \"Client\" is capitalized consistently throughout",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/218",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In particular, when \"Client\" refers to the role in (V)DAF execution.",
      "createdAt": "2023-04-04T22:19:03Z",
      "updatedAt": "2023-07-12T22:18:04Z",
      "closedAt": "2023-07-12T22:18:04Z",
      "comments": []
    },
    {
      "number": 219,
      "id": "I_kwDOGKuqOc5ioIwI",
      "title": "Review 05: Chris Wood: Ideas for intro",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/219",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial",
        "security consideration"
      ],
      "body": ">The overview of Prio3 and Poplar1 in the introduction feels a bit too out of place, especially as it comes before the generic overview. I would suggest removing this content, as it's somewhat redundant with the section in {{prio3}} and {{poplar1}}.\r\n>\r\n> Moreover, to align with the structure of the document, I might try to reframe the intro to first introduce DAFs, and then introduce malicious clients and the need for verifiability, and then introduce VDAFs. I can propose some text for this if you'd be interested.\r\n",
      "createdAt": "2023-04-04T23:04:50Z",
      "updatedAt": "2024-08-07T23:35:04Z",
      "closedAt": "2024-08-07T23:35:04Z",
      "comments": [
        {
          "author": "bkmgit",
          "authorAssociation": "NONE",
          "body": "A introduction with more generic examples would be great.  Some requirements on non-colluding servers would also be helpful, in particular how many servers have been used/should be used in practice and whether there is a time period where collusion can be problematic. ",
          "createdAt": "2023-04-07T18:22:49Z",
          "updatedAt": "2023-04-07T18:22:49Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood would you like to take a swing at this, since you offered?",
          "createdAt": "2023-07-15T00:07:52Z",
          "updatedAt": "2023-07-15T00:07:52Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> @bkmgit: Some requirements on non-colluding servers would also be helpful, in particular how many servers have been used/should be used in practice and whether there is a time period where collusion can be problematic.\r\n\r\nThere's a PR up to address this. I ended up sticking the discussion about non-collusion and the number of aggregators into security considerations, where I feel this discussion is more appropriate.",
          "createdAt": "2024-08-06T17:29:19Z",
          "updatedAt": "2024-08-06T17:29:19Z"
        }
      ]
    },
    {
      "number": 220,
      "id": "I_kwDOGKuqOc5ioZUZ",
      "title": "Review: 05: Chris Wood: Restrictions on aggregation parameter",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/220",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> * `Daf.is_valid(agg_param: AggParam, previous_agg_params: Vec[AggParam]) ->\r\n  Bool`: Checks if the `agg_param` is compatible with all elements of\r\n  `previous_agg_params`.\r\n>\r\n> Is it important that `previous_agg_params` is a list as opposed to a set?\r\n\r\nSimilar question applies for VDAFs.\r\n",
      "createdAt": "2023-04-05T00:37:59Z",
      "updatedAt": "2023-07-12T20:47:27Z",
      "closedAt": "2023-07-12T20:47:27Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "For existing (V)DAFs the answer is no. I also suspect this unlikely to come up in the future.",
          "createdAt": "2023-04-05T00:40:26Z",
          "updatedAt": "2023-04-05T00:40:26Z"
        }
      ]
    },
    {
      "number": 222,
      "id": "I_kwDOGKuqOc5je7L8",
      "title": "Remove aliases of primitive Python types",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/222",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial"
      ],
      "body": "We would like to remove aliases of primitive types in `common.py`, and just use the primitive types straight out of their global bindings.\r\n\r\n_Originally posted by @cjpatton in https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/221#discussion_r1167331240_\r\n            ",
      "createdAt": "2023-04-14T23:34:54Z",
      "updatedAt": "2024-06-06T21:32:02Z",
      "closedAt": "2024-06-06T21:32:02Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "We should just change `Vec` to `list`, right?",
          "createdAt": "2023-07-14T22:24:32Z",
          "updatedAt": "2023-07-14T22:24:32Z"
        }
      ]
    },
    {
      "number": 223,
      "id": "I_kwDOGKuqOc5kQSZp",
      "title": "Review 05: Chris Wood: Simplify `prep_next()` syntaax",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/223",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial"
      ],
      "body": "I find [the current] syntax a bit odd. Since ROUNDS is a constant, we know when prep_next will produce an output share (or fail). Why not split this up into two separate functions to make them more clear? This seems like it ought to simplify this description:\r\n\r\n```\r\n        # Aggregators recover their output shares.\r\n        inbound = None\r\n        for i in range(Vdaf.ROUNDS+1):\r\n            outbound = []\r\n            for j in range(Vdaf.SHARES):\r\n                out = Vdaf.prep_next(prep_states[j], inbound)\r\n                if i < Vdaf.ROUNDS:\r\n                    (prep_states[j], out) = out\r\n                outbound.append(out)\r\n            # This is where we would send messages over the\r\n            # network in a distributed VDAF computation.\r\n            if i < Vdaf.ROUNDS:\r\n                inbound = Vdaf.prep_shares_to_prep(agg_param,\r\n                                                   outbound)\r\n```\r\n\r\nTo something like this (less branching):\r\n\r\n```\r\n        # Aggregators recover their output shares.\r\n        inbound = None\r\n        for i in range(Vdaf.ROUNDS):\r\n            outbound = []\r\n            for j in range(Vdaf.SHARES):\r\n                out = Vdaf.prep_next(prep_states[j], inbound)\r\n                (prep_states[j], out) = out\r\n                outbound.append(out)\r\n            # This is where we would send messages over the\r\n            # network in a distributed VDAF computation.\r\n            inbound = Vdaf.prep_shares_to_prep(agg_param, outbound)\r\n        \r\n        outbound = []\r\n        for j in range(Vdaf.SHARES):\r\n          out = Vdaf.prep_next(prep_states[j], inbound)\r\n        outbound.append(out)\r\n```",
      "createdAt": "2023-04-24T20:33:14Z",
      "updatedAt": "2023-07-19T21:35:31Z",
      "closedAt": "2023-07-19T21:35:31Z",
      "comments": []
    },
    {
      "number": 224,
      "id": "I_kwDOGKuqOc5kQVFY",
      "title": "Review 05: Chris Wood: Rename \"customization string\" to \"domain separation tag\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/224",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The latter is more common for CFRG documents.",
      "createdAt": "2023-04-24T20:40:24Z",
      "updatedAt": "2023-05-02T21:12:18Z",
      "closedAt": "2023-05-02T21:12:18Z",
      "comments": []
    },
    {
      "number": 225,
      "id": "I_kwDOGKuqOc5kQi-6",
      "title": "Review: 05: Chris Wood: `RAND_SIZE` is not specified by `Prio3` or `Poplar1`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/225",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-04-24T21:17:51Z",
      "updatedAt": "2023-05-01T17:58:26Z",
      "closedAt": "2023-05-01T17:58:26Z",
      "comments": []
    },
    {
      "number": 226,
      "id": "I_kwDOGKuqOc5kQmqN",
      "title": "Review: 05: Chris Wood: Prose description of the FLP lacks precision",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/226",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial"
      ],
      "body": "#flp-generic-construction-prove (and the other sections for the generic FLP) uses prose to describe steps of the generic FLP like proof generation, querying, and so on. This is distinctly less precise than the rest of the document, which uses pseudocode to describe steps. For example, consider the step to actually compute gadget polynomials:\r\n\r\n >      Let `poly_gadget_i = G_i(poly_wire_i[0], ..., poly_wire_i[L_i-1])`. That\r\n >    is, evaluate the circuit `G_i` on the wire polynomials for the `i`th\r\n >    gadget. (Arithmetic is in the ring of polynomials over `Field`.)\r\n\r\nI would not expect most people to be familiar with the concept of a ring, nor would most people know how to intuitively implement circuit evaluation. Perhaps it might be good to give examples of common gadgets -- like Mul -- and how to implement this evaluation?\r\n\r\nMoreover, consider the following:\r\n\r\n>   Let `poly_wire_i[j-1]` be the lowest degree polynomial for which\r\n>     `poly_wire_i[j-1](alpha_i^k) == padded_w[k]` for all `k` in `[P_i]`.\r\n\r\nHow does one actually implement this? In general, prose that is not followed by an algorithm seems like it could be replaced with more precise implementation guidance. The reference implementation could be used as the basis for this content, if desired.\r\n",
      "createdAt": "2023-04-24T21:30:33Z",
      "updatedAt": "2023-10-25T18:54:05Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 227,
      "id": "I_kwDOGKuqOc5kQ1u9",
      "title": "`run_flp()` takes `num_shares` but doesn't actually split the inputs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/227",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\nAn FLP is executed by the prover and verifier as follows:\r\n\r\n~~~\r\ndef run_flp(Flp, inp: Vec[Flp.Field], num_shares: Unsigned):\r\n    joint_rand = Flp.Field.rand_vec(Flp.JOINT_RAND_LEN)\r\n    prove_rand = Flp.Field.rand_vec(Flp.PROVE_RAND_LEN)\r\n    query_rand = Flp.Field.rand_vec(Flp.QUERY_RAND_LEN)\r\n\r\n    # Prover generates the proof.\r\n    proof = Flp.prove(inp, prove_rand, joint_rand)\r\n\r\n    # Verifier queries the input and proof.\r\n    verifier = Flp.query(inp, proof, query_rand, joint_rand, num_shares)\r\n\r\n    # Verifier decides if the input is valid.\r\n    return Flp.decide(verifier)\r\n~~~\r\n```\r\n\r\nThis text is meant to clarify the text that comes before, which explains \"full inearity\" and the technical issues that are relevant to implementers:\r\n\r\n```\r\nOur application requires that the FLP is \"fully linear\" in the sense defined in\r\n{{BBCGGI19}}. As a practical matter, what this property implies is that, when\r\nrun on a share of the input and proof, the query-generation algorithm outputs a\r\nshare of the verifier message. Furthermore, the privacy property of the FLP\r\nsystem ensures that the verifier message reveals nothing about the input's\r\nvalidity. Therefore, to decide if an input is valid, the Aggregators will run\r\nthe query-generation algorithm locally, exchange verifier shares, combine them\r\nto recover the verifier message, and run the decision algorithm.\r\n\r\nThe query-generation algorithm includes a parameter `num_shares` that specifies\r\nthe number of shares of the input and proof that were generated. If these data\r\nare not secret shared, then `num_shares == 1`. This parameter is useful for\r\ncertain FLP constructions. For example, the FLP in {{flp-generic}} is defined in\r\nterms of an arithmetic circuit; when the circuit contains constants, it is\r\nsometimes necessary to normalize those constants to ensure that the circuit's\r\noutput, when run on a valid input, is the same regardless of the number of\r\nshares.\r\n```\r\n\r\nHowever it currently doesn't do that very well, since we don't actually do any input splitting.",
      "createdAt": "2023-04-24T22:35:02Z",
      "updatedAt": "2023-05-01T20:49:27Z",
      "closedAt": "2023-05-01T20:49:27Z",
      "comments": []
    },
    {
      "number": 233,
      "id": "I_kwDOGKuqOc5kzOTJ",
      "title": "poc: Avoid shadowing variable names",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/233",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "poc"
      ],
      "body": "We should get rid of variable name shadowing as a general matter.\r\n\r\n_Originally posted by @divergentdave in https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/232#discussion_r1181772727_",
      "createdAt": "2023-05-01T18:14:16Z",
      "updatedAt": "2024-07-02T21:52:17Z",
      "closedAt": "2024-07-02T21:52:17Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "As of #366, this is enforced by CI:\r\nhttps://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/ecaf743825c0f8b6d2e171731284ff489ffc7808/.github/workflows/lint-python.yml#L38-L40",
          "createdAt": "2024-07-02T21:52:17Z",
          "updatedAt": "2024-07-02T21:52:17Z"
        }
      ]
    },
    {
      "number": 239,
      "id": "I_kwDOGKuqOc5mNgdN",
      "title": "Making Prio3Histogram's measurements more flexible",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/239",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "divergentdave"
      ],
      "labels": [],
      "body": "Currently, Prio3Histogram is parameterized by a list of bucket boundaries, and its measurement is a `Integer` that gets compared to all these boundaries, to determine which bucket's counter should be incremented. The same validity circuit has broader application than 1D histograms of integers that are directly supported. For instance, histograms with floating point numbers, multi-dimensional histograms, and multiple choice survey questions could all benefit from the same one-hot/mutual exclusion validity circuit, but using them with the VDAF as defined today would require defining awkward mappings. (i.e. creating a synthetic list of bucket boundaries, and providing measurements chosen to land in particular buckets) Similarly, someone may want a histogram with bucket intervals that are closed on the left instead of on the right.\r\n\r\nI think we should either define a separate Prio3 VDAF, or redefine the Prio3Histogram VDAF, so that it takes a number of buckets as a parameter, and either a bucket index or a vector with a single 1 as a measurement. This would require most use cases to do some preprocessing before calling the shard function, but it wouldn't require turning floating point or vector inputs into an integer to be compared against synthetic bucket boundaries. Plus, replacing the array in the `buckets` parameter with a single cardinal number would make passing around VDAF parameters out of band easier. In ENPA, we handled metrics with over a thousand buckets, as a point of reference. (note that the aggregators have only ever cared about the number of buckets, and not the boundary values) Since this only affects the measurement and parameters, we could maintain wire and proof compatibility. I could prototype out the new interface in libprio-rs, maybe under a name like 'raw histogram'.",
      "createdAt": "2023-05-18T00:31:50Z",
      "updatedAt": "2023-06-07T22:40:34Z",
      "closedAt": "2023-06-07T22:40:34Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "SGTM. Since no one is using Prio3Histogram yet, I'd say it would be alright to replace it. I'd personally be comfortable with the same name, but if a distinguished name would be useful, then Prio3RawHistogram sounds like a fine name to me. (In this case I think we'd also want to change the codepoint.)",
          "createdAt": "2023-05-22T18:12:15Z",
          "updatedAt": "2023-05-22T18:12:15Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm with Chris, in that I hope it's still early enough in VDAF and DAP's lifespan that we can just change how `Prio3Histogram` works instead of forever carrying around two histogram types, one of which should probably never be used.",
          "createdAt": "2023-05-22T22:03:00Z",
          "updatedAt": "2023-05-22T22:03:00Z"
        }
      ]
    },
    {
      "number": 244,
      "id": "I_kwDOGKuqOc5nZkNN",
      "title": "Consider merging `VDAF.prep_init` with the initial `VDAF.prep_next`.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/244",
      "state": "CLOSED",
      "author": "branlwyd",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "Currently, the VDAF preparation process will always follow the initial call to `VDAF.prep_init` with a call to `VDAF.prep_next`. We should consider merging these calls such that the \"new\" `VDAF.prep_init_new` is a sequence of `VDAF.prep_init_old` followed by `VDAF.prep_next`. There are a few upsides to this API layout:\r\n\r\nThe API & preparation sequence would be simplified: for example, `prep_next`'s `inbound` parameter would no longer need to be optional. Error handling to users of this API would also be simplified, though in the spec a blanket exception catch is used so this point is moot.\r\n\r\nThis API layout also matches how `libprio-rs` implements the VDAF API, and will likely soon be how `divviup-ts` implements the VDAF API, so there is evidence that this API layout is preferable to some implementations. Matching the specification to the \"natural\" implementation will likely ease human understanding of the spec & its implementations.",
      "createdAt": "2023-05-31T18:17:31Z",
      "updatedAt": "2023-07-14T20:41:50Z",
      "closedAt": "2023-07-14T20:41:50Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "This was discussed before (https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/77). We decided then to leave open the possibility of a 0-round VDAF, but this is looking to be unlikely. I would be in favor of assuming VDAFs have at least 1 round and making this change. What do you think, @schoppmp?",
          "createdAt": "2023-05-31T23:11:25Z",
          "updatedAt": "2023-05-31T23:11:25Z"
        },
        {
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this change wouldn't preclude the possibility of a 0-round VDAF -- I suppose such a VDAF would initialize by calling `VDAF.prep_init` followed by `VDAF.prep_next` (which would immediately recover an output share), since `VDAF.prep_init` is defined to return only an initial preparation state & therefore has no way to complete preparation on its own.\r\n\r\nSo I think the change to 0-round VDAFs would be equivalent: `VDAF.prep_init` would be redefined to be a fusion of the current `VDAF.prep_init` followed by the current `VDAF.prep_next`, and the new `VDAF.prep_init` would be able to immediately finish.",
          "createdAt": "2023-06-01T00:06:12Z",
          "updatedAt": "2023-06-01T00:06:12Z"
        },
        {
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is a good idea. but it also requires some re-write of the ping-pong topology, which has a ping_ping_start that calls the old prep_init only, followed by a ping_pong_req/resp which will call prep_next.  ",
          "createdAt": "2023-06-21T17:19:32Z",
          "updatedAt": "2023-06-21T17:19:32Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that this is a good idea that would simplify things, and I don't think keeping the option for 0-round VDAFs is worth it anymore.",
          "createdAt": "2023-07-11T17:11:14Z",
          "updatedAt": "2023-07-11T17:11:14Z"
        }
      ]
    },
    {
      "number": 245,
      "id": "I_kwDOGKuqOc5nhl8N",
      "title": "Add extra test vectors with more than two shares",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/245",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "divergentdave"
      ],
      "labels": [],
      "body": "We should add additional test vector files for each VDAF that split into more than two shares, for better coverage.",
      "createdAt": "2023-06-01T18:26:23Z",
      "updatedAt": "2023-06-08T21:21:15Z",
      "closedAt": "2023-06-08T21:21:15Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds reasonable, but how many shares? Would we 2 and 3, say, or just 3?\r\n\r\nAlso, did you detect a bug that these test vectors would have covered?",
          "createdAt": "2023-06-03T01:28:52Z",
          "updatedAt": "2023-06-03T01:28:52Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "A combination of 2 and 3 shares sounds good. This came up during implementation in divviup-ts, with a latent bug in slicing seeds that happened to not be an issue with two shares.",
          "createdAt": "2023-06-03T01:33:13Z",
          "updatedAt": "2023-06-03T01:33:13Z"
        }
      ]
    },
    {
      "number": 246,
      "id": "I_kwDOGKuqOc5noWF_",
      "title": "Consider providing \"rand\" directly in test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/246",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "divergentdave"
      ],
      "labels": [],
      "body": "Currently, producing test vectors requires taking RAND_SIZE many bytes from the sequence [0, 1, 2, 3, ..., 254, 255, 0, 1, 2, ...]. We could instead provide the \"rand\" input in test vector files directly, hex encoded, so other implementations don't have to re-implement this detail of the test vector generation.",
      "createdAt": "2023-06-02T18:29:38Z",
      "updatedAt": "2023-06-08T21:37:15Z",
      "closedAt": "2023-06-08T21:37:14Z",
      "comments": [
        {
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(this might also be nice if certain behavior only exists, or is most easily exercised, with a given sequence of randomness)",
          "createdAt": "2023-06-02T20:30:31Z",
          "updatedAt": "2023-06-02T20:30:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "That seems fine to me. It. would be a little redundant to stick in the Appendix, but would definitely be helpful in the machine-readable test vectors.",
          "createdAt": "2023-06-02T20:35:15Z",
          "updatedAt": "2023-06-02T20:35:15Z"
        }
      ]
    },
    {
      "number": 252,
      "id": "I_kwDOGKuqOc5pJdol",
      "title": "Consider replacing ping_pong_* with input_share_to_out_share_*",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/252",
      "state": "CLOSED",
      "author": "wangshan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The functions begin with `ping_pong` is specific to the topology, the rest of VDAF interface specifies the purpose of each step, which I think makes more sense.\r\n\r\nTo make it consistent with `VDAF.measure_to_input_shares`, `VDAF.out_shares_to_agg_share`, `VDAF.agg_shares_to_result`, I think we should replace `ping_pong` with `input_share_to_out_share`. For e.g.\r\n```\r\ninput_share_to_out_share_start\r\ninput_share_to_out_share_req\r\ninput_share_to_out_share_resp\r\n```\r\n\r\nRelated, I have a few other thoughts about the ping pong steps.\r\n* Intuitively, I would think ping_pong_start transition the state to Start, but it actually transits to either Continue or Rejected.\r\n* Do we want to separate `ping_pong_req` and `ping_pong_resp`? they are essentially the same state transition step on Continue state, just react differently on input. \r\n\r\n",
      "createdAt": "2023-06-19T19:16:34Z",
      "updatedAt": "2023-07-14T12:53:26Z",
      "closedAt": "2023-07-14T12:53:26Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Bear in mind the purpose of this new text is to map VDAF preparation to a concrete communication pattern, which we're currently calling \"ping ponging\" (for lack of a better term). This is not the only valid communication pattern, so were we to make this change, I'd think we'd still want to make it specific to the communication pattern in DAP somehow.\r\n\r\n\r\n> Related, I have a few other thoughts about the ping pong steps.\r\n> \r\n>     * Intuitively, I would think ping_pong_start transition the state to Start, but it actually transits to either Continue or Rejected.\r\n\r\nI see what you're saying, but there is really no difference between `Continued` from ping_pong_start and `Continued` from ping_pong_req or pring_pong_resp: the same transition rules apply no matter how you got there.\r\n\r\nMaybe renaming would be helpful? Perhaps:\r\n* `Start` -> `Ready`\r\n* `Continued` -> `Waiting`\r\n\r\n\r\n \r\n>     * Do we want to separate `ping_pong_req` and `ping_pong_resp`? they are essentially the same state transition step on Continue state, just react differently on input.\r\n\r\nYes because the handling of `inbound` is different. The logic that is identical is already encapsulated by `ping_pong_transition`. I don't see a way to refactor further but you're welcome to give it a shot!\r\n\r\n",
          "createdAt": "2023-06-20T15:20:08Z",
          "updatedAt": "2023-06-20T15:20:08Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@wangshan can you take another look at this issue and let us know if there's anything else to do here?",
          "createdAt": "2023-07-12T22:21:17Z",
          "updatedAt": "2023-07-12T22:21:17Z"
        }
      ]
    },
    {
      "number": 254,
      "id": "I_kwDOGKuqOc5pJ5td",
      "title": "Message exchange described in ping pong topology does not match those in DAP arg-init",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/254",
      "state": "CLOSED",
      "author": "wangshan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "DAP's egg-init section https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/blob/main/draft-ietf-ppm-dap.md#aggregate-initialization-agg-init described the message exchange as following:\r\n\r\nleader calls `VDAF.ping_pong_start`\r\nleader calls `VDAF.ping_pong_req`, which returns state and `outbound` Message.\r\nleader constructs a `PrepareInit` message with the `outbound` Message.\r\n\r\nhelper calls `VDAF.ping_pong_start`\r\nhelper calls `VDAF.ping_pong_resp`, which returns state and `outbound` Message.\r\nhelper constructs a `PrepareResp` message with the `outbound` Message:\r\n\r\n> This procedure determines the initial per-report state, as well as the initial outbound to send in response to the Leader. If state == Rejected(), then the Helper responds with\r\n> \r\n> struct {\r\n>   ReportID report_id;\r\n>   PrepareRespState prepare_resp_state = reject;\r\n>   PrepareError prepare_error = vdaf_prep_error;\r\n> } PrepareResp;\r\n> Otherwise the Helper responds with\r\n> \r\n> struct {\r\n>   ReportID report_id;\r\n>   PrepareRespState prepare_resp_state = continue;\r\n>   opaque payload<0..2^32-1> = outbound;\r\n> } PrepareResp;\r\n\r\nBut this doesn't match what's in `ping_pong_transition`, which I believe will send out a `Finish` message. Besides, there is no Reject Message type, while DAP's `PrepareRespState` doesn't have an `Initialise` message type.\r\n\r\nI think the underlying logic for the simplified ping-pong topology is relatively clear, perhaps we can replace VDAF.Message and DAP.PrepareRespState with a `VDAF.PrepareState` type that just reflects the current _host_ state machine, and let peer react based on host state, peer state and peer state associated data:\r\n\r\n- leader prepares locally, with leader_input_share\r\n  - if failed, transit to `Reject` state, terminal\r\n  - otherwise transit to `Continue` state, sends a _Continue_ message to helper, with state associated data: leader_prep_share\r\n- helper prepares locally, with helper_input_share\r\n  - if failed, transit to `Reject` state, helper responds with _Reject_ message\r\n  - otherwise transit to `Continue` state\r\n- helper completes the preparation\r\n  - if failed, transit to `Reject` state, helper responds with _Reject_ message\r\n  - otherwise transit to `Finish` state, helper responds with _Finish_ message, and state associated data: prep_msg\r\n- leader completes the preparation, \r\n  - if received _Reject_ message, transit to `Reject` state, terminal\r\n  - if final prep failed, transit to `Reject` state, terminal\r\n  - otherwise transit to `Finish` state, terminal\r\n\r\n\r\n\r\n",
      "createdAt": "2023-06-19T20:49:30Z",
      "updatedAt": "2023-10-17T10:00:29Z",
      "closedAt": "2023-10-17T10:00:28Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> But this doesn't match what's in `ping_pong_transition`, which I believe will send out a `Finish` message. Besides, there is no Reject Message type, while DAP's `PrepareRespState` doesn't have an `Initialise` message type.\r\n\r\nThe way to think of`ping_pong_resp()` is that `outbound` is only set (i.e., not equal to `None`) if there is a message to send:\r\n* If the Helper reaches the `Rejected` state, then there is no message to send.\r\n* Else If the Helper reaches `Continued`, then there is a message to send.\r\n* Else if the Helper reaches `Finished`, then there is a message to send.\r\n",
          "createdAt": "2023-06-20T15:10:41Z",
          "updatedAt": "2023-06-20T15:10:41Z"
        },
        {
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Today's VDAF text doesn't really say how helper should communicate it has reached reject state:\r\n\r\n> To respond to the Leader, the Helper runs\r\n> (state, outbound) = Vdaf.ping_pong_resp(agg_param, state, inbound)\r\n> with state == Continued(helper_prep_state), where inbound is the message it received from the Leader, and sends outbound to the Leader.\r\n> \r\n> If state == Finished(out_share) at the end of a request/response cycle, then processing is complete. Note that, depending on the number of rounds of preparation that are required, there may be one more message to send before the peer can also finish processing (i.e., outbound != None).\r\n\r\nIt only describes Helper reaches Reject state, and the outbound is None, there's no message type to send back to Leader, but as part of the response, helper must send something. The Leader's final state transition requires that:\r\n\r\n```\r\ndef ping_pong_req(Vdaf,\r\n                  agg_param: Vdaf.AggParam,\r\n                  state: State,\r\n                  inbound: Optional[Message],\r\n                  ) -> (State, Optional[Message]):\r\n    if inbound == None:\r\n        prep_msg = None\r\n        peer_prep_share = None\r\n    elif inbound.type == 1: # continue\r\n        prep_msg = inbound.prep_msg\r\n        peer_prep_share = inbound.prep_share\r\n    elif inbound.type == 2: # finish\r\n        prep_msg = inbound.prep_msg\r\n        peer_prep_share = None\r\n    else:\r\n        return (Rejected(), None)\r\n\r\n```\r\n\r\nThis is, however, described in DAP:\r\n\r\n> If state == Rejected(), then the Helper responds with\r\n> \r\n> struct {\r\n>     ReportID report_id;\r\n>     PrepareRespState prepare_resp_state = reject;\r\n>     PrepareError prepare_error = vdaf_prep_error;\r\n> } PrepareResp;\r\n",
          "createdAt": "2023-06-21T15:19:52Z",
          "updatedAt": "2023-06-21T15:19:52Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think it's necessary that we do this at the VDAF level. Please take a look at the latest DAP draft: I claim that there it is unambiguous how to process each of the reports in the aggregation flow. If there is an issue let us know!",
          "createdAt": "2023-07-12T22:19:59Z",
          "updatedAt": "2023-07-12T22:19:59Z"
        },
        {
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "if the message exchange in ping_pong is for illustration only, then I agree DAP's description is the single source of truth.",
          "createdAt": "2023-07-14T12:52:46Z",
          "updatedAt": "2023-07-14T12:52:46Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "To be clear: VDAF *does* prescribe the format of the byte string passed to and from the ping pong API. DAP then takes these strings and does something with them, opaquely, without trying to parse them.",
          "createdAt": "2023-07-14T15:15:23Z",
          "updatedAt": "2023-07-14T15:15:23Z"
        },
        {
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "close this since the new ping pong api clarifies the state transitions.",
          "createdAt": "2023-10-17T10:00:28Z",
          "updatedAt": "2023-10-17T10:00:28Z"
        }
      ]
    },
    {
      "number": 255,
      "id": "I_kwDOGKuqOc5pJ_TJ",
      "title": "Define more common types",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/255",
      "state": "CLOSED",
      "author": "wangshan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Some of the commonly used types are not explicitly defined using TLS syntax, or mentioned in \"Conventions and Definitions\". For example:  \r\n\r\n- prep share\r\n- prep msg\r\n- input share\r\n- public share\r\n\r\nwhile similar ones like OutShare, Measurement is.\r\n\r\nother types like `Prep` is treated like a type but it's content not specified when it's mentioned, but only at a later time, for e.g https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/draft-irtf-cfrg-vdaf.md#communication-patterns-for-preparation-vdaf-prep-comm.\r\n\r\n\r\n",
      "createdAt": "2023-06-19T21:08:01Z",
      "updatedAt": "2024-08-20T01:43:06Z",
      "closedAt": "2024-08-20T01:43:06Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Typically you won't see cryptographic algorithms described in CFRG documents described in TLS syntax --- many predate RFC 8446 --- but I agree this would add clarity to the draft. As a bonus, it would allow us to remove some auxiliary functions that deal with serialization.\r\n\r\nI think the only question is whether TLS syntax is expressive enough. I think we should investigate.",
          "createdAt": "2023-06-20T14:40:36Z",
          "updatedAt": "2023-06-20T14:40:36Z"
        },
        {
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree, if TLS is not mandatory or fit for purpose, perhaps a more advanced general purpose language will make the description easier to understand.  ",
          "createdAt": "2023-06-21T14:57:25Z",
          "updatedAt": "2023-06-21T14:57:25Z"
        },
        {
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Related to this, in the generic FLP section (https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/draft-irtf-cfrg-vdaf.md#validity-circuits-flp-generic-valid), many types should have been defined and used, but instead a generic Vec[...] is used:\r\n\r\n`Valid.encode(measurement: Measurement) -> Vec[Field] returns a vector of length INPUT_LEN representing a measurement.`\r\n\r\n",
          "createdAt": "2023-06-30T17:50:53Z",
          "updatedAt": "2023-06-30T17:50:53Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> ... many types should have been defined and used, but instead a generic Vec[...] is used\r\n\r\nWhich types do you think are missing? ",
          "createdAt": "2023-07-12T21:29:48Z",
          "updatedAt": "2023-07-12T21:29:48Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I've started digging this but I'm confused about what the actual ask is here. Currently:\r\n1. If a value *must* be written to the wire in a protocol that uses VDAF, then our convention is to treat it as `Bytes`. This includes the prep share, prep message, input share, and public share.\r\n2. Otherwise if a value is not necessarily written to the wire, then our convention is to define an explicit type for it so that we can use it. This includes the prep state, output share, and aggregate result.\r\n\r\nIt sounds to me that folks would favor replacing the `Bytes` with an explicit type for the first category, i.e., prep share, prep message, input share, and public share?",
          "createdAt": "2023-07-12T21:49:17Z",
          "updatedAt": "2023-07-12T21:49:17Z"
        },
        {
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  sounds to me that folks would favor replacing the Bytes with an explicit type for the first category, i.e., prep share, prep message, input share, and public share?\r\n\r\nFor me, yes.\r\n\r\nI think my ask is similarly to https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/58. Defining explicit type (and specify encoding if necessary) makes the text more readable and also more flexible.\r\n",
          "createdAt": "2023-07-14T14:34:40Z",
          "updatedAt": "2023-07-14T14:34:40Z"
        },
        {
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My this this should be a separate issue, but should the `Prep` type be renamed to `PrepState`? since that's what it meant to represent: https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/draft-irtf-cfrg-vdaf.md#definition-of-vdafs-vdaf\r\n\r\n`Prep | State of each Aggregator during Preparation ({{sec-vdaf-prepare}})`\r\n\r\nthe ping ping topology also introduces a `State` type, which looks like a enum with associated data of type `Prep`, but it's not fully defined in the text:\r\nhttps://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/draft-irtf-cfrg-vdaf.md#ping-pong-topology-only-two-aggregators\r\n\r\n```\r\ndef ping_pong_req(Vdaf,\r\n                  agg_param: Vdaf.AggParam,\r\n                  state: State,\r\n                  inbound: Optional[Message],\r\n                  ) -> (State, Optional[Message]):\r\n```\r\n\r\n\r\n\r\n",
          "createdAt": "2023-07-14T14:51:22Z",
          "updatedAt": "2023-07-14T14:51:22Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Renaming `Prep` to `PrepState` is a good idea \ud83d\udc4d \r\n\r\nI'd like to drill down on the question about explicit types further. What would be the purpose? To make the encoding format explicit, or to be consistent with the other values?\r\n\r\nThe question in #58 is whether this document should be prescriptive about encoding at all. (We currently are.)\r\n",
          "createdAt": "2023-07-14T15:13:34Z",
          "updatedAt": "2023-07-14T15:13:34Z"
        },
        {
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'd like to drill down on the question about explicit types further. What would be the purpose? To make the encoding format explicit, or to be consistent with the other values?\r\n\r\nthe latter. ",
          "createdAt": "2023-07-14T15:35:18Z",
          "updatedAt": "2023-07-14T15:35:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> > I'd like to drill down on the question about explicit types further. What would be the purpose? To make the encoding format explicit, or to be consistent with the other values?\r\n> \r\n> the latter.\r\n\r\nGot it. Let me drill down one step further, and let's focus on input shares: In your opinion, should this document (1) define a type for the input share, (2) define the wire format of an input share, or (3) both? If (3), what would be the benefit of also defining a type, if we've already specified the wire format?\r\n\r\nHere's a concrete proposal.\r\n\r\nFirst, change the type of the input share from `bytes` to `Vdaf.InputShare`. For Prio3 it would be something like \r\n```python3\r\ntuple[\r\n  Union[bytes[Prio3.Prg.SEED_SIZE], Vec[Prio3.Flp.Field[Prio3.Flp.INPUT_LEN]]],\r\n  Union[bytes[Prio3.Prg.SEED_SIZE], Vec[Prio3.Flp.Field[Prio3.Flp.PROOF_LEN]]],\r\n  Optional[bytes[Prio3.Prg.SEED_SIZE]],\r\n]\r\n```\r\n\r\nSecond, in a separate section, perhaps towards the bottom, specify the wire format of the input share. For Prio3 it would be something like (in TLS syntax):\r\n```\r\nstruct {\r\n  select (is_leader) {\r\n     case true:\r\n       Prio3.Flp.Field meas_share[Prio3.Flp.INPUT_LEN];\r\n       Prio3.Flp.Field proof_share[Prio3.Flp.PROOF_LEN];\r\n     default:\r\n        uint8t k_meas_share[Prio3.Prg.SEED_SIZE];\r\n        uint8t k_proof_share[Prio3.Prg.SEED_SIZE];\r\n  };\r\n  select (use_joint_rand) {\r\n    case true: uint8 k_blind[Prio3.Prg.SEED_SIZE];\r\n    default: Empty; \r\n  };\r\n} Prio3InputShare;\r\n```\r\n\r\nWDYT @wangshan? I'd also be curious to here what @branlwyd makes of this plan. \r\n",
          "createdAt": "2023-07-14T22:28:41Z",
          "updatedAt": "2023-07-14T22:28:41Z"
        },
        {
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the idea to specify an explicit type for the preparation share (rather than using a generic type like `Bytes`, to represent the serialized data) -- this will make understanding the specification easier, IMO.\r\n\r\nI don't have as strong an opinion on the wire format change, but I'd understand TLS syntax (or another \"standard\" structured-data specification format) more easily than the current ad-hoc serialization.\r\n\r\nBut is there a reason to use both the `tuple` format & the TLS-syntax `Prio3InputShare` format? Naively, I'd specify only the TLS-syntax format, and write the relevant algorithms to take/return this structure, then say to do standard TLS-syntax serialization for over-the-wire transmission of values. This seems simpler to me than specifying one format for use in the algorithms & one format for the wire (and I suppose defining how to translate between them).",
          "createdAt": "2023-07-17T05:56:49Z",
          "updatedAt": "2023-07-17T05:57:24Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see why we couldn't do that, but we'd have to invent a bit of glue between TLS-syntax and python (@wangshan suggested this). For example, we'd need to make the following code meaningful:\r\n```python3\r\ninput_shares = [Prio3InputShare(leader_meas_share, leader_proof_share, k_leader_blind)]\r\nfor j in range(Prio3.SHARES - 1):\r\n   input_shares.append(Prio3InputShare(k_helper_meas_share[j], k_helepr_proof_sahre[j], k_helper_blind[j]))\r\n```\r\n\r\nFWIW we kind of already do this with the ping-pong API.\r\n\r\nOne advantage of keeping things split is that we don't have to invent anything new. In particular the main section of the document would just speak in terms of python, then we'd have a separate section that would deal with the (optional, see #58) serialization bits.",
          "createdAt": "2023-07-17T15:45:55Z",
          "updatedAt": "2023-07-17T15:45:55Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I've put a PR up to address the bulk of this issue, PTAL. The remaining parts are documented as TODOs.",
          "createdAt": "2023-08-02T01:57:52Z",
          "updatedAt": "2023-08-02T01:57:52Z"
        }
      ]
    },
    {
      "number": 256,
      "id": "I_kwDOGKuqOc5qRGPb",
      "title": "The purpose of the 2nd FLP extension is not clear",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/256",
      "state": "CLOSED",
      "author": "wangshan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial"
      ],
      "body": "The generic FLP extension section (https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/draft-irtf-cfrg-vdaf.md#extensions-flp-generic-overview-extensions) mentioned 3 extensions to original FLP. The first and third one has clear purpose: shorten proof and enable FFT, respectively. But the 2nd extension: allow multiple gadget types, is not very clear for its purpose. Is the example C given an equivalent to the C above it?\r\n\r\n",
      "createdAt": "2023-06-30T17:10:00Z",
      "updatedAt": "2023-07-14T21:24:47Z",
      "closedAt": "2023-07-14T21:24:47Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "The example given is not very clear, but the idea is that you may have multiple, non-affine computations in your circuit. Perhaps the best example we have right now is [`FixedPointBoundedL2Norm`](https://docs.rs/prio/latest/prio/vdaf/prio3/type.Prio3FixedPointBoundedL2VecSum.html), which has a degree-2 gadget and a degree-3 gadget.\r\n\r\nWould a more realistic example be useful?",
          "createdAt": "2023-07-11T16:23:37Z",
          "updatedAt": "2023-07-11T16:23:37Z"
        },
        {
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this might be just editorial, mentioning this extension is to help developer define \"have multiple, non-affine computations in your circuit\" is probably sufficient",
          "createdAt": "2023-07-14T13:06:00Z",
          "updatedAt": "2023-07-14T13:06:00Z"
        }
      ]
    },
    {
      "number": 257,
      "id": "I_kwDOGKuqOc5qRRUU",
      "title": "A diagram to show the relationship of different terms in FLP",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/257",
      "state": "CLOSED",
      "author": "wangshan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial"
      ],
      "body": "There are many terms discussed in the generic FLP section (https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/draft-irtf-cfrg-vdaf.md#a-general-purpose-flp-flp-generic):\r\nGadgets, Validity Circuits, Proof, Prover, Verifier, etc. A diagram shows the relationship between them would make the text easier to follow.",
      "createdAt": "2023-06-30T17:42:20Z",
      "updatedAt": "2024-08-22T16:18:53Z",
      "closedAt": "2024-08-22T16:18:53Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "We can definitely whip up a ladder diagram for this.",
          "createdAt": "2023-07-11T16:20:43Z",
          "updatedAt": "2023-07-11T16:20:43Z"
        }
      ]
    },
    {
      "number": 258,
      "id": "I_kwDOGKuqOc5qSG0R",
      "title": "Is joint randomness optional",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/258",
      "state": "CLOSED",
      "author": "wangshan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial"
      ],
      "body": "The pseudo code in prio3 sharding(https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/draft-irtf-cfrg-vdaf.md#sharding) suggests joint randomness is optional, but the draft text never describes it that way.\r\n\r\nUp to this point, the purpose of joint randomness is not specified yet (it is in the generic flp section later). How should people choose whether to use joint randomness or not? If the purpose is just for shortening the proof, then the text should compare proof size based on different Field size and soundness tolerance, and perhaps compare it with the case where joint randomness is not used. \r\n\r\nFor e.g. if I choose to NOT use joint randomness, and use Field32, do I essentially have a protocol similar to Prio2 with SNIP? Does it have a soundness error of 2^-32? If so then Prio3 with Field128 actually have a far bigger overall input share size compared to Prio2 with Field32, due to the 4x field size increase.",
      "createdAt": "2023-06-30T20:31:10Z",
      "updatedAt": "2023-08-17T01:17:18Z",
      "closedAt": "2023-08-17T01:17:17Z",
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "When clarifying this, we may want to explain that Prio3 produces a zero-knowledge proof over secret shared data by compiling either a fully linear probabilistically checkable proof (in the no-joint randomness case) or a 1.5-round public coin fully linear interactive oracle proof (in the joint randomness case). While the ultimate goal of the joint randomness is shorter proofs, the mechanism by which it achieves that is switching to an entirely different protocol topology, which enables new space-saving tricks in the proof circuit. I think whether to use joint randomness thus comes down to tradeoffs made when designing a new circuit.",
          "createdAt": "2023-06-30T20:59:23Z",
          "updatedAt": "2023-06-30T20:59:23Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to #215.\r\n\r\n",
          "createdAt": "2023-07-03T15:43:31Z",
          "updatedAt": "2023-07-03T15:43:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> When clarifying this, we may want to explain that Prio3 produces a zero-knowledge proof over secret shared data by compiling either a fully linear probabilistically checkable proof (in the no-joint randomness case) or a 1.5-round public coin fully linear interactive oracle proof (in the joint randomness case). \r\n\r\nWe already do explain this here: https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-06.html#section-7.1-12\r\n\r\n> While the ultimate goal of the joint randomness is shorter proofs, the mechanism by which it achieves that is switching to an entirely different protocol topology, which enables new space-saving tricks in the proof circuit. I think whether to use joint randomness thus comes down to tradeoffs made when designing a new circuit.\r\n\r\nAgreed, I'm working on a PR to explain this a bit more clearly.\r\n\r\n",
          "createdAt": "2023-07-12T22:07:23Z",
          "updatedAt": "2023-07-12T22:07:23Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmmm, looking at the text once more, it does seem like we try to explain how the joint randomness is intended to be used: https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-06.html#section-7.3.1.1-2\r\n\r\n@wangshan given this pointer, is there something else you'd like us to do here to make things more clear?\r\n\r\nFor what it's worth, @chris-wood's feedback on this section (https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/226) suggests it can do with rewrite. I suppose you'd advocate for the same thing?",
          "createdAt": "2023-07-12T22:15:42Z",
          "updatedAt": "2023-07-12T22:15:42Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this as there doesn't seem to be any work to do here.",
          "createdAt": "2023-08-17T01:17:17Z",
          "updatedAt": "2023-08-17T01:17:17Z"
        }
      ]
    },
    {
      "number": 259,
      "id": "I_kwDOGKuqOc5qSaHD",
      "title": "Make DAF a special case of VDAF and move it to sections after VDAF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/259",
      "state": "CLOSED",
      "author": "wangshan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This had been discussed in: https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/20. I think it was right to name DAF explicitly and keep it in this document. However, since DAF is at the beginning of this doc, a lot of the key components of VDAF is introduced from DAF, the reader would have to refer to DAF section for the common part and figure out what's the difference. Given that DAF is not recommended and not the main focus of this document, shall we move it to somewhere after VDAF. So section 4 can be definition of VDAFs, right after Overview. \r\n\r\nDAF can be explained as a VDAF without a verification system, maybe it makes sense to mention it after Poplar1? We can try to keep the same interface between DAF and VDAF, but specify parameters like `nonce` and `verify_key` are not used (I imagine this would be how it will be implemented), or still keep the separate interface. ",
      "createdAt": "2023-06-30T22:09:13Z",
      "updatedAt": "2024-06-11T18:00:19Z",
      "closedAt": "2024-06-11T18:00:18Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "This is actually intended. Currently the text is structured such that DAF is a \"warm-up\" for VDAF:\r\n1. Define DAF\r\n2. Describe its intended functionality/privacy goals\r\n3. Say that it's not robust\r\n4. Define VDAF as an interactive version of DAF that gets robustness.\r\n\r\nThat said I can see the merits in making the VDAF section self-contained. I think we could make the text equally clear by introducing VDAF first, but it would require a bit of work.\r\n\r\nDo you have a suggestion for how to make make the `Daf` API a special case of `Vdaf`?",
          "createdAt": "2023-07-11T15:23:02Z",
          "updatedAt": "2023-07-11T15:23:02Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "TODOs from call 2023/7/11:\r\n* Add nonce to API (we need this for IDPF anyway)\r\n* Consider moving DAF after VDAF.",
          "createdAt": "2023-07-11T17:15:34Z",
          "updatedAt": "2023-07-11T17:15:34Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Nonce has been added to the API, so this is ready to close. We'll consider removing DAFs altogether in #346.",
          "createdAt": "2024-06-11T18:00:18Z",
          "updatedAt": "2024-06-11T18:00:18Z"
        }
      ]
    },
    {
      "number": 260,
      "id": "I_kwDOGKuqOc5qSutN",
      "title": "Use verb to describe the 4 stages of VDAF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/260",
      "state": "CLOSED",
      "author": "wangshan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Change all functions to prepend a verb, for eg. `measurement_to_input_shares` -> `shard_measurement_to_input_shares`, `out_shares_to_agg_share` -> `aggregate_out_shares_to_agg_share`, this not only matches the description of the text (4 stages) but also follows common coding styles. \r\n\r\nWe can go future by only keeping the verb, as long as we define all the associated types. `shard(Measurement, ...) -> tuple[PublicShare, Vec[InputShare]]` is as more clear and concise than `shard_measurement_to_input_shares(Measurement, ...) -> tuple[Bytes, Vec[Bytes]]`. This is basically what libprio.rs is doing anyway.",
      "createdAt": "2023-07-01T00:33:00Z",
      "updatedAt": "2023-07-14T21:32:35Z",
      "closedAt": "2023-07-14T21:32:35Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I have no objection. The names \"shard\", \"prepare\", \"aggregate\", and \"unshard\" are fairly well-established. @bifurcation came up with the original naming scheme, so we'll make sure to get his review on the PR.",
          "createdAt": "2023-07-11T14:50:50Z",
          "updatedAt": "2023-07-11T14:50:50Z"
        }
      ]
    },
    {
      "number": 261,
      "id": "I_kwDOGKuqOc5rP5bX",
      "title": "Spell out star topology for VDAFs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/261",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "feature"
      ],
      "body": "We spelled out \"ping pong\" because we needed it for DAP-05. We also [need to spell out the \"star\" topology](https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-06.html#name-star-topology-any-number-of).",
      "createdAt": "2023-07-11T16:38:28Z",
      "updatedAt": "2024-08-07T15:35:40Z",
      "closedAt": "2024-08-07T15:35:40Z",
      "comments": []
    },
    {
      "number": 262,
      "id": "I_kwDOGKuqOc5rQRqz",
      "title": "Flp: Let the circuit output be a vector?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/262",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "feature",
        "idea"
      ],
      "body": "While looking at #258, I was considering how one might implement the Prio2 or Prio3CountVec AFE while using Prio3 without joint randomness. No joint randomness means we can't use random linear combinations. Thus, I think we'd be left with taking the conjunction of multiple range check sub-circuits by raising each sub-circuit output to the power $p-1$, which would be pretty expensive. (I think you'd have to split the exponentiation into multiple gadgets for it to be feasible)\r\n\r\nThis conjunction could be avoided entirely if we let the circuit output a vector instead of a single field element, and require that it be equal to $\\vec{0}$ instead of $0$. Circuits that take advantage of such a change would have a bigger verifier message, but it would give us more power/expressiveness without joint randomness.\r\n\r\nI'm not sure if this change is actually worth making in the document, but I figure it would be a useful counterfactual in Prio2 vs. Prio3 benchmark conversations, and in the broader joint randomness discussion.",
      "createdAt": "2023-07-11T17:35:49Z",
      "updatedAt": "2024-06-20T16:30:58Z",
      "closedAt": "2024-06-20T16:30:58Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like a reasonable change to me, but we need to spend some time thinking about how it impacts existing security analysis. At first blush I can't see how this would possibly be a problem.\r\n\r\nI'm also slightly wary about feature creep. It's definitely worth including if it significantly improves performance for a concrete use case.",
          "createdAt": "2023-07-11T17:53:37Z",
          "updatedAt": "2023-07-11T17:53:37Z"
        },
        {
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think having `valid()` return a vector, or using \"verifier randomness\" to perform reduction of multiple checks per #266 is for good practice, because it eliminates the need of specifically using joint randomness to perform reduction, if joint randomness doesn't have to be part of proof generation (e.g. joint randomness is still needed in the proof size reduction trick in `Prio3SumVec`, also mentioned in #266 ). Using the proposal in #266 is generally ok, except it introduces a small soundness error, if one does it carefully, i.e. chooses a randomness that is completely random and not known to prover. Returning a vector will not have such soundness error. But in either case, the goal should be to not let prover know how verifiers are verifying multiple checks in a particular FLP type, e.g. (1) whether verifiers are doing a reduction of multiple checks, and (2) what randomness verifiers use to perform reduction. However, currently in FLP interface, `valid()` requires a FLP to perform \"some\" reduction in order to return a single value, and the only randomness that is available is joint randomness, which prover has \"some\" control over. Logically, prover should just construct the proof for gadgets, and be done (theoretically it can always claim `valid()` return 0).\r\n\r\n@divergentdave Regarding eliminating joint randomness specifically in `Prio3SumVec`, I think the current `Histogram` FLP type actually can accomplish this for 0/1 range check with polynomial `x^2-x`, with some tweaks, i.e. don't use joint randomness to perform reduction. (Obviously `Prio3SumVec` supports a more generic measurement type, which is a bit vector or sum vector, and `Prio3Histogram` supports one-hot vector, but 0/1 range check applies in both cases.)\r\n\r\nLet's say the encoded measurement in `Histogram` is `X`, and `len(X) = n`.\r\nFrom a code logic perspective, the heavy lifting logic is in [`call_gadget_on_vec_entries`](https://github.com/divviup/libprio-rs/blob/release/0.12/src/flp/types.rs#L668-L680), which is called by `Histogram.valid()` function, and `rnd` is never fed into the gadget, so it won't be part of proof generation. So theoretically, prover can simply call `g.call()` on every vector entry and be done. The [wire polynomial interpolation](https://github.com/divviup/libprio-rs/blob/release/0.12/src/flp.rs#L318-L326), and [gadget polynomial construction](https://github.com/divviup/libprio-rs/blob/release/0.12/src/flp.rs#L328-L332) will then be constructed by `Flp.prove()` method. So prover shouldn't need to know whether verifiers choose to do a reduction, and what randomness is used if a reduction is done.\r\n\r\nMathematically, I think there is only one \"wire polynomial\" here (`arity=1`), `f`, which is interpolated based on `X` (or secret shares of `X` for verifiers), and should have degree `O(n)`, and prover obtains the gadget polynomial `p`, by feeding `f` as `x` into polynomial under verification: `x^2 - x`. The gadget polynomial allows each verifier to linearly evaluate its *secret shares* of `X_i^2 - X_i`, by evaluating gadget polynomial `p` at input `i`. Prover only passes verification, if verifiers sum up the secret shares for each index `i`, and all sums are 0.\r\n\r\nNow to verify `X_i^2-X_i` for all `i`, verifier can either exchange secret shares for all `i`, as a vector per proposal of this issue, or exchange a reduction of all `X_i^2 - X_i` per issue #266 , with \"verifier randomness\". There is also an [\"one-hotness\" property](https://github.com/divviup/libprio-rs/blob/release/0.12/src/flp/types.rs#L405-L409) verified by `Histogram.valid()`, which verifiers can evaluate directly (since it's a degree-1 polynomial) and exchange the secret shares, or fold the one-hotness check into the reduction as well.\r\n\r\nOne can argue eliminating joint randomness here is (marginally?) more secure, because now prover doesn't need to know joint randomness. Per the current FLP architecture that `Histogram` is implemented based on, prover actually knows verifiers are not exactly checking `X_i^2-X_i` for all `i`, instead, they are verifying `r_1 * (\\sum_i r_0^i * (X_i^2 - X_i)) + r_1^2 * ((\\sum_i X_i) - 1)`, where `r_0` and `r_1` are joint randomness, derived based on the PRG hash function that [includes the secret shares of `X` in Prio3 types](https://github.com/divviup/libprio-rs/blob/release/0.12/src/vdaf/prio3.rs#L419-L425), which prover still has \"some\" control over. Prover can try to brute force and find out a  `r_0` and `r_1` that makes verification return 0, and soundness error therefore increases per Theorem 1 of [VDAF paper](https://eprint.iacr.org/2023/130.pdf). If we eliminate joint randomness, we no longer have this attack surface, and therefore, can potentially reduce the field size used in `Histogram` today (it currently [uses `Field128`](https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-06.html#name-prio3histogram)). Proof size wise, I think `Prio3Histogram` is still more expensive than `Prio2` though, `2 * ((n + 1).next_power_of_two() - 1) + 2` vs `(n + 1).next_power_of_two() + 3` (taken from libprio-rs).\r\n\r\nAnother consideration on which approach we should take between this issue and #266 : if we try to tackle #177 in the future, I don't know yet which approach will accommodate an implementation for #177 better, because to do multiple proofs for a FLP that needs joint randomness, one needs the flexibility to evaluate `valid()` twice, with different gadget polynomials, or one has to reduce the outputs from multiple gadget polynomials with \"verifier randomness\" in #266.\r\n\r\n@divergentdave @cjpatton What do you guys think?",
          "createdAt": "2023-07-14T11:42:28Z",
          "updatedAt": "2023-07-14T13:22:28Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think having `valid()` return a vector, or using \"verifier randomness\" to perform reduction of multiple checks per #266 is for good practice, because it eliminates the need of specifically using joint randomness to perform reduction, if joint randomness doesn't have to be part of proof generation (e.g. joint randomness is still needed in the proof size reduction trick in `Prio3SumVec`, also mentioned in #266 ). Using the proposal in #266 is generally ok, except it introduces a small soundness error, if one does it carefully, i.e. chooses a randomness that is completely random and not known to prover.\r\n\r\nIt's true the soundness error goes up, but not by very much. If there are a constant number of checks, then the soundness error increase is constant as well, something like `O(1/|F|)`. And users like Prio3 will have to take care to make sure the verifier randomness is produced securely (as they must do for the query randomness).\r\n\r\n> Another consideration on which approach we should take between this issue and #266 : if we try to tackle #177 in the future, I don't know yet which approach will accommodate an implementation for #177 better, because to do multiple proofs for a FLP that needs joint randomness, one needs the flexibility to evaluate `valid()` twice, with different gadget polynomials, or one has to reduce the outputs from multiple gadget polynomials with \"verifier randomness\" in #266.\r\n\r\nI think that we'd get the benefit either way.\r\n\r\n> @divergentdave @cjpatton What do you guys think?\r\n\r\nI think it's a good idea to make the circuit output a vector, as @divergentdave suggests, but I don't think increasing the size of the size of the verifier shares by `N` field elements is acceptable, in particular for circuits whose outputs are linear in the input length, as @junyechen1996 suggests.\r\n\r\nCombining the two ideas, we could do something like this?\r\n* `Circuit.valid(input: Vec[Field], joint_rand: Vec[Field]) -> Vec[Field]` called by both prover and verifier\r\n* `Circuit.valid_finish(intermediate_output: Vec[Field], verifier_rand: Vec[Field]) -> Field` called by the verifier only on the output of `valid()`",
          "createdAt": "2023-07-14T15:35:08Z",
          "updatedAt": "2023-07-14T16:03:50Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "We could borrow from #266, but fix the verifier-only `valid_finish()` part to always be a random linear combination using pseudorandom vectors derived from the verification key. Having an additional fully general circuit would complicate both security analysis and design of new types of circuits.",
          "createdAt": "2023-07-14T18:58:50Z",
          "updatedAt": "2023-07-14T18:58:50Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "That sounds like a good idea! WDYT @junyechen1996?",
          "createdAt": "2023-07-14T20:32:45Z",
          "updatedAt": "2023-07-14T20:32:45Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "So the current proposal would be:\r\n1. Let valid() output a vector\r\n2. Have the verifier check that the output vector is $\\vec{0}$ by taking a random linear combination with verifier-generated randomness (probably just the query randomness)?\r\n\r\nWhile at it, I want to suggest that we do away with the `FlpGeneric` thing and just say \"this is how we instantiate `Flp`\".",
          "createdAt": "2023-07-14T21:31:35Z",
          "updatedAt": "2023-07-14T21:32:17Z"
        },
        {
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it sounds good. For\r\n\r\n> Have the verifier check that the output vector is 0 by taking a random linear combination with verifier-generated randomness (probably just the query randomness)?\r\n\r\nI think using query randomness here sounds good. I don\u2019t see a particular reason to introduce another type of randomness.",
          "createdAt": "2023-07-15T01:39:29Z",
          "updatedAt": "2023-07-15T01:39:29Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Another question: Could/should Prio3Sum and Prio3Histogram be changed to drop joint rand in favor of query rand?",
          "createdAt": "2023-07-17T15:30:37Z",
          "updatedAt": "2023-07-17T15:30:37Z"
        },
        {
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Another question: Could/should Prio3Sum and Prio3Histogram be changed to drop joint rand in favor of query rand?\r\n\r\nI don't see any downside of dropping joint randomness. Ideally we should avoid using joint randomness in verification if it's not used in proof generation. It doesn't seem like joint randomness is needed by `Prio3Sum` or `Prio3Histogram` in [proof generation](https://github.com/divviup/libprio-rs/blob/release/0.12/src/flp/types.rs#L676). But the current limitation is `valid()` function only has access to joint randomness, but I think it will be relaxed if this change takes place.",
          "createdAt": "2023-07-17T17:21:34Z",
          "updatedAt": "2023-07-17T17:21:34Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Prio3Sum and Prio3Histogram both use joint randomness in proof generation, it's passed in via the `rnd` argument of the `call_gadget_on_vec_entries()` function linked. When at least one joint randomness element is used in a circuit's definition, (see the figures for [Histogram](https://cfrg.github.io/draft-irtf-cfrg-vdaf/draft-irtf-cfrg-vdaf.html#section-7.4.3-5) and [Sum](https://cfrg.github.io/draft-irtf-cfrg-vdaf/draft-irtf-cfrg-vdaf.html#section-7.4.2-7) in the draft) this will always be the case, as the client needs it to produce the circuit output.\r\n\r\nIf the proposed change here were applied to these Prio3 instances, the `valid()` method would return a vector of field elements, and joint randomness could be removed from the circuit.",
          "createdAt": "2023-07-17T17:36:40Z",
          "updatedAt": "2023-07-17T17:36:40Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "right, the suggestion is that we change the `Histgram` and `Sum` circuits so that the they don't use joint rand and instead do the reduction on the output of `valid`. I think this would work for both of these.\r\n\r\nTo be clear: I'm not suggesting we do away with joint rand altogether. Wherever a gadget input takes in the joint rand the prover will need to know the value that's used.\r\n\r\n",
          "createdAt": "2023-07-17T18:30:16Z",
          "updatedAt": "2023-07-17T18:30:16Z"
        },
        {
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes I should be clearer as well. Regarding\r\n\r\n> I don't see any downside of dropping joint randomness. \r\n\r\nI meant if the type doesn't need joint randomness during proof generation like @cjpatton said, i.e. joint randomness is not fed into any gadget. I think neither `Sum` nor `Histogram` feeds joint randomness into gadgets, so I think using \"verifier randomness\" to perform reduction would be better since prover doesn't need to know joint randomness.\r\n\r\nJoint randomness is still needed in `SumVec`, which uses the proof reduction trick with joint randomness feeding as inputs to gadgets.",
          "createdAt": "2023-07-17T22:16:57Z",
          "updatedAt": "2023-07-17T22:17:29Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I've spent some time thinking about this and I so no reason why this change would break anything. I'd only add one requirement: we need to document this in https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-06.html#section-7.3.1.1 as an extension of the FLP from {{BBCGGI19}} so that it's clear to reviewers that we're doing something slightly different.\r\n\r\nThat said, I'm not aware of any `Flp` user that would benefit significantly from this change. Prio3Histogram was cited as an example where we could avoid Fiat-Shamir, but as of https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/284 we'll need to do it anyway. Prio3Sum would benefit a little, but it's already quite fast.",
          "createdAt": "2023-08-17T01:15:13Z",
          "updatedAt": "2023-08-17T01:15:13Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Are folks OK with punting this discussion until after the next draft? Or do we want it for draft-07? cc/ @junyechen1996 ",
          "createdAt": "2023-08-17T01:15:55Z",
          "updatedAt": "2023-08-17T01:15:55Z"
        },
        {
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think there is any rush to implement this for draft-07.",
          "createdAt": "2023-08-17T10:42:16Z",
          "updatedAt": "2023-08-17T10:42:16Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue has been open for several months without much movement. Is there still interest in adding this feature to FLP?\r\n\r\nI believe the only circuits for which we get savings are those for which joint randomness is not passed into a gadget and  used only to reduce the outputs:\r\n\r\n- This is TRUE for Prio3Sum. In fact, by removing joint randomness and changing the field from Field128 to Field64, we reduce the number of bits uploaded by the client (the public share and two input shares) from 1376 bytes to about 700. The number of bytes exchanged during preparation wouldn't change significantly. (Note that using the circuit as-is, but using Field64 and 2 proofs is about the same cost as with Field64 and 1 proof.)\r\n\r\n- This is NOT TRUE for Prio3Histogram or Prio3SumVec. Though as @divergentdave points, for small vectors it may be worth dropping the ParallelSum trick in favor of something linear.\r\n\r\n- I think this is currently NOT TRUE for [PINE](https://github.com/junyechen1996/draft-chen-cfrg-vdaf-pine/blob/main/poc/flp_pine.py) because [the ParallelSum trick is applied to the wraparound tests](https://github.com/junyechen1996/draft-chen-cfrg-vdaf-pine/blob/f803bb9034a4ed6f85b9ef37180ae07ffcaebb6f/poc/flp_pine.py#L331-L332). However if we take https://github.com/junyechen1996/draft-chen-cfrg-vdaf-pine/issues/60, then this may no longer be necessary.",
          "createdAt": "2024-06-06T19:16:29Z",
          "updatedAt": "2024-06-06T19:16:29Z"
        },
        {
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think these all sound right. I'm not particularly worried about computing a random linear combination of multiple circuit outputs, which only increases soundness error by a negligible amount if field size is large. But if we use joint randomness to do this reduction, it complicates the security analysis a bit, because now client has control over this reduction.\r\n\r\nBtw, I don't think this will be a breaking change for the wire format between client and server, assuming field size remains the same? If joint randomness is not used in proof generation, aggregators can just use their private randomness to reduce the circuit outputs. I believe all our VDAFs first generate joint randomness field elements used in proof generation, then generate more if they are needed to reduce circuit outputs. We can just avoid generating those joint randomness field elements for reducing circuit outputs?",
          "createdAt": "2024-06-07T13:15:29Z",
          "updatedAt": "2024-06-07T13:17:38Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think these all sound right. I'm not particularly worried about computing a random linear combination of multiple circuit outputs, which only increases soundness error by a negligible amount if field size is large. But if we use joint randomness to do this reduction, it complicates the security analysis a bit, because now client has control over this reduction.\r\n\r\nIt complicates analysis insofar as we have to account for attacks on Fiat-Shamir, hence the larger field (or more proof). Did you have anything else in mind beyond this?\r\n\r\n\r\n> Btw, I don't think this will be a breaking change for the wire format between client and server, assuming field size remains the same?\r\n\r\nI agree, we can make this change without breaking changes to existing circuits. That said, we may consider modifying existing circuits to make them ore efficient, such as `Sum`.\r\n\r\n> If joint randomness is not used in proof generation, aggregators can just use their private randomness to reduce the circuit outputs.\r\n\r\nThis should work:\r\n\r\n- each aggregator $j$ chooses a random $r_j$ and broadcasts $[M]_j = v_0 + r_j \\cdot [v_1]_j + r_j^2 \\cdot [v_2]_j + \\cdots$ where $[v_i]$ is its share of the $i$-th circuit output.\r\n- to finish preparation, compute $M = [M]_1 + \\cdots + [M]_S = v_0 + (r_1 + \\cdots r_S) \\cdot v_1 + (r_1^2 + \\cdots r_S^2) \\cdot v_2 + \\cdots$ and check if $M=0$.\r\n\r\nOne problem is that we would like preparation to be de-randomized. To do this, we'd have each aggregator derive their verification randomness $r_j$ from the verification key, similar to how they derive the query randomness.\r\n\r\nI would also simplify this further by having each aggregator compute a share of the same verification randomness $r$. We do this in the circuit with joint randomness by dividing by the number of shares $S$.\r\n\r\n> I believe all our VDAFs first generate joint randomness field elements used in proof generation, then generate more if they are needed to reduce circuit outputs. We can just avoid generating those joint randomness field elements for reducing circuit outputs?\r\n\r\nWe only generate joint randomness if `Flp.JOINT_RAND_LEN > 0`.\r\n\r\n",
          "createdAt": "2024-06-07T13:55:32Z",
          "updatedAt": "2024-06-07T13:56:07Z"
        },
        {
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Did you have anything else in mind beyond this?\r\n\r\nNot really. Maybe if the circuit already needs joint randomness to do proof generation, using more joint randomness to reduce circuit outputs isn't a terrible thing..?\r\n\r\n> This should work:\r\n\r\nI don't quite get this part. Shouldn't $r_j$ be agreed upon among aggregators? It should be like this?\r\n\r\n* aggregators agree on a verification randomness $r$, derived from the verification key, similarly as query randomness.\r\n* each aggregator j broadcasts $M_j = [v_0]_j + r * [v_1]_j + r^2 * [v_2]_j + ...$, where $[v_i]_j$ is aggregator $j$'s share of the i-th circuit output.\r\n* to finish preparation among $S$ aggregators, compute $M=M_1 + ... + M_S = ([v_0]_1 + ... + [v_0]_S) + r * ([v_1]_1 + ... + [v_1]_S) + r^2 * ([v_2]_1 + ... + [v_2]_S) + ...$, and check if $M$ is 0.\r\n",
          "createdAt": "2024-06-07T14:37:34Z",
          "updatedAt": "2024-06-07T14:41:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah that what I was suggesting here:\r\n\r\n> I would also simplify this further by having each aggregator compute a share of the same verification randomness $r$.\r\n\r\n\r\n",
          "createdAt": "2024-06-07T18:16:37Z",
          "updatedAt": "2024-06-07T18:16:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "There's a PR up for extending FLP. I'm going to assume there's no appetite to modify the circuits for which we don't get any performance benefit. This leaves Prio3Sum as the only possible breaking change. I suggest we close this issue as completed once the PR lands and consider what to do with Prio3Sum in #306.",
          "createdAt": "2024-06-08T21:51:27Z",
          "updatedAt": "2024-06-08T21:51:27Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@junyechen1996 noted to me offline that this optimization doesn't help all that much with PINE.",
          "createdAt": "2024-06-12T23:33:52Z",
          "updatedAt": "2024-06-12T23:33:52Z"
        }
      ]
    },
    {
      "number": 266,
      "id": "I_kwDOGKuqOc5rgc-g",
      "title": "Flp: Add post-processing step that uses verifier randomness",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/266",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "feature"
      ],
      "body": "A common trick in designing the arithmetic circuit is to set the output to a random linear combination of intermediate values. The only option for computing this is to use the joint randomness, which incurs the cost of using a larger field (for Fiat-Shamir). Another option is to use randomness generated by the verifier themself.\r\n\r\nOne way we could do this is to define a postprocessing step for `Flp` that is run the verifier, but not the prover. In applications like `Prio3`, the randomness used could be derived from the verify key just as as the query randomness is done today.\r\n\r\nThe joint randomness would still be needed wherever it is used as input to a gadget, as would be the case for (the current design of) the `SumVec` type (see #124).\r\n\r\nThis could be seen as an alternative to #262.",
      "createdAt": "2023-07-13T19:50:13Z",
      "updatedAt": "2023-07-14T20:33:07Z",
      "closedAt": "2023-07-14T20:33:06Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #262.",
          "createdAt": "2023-07-14T20:33:06Z",
          "updatedAt": "2023-07-14T20:33:06Z"
        }
      ]
    },
    {
      "number": 273,
      "id": "I_kwDOGKuqOc5s4hZa",
      "title": "Poplar1 security considerations: explain importance of \"extractability\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/273",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "security consideration",
        "draft-09"
      ],
      "body": "A recent [email](https://mailarchive.ietf.org/arch/msg/ppm/6DEXt2PS3IGOGWcg5hHzgsIGYyg/) on the PPM list mentioned using Poplar1 and making some optimizations in the traversal of the IDPF tree. One natural way to alter the tree traversal algorithm would be to stop early before reaching the leaf level, but I'm concerned that doing so would lose the benefit of the \"extractability\" property, which depends on the leaf level field size being larger, and thus it could impact the whole scheme's robustness. Currently, we only mention extractability twice, in the context of the public share and the leaf level field size, but we do not explain its relevance. Is it the case that maliciously constructed reports could evaluate to \"1\" on multiple prefixes at some inner level, but it would be computationally infeasible to do the same on the leaf level? If so, we should outline the limitations on robustness, and possibly provide advice about skipping tree levels, i.e. to always do one last subset histogram at the leaf level. In what way do the secure sketching scheme and the extractability property contribute to the overall VDAF's robustness? Would the attack on an inner level be brute-forcing keys that produce values that pass secure sketching by pure chance, inside a ~2^-64 soundness error?",
      "createdAt": "2023-07-28T16:53:58Z",
      "updatedAt": "2024-05-07T14:05:53Z",
      "closedAt": "2024-05-07T14:05:53Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch, and +1 to clarifying. (Please follow up on the list, if you haven't already.)\r\n\r\nIn [[DPRS23](https://eprint.iacr.org/2023/130)] we ended up needing extractability for the IDPF (Definition 5) in order to prove security for Doplar. However, our design is more conservative, I think due to the more flexible VDAF abstraction.  in Doplar, we need to be able to extract the IDPF inputs from the random oracle even if the attacker doesn't query the leaf nodes. I think [[BBCG+21](https://eprint.iacr.org/2021/017.pdf)] expect the IDPF to always be queried at the leaf nodes (eventually), which maybe is enough in a more restricted threat model.\r\n\r\ncc/ @schoppmp ",
          "createdAt": "2023-08-01T20:53:00Z",
          "updatedAt": "2023-08-01T20:55:01Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Related: https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/pull/533#discussion_r1411291353",
          "createdAt": "2023-12-05T22:29:30Z",
          "updatedAt": "2023-12-05T22:29:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Related: https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/101",
          "createdAt": "2023-12-05T22:30:15Z",
          "updatedAt": "2023-12-05T22:30:15Z"
        }
      ]
    },
    {
      "number": 274,
      "id": "I_kwDOGKuqOc5tMGQC",
      "title": "Apply parallel sum gadget optimization to Prio3Histogram",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/274",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "divergentdave"
      ],
      "labels": [
        "wire change"
      ],
      "body": "The range check portion of the `Prio3Histogram` circuit could be rewritten to use the parallel sum gadget. This would result in more wire polynomials, each of smaller degree, smaller proofs ($O(\\sqrt{n})$ instead of $O(n)$<span/>), faster proving, and larger preparation message shares ($O(\\sqrt{n})$ instead of $O(1)$<span/>). See https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/124#issuecomment-1656741283.",
      "createdAt": "2023-08-01T19:24:39Z",
      "updatedAt": "2023-09-25T19:32:12Z",
      "closedAt": "2023-09-25T19:32:12Z",
      "comments": []
    },
    {
      "number": 277,
      "id": "I_kwDOGKuqOc5tZEwU",
      "title": "poc: Replace `ERR_INPUT` et al. with `Error('...')`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/277",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial",
        "poc"
      ],
      "body": "              I think these are fine, our `Error` class subclasses `Exception` from the standard library. It inherits from the right things, and it gets good `repr` formatting for free. We could do `raise Error('input: invalid length')` to provide more granular messages.\r\n\r\n_Originally posted by @divergentdave in https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/276#discussion_r1283348909_\r\n            ",
      "createdAt": "2023-08-03T15:30:50Z",
      "updatedAt": "2024-06-07T14:02:21Z",
      "closedAt": "2024-06-07T14:02:21Z",
      "comments": []
    },
    {
      "number": 282,
      "id": "I_kwDOGKuqOc5txp3W",
      "title": "Sage: Use finite field and polynomial ring classes directly",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/282",
      "state": "OPEN",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "divergentdave"
      ],
      "labels": [
        "poc"
      ],
      "body": "If we moved field element encoding/decoding routines elsewhere, we could simplify the proof of concept implementation by eliminating our `Field` class and using Sage's finite field classes directly. We could also represent polynomials in Sage natively rather than as lists of field elements. This would simplify implementing gadgets, as we'd no longer need a separate `eval_poly()`. (Currently, we only use `PolynomialRing` when interpolating, but then drop out to the list representation immediately)",
      "createdAt": "2023-08-08T17:37:42Z",
      "updatedAt": "2024-04-30T23:11:58Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 283,
      "id": "I_kwDOGKuqOc5uaIML",
      "title": "poc: Test (and add test vectors for?) ping-pong API",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/283",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "poc"
      ],
      "body": "              This is fine as pseudocode, but as an FYI, this won't work in actual Python. The left hand side is `<class 'tuple'>`, while the right hand side is an instance of `types.GenericAlias`. The collection types are fully dynamic to begin with, and everything in the `types` module is meant for static analysis, not RTTI.\r\n\r\n_Originally posted by @divergentdave in https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/275#discussion_r1295061219_\r\n            ",
      "createdAt": "2023-08-16T01:01:53Z",
      "updatedAt": "2024-08-13T18:43:27Z",
      "closedAt": "2024-08-13T18:43:27Z",
      "comments": []
    },
    {
      "number": 286,
      "id": "I_kwDOGKuqOc5vAK80",
      "title": "Consider using SHA-3, not SHAKE128, for computing the fixed key in PrgFixedKeyAes128.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/286",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wire change"
      ],
      "body": "              (For consideration in a follow-up PR.) @schoppmp We might go with plain SHA-3 in order instead of SHAKE128 since the output length is fixed.\r\n\r\n_Originally posted by @cjpatton in https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/285#discussion_r1300803021_\r\n            ",
      "createdAt": "2023-08-22T23:08:30Z",
      "updatedAt": "2023-11-16T14:38:41Z",
      "closedAt": "2023-11-16T14:38:41Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "We could also consider doing the same for the joint randomness computation in Prio3.",
          "createdAt": "2023-11-16T14:37:35Z",
          "updatedAt": "2023-11-16T14:37:35Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "The editors discussed this and are not enthusiastic about making this change at this time. We agree that it's nice to have a single object, `Xof`, for multiple purposes, even if doing so is slightly inefficient",
          "createdAt": "2023-11-16T14:38:41Z",
          "updatedAt": "2023-11-16T14:38:41Z"
        }
      ]
    },
    {
      "number": 287,
      "id": "I_kwDOGKuqOc5vGV7N",
      "title": "Prio3 VDAF for vectors with a bounded number of 1s",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/287",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "feature",
        "idea"
      ],
      "body": "Section 4.5 of [Samplable Anonymous Aggregation for Private Federated Data Analysis](https://arxiv.org/pdf/2307.15017.pdf) notes that it's possible to efficiently validate that a vector consists of zeros and ones, with at most some constant number of ones. This could be done by generalizing Prio3Histogram. (Open question: does this belong in this document or a separate one?) Here's how I'd implement this:\r\n\r\n* The parameters would be the length, $n$, the chunk length, and the maximum number of ones, $m$.\r\n* Input length would be $n+\\left\\lfloor{log_2(m)}\\right\\rfloor+1$. Let $l_m=\\left\\lfloor{log_2(m)}\\right\\rfloor+1$, the number of bits needed to represent $m$.\r\n* Encoding: The first $n$ field elements are just projected measurement values. Let $c=2^{l_m}-1-m$, a constant offset to let us achieve the sum limit we want. Then, for input values $x_i$, compute $c+\\sum_i{x_i}$, encode it as a bit vector, and append it to the encoded measurement.\r\n* Truncation: Take the first $n$ elements.\r\n* Decoding: $id$\r\n* Validity circuit: Evaluate the range check polynomial $x(x-1)$ on all `INPUT_LEN` elements, and combine the results in a random linear combination (using the parallel sum optimization). Separately, evaluate the following, where $x_i$ are the measurement values from the encoded measurement, and $s_j$ are the bits of the $c+\\sum_i{x_i}$ from the encoded measurement. $$c + \\sum_{i=0}^{n-1} {x_i} - \\sum_{j=0}^{l_m-1} {2^j s_j}$$ Add the range check and sum check intermediate values together in another random linear combination, and return the result.",
      "createdAt": "2023-08-23T20:00:42Z",
      "updatedAt": "2024-06-11T22:20:18Z",
      "closedAt": "2024-06-11T22:20:18Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "If the generalization is straight-forward, then I think we can put it here.\r\n\r\nCan you explain why this range check is sufficient? (Suppose $m$ is not a power of 2.)\r\n\r\nCan we make the $m=1$ case wire-compatible with the current version of the circuit?",
          "createdAt": "2023-08-25T00:21:38Z",
          "updatedAt": "2023-08-25T00:21:38Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "During encoding, we require the client to commit to the sum of its measurement and the constant c in some auxiliary bits. Because we apply range checks to the auxiliary bits, then $c+\\sum_i{x_i}$ must be in the range $[0, 2^{l_m})$. The sum check confirms that the auxiliary bits are consistent with the number of ones in the measurement. Then, $\\sum_i{x_i}$ is in the range $[0-c, 2^{l_m}-c)=[-c,2^{l_m}-2^{l_m}+1+m)=[-c,m+1)=[-c,m]$. Since $x_i$ is always non-negative, we can clip this and say that $\\sum_i{x_i} \\leq m$.\r\n\r\nNote that c is equal to zero when m is one less than a power of two. As a concrete example with an \"interesting\" value of c, let's set m to 5. Five fits in three bits, so $l_m=3$, and c is 2. If a client shards a measurement that's all zeros, they would append <0, 1, 0> when encoding, because $c+\\sum_i{x_i}=2$. If a measurement included the maximum of five ones, then $c+\\sum_i{x_i}=2+5=7$, and they would append <1, 1, 1>. If a malicious client wanted to include six ones in their measurement, then $c+\\sum_i{x_i}=8$, but there's no way for $\\sum_{j=0}^{l_m} {2^j s_j}$ to equal eight when the range checks are satisfied, so they won't be able to zero out the sum check.\r\n\r\nThe VDAF described here, with m set to 1, is not semantically equivalent to Prio3Histogram, since it would allow measurements with either zero or one ones, while Prio3Histogram only allows exactly one one. (This additional flexibility is reflected in encoded measurements being one element longer, for $s_0$) We could make Prio3Histogram wire-compatible with a different VDAF, or a mode of this VDAF, that does not add any extra elements during encoding, and only allows vectors with exactly m ones.",
          "createdAt": "2023-08-25T21:40:35Z",
          "updatedAt": "2023-08-25T21:40:35Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Cool, this sounds like a new Prio3 variant. I don't know how many variants we want in the core document -- I suppose we should discuss this. But if we have concrete use cases in mind for this, I don't see why we couldn't add it here.\r\n\r\nOne other way I can imagine using this is to for aggregating a Bloom filter: Each measurement would be a contribution to this filter, where the contribution is a bitvector with between $1$ and $k$ bits set, where $k$ is a parameter of the Bloom filter. (Bits are set by hashing a string and deriving indices into the Bloom filter from the hash value.) We could probably get away with a range check of $[0, k]$, but $[1, k]$ would be more correct. (If the Client is behaving correctly, then at least one bit will be set.) Hence I think generalizing range check to include a non-$0$ lower bound would be useful.\r\n\r\nWhat would you call this thing?\r\n\r\nAnother observation: There is an implicit generalization of the `Sum` circuit here that I think would be useful for  `Prio3Sum`, and perhaps even `Prio3SumVec`. Though for the latter we would want to make sure we don't blow up the communication overhead for the common 0/1-vector use case.",
          "createdAt": "2023-08-29T01:15:45Z",
          "updatedAt": "2023-08-29T01:15:45Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> What would you call this thing?\r\n\r\nOne suggestion, from discussions about Client-side DP mechanisms: `NoisyHistogram`? ",
          "createdAt": "2023-09-25T20:56:48Z",
          "updatedAt": "2023-09-25T20:56:48Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "We could consider renaming Prio3Histogram to Prio3OneHotVector and making this new idea Prio3ManyHotVector",
          "createdAt": "2023-09-25T22:36:18Z",
          "updatedAt": "2023-09-25T22:36:18Z"
        },
        {
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for putting this together @divergentdave ! I think this new Prio3 variant is useful for checking bounded number of 1s after the one-hot vector goes through randomized response Client-DP.\r\n\r\nOne clarification is: this assumes $$c + \\sum_{i=0}^{n-1} x_i$$ (roughly at most $m + n$) won't overflow field size. It won't be a problem here, because we have already done bit check on $x_i$ and we are using some reasonably large field size which is much larger than $m + n$.",
          "createdAt": "2023-09-26T00:43:01Z",
          "updatedAt": "2023-09-26T00:43:29Z"
        },
        {
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> We could consider renaming Prio3Histogram to Prio3OneHotVector and making this new idea Prio3ManyHotVector\r\n\r\n+1, I would suggest `Prio3OneHotVec` and `Prio3MultiHotVec`, or if we want to keep Prio3Histogram, can we call the new one `Prio3MultiHotHistogram`.\r\n\r\nAlternatively we can keep `Prio3Histogram` an alias to `Prio3OneHotVec`",
          "createdAt": "2023-09-29T23:30:36Z",
          "updatedAt": "2023-09-29T23:30:36Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@junyechen1996 it looks like we're going to want this circuit for the DP draft for PPM, correct? If so, what do you think about at least adding it to the reference code here? If useful enough we could also consider putting it in the spec.\r\n\r\nAlso, I just wanted to suggest a potential alternative circuit inspired by a discussion with @pag-crypto: If the range is relatively small, then instead of bit-encoding the sum and doing an equality check, an alternative would be to do a kind of look-up table thing. (This isn't exactly Paul's idea, so don't blame him if it turns out to be broken.)\r\n\r\nLet $s$ denote the sum of the inputs; we want to check that $s \\in [1..m]$. It suffices to check that $(s - 1) \\cdots (s - m) = 0$. \r\n\r\nThis means more multiplications, but the upside is we don't break wire compatibility. Plus, we might get away with not increasing the number of `ParallelSum`-calls. What do you think @divergentdave?",
          "createdAt": "2023-10-10T21:01:41Z",
          "updatedAt": "2023-10-10T21:01:41Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, that makes sense, I think that's just the \"range check polynomial\" applied in a new place. One nit: none of the alternatives would be wire compatible, since the proofs wouldn't verify naturally, but this would let us keep the same AFE encoding/decoding, and only change the validity circuit.\r\n\r\nThere's going to be a complicated performance and proof size tradeoff between the two, since the range check polynomial could have a high degree with certain parameter choices. Both approaches would work better with small ranges of valid Hamming weights, but I'm sure they scale differently as the range of Hamming weights broadens.",
          "createdAt": "2023-10-10T21:22:14Z",
          "updatedAt": "2023-10-10T21:22:14Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh hmm, I wouldn't want to implement this if we had to use a high-degree gadget like `PolyEval`. I was thinking we could just `Mul` for this, which we already have?\r\n\r\n> Yeah, that makes sense, I think that's just the \"range check polynomial\" applied in a new place. One nit: none of the alternatives would be wire compatible, since the proofs wouldn't verify naturally, but this would let us keep the same AFE encoding/decoding, and only change the validity circuit.\r\n\r\nYou're right, the proof would change.\r\n\r\n\r\n> There's going to be a complicated performance and proof size tradeoff between the two, since the range check polynomial could have a high degree with certain parameter choices. Both approaches would work better with small ranges of valid Hamming weights, but I'm sure they scale differently as the range of Hamming weights broadens.\r\n\r\nOh hmmm, I wouldn't want to use a high-degree gadget for the range check. Couldn't we use `Mul`, via `ParallelSum`?",
          "createdAt": "2023-10-10T21:29:05Z",
          "updatedAt": "2023-10-10T21:29:05Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "The two straightforward ways to do this would be to put the entire polynomial in one `PolyEval` gadget (one gadget call, arity 1, degree equal to the number of allowable s values) or to build it out of affine gates and many many `Mul` gadgets (gadget call count equal to one less than the number of allowable s values, arity 2, degree 2).\r\n\r\nParallelSum wouldn't be easy to apply, because at minimum we'd need some separate multiplication gadget calls upstream of our ParallelSum gadget. Since subcircuit outputs get added up, that means we have to start by expanding the polynomial. We could end up burning gadget arity on constant inputs in order to meet the \"identical subcircuit\" restriction as well.\r\n\r\nThe goal of ParallelSum is to balance out the number of gadget calls and the gadget's arity, so we could instead take inspiration from that, define one PolyEval gadget that uses a smaller degree range check polynomial, feed in 's' minus various constants into that gadget, and then finish up the larger range check polynomial by feeding the output of the small polynomials through `Mul`.\r\n\r\nBefore we get too far in the weeds specifying something that complicated, do we have a good idea for how wide the range of allowable Hamming weights would be randomized response applications with typical DP parameters?",
          "createdAt": "2023-10-10T22:07:59Z",
          "updatedAt": "2023-10-10T22:07:59Z"
        },
        {
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Before we get too far in the weeds specifying something that complicated, do we have a good idea for how wide the range of allowable Hamming weights would be randomized response applications with typical DP parameters?\r\n\r\nI think that depends a lot on the dimension, for e.g. with 100,000 dimension, I think the range is between dozens to hundreds.",
          "createdAt": "2023-10-11T17:20:51Z",
          "updatedAt": "2023-10-11T17:20:51Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Bit-checks it is then :)",
          "createdAt": "2023-10-11T17:22:34Z",
          "updatedAt": "2023-10-11T17:22:34Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd say this is ready for work. Who'd like to take it?",
          "createdAt": "2023-10-11T17:28:00Z",
          "updatedAt": "2023-10-11T17:28:00Z"
        },
        {
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can take this. I will start with a Python implementation in poc folder. Does that sound good @cjpatton @divergentdave ?",
          "createdAt": "2023-10-11T18:28:26Z",
          "updatedAt": "2023-10-11T18:28:26Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "SGTM.",
          "createdAt": "2023-10-11T18:39:20Z",
          "updatedAt": "2023-10-11T18:39:20Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Next step is to decide whether to assign a codepoint for Prio3MultiHotHistogram and, potentially, add it to the draft. It may end up being a dependency for https://github.com/wangshan/draft-wang-ppm-differential-privacy/, in which case we'll at least need to assign the codepoint\r\n\r\nNow might be a good time to figure how how this is supposed to work. I'll try to get some feedback at CFRG on how to manage codepoints for VDAFs (cc/ @bifurcation in case you already have a vision for this.)\r\n\r\n@divergentdave do you have thoughts about if/how to incorporate this new type into the draft?",
          "createdAt": "2023-10-17T01:06:31Z",
          "updatedAt": "2023-10-17T01:26:23Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "My latest thought here is that we should just replace Prio3Histogram with Prio3MultiHotHistogram, since the latter is just a generalization.",
          "createdAt": "2023-10-25T20:20:49Z",
          "updatedAt": "2023-10-25T20:20:49Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Replacing it seems reasonable. For Prio3Histogram use cases, the encoded measurement will get one field element longer, which is negligible. It won't be possible to enforce \"exactly one hot\" anymore, but only \"zero or one hot\". I think that should be fine, by and large. Choosing the \"wrong\" bucket affects the aggregate twice as much as choosing no buckets when you \"should\" choose one, so this isn't giving malicious clients an advantage. If choosing zero buckets doesn't make sense semantically, like in a multiple-choice survey, I think results will still be meaningful even if some zero bucket measurements get included.\r\n\r\nHow about `Prio3MultiHotVec` for the name? The path dependence of the \"histogram\" name is starting to wear on me.",
          "createdAt": "2023-10-25T23:34:20Z",
          "updatedAt": "2023-10-25T23:34:20Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Works for me. As for renaming: so far we have tried to align the name of the circuit with the data type of the aggregate result rather than than the type of the measurement. I'm OK breaking this convention if it's annoying :)",
          "createdAt": "2023-10-26T00:24:04Z",
          "updatedAt": "2023-10-26T00:24:13Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Erring on the side of not breaking compatibility, I'm going to add this as a new Prio3 variant and assign it a codepoint. I'll take @divergentdave's suggested name of `Prio3MultiHotVec`.",
          "createdAt": "2024-06-06T19:24:34Z",
          "updatedAt": "2024-06-06T19:24:34Z"
        }
      ]
    },
    {
      "number": 288,
      "id": "I_kwDOGKuqOc5vS8L3",
      "title": "Re-generate SHA-3 output test",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/288",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "              When breaking a test, it's important to make clear to the reader why the test is broken (and how it should be fixed).\r\nBonus: We should file an issue to remind us to fix this test, and reference the issue in this comment.\r\n```suggestion\r\n    # TODO: Update the test to account for the change from cSHAKE128 to SHAKE128.\r\n    # assert expanded_vec[-1] == Field64(13681157193520586550)\r\n```\r\n\r\n_Originally posted by @cjpatton in https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/285#discussion_r1303323003_\r\n            ",
      "createdAt": "2023-08-25T15:16:37Z",
      "updatedAt": "2023-09-06T16:36:25Z",
      "closedAt": "2023-09-06T16:36:25Z",
      "comments": []
    },
    {
      "number": 299,
      "id": "I_kwDOGKuqOc5zi8Fk",
      "title": "Replace SHAKE128 with TurboSHAKE128",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/299",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "wire change",
        "ietf118"
      ],
      "body": "As discussed on the CFRG mailing list: https://mailarchive.ietf.org/arch/msg/cfrg/zzpG6CWQHG2hvQuzmfmkZcZ2AzM/",
      "createdAt": "2023-10-11T19:10:06Z",
      "updatedAt": "2023-11-15T14:43:06Z",
      "closedAt": "2023-11-15T14:43:06Z",
      "comments": []
    },
    {
      "number": 304,
      "id": "I_kwDOGKuqOc50ZtZB",
      "title": "Clarify threat model for robustness",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/304",
      "state": "CLOSED",
      "author": "jimouris",
      "authorAssociation": "NONE",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "security consideration"
      ],
      "body": "Hello, I had a discussion with @cjpatton and @pratiksarkar93 about the VDAF security considerations. The draft states:\r\n\r\n```\r\n VDAFs have two essential security goals:\r\n\r\n 1.  Privacy: An attacker that controls the network, the Collector,\r\n     and a subset of Clients and Aggregators learns nothing about the\r\n     measurements of honest Clients beyond what it can deduce from the\r\n     aggregate result.\r\n\r\n 2.  Robustness: An attacker that controls the network and a subset of\r\n     Clients cannot cause the Collector to compute anything other than\r\n     the aggregate of the measurements of honest Clients.\r\n```\r\n\r\nI was wondering if the notion of **robustness** is referring only to **correctness** or to both correctness and **guaranteed output delivery (GOD)**. Would it make sense to split robustness into these two properties to use more formal MPC terms (i.e., [pages 2 & 3 from Lindell's paper](https://eprint.iacr.org/2020/300.pdf))? \r\n\r\nFor example, the draft states \"break robustness\" or \"attack on robustness\" but it is not clear if that means to cause the Collector to output an incorrect result (i.e., attack on correctness) or to prevent honest parties from receiving their output (i.e., attack on GOD).\r\n\r\n\r\n",
      "createdAt": "2023-10-19T19:08:55Z",
      "updatedAt": "2024-06-10T23:56:21Z",
      "closedAt": "2024-06-10T23:56:21Z",
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, a dishonest Aggregator can cause the Collector to output an incorrect result by sending an arbitrary aggregate share, or prevent the protocol from completing by not sending proscribed messages during the aggregation flow or collection flow. I think we should spell out both kinds of outcomes, and we could connect them to these MPC terms, but I think we should still use \"robustness\" throughout the bulk of the document. Thus far, no proposed VDAF would lack guaranteed output delivery but have correctness in the face of one dishonest Aggregator, so we don't need to make a distinction once all the terms are introduced. Additionally, \"robustness\" is used in the referenced papers, including the original Prio paper (from NSDI in 2017) and the 2023 Davis et. al. paper.",
          "createdAt": "2023-10-23T15:53:04Z",
          "updatedAt": "2023-10-23T15:53:04Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch @jimouris. What we call \"robustness\" is what you call correctness --- we're not after guaranteed-output-delivery. If the attacker does control the network, then it can prevent the Collector from computing anything by dropping packets.\r\n\r\nInstead of clarifying both goals, I think we should refine our threat model for robustness, i.e., say that the attacker **does not control the network**. We could additionally mention that an attacker that controls the network can force the Collector to drop reports.\r\n\r\nDo you think we should rename \"robustness\" to \"correctness\"? It's good to keep the terminology consistent with the informative references in the draft (Boneh-Corrigan-Gibbs NSDI 2017, Davis et al. PETS 2023). However these works were not necessarily developed with the whole of the MPC literature in mind and, arguably, picked the wrong terms.",
          "createdAt": "2023-10-24T18:28:50Z",
          "updatedAt": "2023-10-24T18:28:50Z"
        },
        {
          "author": "jimouris",
          "authorAssociation": "NONE",
          "body": "That makes sense, thank you both for clarifying! Personally, I think \"correctness\" is well-defined in MPC whereas \"robustness\" might be a bit ambiguous. In the Prio paper, it's clear that it refers to correctness, but I've seen it used freely.\r\n\r\nI think either term is fine, as long as there is a clarification somewhere that robustness refers to the notion of correctness.",
          "createdAt": "2023-10-24T19:26:09Z",
          "updatedAt": "2023-10-24T19:26:09Z"
        },
        {
          "author": "pratiksarkar93",
          "authorAssociation": "NONE",
          "body": "Usually in MPC **correctness** refers to the setting where everyone is honest and the protocol output is the same as the function (being computed) output. \r\nIn MPC terminology, Robustness considers the setting where one of the aggregators behaves maliciously. This inherently also implies that a malicious aggregator cannot affect the protocol output. If it does change the output then the honest parties will detect it. \r\n\r\nI think a better way to rephrase robustness is by breaking it up into two properties, following the terminology used in Section 2.3 of **Poplar** :\r\n1. Robustness/guaranteed output delivery against malicious clients. \r\n2. Privacy of honest clients against a malicious aggregator/collector \r\n\r\nAnd correctness should be separate. \r\n\r\nLet me know what you think.",
          "createdAt": "2023-10-24T19:41:43Z",
          "updatedAt": "2023-10-24T19:41:43Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @pratiksarkar93, I believe the way we've split it up in the draft already matches your suggestion.",
          "createdAt": "2023-10-24T20:02:41Z",
          "updatedAt": "2023-10-24T20:02:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "On the other I hand I might be misunderstanding you. Perhaps you'd consider writing a PR that aligns the Security Considerations section with the correct terminology?",
          "createdAt": "2023-10-24T20:04:29Z",
          "updatedAt": "2023-10-24T20:04:29Z"
        },
        {
          "author": "pratiksarkar93",
          "authorAssociation": "NONE",
          "body": "@cjpatton  Yes the draft is aligned with what I was proposing. The terms \"robustness\" and \"privacy\" need to be elaborated more. I can do that in the Security Considerations section. ",
          "createdAt": "2023-10-25T11:42:52Z",
          "updatedAt": "2023-10-25T11:42:52Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Summarizing TODOs from this issue and offline discussions:\r\n\r\n- [ ] Clarify that an attacker that controls the network can break guaranteed-output-delivery\r\n- [ ] Clarify distinction between robustness against malicious Clients and robustness against malicious Clients and Aggregators (the draft's goal is the former).\r\n",
          "createdAt": "2023-11-20T13:13:20Z",
          "updatedAt": "2023-11-20T13:13:20Z"
        }
      ]
    },
    {
      "number": 306,
      "id": "I_kwDOGKuqOc509fzZ",
      "title": "Generalize range check in Prio3Sum",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/306",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "wire change",
        "idea",
        "draft-12"
      ],
      "body": "In Prio3Sum and Prio3SumVec we do a simple $[0, 2^k)$ range check by encoding the integer as a $k$-bit string and checking each bit is $0$ or $1$. In #287 we devised a simple strategy for generalizing this check to $[0, C)$ for any $C > 0$, even if $C$ is not a power of $2$. What's more, this check is concretely efficient in that it doesn't change the input length or the number of gadget calls. (The affine part of the computation is a bit more complex.)\r\n\r\nCould we, and would it be worth it to, do the same for Prio3Sum and Prio3SumVec? It seems to me this would be a valuable improvement.\r\n\r\ncc/ @divergentdave, @junyechen1996 ",
      "createdAt": "2023-10-25T21:43:29Z",
      "updatedAt": "2024-08-22T16:20:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't immediately see how we could do this without increasing the input size of Prio3Sum. In the other case, we relied on the already-present range checks on histogram bits for the \u22650 end of the range.\n\nOne unoptimized way we could extend Prio3Sum to do different range checks would be to double the input length, encode the measurement as a bit vector, and then encode the measurement plus some constant as a bit vector. The validity circuit would range check all the bits, and then do a sum check on the two halves of the input, confirming that the latter encoded integer is equal to the former plus the constant. This effectively lets us slide two [0, 2^n) range checks over each other, and build a [0, m) range check from their intersection.",
          "createdAt": "2023-10-25T22:01:00Z",
          "updatedAt": "2023-10-25T22:01:00Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": ":face_palm: You are absolutely right, we'd need to double the input length to apply the same trick.\r\n\r\nI think it's worth doing for Prio3Sum since input is fairly small.\r\n\r\nFor Prio3SumVec, we definitely don't want to blow up the common \"bit-vector\" use case ($k=1$). If we wanted to change Prio3SumVec this way, then we probably would want to split out the bit-vector circuit into a different variant, e..g, Prio3CountVec or something.",
          "createdAt": "2023-10-25T22:35:25Z",
          "updatedAt": "2023-10-25T22:35:25Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "We may end up with a breaking change for Prio3Sum as part of #262. If so, we should also consider taking this change as well.",
          "createdAt": "2024-06-06T22:39:42Z",
          "updatedAt": "2024-06-06T22:39:42Z"
        }
      ]
    },
    {
      "number": 307,
      "id": "I_kwDOGKuqOc5099kE",
      "title": "Authors list doesn't render properly for some informative references",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/307",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "E.g., [GKWY20, GKWWY20]",
      "createdAt": "2023-10-25T22:47:02Z",
      "updatedAt": "2023-11-14T16:30:43Z",
      "closedAt": "2023-11-14T16:30:43Z",
      "comments": []
    },
    {
      "number": 311,
      "id": "I_kwDOGKuqOc53B8cg",
      "title": "Prio3: Add guidance for choosing `PROOFS` and `Flp.Field` ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/311",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "If a small field is used, then it may be necessary to use a larger number of proofs in order to achieve the desired level of robustness. (Privacy is not significantly impacted by the choice of these parameters.) The draft needs to provide some guidance for choosing this.\r\n\r\nWe may also consider re-parameterizing the existing Prio3 variants.\r\n\r\nSee #177 for initial discussion and analysis.\r\n\r\ncc/ @albertpl ",
      "createdAt": "2023-11-16T14:34:37Z",
      "updatedAt": "2024-01-23T21:58:41Z",
      "closedAt": "2024-01-23T21:58:41Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "(REVISED, see comment below.)\r\n\r\nI've written a sage script (#318) for plotting robustness of Prio3SumVec for various choices of field and number of proofs. The generated plot is below. What it shows is an upper bound of the probability that $1$ in $1,000,000,000$ accepted reports is invalid, given a amount of computational resources ($2^{80}$ random oracle queries, which is a pretty comfortable margin). The x-axis shows the input length; the number of bits is $1$; and the chunk length is set to the asymptotic optimal (square root of the length).\r\n\r\n![prio3_sum_vec](https://github.com/cfrg/draft-irtf-cfrg-vdaf/assets/3453007/49442bc9-91c8-4c87-9203-72b5df267d7b)\r\n\r\n* The baseline is Field128/1 (one proof). The probability of a robustness error is definitely non-negligible (where \"negligible\" is approximately the probability of correctly guessing an AES key), but it's still quite unlikely to happen. For instance, for input size = $100,000$, the probability that $1$ in every $1$ billion accepted reports is invalid is at most $2^{-36}$. This is the same as the probability of ruining $1$ in every $100,000$ batches assuming a batch size of $10,000$.\r\n* Field64/1 is quite terrible and should not be deployed.\r\n* Field64/2 is worse than Field128/1, but may be tolerable depending on the application.\r\n* Field64/3 is comfortably better than Field128/1.\r\n* Field64/4 is much more robust than we'd ever need.\r\n\r\nBased on this analysis, I'd suggest the following text change. Top of Section 7.4:\r\n\r\n> For circuits for which the number of gadget calls grows sub-linearily in the parameters (e.g., `Sum`, `SumVec`, or `Histogram`), a smaller field can be used as long as additional proofs are generated and verified. When replacing `Field128` with `Field64` it is RECOMMENDED to use `3` proofs. However, some applications may tolerate as few as `2`.\r\n",
          "createdAt": "2023-12-05T22:05:27Z",
          "updatedAt": "2023-12-06T19:59:33Z"
        },
        {
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This assumes the adversary donates 1000000000 reports? either control the number of devices or break authentication / rate limit.",
          "createdAt": "2023-12-06T05:22:30Z",
          "updatedAt": "2023-12-06T05:22:30Z"
        },
        {
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "is there an explanation that Field64/1 prob is > 1?",
          "createdAt": "2023-12-06T12:22:26Z",
          "updatedAt": "2023-12-06T12:22:26Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> @albertpl This assumes the adversary donates 1000000000 reports? either control the number of devices or break authentication / rate limit.\r\n\r\nThe bond actually says something slightly different: it tells us the maximum probability that, among 1 billion reports that we accepted, at least one of them is invalid. In other words, we must include benign (i.e., not malicious reports) as part of the attack. (Intuitively, this is because VDAF preparation depends on a secret key, and information about this key gets exposed to the adversary over the course of its attack. For details, see the robustness game in ia.cr/2023/130, Figure 3.)\r\n\r\n> @wangshan is there an explanation that Field64/1 prob is > 1?\r\n\r\nThe thing that's plotted is an upperbound of the probability, not the probability. If the bounds is > 1, then it's called \"vacuous\", meaning it tells us nothing about the chances of a successful attack. The way to interpret this is: the parameters are too weak to provide meaningful robustness.\r\n\r\n",
          "createdAt": "2023-12-06T17:54:40Z",
          "updatedAt": "2023-12-06T17:54:57Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @junyechen1996 and @albertpl for your feedback on the PR. Due primarily to https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/318#discussion_r1417425565, we need to revise the bounds:\r\n\r\n![prio3_sum_vec_revised](https://github.com/cfrg/draft-irtf-cfrg-vdaf/assets/3453007/645b1567-51ce-4fc0-9fbc-ad8b7c184aa8)\r\n\r\n* Field128/1 (baseline): For input size = $100,000$, the probability that $1$ in every $1$ billion accepted reports is invalid is at most $2^{-29}$.\r\n* Field64/2 is significantly worse than Field128/1, but may be tolerable for some applications and for small input sizes.\r\n* Field64/3 is comfortably better than Field128/1.\r\n\r\nI'd revise the text change as follows: \r\n\r\n> For some circuits, a smaller field can be used safely as long as additional proofs are generated and verified. When replacing `Field128` with `Field64` it is RECOMMENDED to use `3` proofs. However, some applications may tolerate as few as `2`.\r\n\r\n",
          "createdAt": "2023-12-06T20:09:15Z",
          "updatedAt": "2023-12-06T20:09:15Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Slight improvement after fixing a typo pointed out by @junyechen1996:\r\n\r\n![prio3_sum_vec_revised2](https://github.com/cfrg/draft-irtf-cfrg-vdaf/assets/3453007/5592a56f-2ef4-40d6-9f8e-197424ceb2e3)\r\n",
          "createdAt": "2023-12-07T17:10:03Z",
          "updatedAt": "2023-12-07T17:10:03Z"
        },
        {
          "author": "bwesterb",
          "authorAssociation": "NONE",
          "body": "To help with the tightness of the bound, here is a simple concrete attack. I do lack quite a bit of context, so I hope it's not too far off the actual problem.\r\n\r\nFrom what I understand the goal is to find field elements x_1, ..., x_n such that p(r) = 0, where r = H(x_1, ..., x_n) and p(s) = sum_i=1^n x_i (1 - x_i) x^(i-1), but where x_i not in {0,1} for some i.\r\n\r\nFor the moment assume n is even, and there is a nth degree primitive root of unity zeta in the field\u00a0\u2014 that is: there is a zeta with zeta^n = 1 and zeta^i \u2260 1 for all 0 \u2264 i < n.\r\n\r\nRecall two basic facts about such a PROU:\r\n\r\n- zeta + zeta^2 + ... + zeta^n = 0, because for that sum S, we have (zeta - 1)S = zeta^(n+1) - zeta = 0, and zeta \u2260 1.\r\n\r\n- In fact, for any 0<i<n, we have zeta^i + zeta^(2i) + ... + zeta^(ni) = 0. Indeed, for this sum S, we have (zeta^i - 1) S = zeta^((n+1)i) - zeta^i = zeta^i - zeta^i = 0. As zeta^i \u2260 1 by definition of PROU, we have S = 0 as desired.\r\n\r\n- zeta, zeta^2, ..., zeta^n are all distinct, for if zeta^i = zeta^j with WLOG i > j, then zeta^(i-j)=1 contradicting n being a PROU.\r\n\r\nNow, pick a random field element y not in {0,1}, and set x_1 = 0, x_2 = y, x_3 = y, ..., x_n = y.\r\n\r\nThen for any 0 < i < n, we have p(zeta^i) = y(1-y) ( zeta^i + zeta^(2i) + ... + zeta^(ni) ) = 0.\r\n\r\nThus, first precompute Z = { zeta^1, ..., zeta^(n-1) }.\r\n\r\nThen search for an y \u2260 0, 1 such that H( 0, y, y, ..., y ) in Z.\r\n\r\nWhen found, we have broken robustness. Note that in any interesting case, essentially all time of the attack is spent in computing H.\r\n\r\nWith n = 2^20, and we're using a 64 bit field, we expect only 2^44 calls to H. That's practical.\r\n\r\nWhen requiring two proofs for that 64 bit field, we're looking at 2^88 calls to H. That's possible to pull of, but _very_ expensive (>10M$).",
          "createdAt": "2023-12-08T18:16:50Z",
          "updatedAt": "2023-12-08T18:16:50Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> To help with the tightness of the bound, here is a simple concrete attack. I do lack quite a bit of context, so I hope it's not too far off the actual problem.\r\n> \r\n> From what I understand the goal is to find field elements x_1, ..., x_n such that p(r) = 0, where r = H(x_1, ..., x_n) and p(s) = sum_i=1^n x_i (1 - x_i) x^(i-1), but where x_i not in {0,1} for some i.\r\n\r\nThis is roughly the idea, but let me make it a little more precise. (@divergentdave please fix any bugs that you see.) We're attacking Prio3SumVec, whose circuit $C$ takes as input a vector $\\vec x = (x_1, \\ldots, x_n)$ and random input $r$ and outputs:\r\n\r\n$C(\\vec x, r) = \\Sigma_{i=1}^{n}{r^i x_i (x_i - 1)}$\r\n\r\nWe can think of $x_i(x_i-1)$ as the $i$-th coefficient of a polynomial $p$ and computing $p(r)$:\r\n\r\n* If $x_i \\in \\\\{0,1\\\\}$ then $C(\\vec x, r) = 0$ for all $r$;\r\n* If $x_i \\not\\in \\\\{0,1\\\\}$ for some $i$ then $(\\vec x, r) = 0$ with probability at most $\\epsilon = n/|\\mathbb{F}|$, assuming $r$ was chosen fairly. (This is because the maximum number of roots of $p$ is $n$.)\r\n\r\nIn fact, $r$ is not sampled, but _derived_, roughly as you've described. In more detail, the Client:\r\n\r\n* secret-shares the vector $\\vec x$ into $[[\\vec x]]_1, \\ldots, [[\\vec x]]_s$, where $s$ is the number of Aggregators\r\n* samples random \"blinds\" $B_1, \\ldots, B_s$\r\n* computes $r = H([[\\vec x]]_1, ..., [[\\vec x]]_s, B_1, \\ldots, B_s)$ so that the Aggregators can reconstruct $r$ without sharing their shares or blinds.\r\n\r\nThe question is how much computation do we have to do in order to break robustness of Prio3SumVec with advantage significantly better than $\\epsilon$.\r\n\r\nIn fact, if we have multiple proofs, then we evaluate $C$ multiple times on independent random inputs output by $H$. In this case we need to be $\\epsilon^k$ where $k$ is the number of proofs.\r\n\r\n\r\n\r\n\r\n> For the moment assume n is even, and there is a nth degree primitive root of unity zeta in the field \u2014 that is: there is a zeta with zeta^n = 1 and zeta^i \u2260 1 for all 0 \u2264 i < n.\r\n\r\nThis is the case for us :)\r\n\r\n>\r\n> Recall two basic facts about such a PROU:\r\n> \r\n>     * zeta + zeta^2 + ... + zeta^n = 0, because for that sum S, we have (zeta - 1)S = zeta^(n+1) - zeta = 0, and zeta \u2260 1.\r\n> \r\n>     * In fact, for any 0<i<n, we have zeta^i + zeta^(2i) + ... + zeta^(ni) = 0. Indeed, for this sum S, we have (zeta^i - 1) S = zeta^((n+1)i) - zeta^i = zeta^i - zeta^i = 0. As zeta^i \u2260 1 by definition of PROU, we have S = 0 as desired.\r\n> \r\n>     * zeta, zeta^2, ..., zeta^n are all distinct, for if zeta^i = zeta^j with WLOG i > j, then zeta^(i-j)=1 contradicting n being a PROU.\r\n\r\n\u2764\ufe0f \r\n\r\n\r\n> Now, pick a random field element y not in {0,1}, and set x_1 = 0, x_2 = y, x_3 = y, ..., x_n = y.\r\n> \r\n> Then for any 0 < i < n, we have p(zeta^i) = y(1-y) ( zeta^i + zeta^(2i) + ... + zeta^(ni) ) = 0.\r\n> \r\n> Thus, first precompute Z = { zeta^1, ..., zeta^(n-1) }.\r\n> \r\n> Then search for an y \u2260 0, 1 such that H( 0, y, y, ..., y ) in Z.\r\n\r\nI.e., fix coins for secret sharing and generating blinds and for each $y \\in \\mathbb{F}\\setminus \\\\{0,1\\\\}$ and compute $r = H([[\\vec x]]_1, ..., [[\\vec x]]_s, B_1, \\ldots, B_s)$. Stop when $r \\in Z$.\r\n\r\n> \r\n> When found, we have broken robustness. Note that in any interesting case, essentially all time of the attack is spent in computing H.\r\n> \r\n> With n = 2^20, and we're using a 64 bit field, we expect only 2^44 calls to H. That's practical.\r\n> \r\n> When requiring two proofs for that 64 bit field, we're looking at 2^88 calls to H. That's possible to pull of, but _very_ expensive (>10M$).\r\n\r\nI'd like to come up with a formula. Modeling $H$ as a random oracles it's just a series of independent Bernoulli's with probability $p = (|Z|/|\\mathbb{F}|)^k = (n/|\\mathbb{F}|)^k$ and we go until one of them succeeds.\r\n\r\nThat means the success probability after $q$ random oracle queries is $(1 - p)^q \\cdot p$, and the expected number of random oracles queries we have to make is $1/p = (|\\mathbb{F}|/n)^k$.\r\n\r\nThis confirms your math. It does seem like you could pull off $2^{88}$ evaluations of $H$ but it would require immense resources. For scale, here's a website that estimates humanity's Bitcoin-mining capacity, which is a pretty good approximation of the resources we have to break Prio: https://www.coinwarz.com/mining/bitcoin/hashrate-chart\r\n\r\nFor the record, `Field128` with one proof and `Field64` with three proofs are both definitely safe (expected $q$ of $2^{108}$ and $2^{132}$ respectively).",
          "createdAt": "2023-12-16T01:53:02Z",
          "updatedAt": "2023-12-18T16:16:54Z"
        }
      ]
    },
    {
      "number": 312,
      "id": "I_kwDOGKuqOc53CORA",
      "title": "Add test vectors to draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/312",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "pre-RGLC"
      ],
      "body": "We removed them a couple of drafts ago because updating them was becoming a pain. (Note that machine-readable test vectors can be found in https://github.com/cfrg/draft-irtf-cfrg-vdaf/tree/main/poc/test_vec.)",
      "createdAt": "2023-11-16T15:03:15Z",
      "updatedAt": "2024-06-06T22:42:22Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 314,
      "id": "I_kwDOGKuqOc54FTdx",
      "title": "Consider generalizing `num_shares` in `Flp` interface",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/314",
      "state": "CLOSED",
      "author": "junyechen1996",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "feature"
      ],
      "body": "Under [Flp](https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-08.html#name-fully-linear-proof-flp-syst) interface, the APIs contain a parameter `num_shares` which seems to be something useful in certain FLP constructions, e.g., FLPs that need to normalize a constant if it's not multiplied with a secret-shared variable. I wonder if this parameter can be more generic to tailor the need for each FLP. Some use cases that may benefit from this:\r\n\r\n- Avoid re-computation of variables that stay the same in each FLP proof in [multiproof setting](https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-08.html#name-multiple-proofs). In #177  and #305 , the VDAF spec added support to allow a VDAF to run multiple proofs of its FLP to improve robustness. Inside the `eval()` function used by both `prove()` and `query()`, the FLP may compute \"some variables\" locally, which will then be fed as inputs to gadgets. Those variables don't change within each proof, so the VDAF may choose to compute those variables once, and feed them to each FLP's proof repetition to save computation time. Examples include the `sum_check` variable in [`Prio3Histogram`](https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-08.html#name-prio3histogram), which only needs to be computed once, and stays the same for all FLP proof repetitions.\r\n\r\n- FLPs that prefer to sample random values from a seed directly, instead of passing the random values as field elements in `joint_rand` to `prove()` and `query()`. The benefit include: (1) if the FLP uses a large number of field elements, it may prefer to sample the field elements on the fly instead of keeping all field elements in memory. (2) If the FLP prefers to not use field elements to represent its random values, (e.g., it may only want to sample binary values), so it's more convenient for FLP to sample from a random buffer directly, e.g., by looking at the random buffer bit by bit.\r\n\r\nPerhaps we can generalize today's `num_shares` parameter to a FLP-specific struct to support these use cases? Note this won't be wire breaking to the VDAF interface, but improves the flexibility of the integration between VDAF and FLP.",
      "createdAt": "2023-11-28T15:05:32Z",
      "updatedAt": "2024-01-24T12:07:58Z",
      "closedAt": "2024-01-24T12:07:58Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "This sounds like a useful improvement to me. I'm imagining something like an associated type for the `Valid` API. Call it something like `Context`, or `EvaluationParam`?",
          "createdAt": "2023-11-28T15:47:36Z",
          "updatedAt": "2023-11-28T15:47:36Z"
        },
        {
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I realized there is not enough motivation to complicate the spec with this change right now, so closing it.",
          "createdAt": "2024-01-24T12:07:58Z",
          "updatedAt": "2024-01-24T12:07:58Z"
        }
      ]
    },
    {
      "number": 316,
      "id": "I_kwDOGKuqOc54mcxP",
      "title": "Clarify that Poplar-like protocols may leak sensitive information if the collector misbehaves",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/316",
      "state": "CLOSED",
      "author": "simon-friedberger",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "schoppmp"
      ],
      "labels": [
        "security consideration",
        "draft-09"
      ],
      "body": "The collector decides which parts of the IDPF tree to explore. This not only leaks prefixes of the heavy hitter values but, if the collector decides to explore other branches, possibly the values of individual clients.\r\n\r\nThis is pointed out in BBCGGI21:\r\n\r\n> A malicious server\u2019s only strategy to learn extra information\r\nin Protocol 5 is to manipulate answers to the prefix-count oracle\r\nqueries using an \u201cadditive attack.\u201d [...] Intuitively:\r\nthe adversary can essentially control which strings are heavy\r\nhitters (and can thus learn how many honest clients hold strings\r\nin a small set), [..]\r\n\r\nIn the current DAP implementation this is attack is trivial to execute for the collector since it even sees the values in plain. This risk should be clearly pointed out in the standard.",
      "createdAt": "2023-12-04T08:58:48Z",
      "updatedAt": "2024-05-13T21:20:35Z",
      "closedAt": "2024-05-13T21:20:35Z",
      "comments": [
        {
          "author": "simon-friedberger",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While this clarifies the threat in the text. It leaves a problematic situation where there is no clear argument why anybody should use Poplar instead of a much cheaper shuffling based solution.",
          "createdAt": "2023-12-04T09:20:58Z",
          "updatedAt": "2023-12-04T09:20:58Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for flagging, Simon!",
          "createdAt": "2023-12-04T18:01:13Z",
          "updatedAt": "2023-12-04T18:01:13Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "I think Poplar1 still has a good case if it is deployed with differential privacy noise added at the aggregators. This would have minimal impact on the utility of the heavy hitters results, while protecting the privacy of rare measurements.\r\n\r\nMy initial hunch is that we'd want to sample DP noise from either the exponential or Laplace distribution, and add that to the shares of counts for each candidate prefix.",
          "createdAt": "2023-12-05T23:38:43Z",
          "updatedAt": "2023-12-05T23:38:43Z"
        },
        {
          "author": "simon-friedberger",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@divergentdave But doesn't the same DP countermeasure apply to shuffling?",
          "createdAt": "2023-12-06T16:17:26Z",
          "updatedAt": "2023-12-06T16:17:26Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that without functional secret sharing, you would have to trust the server that decrypts inputs received from the anonymizing proxy to actually apply the DP when counting occurrences, and keep the raw inputs private. Whereas with functional secret sharing, we can implement the addition of DP noise in a way that only needs one honest server out of two.",
          "createdAt": "2023-12-06T16:30:41Z",
          "updatedAt": "2023-12-06T16:30:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "2024/1/25: We believe we can mitigate this threat by extending VDAF to allow enforcing Algorithm 3 in the Poplar paper:\r\n![image](https://github.com/cfrg/draft-irtf-cfrg-vdaf/assets/3453007/c1d78ea4-b044-4f21-b679-cef159634747)\r\n",
          "createdAt": "2024-01-25T19:01:45Z",
          "updatedAt": "2024-01-25T19:01:45Z"
        },
        {
          "author": "simon-friedberger",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I need to pick nits, sorry. That article has a query oracle so it cannot be implemented. The proposal was for the collector to tell the aggregators the number of reports in each tree branch so the aggregators can at least prevent the collector from exploring more leafs than the number of reports and the size of the anonymity set permit.\r\n\r\nExample: With 100k reports and an anonymity set of 1k the collector can explore 100 leafs of his choosing instead of the entire tree. This still allows getting the 100 rarest values which probably are the values of individuals.",
          "createdAt": "2024-02-02T13:31:29Z",
          "updatedAt": "2024-02-02T13:31:29Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that without Differential Privacy, this attack allowing the malicious aggregator to explore N/T paths of its choice still exists (N=#inputs, T=heavy hitter threshold). It would still exist even if we made the collectors commit to their aggregate shares before exchanging them, since the malicious aggregator can use prior knowledge about the weight of paths to consistently modify its shares.\r\n\r\nI believe the best thing we can do is what @cjpatton suggested, i.e. implement the algorithm where the total count of the children at each expansion is capped by the count of the parent, make it clear in the security considerations that this still allows the attack you mention, and suggest Differential Privacy as a mitigation for that.",
          "createdAt": "2024-02-02T14:39:42Z",
          "updatedAt": "2024-02-02T14:40:24Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Concretely, it sounds like what we need to do is pass the previous aggregate result to `Vdaf.is_valid()` so that the Aggregators can enforce this. Does that sound right, @schoppmp ?",
          "createdAt": "2024-02-22T20:03:38Z",
          "updatedAt": "2024-02-22T20:03:38Z"
        },
        {
          "author": "wbl",
          "authorAssociation": "NONE",
          "body": "So I was a bit confused by what gets revealed and I think there's a very powerful attack here.\r\n\r\nLet's say the strings are 6 bits, and we have 100110 reported 128 times, 101010 reported another 128 and 110010 is some string an attacker would love to determine that appears once 1. Critically the attacker knows that it starts with 110. We'll pretend nothing is known about the whole number of things/there's enough stuff getting dropped. We'll say that the threshold for discovery is 64, and we're holding two prefixes at once so each query is 4 strings, and the top two survive.\r\n\r\nAttacker reports bit 1 happens 4097 times, and 0 0. Next round we ask about 10 and 11. Now the attacker starts cheating. 10 is 256 as honest, but 11 is 3841. The next round is 100, 101, 110, and 111. The attacker doesn't boost 100 and 101 which are both 128, and then 110 gets boosted to 1921, while 111 is left at 1920. Now the next four are 1100, 1101, 1110 and 1111, and the attacker boosts so that 1100 is 961, while the others only 960. Whatever tiebreaking happens 1100 survives, and next 11001 and then 11010.\r\n\r\nIn fact the attacker can do this blind: just by splitting their addition in half every time across the prefix they get the information. And they (unless I'm missing something) see the resulting string. So its not learn how many clients have a string in a small set but recover strings in the set at will if you know enough to pick the one you want to start with. Application to URLs with tokens in them is left as an exercise.\r\n\r\nUnless I'm really missing something I think submitter privacy is still preserved, but this is still really bad.\r\n(Edit: this is be what @simon-friedberger meant in the PR, but it wasn't clear to me how powerful it was from the bug)",
          "createdAt": "2024-03-07T06:44:41Z",
          "updatedAt": "2024-03-07T06:51:14Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm, I  don't think what you describe generalizes to longer strings, assuming the mitigation I described [above](https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/316#issuecomment-1924018708) is implemented.\r\n\r\nIf I understand correctly, the goal of the attacker in your example is to discover an unknown string with a known prefix, that appears only once (say, a URL with a security token in it). It does that by putting as much \"weight\" as possible on the known prefix, by actively changing the output of the corrupted aggregator. Now at the \"unknown\" part, it starts splitting the weight in half at each level, exploring the path with the greatest weight (since that's where the victim's string is).\r\n\r\nIn your example, the total weight the attacker starts with is 4097, which would be enough to make the entire tree consist of heavy hitters (2^6 * 64 = 4096). This won't work for longer strings, since the honest aggregator can abort if it sees a total weight more than the number of client inputs. So to discover a uniform length-L token, the attacker would need at least 2^L clients / total weight to start with.\r\n\r\nThat said, I agree that even with mitigations in place, Poplar reveals far more than only the heavy hitters (even passive adversaries learn the prefix tree. Actively changing the prefix tree is what enables all the attacks in this thread). I will try to make this very explicit in the PR I'm working on.",
          "createdAt": "2024-03-07T09:50:48Z",
          "updatedAt": "2024-03-07T09:50:48Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "I pushed a first draft in #332. @simon-friedberger @wbl do the changes to `is_valid` plus the text in the security considerations adequately describe the issue?",
          "createdAt": "2024-03-07T14:43:35Z",
          "updatedAt": "2024-03-07T14:43:35Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to see more prose describing the invariants we want to guarantee. Also, as suggested there, I wonder if we want to enforce that the sum of the prefix counts is equal to the number of reports.",
          "createdAt": "2024-03-07T18:49:34Z",
          "updatedAt": "2024-03-07T18:49:34Z"
        },
        {
          "author": "wbl",
          "authorAssociation": "NONE",
          "body": "@Schoppmp The attacker needs 2^b to recover b bits, but can wait to start recovering until after going down the tree a bit, and can subtract from other counts. So in one round they recover very, next round verysec, next round verysecret, etc. ",
          "createdAt": "2024-03-07T18:57:39Z",
          "updatedAt": "2024-03-07T18:57:39Z"
        }
      ]
    },
    {
      "number": 319,
      "id": "I_kwDOGKuqOc55GJpO",
      "title": "XofTurboShake128: Consider bumping SEED_SIZE from 16 to 32 bytes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/319",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "wire change",
        "draft-12"
      ],
      "body": "When thinking about Prio3 robustness (ia.cr/2023/130, Theorem 1) we (err, I, really) have been ignoring the term that depends on the size of the seed: $(q_\\text{RG} + {q_{\\text{Prep}}}^2) / 2^{\\kappa -1}$\r\n\r\n* $q_\\text{RG}$ - the number of random oracle queries (XofTurboShake128 is modeled as an RO)\r\n* $q_\\text{Prep}$ - the number of (potentially malicious) reports consumed in a given DAP task\r\n* $\\kappa$ - the seed size (16 bytes for XofTurboShake128)\r\n\r\nAs @albertpl pointed out in https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/318#discussion_r1416669600, the bound becomes vacuous after $q_\\text{Prep}=2^{63.5}$ reports (since $(2^{63.5})^2 = 2^{\\kappa -1}$).\r\n\r\nWhile it's doubtful that we'd ever consume so many reports in a single task, it's not a bad idea to have a more conservative safety margin. 32 bytes seems like a reasonable choice.",
      "createdAt": "2023-12-07T22:57:31Z",
      "updatedAt": "2024-08-20T22:01:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Update: the term we're looking at here deals with the probability of two reports deriving the same joint randomness. While our main concern here was the number of online attacks against robustness (and whether a birthday attack is too close for comfort, given the current seed size), @bwesterb pointed out the possibility of an offline attacker finding pair of distinct reports that derive the same joint randomness seed. This is clearly a possibility: an offline attacker can try to find joint randomness hints that produce the same joint randomness seed, or two reports that produce the same joint randomness hints.\r\n\r\nThis points to a bug in the current proof. The ${q_\\text{Prep}}^2/2^\\kappa$ is actually more like $(q_\\text{RG} + q_\\text{Prep})^2/2^\\kappa$. @hannahdaviscrypto and I are updating the paper and will put it on eprint soon.\r\n\r\nCertainly ${q_\\text{RO}}^2/2^\\kappa$ is too weak, so we'll need to fix this. Rather than double the seed size for `XofTurboShake128`, we propose a more targeted fix: to double the size of the joint randomness seed only, and adjust the joint randomness derivation accordingly. See PR #407.",
          "createdAt": "2024-08-20T22:01:13Z",
          "updatedAt": "2024-08-20T22:01:13Z"
        }
      ]
    },
    {
      "number": 321,
      "id": "I_kwDOGKuqOc56DZEC",
      "title": "poc: TurboSHAKE128: Replace reference implementation with a stateful version",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/321",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We currently impose a limit on the number of bytes output by `XofTurboShake128` due to the inefficiency of the current implementation. Replace the stateless implementation with a stateful one and remove the limit.",
      "createdAt": "2023-12-19T00:22:46Z",
      "updatedAt": "2024-01-10T02:58:20Z",
      "closedAt": "2024-01-10T02:58:20Z",
      "comments": []
    },
    {
      "number": 323,
      "id": "I_kwDOGKuqOc57lv9I",
      "title": "poc: Use PyCryptodome for TurboSHAKE",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/323",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "As of this writing, PyCryptodome does not support TurboSHAKE. However the next release will: https://github.com/Legrandin/pycryptodome/issues/780\r\n\r\nIn the meantime, we are using our own implementation: https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/322\r\n\r\nOnce a PyCryptodome is released with support TurboSHAKE, use it instead.",
      "createdAt": "2024-01-10T02:57:09Z",
      "updatedAt": "2024-01-11T19:58:23Z",
      "closedAt": "2024-01-11T19:58:23Z",
      "comments": []
    },
    {
      "number": 327,
      "id": "I_kwDOGKuqOc589SUl",
      "title": "Testing improvements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/327",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "poc"
      ],
      "body": "1. Adopt `unittest` for unit tests.\r\n2. Decouple test vector generation from unit tests. Requirements:\r\n     * We would like the code to set the path for the test vector (e.g., `test_vec/08`).\r\n     * Unit tests should always generate fresh randomness; for test vectors, either: (1) use the a fixed sequence of coins, as the draft suggests; or (2) publish the generated randomness with test vectors.\r\n     * We need a separate function for generating test vectors and running the VDAF.\r\n\r\ncc/ @junyechen1996 ",
      "createdAt": "2024-01-23T16:12:11Z",
      "updatedAt": "2024-08-05T23:14:40Z",
      "closedAt": "2024-08-05T23:14:40Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Another issue here: Some tests, when they fail, merely dump something to stdout without triggering unittest to have a fatal exit status. This means these failures won't be noticed in CI.",
          "createdAt": "2024-08-01T21:01:54Z",
          "updatedAt": "2024-08-01T21:01:54Z"
        }
      ]
    },
    {
      "number": 328,
      "id": "I_kwDOGKuqOc58_o0_",
      "title": "Have Prio3 specify the field rather than the FLP circuit",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/328",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "              > @divergentdave  Looks good. I think we should also add `| PROOFS | 1 |` to tables 9, 10, 11, and 12, right after `Field`, to be clear about the parameter values for the four concrete Prio3 VDAFs (and algorithm IDs) we define.\r\n\r\nThese tables specify parameters of the circuit; the number of proofs is not a parameter of the circuit. In fact, the gudance here is about modifying one of the circuits, say `SumVec` by changing the field from `Field64` to `Field128`.\r\n\r\nWhat do you think about decoupling `Field` from the circuit and moving it to the `Prio3` variant. There, `PROOFS` is (or should, at least) be specified.\r\n\r\n_Originally posted by @cjpatton in https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/325#issuecomment-1906952751_\r\n            ",
      "createdAt": "2024-01-23T21:58:11Z",
      "updatedAt": "2024-07-03T18:16:57Z",
      "closedAt": "2024-07-03T18:16:57Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we'll end up resolving this as part of the #361 refactor.",
          "createdAt": "2024-06-12T23:56:17Z",
          "updatedAt": "2024-06-12T23:56:17Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Reopening so we don't forget this",
          "createdAt": "2024-06-26T17:27:23Z",
          "updatedAt": "2024-06-26T17:27:23Z"
        }
      ]
    },
    {
      "number": 333,
      "id": "I_kwDOGKuqOc6EXtM0",
      "title": "Poplar1: Should the threshold be a parameter of the scheme?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/333",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wire change"
      ],
      "body": "The privacy of this VDAF depends on the threshold chosen by the Collector. At the application level, it will often be useful to ensure that all honest parties agree on the threshold such that the attacker can't change its value, for example, with the task binding mechanism of the proposed [taskprov extension for DAP.](https://github.com/wangshan/draft-wang-ppm-dap-taskprov).",
      "createdAt": "2024-04-02T15:21:17Z",
      "updatedAt": "2024-06-10T15:22:44Z",
      "closedAt": "2024-06-10T15:22:44Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Binding Poplar1 execution to the threshold is similar to binding VDAF's execution to the batch size, something we have not done. One reason not to do the latter is that the batch size may be chosen dynamically by the aggregators, w/ DP noise tuned accordingly.\r\n\r\nBinding to these types of parameters could also be accomplished at the protocol layer, e.g., in DAP via https://github.com/wangshan/draft-wang-ppm-dap-taskprov.",
          "createdAt": "2024-06-10T15:22:44Z",
          "updatedAt": "2024-06-10T15:22:44Z"
        }
      ]
    },
    {
      "number": 334,
      "id": "I_kwDOGKuqOc6Ei6kZ",
      "title": "Version Poplar1 and Prio3 separately",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/334",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-12"
      ],
      "body": "The draft specifies a constant `VERSION` that is used for domain separation in Prio3 and Poplar1. This is intended to force incompatibility across drafts such that an old version of Prio3 doesn't interop with a new version. (Likewise for Poplar1.)\r\n\r\nWe're considering two breaking changes for Poplar1 in the next draft:\r\n- #316\r\n- #333\r\n\r\nHowever we're not likely to see breaking changes for Prio3.  VDAF-08-Prio3 is already deployed:  I propose that, for VDAF-09, we keep the version tag for Prio3 the same and only bump the version tag for Poplar1. If breaking changes for Prio3 are required in the future, then we can bump the version tag then.",
      "createdAt": "2024-04-03T19:29:27Z",
      "updatedAt": "2024-08-14T15:47:31Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 335,
      "id": "I_kwDOGKuqOc6HcejI",
      "title": "Consider renaming \"secure sketch\" to \"arithmetic sketch\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/335",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial"
      ],
      "body": "As formalized in https://eprint.iacr.org/2023/1012.",
      "createdAt": "2024-04-30T20:22:51Z",
      "updatedAt": "2024-06-18T14:13:19Z",
      "closedAt": "2024-06-18T14:13:19Z",
      "comments": []
    },
    {
      "number": 338,
      "id": "I_kwDOGKuqOc6HjT5y",
      "title": "Is it OK to mention specific companies/projects?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/338",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial",
        "pre-RGLC"
      ],
      "body": "The intro mentions the MOzilla Origin Telemtry project, ENPA, ISRG, Google, and Apple by name. I'm not sure this is appropriate for an RFC to do. ",
      "createdAt": "2024-05-01T20:51:16Z",
      "updatedAt": "2024-08-05T16:10:48Z",
      "closedAt": "2024-08-05T16:10:48Z",
      "comments": [
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "Credit them in the acknowledgements for providing the impetus to write the draft?",
          "createdAt": "2024-08-01T20:17:30Z",
          "updatedAt": "2024-08-01T20:17:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Great idea, thanks Rich!",
          "createdAt": "2024-08-01T20:22:46Z",
          "updatedAt": "2024-08-01T20:22:46Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "List feedback: https://mailarchive.ietf.org/arch/msg/cfrg/4TAP3_bgDGFEy8C29qigQUwNc2A/",
          "createdAt": "2024-08-03T00:27:43Z",
          "updatedAt": "2024-08-03T00:27:43Z"
        }
      ]
    },
    {
      "number": 341,
      "id": "I_kwDOGKuqOc6H9dia",
      "title": "IDPF: Use XofTurboShake128 for deriving the leaf nodes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/341",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "wire change",
        "draft-12"
      ],
      "body": "This is needed for IDPF to be extractable.\r\n\r\n_Originally posted by @schoppmp in https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/336#discussion_r1588266127_\r\n            ",
      "createdAt": "2024-05-06T14:36:25Z",
      "updatedAt": "2024-08-16T19:52:14Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 342,
      "id": "I_kwDOGKuqOc6II4hk",
      "title": "Clarify that public share requirements are relevant to robustness",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/342",
      "state": "CLOSED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial"
      ],
      "body": "I think I'm being fussy but I want to make sure we don't slip up here. Continuing from #336:\r\n\r\n>The risk that the Poplar paper talks about when the aggregators don't have a consistent view of the public parameters is that the malicious client could control the output of the DPF at two inputs, instead of one, like we want. This happens because choosing different group element correction words for one level, and giving each aggregator a different one, gives the client an extra degree of freedom it shouldn't have.\r\n>\r\n>Since we're considering a malicious client when we consider attempts to break extractability in this manner, we don't need to protect this report's privacy, and thus the only goal that matters is robustness. For robustness, we get to assume that both aggregators are honest, and thus we can assume that the leader will distribute the public share to the helper correctly, without considering the HPKE AAD.\r\n>\r\n>Including the public share in the HPKE AAD is probably more relevant for protecting against privacy attacks, as we wouldn't want to let a rogue leader pass an honest client's input share with a tampered public share.\r\n\r\n_Originally posted by @divergentdave in https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/336#discussion_r1591715132_\r\n\r\nI think I agree with that analysis, but it's hard to square with the MUST added by #336, which reads:\r\n\r\n> The Aggregators MUST verify that they have both received the same public share from\r\n> the Client. It is sufficient, for example, to exchange a hash of the public\r\n> share over a secure channel.\r\n\r\nPerhaps this paragraph should say something like \"In order to protect robustness, the Aggregators MUST verify...\". That would give \"permission\" to a higher level protocol like DAP to apply David's analysis and opt out of doing something like an explicit exchange of the public share. I also wonder if David's analysis should be incorporated into the text of DAP.",
      "createdAt": "2024-05-07T19:04:29Z",
      "updatedAt": "2024-05-08T15:31:56Z",
      "closedAt": "2024-05-08T15:31:56Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't quite see how the text we landed doesn't square with David's analysis. Is it that \"the Aggregators MUST verify\" sounds like there needs to be some explicit procedure, like exchanging the hash? As David explains, explicit verification is not necessary: in DAP, the Leader is supposed to copy the public share from the report into the Helper's report share. This provides the property we need, just implicitly.\r\n\r\nPerhaps \"the Aggregators MUST ensure they hold the same public share\"?\r\n\r\nNote that including the the public share in the HPKE AAD is not strictly necessary, either for privacy or robustness. We do this just for defense-in-depth.\r\n\r\nAll that said, your suggestion sounds fine -- feel free to send a PR.",
          "createdAt": "2024-05-07T20:27:35Z",
          "updatedAt": "2024-05-07T20:27:35Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "The VDAF security model just stipulates secure channels between protocol participants, so part of what's going on is just DAP's implementation decisions regarding instantiating the secure channel from the Client to Leader and Client to Helper. Splitting the report, encrypting part of it, and committing to the other part is complicated, but it saves some communication cost by avoiding duplicate data. (I think DAP does need to include the public share in the HPKE AAD in order to maintain integrity of the whole report while tunneling through the maybe-malicious Leader.)\r\n\r\nI don't think we should say anything about the relationship between robustness and the Aggregators having the same public share, because that could then become a new requirement on VDAFs, depending on how it's phrased. Rephrasing it to make it clear an extra explicit check isn't necessary sounds good.",
          "createdAt": "2024-05-07T20:41:19Z",
          "updatedAt": "2024-05-07T20:41:19Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Is it that \"the Aggregators MUST verify\" sounds like there needs to be some explicit procedure, like exchanging the hash?\r\n\r\nYeah, that's what concerns me. Saying \"MUST ensure\" sounds like a good way to resolve this. \r\n\r\n> in DAP, the Leader is supposed to copy the public share from the report into the Helper's report share. This provides the property we need, just implicitly.\r\n\r\nOh, this is the part I was missing: the honest leader does get to enforce that the public shares match.\r\n\r\nWith all this understood, I'd be comfortable with changing \"MUST verify\" to \"MUST ensure\", but I'd also be OK with doing nothing and closing this without any change.",
          "createdAt": "2024-05-07T21:11:57Z",
          "updatedAt": "2024-05-07T21:14:01Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "PR up: @tgeoghegan please take a look!",
          "createdAt": "2024-05-08T14:56:03Z",
          "updatedAt": "2024-05-08T14:56:03Z"
        }
      ]
    },
    {
      "number": 346,
      "id": "I_kwDOGKuqOc6LS0_2",
      "title": "Consider removing definition of DAFs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/346",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "DAFs are the same as VDAFs except they don't provide robustness on their own. This feature was requested early on in the history of PPM (https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/issues/45). However no DAF has been defined, much less deployed.\r\n\r\nWe should consider removing DAFs from the draft:\r\n1. This would reduce some maintenance cost in the draft and reference implementation.\r\n2. This would simplify https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/259, which conflicts with the current goal of writing down DAF as a \"warm-up\" to VDAFs.",
      "createdAt": "2024-06-05T23:06:10Z",
      "updatedAt": "2024-08-07T23:35:04Z",
      "closedAt": "2024-08-07T23:35:04Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "We got a little feedback on this from the list: https://mailarchive.ietf.org/arch/msg/cfrg/CIqmoCeaTKtxDo-qDyb5i2WwF1o/\r\n\r\nA couple of people spoke up and suggested it's fine to keep the syntax without instantiating it. Let's hold this open a little longer.",
          "createdAt": "2024-07-23T19:34:56Z",
          "updatedAt": "2024-07-23T19:34:56Z"
        }
      ]
    },
    {
      "number": 352,
      "id": "I_kwDOGKuqOc6LiXik",
      "title": "Clarify requirements for generating the IDPF binder string",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/352",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "schoppmp"
      ],
      "labels": [
        "security consideration",
        "draft-10"
      ],
      "body": "We require the binder string to be generated at random, but we don't prescribe its length or say why it needs to be random:\r\n\r\nhttps://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/3ac03623c4680b28d1517af0a16dd513e1d0c310/draft-irtf-cfrg-vdaf.md?plain=1#L3710-L3714\r\n\r\nI believe this has to do with how `XofFixedKeyAes128` affects the concrete security of `Poplar1`, but I don't remember the details. Let's make sure this is documented. Furthermore, we need to define the length so that the user knows how many bytes to sample. I'd suggest renaming the binder to `nonce` and adding `Idpf.NONCE_SIZE` as a constraint on `Idpf`. (`Poplar1` may need to be modified accordingly.)",
      "createdAt": "2024-06-07T19:27:11Z",
      "updatedAt": "2024-07-23T19:25:09Z",
      "closedAt": "2024-07-23T19:25:09Z",
      "comments": [
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "This was decided in https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/32#issuecomment-1465432536 and you are correct, it is needed for the concrete security of the fixed-key AES construction. I'll send a PR to clarify this.",
          "createdAt": "2024-06-18T11:23:28Z",
          "updatedAt": "2024-06-18T11:23:28Z"
        }
      ]
    },
    {
      "number": 359,
      "id": "I_kwDOGKuqOc6MBqlv",
      "title": "Make proof of concept code pip-installable",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/359",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "poc"
      ],
      "body": "We should rearrange the directory and module structure of the proof of concept code, and add metadata files (i.e. pyproject.toml or setup.py) to make it installable as a package. This would remove the need for other related drafts to use git submodules and Python import path hacks. I figure we'd want to provide just one top-level module, probably called `vdaf`, and then move module paths under that. Note that this would require moving around files and rewriting a lot of internal import statements. The goal is that other projects should be able to do `pip install git+https://github.com/cfrg/draft-irtf-cfrg-vdaf.git@draft-irtf-cfrg-vdaf-NN#subdirectory=poc`, and then `import vdaf`.",
      "createdAt": "2024-06-12T16:52:55Z",
      "updatedAt": "2024-07-31T00:14:22Z",
      "closedAt": "2024-07-31T00:14:22Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Some notes:\r\n\r\n1.  We need to make it clear to users that the code is _slow_ and _not secure_ (we don't aim for constant time). If someone wants Python, then they should really just write bindings to libprio.\r\n\r\n1. We currently always invoke the code with `sage`: what happens if someone tries to pip install this directly?\r\n\r\n",
          "createdAt": "2024-06-12T23:55:42Z",
          "updatedAt": "2024-06-12T23:55:42Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Good point, it would actually be `sage -pip install git+https://...`. Using pip from a regular Python environment would result in installing the package to the wrong place, and eventually you'd run into trouble at the `import sage.all` statement.",
          "createdAt": "2024-06-13T00:07:56Z",
          "updatedAt": "2024-06-13T00:07:56Z"
        }
      ]
    },
    {
      "number": 361,
      "id": "I_kwDOGKuqOc6MCJgk",
      "title": "Check types at runtime",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/361",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "poc",
        "draft-10"
      ],
      "body": "While working on #59 we found that the \"class factory\" pattern we're following for instantiating the `Vdaf` API is not enforceable by `mypy`. We still want type enforcement, so we'll do this at runtime instead. We think this will be easier/cleaner if we move away from the hacky class factory pattern to proper, Python-style OOP. E.g.:\r\n```python\r\nclass Vdaf:\r\n   \"\"\"An abstract base class.\"\"\"\r\n   def shard(self, measurement, nonce, rand):\r\n       raise NotImplementedError()\r\n\r\n   def shard_check_inputs(self, measurement, nonce, rand):\r\n      assert type(measurement) == self.Measurement\r\n      assert type(nonce) == bytes\r\n      assert len(nonce) == self.NONCE_SIZE\r\n      assert type(rand) == bytes\r\n      assert len(rand) == self.RAND_SIZE      \r\n```\r\n\r\nThen a concrete VDAF would call this method explicitly:\r\n```python\r\nclass Prio3(Vdaf):\r\n  def __init__(self, flp, field):\r\n     self.field = field\r\n     self.flp = flp\r\n     self.Measurement = flp.Measurement\r\n     ...\r\n\r\n  def shard(self, measurement, nonce, rand):\r\n      self.shard_check_inputs(measurement, nonce, rand)\r\n      ...\r\n```",
      "createdAt": "2024-06-12T17:48:54Z",
      "updatedAt": "2024-07-02T19:42:50Z",
      "closedAt": "2024-07-02T19:42:50Z",
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "For basic type checks, it would be better form to do `assert isinstance(rand, bytes)`. For more complicated types, note that `list[int]` in the source turns into just `list` at runtime. Thus, we'd have to split up the assertions into, for example, `assert isinstance(measurement, list)` and `assert all(isinstance(elem, int) for elem in measurement)`.",
          "createdAt": "2024-06-12T17:58:54Z",
          "updatedAt": "2024-06-12T17:58:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Which implies that the type would have to define its own type checking method :(",
          "createdAt": "2024-06-12T18:00:23Z",
          "updatedAt": "2024-06-12T18:00:23Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, at that point I think it would make sense to roll the asserts into the top of each VDAF method.",
          "createdAt": "2024-06-12T18:01:55Z",
          "updatedAt": "2024-06-12T18:01:55Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "After #363, `mypy`'s type checking is now working much better for us. While these type hints aren't checked at runtime, they still provide a good degree of assurance that our code is well-typed (especially with `check_untyped_defs = True`). Thus, there is no longer a need for manual runtime type assertions.",
          "createdAt": "2024-07-02T19:42:50Z",
          "updatedAt": "2024-07-02T19:42:50Z"
        }
      ]
    },
    {
      "number": 364,
      "id": "I_kwDOGKuqOc6NowH2",
      "title": "Clean up use of xml2rfc artwork and sourcecode tags",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/364",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "divergentdave"
      ],
      "labels": [
        "editorial"
      ],
      "body": "We currently use a mixture of `<artwork>` and `<sourcecode>` tags. These are both generated when we fence off preformatted text with three or more tildes. If an identifier appears after the leading group of tildes, on the same line, then a `<sourcecode>` element is generated, with its `type` attribute set to that identifier. See https://datatracker.ietf.org/doc/html/rfc7991#section-2.48 for the xml2rfc tag definition, `<sourcecode>` is now preferred over `<artwork>` for source code and formal languages. The document has a mix of ASCII art and source code excerpts, though almost all `~~~` code fences lack an identifier, save for one with `state` and four with `transition`. We should change excerpts from the proof of concept to `~~~ python`, and change `~~~ state` and `~~~ transition` to `~~~ pseudocode`, which are among the list of preferred values. As a bonus, my editor supports embedded syntax highlighting when I switch a block to `~~~ python`. The fences around true ASCII art can stay as they are.",
      "createdAt": "2024-06-26T20:57:46Z",
      "updatedAt": "2024-07-02T19:19:46Z",
      "closedAt": "2024-07-02T19:19:46Z",
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "There is a living list of preferred values for `type` at https://www.rfc-editor.org/rpc/wiki/doku.php?id=sourcecode-types, and it incldues `tls-presentation`. We should use this in the ping-pong topology section.",
          "createdAt": "2024-06-26T21:07:16Z",
          "updatedAt": "2024-06-26T21:07:16Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> There is a living list of preferred values for `type` at https://www.rfc-editor.org/rpc/wiki/doku.php?id=sourcecode-types, and it incldues `tls-presentation`. We should use this in the ping-pong topology section.\r\n\r\nWe also use TLS representation for specifying some of the message formats in {{prio3}} and {{poplar1}}.",
          "createdAt": "2024-06-27T00:49:10Z",
          "updatedAt": "2024-06-27T00:49:10Z"
        }
      ]
    },
    {
      "number": 365,
      "id": "I_kwDOGKuqOc6NzhPU",
      "title": "Prio3Count circuit optimization",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/365",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wire change"
      ],
      "body": "The Count circuit currently computes $x^2-x$ using one `Mul` gate, and some affine gates. This could be slightly improved by instead using a polynomial evaluation gate, with arity 1 instead of 2, to compute either $x^2$ or the whole polynomial. This would save a little bit of space on the wire, and probably some computation time as well. We should benchmark the potential improvement, and then decide whether it is worth breaking wire compatibility of Prio3Count or not.",
      "createdAt": "2024-06-27T21:06:47Z",
      "updatedAt": "2024-07-05T19:27:58Z",
      "closedAt": "2024-07-05T19:27:58Z",
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "See divviup/libprio-rs#1090 for preliminary benchmarking results. I didn't see any CPU performance thus far, though there may still be some room for optimizing the implementation. In terms of message sizes, we would save 8 bytes on the leader input share and 8 bytes on the prepare shares.",
          "createdAt": "2024-07-03T21:59:36Z",
          "updatedAt": "2024-07-03T21:59:36Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for trying this out! Given that you had to roll a special gadget for this to get competitive CPU time, I would say the implementation complexity outweights the bandwidth gains. What's 8 bytes between friends?",
          "createdAt": "2024-07-04T00:16:00Z",
          "updatedAt": "2024-07-04T00:16:00Z"
        }
      ]
    },
    {
      "number": 366,
      "id": "I_kwDOGKuqOc6N5_LM",
      "title": "Poplar1: reject empty first round prepare message immediately",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/366",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "Currently, when `prep_next()` handles the first round prepare message, it replaces an empty message with three zeros, before continuing on with sketching. Stepping backwards, `prep_shares_to_prep()` just adds shares of a vector of three elements together and returns it. Previously, it used to encode vectors of zeros as the empty string, see https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/363#discussion_r1657803678. I think getting three zero field elements in the first round of sketching is highly unlikely. Since `prep_shares_to_prep()` won't return `None` on the first round, then we can remove this special case, reject empty prepare messages on this round, and stop continuing to verify a sketch of zeros.",
      "createdAt": "2024-06-28T16:35:54Z",
      "updatedAt": "2024-07-03T16:36:59Z",
      "closedAt": "2024-07-03T16:36:59Z",
      "comments": []
    },
    {
      "number": 380,
      "id": "I_kwDOGKuqOc6QPIjs",
      "title": "Prio3: Store compressed helper input share in PrepState",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/380",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Currently, the PrepState for Prio3 is `tuple[list[F], Optional[bytes]]`, consisting of the output share and the recomputed joint randomness seed. We could improve the storage requirements for the helper if the helper instead stored its compressed input share seed, and then re-expanded and re-truncated it into an output share during prep_next(). I think the leader should still store its output share in the PrepState, as it may be shorter than the leader input share, depending on the Prio3 instance. This would be quasi-wire breaking, in that it would change the format of an aggregator's persistent storage, but wouldn't affect messages between parties.",
      "createdAt": "2024-07-19T21:19:38Z",
      "updatedAt": "2024-08-02T17:29:38Z",
      "closedAt": "2024-08-02T17:29:38Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Does this need to be specified, or would an implementation note suffice? libprio already does this, fwiw:\r\nhttps://github.com/divviup/libprio-rs/blob/main/src/vdaf/prio3.rs#L1045\r\n\r\nI don't think this is a wire breaking change because the prep state is never transmitted between parties.",
          "createdAt": "2024-07-19T21:24:01Z",
          "updatedAt": "2024-07-19T21:24:01Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah good point. An implementation note would be good, in that case.",
          "createdAt": "2024-07-19T21:25:16Z",
          "updatedAt": "2024-07-19T21:25:16Z"
        }
      ]
    },
    {
      "number": 389,
      "id": "I_kwDOGKuqOc6R_-_a",
      "title": "Replace `Union[TypeA, TypeB]` with `TypeA | TypeB`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/389",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "poc"
      ],
      "body": "A little nit-picky, but recent versions of Python allow `|` to be used to express union types.",
      "createdAt": "2024-08-05T20:58:06Z",
      "updatedAt": "2024-08-06T17:33:48Z",
      "closedAt": "2024-08-06T17:33:48Z",
      "comments": []
    },
    {
      "number": 396,
      "id": "I_kwDOGKuqOc6SwJAX",
      "title": "Capitalization after colon",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/396",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Sometimes we capitalize the first letter after a colon, other times we don't. Let's be consistent. (The latter is probably the correct one.)",
      "createdAt": "2024-08-13T00:05:17Z",
      "updatedAt": "2024-08-14T15:55:03Z",
      "closedAt": "2024-08-14T15:55:03Z",
      "comments": []
    },
    {
      "number": 397,
      "id": "I_kwDOGKuqOc6S4TXn",
      "title": "Gentle introduction to IDPF generation/evaluation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/397",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "schoppmp"
      ],
      "labels": [
        "editorial"
      ],
      "body": "We need text that conveys the intuition of how IDPFs work, and whey they're private:\r\n\r\nhttps://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/beaaffec1d066157deac9fe6b6367a4eaec2f2f3/draft-irtf-cfrg-vdaf.md?plain=1#L4902-L4903\r\n\r\nhttps://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/beaaffec1d066157deac9fe6b6367a4eaec2f2f3/draft-irtf-cfrg-vdaf.md?plain=1#L4981",
      "createdAt": "2024-08-13T21:13:44Z",
      "updatedAt": "2024-08-13T21:13:44Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 398,
      "id": "I_kwDOGKuqOc6S4oCp",
      "title": "Replace \"FFT\" with \"NTT\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/398",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "editorial",
        "poc"
      ],
      "body": "Number theoretic transform is the terminology used much more widely in cryptography: https://eprint.iacr.org/2024/585",
      "createdAt": "2024-08-13T22:11:25Z",
      "updatedAt": "2024-08-20T01:47:29Z",
      "closedAt": "2024-08-20T01:47:29Z",
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOGKuqOc4tFEy5",
      "title": "Edits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/1",
      "state": "MERGED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Some clarifications and changes found while reviewing https://github.com/abetterinternet/libprio-rs/pull/93 and checking it against this document.\r\n\r\n- `vdaf_input` returns a vector of input shares rather than a single blob'o'bytes\r\n- make aggregation parameter more obvious in `vdaf_start`\r\n- remove obsolete references to ready and waiting states in Prio3 `vdaf_start` and `vdaf_finish` definitions",
      "createdAt": "2021-10-12T15:29:23Z",
      "updatedAt": "2021-10-12T16:29:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "c667b77422eabbe1cf1c8450f396e5ba54d887c8",
      "headRepository": "tgeoghegan/vdaf",
      "headRefName": "edits",
      "headRefOid": "0b2ae6afa5f8a8473cc5aa7baf6f0cfca206aac9",
      "closedAt": "2021-10-12T16:29:27Z",
      "mergedAt": "2021-10-12T16:29:26Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "d25be886346f3388b1972e540f5f38209e521401"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOGKuqOc4tGzIf",
      "title": "Add an intro",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/2",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-12T21:43:32Z",
      "updatedAt": "2022-05-26T14:58:01Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "810e990a8c6cf03b6b21091d72fd394b6a68a6f9",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "intro",
      "headRefOid": "12e409b59fcbff030a351de55606c562b8dd215d",
      "closedAt": "2021-10-13T21:54:17Z",
      "mergedAt": "2021-10-13T21:54:17Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "9d04d03236a215b29a3e9087159dfa2de1247692"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4uXdKU",
          "commit": {
            "abbreviatedOid": "6d91a58"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This is great! A few comments.",
          "createdAt": "2021-10-12T21:57:25Z",
          "updatedAt": "2021-10-12T22:15:37Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nThe remainder of this document is structured as follows:\r\n```",
              "createdAt": "2021-10-12T21:57:25Z",
              "updatedAt": "2021-10-12T22:15:37Z"
            },
            {
              "originalPosition": 29,
              "body": "This is a pretty good description of systems like RAPPOR, but I think it would be useful to speak about DP more broadly. Roughly speaking, differentially private data aggregation systems guarantee that the degree to which an individual user influences the aggregate output is small.",
              "createdAt": "2021-10-12T22:14:50Z",
              "updatedAt": "2021-10-12T22:15:37Z"
            },
            {
              "originalPosition": 36,
              "body": "In my view, the greater drawback of DP is the need to enforce a privacy budget. ",
              "createdAt": "2021-10-12T22:15:13Z",
              "updatedAt": "2021-10-12T22:15:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 3,
      "id": "PR_kwDOGKuqOc4tG5Ka",
      "title": "Some comments",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/3",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-12T22:12:05Z",
      "updatedAt": "2022-05-26T14:58:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "b23df123f181528e4b1fedbcc231d81e3a707a72",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "rlb-review",
      "headRefOid": "be528b0101facbb7d53bdb18edf3a43b98175441",
      "closedAt": "2021-10-25T14:54:20Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4uXjtC",
          "commit": {
            "abbreviatedOid": "be528b0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T22:32:02Z",
          "updatedAt": "2021-10-12T22:37:46Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "DAFs and VDAFs are meant to be distinct primitives. They differ in two important ways: VDAFs require the aggregators to interact; and DAFs don't provide any guarantee about the validity of the output. DAFs and VDAFs aren't necessarily \"compatible\" with one another. It's true that that there may be some overlap between specific constructions, but this isn't necessarily the case.\r\n\r\nTo be clear, VDAFs are the interesting primitive here. The main reason I defined DAFs is because they are conceptually simpler and provide a nice warm up to VDAFs. Perhaps we should just drop DAFs altogether?",
              "createdAt": "2021-10-12T22:32:02Z",
              "updatedAt": "2021-10-12T22:37:46Z"
            },
            {
              "originalPosition": 17,
              "body": "Validation applies to VDAFs, not DAFs.",
              "createdAt": "2021-10-12T22:32:47Z",
              "updatedAt": "2021-10-12T22:37:46Z"
            },
            {
              "originalPosition": 25,
              "body": "The aggregation parameter is what maps an input to an output. For heavy hitters for example, the aggregation parameter is the set of candidate prefixes. I'll make this more clear.",
              "createdAt": "2021-10-12T22:34:25Z",
              "updatedAt": "2021-10-12T22:37:46Z"
            },
            {
              "originalPosition": 31,
              "body": "Right, the way aggregability is defined currently is that the set of output shares is an algebraic group, and the output is recovered by adding up the output shares. Would defining an explicit \"unsharding\" algorithm be more clear, in your opinion?",
              "createdAt": "2021-10-12T22:35:33Z",
              "updatedAt": "2021-10-12T22:37:46Z"
            },
            {
              "originalPosition": 62,
              "body": "This is something that's a bit in-flux right now. I think where we're going to land is that the client gets a \"public key\" (the \"public parameter\") and each aggregator gets its own \"secret key\" (the \"verification parameter\").",
              "createdAt": "2021-10-12T22:37:02Z",
              "updatedAt": "2021-10-12T22:37:46Z"
            },
            {
              "originalPosition": 72,
              "body": "That's the plan! This is still very much WIP.",
              "createdAt": "2021-10-12T22:37:35Z",
              "updatedAt": "2021-10-12T22:37:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4ugW0-",
          "commit": {
            "abbreviatedOid": "be528b0"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-14T20:48:19Z",
          "updatedAt": "2021-10-14T20:48:39Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I think that's the right answer. It would be fine to describe it just in the process of describing a VDAF, but just to motivate the whole thing. The way I usually describe this is to just walk through what it means to be a DAF and then say \"of course you need proofs\" and then talk about the proofs. In this document  I would signal that at the beginning and then just define VDAFs.",
              "createdAt": "2021-10-14T20:48:19Z",
              "updatedAt": "2021-10-14T20:48:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 4,
      "id": "PR_kwDOGKuqOc4tcP5z",
      "title": "WIP: Define VDAF for heavy hitters",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/4",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-20T13:54:35Z",
      "updatedAt": "2021-10-25T09:29:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "fee81313bda6dde38d702c48a09bf2c2e8962c32",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "vdaf_hits",
      "headRefOid": "f319d38c96aea2e7e960fdbf2e9450f68c32c270",
      "closedAt": "2021-10-22T23:27:51Z",
      "mergedAt": "2021-10-22T23:27:51Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "97c3ad0df641cd02734908475fb2de1a5f647e1b"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "It looks like you merged at some point to deal with conflicts. While trying to rebase I gave up and just force-pushed a commit with your patch.",
          "createdAt": "2021-10-22T23:27:08Z",
          "updatedAt": "2021-10-22T23:27:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4uxeF_",
          "commit": {
            "abbreviatedOid": "ed0fa2d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Good start! I left some mostly editorial comments to start. Some high level editorial things: \r\n* `make` fails due to trailing whitespace. Make sure you can run `make` locally and that it builds successfully. (If you've never built an Internet-Draft before, let me know and I can help you get started!)\r\n* Please wrap lines at 80 characters.\r\n\r\nAs for the design:\r\n1. The purpose of the nonce is to allow the aggregators to derive fresh randomness per VDAF evaluation. This randomness could be derived by applying a PRF to the nonce using the key generated for the verification parameters.\r\n2. I'm curious why you allow the caller to specify the group parameters for each level of the tree. I would think it's better if the scheme *prescribed* these parameters. In other words, a concrete IDPF would specify the field parameters of each level of the tree.",
          "createdAt": "2021-10-20T16:19:25Z",
          "updatedAt": "2021-10-20T16:34:35Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "* Replace this reference with `[BBCGGI21, Section 4.3]`\r\n* When this gets compiled, the markdown reference won't appear in the text version. The reference should be added to the  list of informative references at the top of this file.",
              "createdAt": "2021-10-20T16:19:25Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            },
            {
              "originalPosition": 8,
              "body": "Add a newline between headings and the first line.",
              "createdAt": "2021-10-20T16:21:33Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            },
            {
              "originalPosition": 17,
              "body": "?\r\n```suggestion\r\nAn IDPF is defined over a domain of size `2**d`. The client can specify an index `alpha` and values `beta`, one for each level `l` in `[d]`. The key generation generates two IDPF keys that individually hide `alpha` and `beta`. When locally evaluated at any point `x` in `2**l` at level `l`, the IDPF returns shares of `beta[l]`, if `x` is the `l`-bit prefix of `alpha`, and shares of zero otherwise.\r\n```",
              "createdAt": "2021-10-20T16:22:27Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n- `idpf_gen(value_types: Vec[ValueType], alpha: int, beta: Vec[Value]) -> (Bytes, Bytes)`: Takes as input the value types describing the IDPF output domains, as well as the index and values for the IDPF. Returns two serialized DPF keys, one for each aggregator.\r\n```",
              "createdAt": "2021-10-20T16:23:35Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            },
            {
              "originalPosition": 21,
              "body": "Should `x` be unsigned? How about `Unsigned` as the type hint, for consistency with the section above?",
              "createdAt": "2021-10-20T16:24:28Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n### Malicious sketching for IDPFs\r\n```",
              "createdAt": "2021-10-20T16:26:36Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            },
            {
              "originalPosition": 115,
              "body": "The nonce should be used to generate a seed for the verification randomness vector `r`. For example, in prio3 we have\r\n```python\r\ndef vdaf_start(k_query_init, _, nonce, r_input_share):  \r\n  ...\r\n  k_query_rand = get_key(k_query_init, byte(255) + nonce)\r\n  ...\r\n```\r\n\r\nwhere `k_query_init` is the verification parameter.",
              "createdAt": "2021-10-20T16:29:57Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u1kkX",
          "commit": {
            "abbreviatedOid": "cdd7a84"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T14:35:44Z",
          "updatedAt": "2021-10-21T14:35:44Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I removed the second reference, since the value type implementation is not really important if we assume that the concrete scheme fixes the types for each level.",
              "createdAt": "2021-10-21T14:35:44Z",
              "updatedAt": "2021-10-21T14:35:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u1kn7",
          "commit": {
            "abbreviatedOid": "cdd7a84"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T14:35:55Z",
          "updatedAt": "2021-10-21T14:35:55Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Done.",
              "createdAt": "2021-10-21T14:35:55Z",
              "updatedAt": "2021-10-21T14:35:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u1kr_",
          "commit": {
            "abbreviatedOid": "cdd7a84"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T14:36:06Z",
          "updatedAt": "2021-10-21T14:36:07Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Done.",
              "createdAt": "2021-10-21T14:36:06Z",
              "updatedAt": "2021-10-21T14:36:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u1lIl",
          "commit": {
            "abbreviatedOid": "cdd7a84"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T14:37:25Z",
          "updatedAt": "2021-10-21T14:37:25Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Done.",
              "createdAt": "2021-10-21T14:37:25Z",
              "updatedAt": "2021-10-21T14:37:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u3TbU",
          "commit": {
            "abbreviatedOid": "02a855d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-10-21T22:19:46Z",
          "updatedAt": "2021-10-21T22:30:19Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\ndetails. An instantiation of this VDAF specifies a function `get_value_type(n: Unsigned) -> ValueType` that\r\n```",
              "createdAt": "2021-10-21T22:19:47Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nof a given group, and `Value` to refer to an actual element of the group.\r\n```",
              "createdAt": "2021-10-21T22:20:17Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 23,
              "body": "I know we're supposed to be doing everything in Python, but let's just write this as\r\n```suggestion\r\nAn IDPF is defined over a domain of size `2^d`. The client can specify an\r\n```",
              "createdAt": "2021-10-21T22:21:01Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 27,
              "body": "Would it be more accurate to say\r\n```suggestion\r\nWhen locally evaluated at any point `x` in `2**l` at level `l`, the IDPF\r\nkey returns a share of `beta[l]`, if `x` is the `l`-bit prefix of `alpha`, and\r\n```",
              "createdAt": "2021-10-21T22:22:35Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 31,
              "body": "I've been naming the output parameters. How about `-> (idpf_key1: Bytes, idpf_key2: Bytes)` or something?",
              "createdAt": "2021-10-21T22:24:05Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nkeys, one for each aggregator.\r\n```",
              "createdAt": "2021-10-21T22:24:16Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\n- `idpf_eval_next(state: State, idpf_key: Bytes, x: Unsigned) `\r\n```",
              "createdAt": "2021-10-21T22:25:07Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 44,
              "body": "Above I use \"joint rand\" to refer to randomness shared by the prover and verifier for PCPs. Can we call this something else, like \"verify_rand\"?",
              "createdAt": "2021-10-21T22:26:55Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 44,
              "body": "Here and elsewhere\r\n```suggestion\r\n  r = expand_rand(joint_randomness, len(idpf_output), level)\r\n```",
              "createdAt": "2021-10-21T22:27:10Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 47,
              "body": "Here and below\r\n```suggestion\r\n    [value[0] for value in dpf_output,\r\n```",
              "createdAt": "2021-10-21T22:28:01Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 133,
              "body": "I'm having a hard time understanding what's going on here. It seeems like you want the IDPF api to be stateful, but the VDAF api is not. So how does the state of the IPDF get passed through to subsequent VDAF evaluations?\r\n\r\nUnless I'm misunderstanding, I think the answer is that, at least as far as this spec is concerned, the IDPF api needs to be stateless. ",
              "createdAt": "2021-10-21T22:30:13Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u42C9",
          "commit": {
            "abbreviatedOid": "dda25de"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T09:56:12Z",
          "updatedAt": "2021-10-22T09:56:12Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Not sure I understand the statefull / stateless distinction here.\r\nIn the [input evaluation](https://github.com/cjpatton/vdaf/blob/main/draft-patton-cfrg-vdaf.md#input-evaluation) section, it seems like there is an `EvalState` that is kept between the communication rounds between the aggregators. Wouldn't this state also be able to contain the partially evaluated IDPF state? The IDPF-based heavy hitter protocol needs to keep some sort of state between rounds. We could of course emulate that by sending the state back and forth encrypted, but I think that would unnecessarily limit implementations who might want to keep state locally.",
              "createdAt": "2021-10-22T09:56:12Z",
              "updatedAt": "2021-10-22T09:56:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u5Rbs",
          "commit": {
            "abbreviatedOid": "dda25de"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T12:08:41Z",
          "updatedAt": "2021-10-22T12:08:41Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Done.",
              "createdAt": "2021-10-22T12:08:41Z",
              "updatedAt": "2021-10-22T12:08:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u5Rn0",
          "commit": {
            "abbreviatedOid": "dda25de"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T12:09:31Z",
          "updatedAt": "2021-10-22T12:09:31Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Done.",
              "createdAt": "2021-10-22T12:09:31Z",
              "updatedAt": "2021-10-22T12:09:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u5SSE",
          "commit": {
            "abbreviatedOid": "dda25de"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T12:12:40Z",
          "updatedAt": "2021-10-22T12:12:40Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Done.",
              "createdAt": "2021-10-22T12:12:40Z",
              "updatedAt": "2021-10-22T12:12:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u5STf",
          "commit": {
            "abbreviatedOid": "dda25de"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T12:12:47Z",
          "updatedAt": "2021-10-22T12:12:47Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Done.",
              "createdAt": "2021-10-22T12:12:47Z",
              "updatedAt": "2021-10-22T12:12:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u7ah-",
          "commit": {
            "abbreviatedOid": "f319d38"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Merging as-is and will iterate on it over the weekend.",
          "createdAt": "2021-10-22T23:27:43Z",
          "updatedAt": "2021-10-22T23:27:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOGKuqOc4tnd68",
      "title": "Finish `hits` specification",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/5",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-25T10:33:46Z",
      "updatedAt": "2021-10-25T15:56:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "a17f7917cbf554c3c50464252c371286561a9040",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "vdaf_hits",
      "headRefOid": "76f086eddda2feba75558d41c381991d873fe17e",
      "closedAt": "2021-10-25T15:55:00Z",
      "mergedAt": "2021-10-25T15:55:00Z",
      "mergedBy": "schoppmp",
      "mergeCommit": {
        "oid": "4ab9d62399dc4b879f592af05cf16c37c0f4eed2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4u-t8t",
          "commit": {
            "abbreviatedOid": "5e545b3"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:21:21Z",
          "updatedAt": "2021-10-25T14:32:08Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "No, each aggregator is mean to consume all of the messages sent in the previous round.",
              "createdAt": "2021-10-25T14:21:21Z",
              "updatedAt": "2021-10-25T14:32:08Z"
            },
            {
              "originalPosition": 38,
              "body": "Ack, let's delete my comment then.",
              "createdAt": "2021-10-25T14:22:29Z",
              "updatedAt": "2021-10-25T14:32:08Z"
            },
            {
              "originalPosition": 49,
              "body": "The first is used by the first aggregator and the second is used by the second.",
              "createdAt": "2021-10-25T14:22:57Z",
              "updatedAt": "2021-10-25T14:32:08Z"
            },
            {
              "originalPosition": 61,
              "body": "It does. I went back-and-forth on this and ultimately thought that this is simpler. The reason is that this loop in `run_vdaf` \r\n```\r\n# Aggregators recover their output shares.\r\ninbound = []\r\nfor i in range(ROUNDS+1):\r\n  outbound = []\r\n  for j in range(SHARES):\r\n    outbound.append(eval_states[j].next(inbound))\r\n  inbound = outbound\r\n```\r\n\r\nwould have to be something like\r\n```\r\n# Aggregators recover their output shares.\r\ninbound = []\r\nfor i in range(ROUNDS+1):\r\n  outbound = []\r\n  for j in range(SHARES):\r\n    inbound_for_aggregator = []\r\n    for (k, v) in enumerate(inbound):\r\n      if k != j: inbound_for_aggregator.append(v)\r\n    outbound.append(eval_states[j].next(inbound))\r\n  inbound = outbound\r\n```",
              "createdAt": "2021-10-25T14:30:29Z",
              "updatedAt": "2021-10-25T14:32:08Z"
            },
            {
              "originalPosition": 76,
              "body": "I don't think so, and good catch here. What about passing the aggregation parameter into the constructor here and computing the number of prefixes from that? We'd need to make the same change in the VDAF definition section.",
              "createdAt": "2021-10-25T14:32:00Z",
              "updatedAt": "2021-10-25T14:32:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-46g",
          "commit": {
            "abbreviatedOid": "5e545b3"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:53:21Z",
          "updatedAt": "2021-10-25T14:53:22Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Changed the definition here.",
              "createdAt": "2021-10-25T14:53:22Z",
              "updatedAt": "2021-10-25T14:53:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-48u",
          "commit": {
            "abbreviatedOid": "f9fdc26"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:53:27Z",
          "updatedAt": "2021-10-25T14:53:28Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Okay, removed my comment.",
              "createdAt": "2021-10-25T14:53:27Z",
              "updatedAt": "2021-10-25T14:53:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-4-3",
          "commit": {
            "abbreviatedOid": "f9fdc26"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:53:33Z",
          "updatedAt": "2021-10-25T14:53:33Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Ack. Removed the comment.",
              "createdAt": "2021-10-25T14:53:33Z",
              "updatedAt": "2021-10-25T14:53:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-5A2",
          "commit": {
            "abbreviatedOid": "f9fdc26"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:53:38Z",
          "updatedAt": "2021-10-25T14:53:39Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Done.",
              "createdAt": "2021-10-25T14:53:38Z",
              "updatedAt": "2021-10-25T14:53:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-5Kx",
          "commit": {
            "abbreviatedOid": "f9fdc26"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:54:07Z",
          "updatedAt": "2021-10-25T14:54:07Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Ack. Removed comment.",
              "createdAt": "2021-10-25T14:54:07Z",
              "updatedAt": "2021-10-25T14:54:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-6P9",
          "commit": {
            "abbreviatedOid": "962a327"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:57:18Z",
          "updatedAt": "2021-10-25T14:57:41Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "As we (ideally!) make clear in the Overview/Definition sections, this document doesn't tell you how to execute the protocol over a network. This function in particular only tells you how you put the pieces together to execute the VDAF over a set of inputs.\r\n\r\nTo make an analogy: VDAF is, in this sense, like an encryption scheme. It doesn't tell *how* to encrypt packets that you send over the network, it just describes a function and its intended properties. ",
              "createdAt": "2021-10-25T14:57:18Z",
              "updatedAt": "2021-10-25T14:57:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-70M",
          "commit": {
            "abbreviatedOid": "962a327"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T15:01:52Z",
          "updatedAt": "2021-10-25T15:11:55Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "I found this necessary when I did my implemnetation. The reason is that the `verifier_share` is supposed to be a 2-way additive share.",
              "createdAt": "2021-10-25T15:01:52Z",
              "updatedAt": "2021-10-25T15:11:55Z"
            },
            {
              "originalPosition": 47,
              "body": "Resolution: have one party add the first term.",
              "createdAt": "2021-10-25T15:11:52Z",
              "updatedAt": "2021-10-25T15:11:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u_IWT",
          "commit": {
            "abbreviatedOid": "1f0adbf"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T15:41:52Z",
          "updatedAt": "2021-10-25T15:41:52Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Okay. Changed the comment to clarify where the network communication would take place.",
              "createdAt": "2021-10-25T15:41:52Z",
              "updatedAt": "2021-10-25T15:41:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u_IZK",
          "commit": {
            "abbreviatedOid": "1f0adbf"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T15:42:01Z",
          "updatedAt": "2021-10-25T15:42:02Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Done.",
              "createdAt": "2021-10-25T15:42:02Z",
              "updatedAt": "2021-10-25T15:42:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u_Js9",
          "commit": {
            "abbreviatedOid": "1f0adbf"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-25T15:46:32Z",
          "updatedAt": "2021-10-25T15:46:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOGKuqOc4toxx7",
      "title": "Update authors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/6",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-25T16:57:11Z",
      "updatedAt": "2022-05-26T14:58:04Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "8d6bc15ea63c534a8398985fbacaf7acc1aad9a9",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "update_authors",
      "headRefOid": "a3e13b02617094cee91ba6a8ef9e3d13724a6ffe",
      "closedAt": "2021-10-25T17:00:39Z",
      "mergedAt": "2021-10-25T17:00:39Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "ee05d18c5cd217354acfa713e0fec79aeec61330"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4u_dkr",
          "commit": {
            "abbreviatedOid": "a3e13b0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-25T17:00:29Z",
          "updatedAt": "2021-10-25T17:00:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 7,
      "id": "PR_kwDOGKuqOc4tpN7W",
      "title": "RLB refactor of vdaf",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/7",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-25T19:35:28Z",
      "updatedAt": "2022-05-26T14:58:04Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d8059ea57a2d09fbd21842dd297c735584c35887",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "vdaf-refactor",
      "headRefOid": "a96d3c3b163c955abeb56671fc8f1c8ca3aa239f",
      "closedAt": "2021-10-25T20:54:52Z",
      "mergedAt": "2021-10-25T20:54:52Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "29a8ff25572bd9fc4ba400100c1e58332b6e32b3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4vACJz",
          "commit": {
            "abbreviatedOid": "94b96e1"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-25T19:40:51Z",
          "updatedAt": "2021-10-25T20:52:38Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Caption needs updating.",
              "createdAt": "2021-10-25T19:40:51Z",
              "updatedAt": "2021-10-25T20:52:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4vAjVp",
          "commit": {
            "abbreviatedOid": "a96d3c3"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T22:23:01Z",
          "updatedAt": "2021-10-25T22:26:37Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I don't love this term. Maybe \"Decoding\"?",
              "createdAt": "2021-10-25T22:23:02Z",
              "updatedAt": "2021-10-25T22:26:37Z"
            },
            {
              "originalPosition": 50,
              "body": "Do we need to assume it's randomized?",
              "createdAt": "2021-10-25T22:24:15Z",
              "updatedAt": "2021-10-25T22:26:37Z"
            },
            {
              "originalPosition": 56,
              "body": "Is this always true? Suppose we had a VDAF in which the ZKPs of correctness were publicly verifiable?",
              "createdAt": "2021-10-25T22:25:16Z",
              "updatedAt": "2021-10-25T22:26:37Z"
            },
            {
              "originalPosition": 90,
              "body": "This seems like an unnecessary assumption. It might be true, but it might not be.",
              "createdAt": "2021-10-25T22:26:06Z",
              "updatedAt": "2021-10-25T22:26:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOGKuqOc4wWGea",
      "title": "Add public preprocessing of messages",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/14",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #11.\r\n\r\nThis makes explicit a feature of prio3 and hits that allows applications\r\nto save on bandwidth. At the same time, it does not decrease generality\r\nsince this preprocessing step might simply be a no-op.\r\n\r\nThis change also replaces reference to `vec_zeros()` with\r\n`Field.zeros()`.\r\n",
      "createdAt": "2021-12-28T18:47:12Z",
      "updatedAt": "2022-02-08T16:52:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "71f9481b446f191da17118fd4b82b1a8cf9aa6fd",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/issue11",
      "headRefOid": "bd8b7a4a80336d15980164b1afe731c17bc1f3a2",
      "closedAt": "2022-01-19T17:44:44Z",
      "mergedAt": "2022-01-19T17:44:43Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "6b856956b14b89d70e22ed8fd3655f9521720b14"
      },
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It seems like this PR is just splitting `next` into two steps that both happen inside the same computer. Why is this useful?\r\n> \r\n> In general, I think the design philosophy should be that the inputs and outputs from these abstract functions should be to the network, i.e., the boundaries that matter are the ones that are visible from the outside. How the processing is arranged inside the computer, between network-observable points, is up to the individual implementation.\r\n\r\nThe idea is that the leader can do the `prep_preprocess` step once and broadcast the result to however many helpers there are, whereas previously, every aggregator would have had to broadcast prep messages to every other aggregator (extra network communication) and then every aggregator would have to run the prep message assembly (extra CPU time). The reduction in network communication is a much more significant win than the reduction of redundant work, but the it's hard to see that communication graph in this specification, because it's all abstracted away behind the `inputs = outputs` step, which in a real deployment would be a big, messy graph with `n^2` edges in it.",
          "createdAt": "2022-01-06T18:40:17Z",
          "updatedAt": "2022-01-06T18:40:17Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "With the current syntax:  In a Leader/Helper communication model, the Leader would request each Helper's next prepare message in one round, then broadcast the entire round of messages to each Helper in the next round.\r\n\r\nWith the changed syntax: Instead of broadcasting all of the messages, the Leader can perform this precomputation step, which for both `prio3` and `poplar1` reduces the amount of data broadcast by a factor of `SHARES`.",
          "createdAt": "2022-01-06T22:28:39Z",
          "updatedAt": "2022-01-06T22:28:39Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to make an executive decision and merge this by Wednesday, 2022/01/19 unless anyone flags objections to this change. ",
          "createdAt": "2022-01-15T00:27:00Z",
          "updatedAt": "2022-01-15T00:27:00Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm OK with this, as long as we agree that the degenerate case where `prep_shares_to_prep` just concatenates the shares is in-bounds (which puts us back in the broadcast posture).",
          "createdAt": "2022-01-18T22:03:51Z",
          "updatedAt": "2022-01-18T22:04:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm OK with this, as long as we agree that the degenerate case where `prep_shares_to_prep` just concatenates the shares is in-bounds (which puts us back in the broadcast posture).\r\n\r\nYeah I agree. It would be premature to rule this out.",
          "createdAt": "2022-01-19T00:29:16Z",
          "updatedAt": "2022-01-19T00:29:16Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Squashed. Thanks all for your feedback!",
          "createdAt": "2022-01-19T17:44:29Z",
          "updatedAt": "2022-01-19T17:44:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4yIVrb",
          "commit": {
            "abbreviatedOid": "cc28349"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-28T18:48:16Z",
          "updatedAt": "2021-12-28T18:48:16Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Can we think of a better verb than \"preprocess\"? While accurate, it seems too generic.",
              "createdAt": "2021-12-28T18:48:16Z",
              "updatedAt": "2021-12-28T18:48:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yT1lW",
          "commit": {
            "abbreviatedOid": "aa4ebef"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-04T22:25:32Z",
          "updatedAt": "2022-01-05T01:48:26Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Should this be `Optional[Vec[Bytes]]` or is `Bytes` itself a vector of bytes? ",
              "createdAt": "2022-01-04T22:25:32Z",
              "updatedAt": "2022-01-05T01:48:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yUNLA",
          "commit": {
            "abbreviatedOid": "aa4ebef"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-05T02:05:32Z",
          "updatedAt": "2022-01-05T02:05:32Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "`Bytes` is itself a vector of bytes.",
              "createdAt": "2022-01-05T02:05:32Z",
              "updatedAt": "2022-01-05T02:05:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yZl0N",
          "commit": {
            "abbreviatedOid": "aa4ebef"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-06T12:16:36Z",
          "updatedAt": "2022-01-06T12:19:04Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Can you elaborate a bit what the `prep_preprocess` step does and in what cases it is useful? This doesn't become clear from the description currently.",
              "createdAt": "2022-01-06T12:16:36Z",
              "updatedAt": "2022-01-06T12:19:04Z"
            },
            {
              "originalPosition": 29,
              "body": "I agree, in particular the double `pre` prefix is a bit confusing. Maybe `combine_verifier_shares` or something like that?",
              "createdAt": "2022-01-06T12:18:49Z",
              "updatedAt": "2022-01-06T12:19:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4ya-93",
          "commit": {
            "abbreviatedOid": "aa4ebef"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "It seems like this PR is just splitting `next` into two steps that both happen inside the same computer.  Why is this useful?\r\n\r\nIn general, I think the design philosophy should be that the inputs and outputs from these abstract functions should be to the network, i.e., the boundaries that matter are the ones that are visible from the outside.  How the processing is arranged inside the computer, between network-observable points, is up to the individual implementation.",
          "createdAt": "2022-01-06T18:33:55Z",
          "updatedAt": "2022-01-06T18:33:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc4yb1Kk",
          "commit": {
            "abbreviatedOid": "5b0720b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-06T23:18:57Z",
          "updatedAt": "2022-01-06T23:18:58Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I like the term `verifier_share`, but it's somewhat specific to schemes like `prio3` and `poplar1` where the output share are first recovered and then verified. At this stage I'd like to leave the door open for things like Prio+ that are based instead on oblivious transfer. (Output shares aren't known until the prep phase is complete.)",
              "createdAt": "2022-01-06T23:18:58Z",
              "updatedAt": "2022-01-06T23:18:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yb1Xm",
          "commit": {
            "abbreviatedOid": "5b0720b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-06T23:20:42Z",
          "updatedAt": "2022-01-06T23:20:42Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I went with \"prepare-message share\", which is overly wordy but says what we want. The method is now called `prep_share_to_prep`, which is somewhat consistent with our naming conventions else where. \r\n\r\nOther suggestions for alternatives are welcome! (Naming things is hard.) ",
              "createdAt": "2022-01-06T23:20:42Z",
              "updatedAt": "2022-01-06T23:20:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yb1ZF",
          "commit": {
            "abbreviatedOid": "5b0720b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-06T23:20:55Z",
          "updatedAt": "2022-01-06T23:20:55Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I've tacked on a commit that will hopefully make this more clear.",
              "createdAt": "2022-01-06T23:20:55Z",
              "updatedAt": "2022-01-06T23:20:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4y7LBX",
          "commit": {
            "abbreviatedOid": "176ab24"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-17T13:05:33Z",
          "updatedAt": "2022-01-17T13:09:35Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "`transffer` -> `transfer`",
              "createdAt": "2022-01-17T13:05:34Z",
              "updatedAt": "2022-01-17T13:09:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4zAkR7",
          "commit": {
            "abbreviatedOid": "6de0c44"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-18T17:57:39Z",
          "updatedAt": "2022-01-18T17:57:39Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "Done",
              "createdAt": "2022-01-18T17:57:39Z",
              "updatedAt": "2022-01-18T17:57:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOGKuqOc4wiAdr",
      "title": "Rename \"Heavy Hitters\" to \"Poplar\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/16",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The authors of [BBCGGI21] have recently amended their paper to give the\r\nprotocol a proper name.",
      "createdAt": "2022-01-04T21:41:01Z",
      "updatedAt": "2022-02-08T16:52:26Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "84e7b02d3474c2a6fcf79de1c79abacec4d0303f",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/poplar",
      "headRefOid": "5b961d3a0192626bfc66a2ef97b24bb054283cf9",
      "closedAt": "2022-01-06T18:31:40Z",
      "mergedAt": "2022-01-06T18:31:40Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "082a2ed7e5090d2258be98039d51b10f7532900c"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "s/pops/poplar1",
          "createdAt": "2022-01-06T18:31:15Z",
          "updatedAt": "2022-01-06T18:31:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4yTwIQ",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-04T21:51:28Z",
          "updatedAt": "2022-01-04T21:51:52Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I would just call this `poplar`, since we just use `prio` for Prio.",
              "createdAt": "2022-01-04T21:51:28Z",
              "updatedAt": "2022-01-04T21:51:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yTwgh",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-04T21:53:40Z",
          "updatedAt": "2022-01-04T21:53:40Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "In fact we use `prio3` for Prio, so it's not even like there's a 4-letter code convention.",
              "createdAt": "2022-01-04T21:53:40Z",
              "updatedAt": "2022-01-04T21:53:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yTwnd",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-04T21:54:18Z",
          "updatedAt": "2022-01-04T21:54:19Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "It's tricky because the full-blown heavy hitters protocol is called \"Poplar\". I wanted a distinct name for the underlying VDAF. \"pops\" is the name that @henrycg and I discussed over email.",
              "createdAt": "2022-01-04T21:54:18Z",
              "updatedAt": "2022-01-04T21:54:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yTxF9",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-04T21:57:09Z",
          "updatedAt": "2022-01-04T21:57:09Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "We could go with something more verbose, like \"poplar-vdaf\".",
              "createdAt": "2022-01-04T21:57:09Z",
              "updatedAt": "2022-01-04T21:57:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yT4NJ",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-04T22:41:38Z",
          "updatedAt": "2022-01-04T22:41:38Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I prefer `poplar` but I'm happy to defer to you as the author here.",
              "createdAt": "2022-01-04T22:41:38Z",
              "updatedAt": "2022-01-04T22:41:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yT4OR",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-04T22:41:46Z",
          "updatedAt": "2022-01-04T22:41:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc4yT7nH",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-04T23:07:14Z",
          "updatedAt": "2022-01-04T23:07:14Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I'd like to give folks a chance to mull on it, so we''ll keep this open for now.",
              "createdAt": "2022-01-04T23:07:14Z",
              "updatedAt": "2022-01-04T23:07:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yZnxO",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-06T12:27:42Z",
          "updatedAt": "2022-01-06T12:28:54Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I'm not sure about `pops`, at first it looks like it's an acronym, but it isn't. I don't think using `poplar` for both the end-to-end protocol and the VDAF is too much of an issue. Or @cjpatton do you think there will be instantiations of poplar-the-protocol that use a different VDAF? And in that case, couldn't that VDAF be called `poplar2` (the same way the current Prio VDAF is `prio3`?\r\nAlternatively, I think using `poplar-vdaf` (and also changing `prio3` to `prio3-vdaf` or just `prio-vdaf`) is also fine.",
              "createdAt": "2022-01-06T12:27:42Z",
              "updatedAt": "2022-01-06T12:28:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4ya-PU",
          "commit": {
            "abbreviatedOid": "5b961d3"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-06T18:30:28Z",
          "updatedAt": "2022-01-06T18:30:28Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Cool, one more point of agreement :) As discussed in https://github.com/abetterinternet/ppm-specification/pull/177#discussion_r778413433 we're going with `poplar1`, for the same reason you point out.",
              "createdAt": "2022-01-06T18:30:28Z",
              "updatedAt": "2022-01-06T18:30:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOGKuqOc4wiH08",
      "title": "fix typos",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/17",
      "state": "MERGED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix typos encountered while reviewing #14",
      "createdAt": "2022-01-04T22:40:50Z",
      "updatedAt": "2022-01-04T23:03:23Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "2c85aaa13d93b9105bb4139ce501aa9f6dcbdd1b",
      "headRepository": "tgeoghegan/vdaf",
      "headRefName": "typo",
      "headRefOid": "c269414d533f4a20f91d6aca9f25a482e79eacae",
      "closedAt": "2022-01-04T23:03:23Z",
      "mergedAt": "2022-01-04T23:03:23Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "84e7b02d3474c2a6fcf79de1c79abacec4d0303f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4yT7If",
          "commit": {
            "abbreviatedOid": "c269414"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-04T23:03:16Z",
          "updatedAt": "2022-01-04T23:03:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOGKuqOc4x1Ntz",
      "title": "Make re-generation of `verify_params` RECOMMENDED",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/21",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in #18, generating `verify_params` in advance may allow an adversary to break correctness if they can corrupt an aggregation server (passively) and a client (actively). This change recommends generating `verify_params` only after a set of client shares has been fixed.",
      "createdAt": "2022-01-31T11:28:30Z",
      "updatedAt": "2022-05-26T14:58:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "6b856956b14b89d70e22ed8fd3655f9521720b14",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "regenerate_verify_params",
      "headRefOid": "1f0e87e6161fe5aa02f7945627ae06affc2982f8",
      "closedAt": "2022-02-04T15:22:50Z",
      "mergedAt": "2022-02-04T15:22:49Z",
      "mergedBy": "schoppmp",
      "mergeCommit": {
        "oid": "0412bc0b85f6f35bc510543840ba1a54aa9bfb35"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4zwKNl",
          "commit": {
            "abbreviatedOid": "d29f39c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-31T18:32:32Z",
          "updatedAt": "2022-01-31T18:32:37Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I'd prefer this text to be in security considerations, along with a short explanation of the threat model being considered.",
              "createdAt": "2022-01-31T18:32:33Z",
              "updatedAt": "2022-01-31T18:32:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4z6ess",
          "commit": {
            "abbreviatedOid": "1f0e87e"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T18:42:35Z",
          "updatedAt": "2022-02-02T18:42:35Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Done.",
              "createdAt": "2022-02-02T18:42:35Z",
              "updatedAt": "2022-02-02T18:42:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4z_lBN",
          "commit": {
            "abbreviatedOid": "1f0e87e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Perfect, thanks!",
          "createdAt": "2022-02-03T19:17:14Z",
          "updatedAt": "2022-02-03T19:17:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDOGKuqOc4x_qJm",
      "title": "prio3 reference implementation (part 1)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/23",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-02T22:54:17Z",
      "updatedAt": "2022-02-03T02:30:38Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "6b856956b14b89d70e22ed8fd3655f9521720b14",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/prio3-wrapper",
      "headRefOid": "1bc6e937680767f7aa7075ac389c624c1899ecd5",
      "closedAt": "2022-02-03T02:30:38Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 24,
      "id": "PR_kwDOGKuqOc4yAQaA",
      "title": "poc: Wrapper bits for prio3",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/24",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-03T04:55:32Z",
      "updatedAt": "2022-02-08T22:16:46Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "5da19ba913c82e3b8c9a4d0cdeaa5fcf6309f778",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/prio3-wrapper",
      "headRefOid": "6d2f6fa590e0ecabaf9825f3aa6f4f086714c9c3",
      "closedAt": "2022-02-08T22:16:39Z",
      "mergedAt": "2022-02-08T22:16:39Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "181607612619efcab9115c5572ec523d364f0a5b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 25,
      "id": "PR_kwDOGKuqOc4yNMJN",
      "title": "Specify a method for deriving pseudorandom field elements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/25",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #13.",
      "createdAt": "2022-02-08T01:15:41Z",
      "updatedAt": "2022-08-26T18:33:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d5baf89e87695569f4dbf8d79d9e008fcfc9e79c",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/prg",
      "headRefOid": "24998534b894de7a5aeca6bd7764a81608384225",
      "closedAt": "2022-02-14T20:28:15Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Re-opening this PR with a new base.",
          "createdAt": "2022-02-14T20:28:15Z",
          "updatedAt": "2022-02-14T20:28:15Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 26,
      "id": "PR_kwDOGKuqOc4yRjBk",
      "title": "prio3: Don't generate joint randomness if JOINT_RAND_LEN == 0",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/26",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #15.",
      "createdAt": "2022-02-09T03:58:04Z",
      "updatedAt": "2022-02-09T04:35:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "0ed776f687b2592820af150416a30ed16dbab7da",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/joint-rand-len",
      "headRefOid": "94a9986bc29be2455f998dd60eec9091186fbf03",
      "closedAt": "2022-02-09T04:35:39Z",
      "mergedAt": "2022-02-09T04:35:39Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "5de2062ac1f1524a9ce8e23c08a24938c5f32fc1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 27,
      "id": "PR_kwDOGKuqOc4ydh-y",
      "title": "prio3: Specify the generic FLP",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/27",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Specification of the \"generic FLP\", an extension of Theorem 4.3 from [BBCGGI19]. This proof system is implemented by https://github.com/abetterinternet/libprio-rs/blob/main/src/pcp.rs.\r\n\r\n2022/2/10: This PR is marked as \"draft\" for now, as it'll need a few more clean-up passes before it's ready to merge. I wanted to have something up early so @chris-wood has something to work off of for the reference implementation.\r\n2022/23/14: Ready to merge.",
      "createdAt": "2022-02-11T02:25:06Z",
      "updatedAt": "2022-08-26T18:33:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d8cf35917ab6556cc5e7514a05569136fad23d1e",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/flp",
      "headRefOid": "bea5fd53554b10103a8ec92e4ebe1b820d6dd41c",
      "closedAt": "2022-02-25T19:40:13Z",
      "mergedAt": "2022-02-25T19:40:13Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "58d3bf725cbf33c83667f14f1d83746bbaf13fab"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc40_UD0",
          "commit": {
            "abbreviatedOid": "4b80527"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-21T18:38:43Z",
          "updatedAt": "2022-02-25T17:40:54Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Is this really a requirement, or simply something that's nice to have?",
              "createdAt": "2022-02-21T18:38:43Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            },
            {
              "originalPosition": 129,
              "body": "```suggestion\r\nover the input. For VDAFs, this computation is distributed amongst multiple Aggregators, \r\neach of which has only a share of the input.\r\n```",
              "createdAt": "2022-02-21T18:42:49Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            },
            {
              "originalPosition": 191,
              "body": "I'd hint at how these are fixed (for FFT friendliness) somehow.",
              "createdAt": "2022-02-21T18:57:55Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            },
            {
              "originalPosition": 282,
              "body": "I wouldn't use the term arity in this document, even if it's technically correct. I would use something simpler, i.e., the gadgets input counts. ",
              "createdAt": "2022-02-21T19:07:59Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            },
            {
              "originalPosition": 358,
              "body": "```suggestion\r\n1. For each `G` in `Valid.GADGETS` create an empty table `wire_i`.\r\n```",
              "createdAt": "2022-02-21T19:32:15Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            },
            {
              "originalPosition": 331,
              "body": "```suggestion\r\n* For each `i` in `len(Valid.GADGETS)`:\r\n```",
              "createdAt": "2022-02-21T19:35:10Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            },
            {
              "originalPosition": 336,
              "body": "```suggestion\r\n    * Let `alpha_i = Field.gen()^(Field.GEN_ORDER / P_i)`\r\n```",
              "createdAt": "2022-02-21T19:35:20Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41Sivj",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:00:54Z",
          "updatedAt": "2022-02-25T19:00:55Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "As noted here, this is required for the generic FLP construction, in particular because it uses the group generator to pick the points used to construct the gadget polynomials. It would be possible to pick these points differently, but that would be a different construction.\r\n\r\nAnother option is to make these fixed points a parameter. I see no reason to do this, however.",
              "createdAt": "2022-02-25T19:00:55Z",
              "updatedAt": "2022-02-25T19:00:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41SjHt",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:02:17Z",
          "updatedAt": "2022-02-25T19:02:17Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "Done",
              "createdAt": "2022-02-25T19:02:17Z",
              "updatedAt": "2022-02-25T19:02:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41Sj78",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:06:06Z",
          "updatedAt": "2022-02-25T19:06:06Z",
          "comments": [
            {
              "originalPosition": 191,
              "body": "Done",
              "createdAt": "2022-02-25T19:06:06Z",
              "updatedAt": "2022-02-25T19:06:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41Sj_a",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:06:22Z",
          "updatedAt": "2022-02-25T19:06:23Z",
          "comments": [
            {
              "originalPosition": 282,
              "body": "Ack",
              "createdAt": "2022-02-25T19:06:23Z",
              "updatedAt": "2022-02-25T19:06:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41SkBt",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:06:31Z",
          "updatedAt": "2022-02-25T19:06:31Z",
          "comments": [
            {
              "originalPosition": 358,
              "body": "Ack",
              "createdAt": "2022-02-25T19:06:31Z",
              "updatedAt": "2022-02-25T19:06:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41SkDe",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:06:39Z",
          "updatedAt": "2022-02-25T19:06:39Z",
          "comments": [
            {
              "originalPosition": 331,
              "body": "Ack",
              "createdAt": "2022-02-25T19:06:39Z",
              "updatedAt": "2022-02-25T19:06:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41SkFo",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:06:48Z",
          "updatedAt": "2022-02-25T19:06:48Z",
          "comments": [
            {
              "originalPosition": 336,
              "body": "Done",
              "createdAt": "2022-02-25T19:06:48Z",
              "updatedAt": "2022-02-25T19:06:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 28,
      "id": "PR_kwDOGKuqOc4y0Ao1",
      "title": "Specify an instantiation of `Prg`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/28",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Specifies a construction based on AES128. While pretty straight-forward,\r\nthis scheme uses CMAC, which is not widely used. We may want to provide\r\nadditional options in the future.",
      "createdAt": "2022-02-14T20:33:31Z",
      "updatedAt": "2022-05-26T14:58:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "582c3a58e8c9a8c6c9fb1763b52ed4de98b3d248",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/prg-constructions",
      "headRefOid": "33d5930607a3853cb701e768314ec7f27fda2e76",
      "closedAt": "2022-02-28T16:07:42Z",
      "mergedAt": "2022-02-28T16:07:42Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "5b832679851002485c004c461948491837624102"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> This will likely be called often, but with small `length`s, right? In that case I believe constructions based on [fixed-key AES hashing](https://eprint.iacr.org/2019/074.pdf) should be more efficient, since they avoid repeating the AES key schedule. In the paper there is a tweakable version (using two AES calls) that can be used to derive new seeds for different `info` strings.\r\n\r\nGreat question. There are two key schedules:\r\n* One for CMAC. The same key is used for each blockcipher call, including for generating the subkey K1 (or K2, depending on the length of the message.) See https://datatracker.ietf.org/doc/html/rfc4493#section-2.2.\r\n* One for CTR.\r\n\r\nEventually the cumulative cost of AES costs will outstrip the cost of the initial setup of these two key schedules, so the question is whether we reach this point in our code. There are at least two cases to consider: \r\n1. In #31, each `length` passed to `prg.next()` is small, but we call `prg.next()` many times. Hence the computational cost will be dominated in `AES128-CTR()`.\r\n2. In prio3, we use `Prg.derive()` as a PRF. Here the input is long (though not as long as in (1.)), but the output is short. Hence the computational cost will be dominated by `AES128-CMAC()`.\r\n\r\nMy hunch is that we cross this threshold fairly quickly for (1.), but I'm not so sure about (2.). I think this is something worth benchmarking in any case.\r\n\r\nI suggest we put a pin in this for now. I'll mark this is an \"OPEN ISSUE\" in the text and we can open an issue for tracking benchmarking of various PRGs.\r\n\r\n\r\n",
          "createdAt": "2022-02-25T19:38:12Z",
          "updatedAt": "2022-02-25T19:38:12Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I've added a pointer to https://github.com/cjpatton/vdaf/issues/32 to the text.",
          "createdAt": "2022-02-25T19:50:52Z",
          "updatedAt": "2022-02-25T19:50:52Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> I suggest we put a pin in this for now. I'll mark this is an \"OPEN ISSUE\" in the text and we can open an issue for tracking benchmarking of various PRGs.\r\n\r\nSounds good, thanks!",
          "createdAt": "2022-02-28T11:33:20Z",
          "updatedAt": "2022-02-28T11:33:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc40lRkI",
          "commit": {
            "abbreviatedOid": "7b4e1f9"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T21:05:30Z",
          "updatedAt": "2022-02-14T21:07:15Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\ngenerating the output. A fixed initialization vector (IV) is used.\r\n```",
              "createdAt": "2022-02-14T21:05:30Z",
              "updatedAt": "2022-02-14T21:07:15Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n    # a fixed, all-zero IV.\r\n```",
              "createdAt": "2022-02-14T21:05:55Z",
              "updatedAt": "2022-02-14T21:07:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41SkO8",
          "commit": {
            "abbreviatedOid": "9c80897"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This will likely be called often, but with small `length`s, right? In that case I believe constructions based on [fixed-key AES hashing](https://eprint.iacr.org/2019/074.pdf) should be more efficient, since they avoid repeating the AES key schedule. In the paper there is a tweakable version (using two AES calls) that can be used to derive new seeds for different `info` strings.",
          "createdAt": "2022-02-25T19:07:29Z",
          "updatedAt": "2022-02-25T19:07:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc41WDWq",
          "commit": {
            "abbreviatedOid": "33d5930"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-28T11:33:30Z",
          "updatedAt": "2022-02-28T11:33:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 29,
      "id": "PR_kwDOGKuqOc4y0B4C",
      "title": "Use \"pad-then-reduce\" method for generating field elements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/29",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #13 by taking @armfazh' suggestion.\r\n\r\nSpecifies an algorithm for mapping a pseudorandom byte string to a\r\nvector of field elements. This method is based on the \"hash_to_field\"\r\nalgorithm from draft-irtf-cfrg-hash-to-curve-13.",
      "createdAt": "2022-02-14T20:39:05Z",
      "updatedAt": "2022-08-26T18:33:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d8cf35917ab6556cc5e7514a05569136fad23d1e",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/field-elem-gen-1",
      "headRefOid": "159d7a217560682d1a2c249fe5c89b555014dfeb",
      "closedAt": "2022-02-25T16:13:08Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed in favor of #31.\r\n",
          "createdAt": "2022-02-25T16:13:08Z",
          "updatedAt": "2022-02-25T16:13:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc40lUK4",
          "commit": {
            "abbreviatedOid": "6cdf917"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T21:17:14Z",
          "updatedAt": "2022-02-14T21:18:13Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "... The second one generates a sequence of field elements from a pseudorandom byte string. Such a generation is based on ...",
              "createdAt": "2022-02-14T21:17:14Z",
              "updatedAt": "2022-02-14T21:18:13Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n  per field element when expanding a seed into a sequence of field elements\r\n```",
              "createdAt": "2022-02-14T21:17:40Z",
              "updatedAt": "2022-02-14T21:18:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc40lWor",
          "commit": {
            "abbreviatedOid": "6cdf917"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T21:28:10Z",
          "updatedAt": "2022-02-14T21:28:11Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Done",
              "createdAt": "2022-02-14T21:28:10Z",
              "updatedAt": "2022-02-14T21:28:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 30,
      "id": "PR_kwDOGKuqOc4y0PEW",
      "title": "Use \"borrow-then-reduce\" method for generating field elements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/30",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #13 by taking @schoppmp's suggestion.\r\nAlternative to #29.\r\n\r\nSpecifies an algorithm for a mapping pseudorandom byte string to a\r\nvector of field elements. The algorithm was ported from google's IDPF\r\nimplementation.",
      "createdAt": "2022-02-14T21:39:21Z",
      "updatedAt": "2022-08-26T18:33:14Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d8cf35917ab6556cc5e7514a05569136fad23d1e",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/field-elem-gen-2",
      "headRefOid": "734b67651a3aea4156e840f12bbb1e21e0f0a81b",
      "closedAt": "2022-02-25T16:12:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed in favor of #31.",
          "createdAt": "2022-02-25T16:12:52Z",
          "updatedAt": "2022-02-25T16:12:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc40la8c",
          "commit": {
            "abbreviatedOid": "734b676"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T21:46:55Z",
          "updatedAt": "2022-02-14T21:46:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc41Hfoi",
          "commit": {
            "abbreviatedOid": "734b676"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-23T14:25:28Z",
          "updatedAt": "2022-02-23T14:30:04Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "This can be (length-1) * L + P, since the first sample is taken by reducing r directly, and we don't need to \"fill up\" r at the last iteration.",
              "createdAt": "2022-02-23T14:25:28Z",
              "updatedAt": "2022-02-23T14:30:04Z"
            },
            {
              "originalPosition": 40,
              "body": "This reduction mod 2**P is only needed because Python uses BigInt, right? In that case it might be more efficient to first use a mask to zero out the highest L*8 bits of r, and then do the left-shift. That way we'll only ever use P bits.",
              "createdAt": "2022-02-23T14:28:47Z",
              "updatedAt": "2022-02-23T14:30:04Z"
            },
            {
              "originalPosition": 41,
              "body": "As written above, this is not needed in the last iteration, so we can save L random bytes.",
              "createdAt": "2022-02-23T14:29:09Z",
              "updatedAt": "2022-02-23T14:30:04Z"
            },
            {
              "originalPosition": 36,
              "body": "Assuming the constructor doesn't fail when r > Field.MODULUS. Maybe make the modulo reduction explicit here?",
              "createdAt": "2022-02-23T14:29:51Z",
              "updatedAt": "2022-02-23T14:30:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41KhCb",
          "commit": {
            "abbreviatedOid": "734b676"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-24T03:43:14Z",
          "updatedAt": "2022-02-24T03:43:14Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Yup this this is because Python is bigint.",
              "createdAt": "2022-02-24T03:43:14Z",
              "updatedAt": "2022-02-24T03:43:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41KhIU",
          "commit": {
            "abbreviatedOid": "734b676"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-24T03:44:08Z",
          "updatedAt": "2022-02-24T03:44:09Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "The `Field(.)` constructor does the reduction, as documented above. But I think it would make sense to make this explicit.",
              "createdAt": "2022-02-24T03:44:08Z",
              "updatedAt": "2022-02-24T03:44:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41KhJr",
          "commit": {
            "abbreviatedOid": "734b676"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-24T03:44:23Z",
          "updatedAt": "2022-02-24T03:44:23Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Good call! I'll fix if we end up merging.",
              "createdAt": "2022-02-24T03:44:23Z",
              "updatedAt": "2022-02-24T03:44:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 31,
      "id": "PR_kwDOGKuqOc4zcDuH",
      "title": "Use \"rejection sampling\" for generating field elements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/31",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #13 by doing \"rejection sampling\". This an alternative to #29 and #30.",
      "createdAt": "2022-02-25T00:50:34Z",
      "updatedAt": "2022-08-26T18:33:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "58d3bf725cbf33c83667f14f1d83746bbaf13fab",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/prg-rejection-sampling",
      "headRefOid": "d6b3965cc36026bd77a2e4fb2f60853f76e39e5d",
      "closedAt": "2022-02-25T19:42:17Z",
      "mergedAt": "2022-02-25T19:42:16Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "7d74148aa7d2d8b8bfaf0346d0289ee318ed4801"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc41Ral0",
          "commit": {
            "abbreviatedOid": "e995fa5"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T14:41:59Z",
          "updatedAt": "2022-02-25T14:46:19Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Please add some info about what we expect from the output, e.g.\r\n`\r\nThe bytes returned are uniformly pseudorandom when the PRG was constructed with a uniformly random seed.\r\n`",
              "createdAt": "2022-02-25T14:41:59Z",
              "updatedAt": "2022-02-25T14:46:19Z"
            },
            {
              "originalPosition": 31,
              "body": "Can you add some information for why this is needed? Also please add that the seed MUST have high entropy.",
              "createdAt": "2022-02-25T14:44:46Z",
              "updatedAt": "2022-02-25T14:46:19Z"
            },
            {
              "originalPosition": 37,
              "body": "Same as above, please make sure that this is always used in a safe way by requiring that the seed MUST have high entropy and be only used once.",
              "createdAt": "2022-02-25T14:46:12Z",
              "updatedAt": "2022-02-25T14:46:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41Rq8D",
          "commit": {
            "abbreviatedOid": "e995fa5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T15:31:44Z",
          "updatedAt": "2022-02-25T15:42:27Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Done. I also stipulated that the random seed might be an output of a previous call to the PRG.\r\n\r\n",
              "createdAt": "2022-02-25T15:31:44Z",
              "updatedAt": "2022-02-25T15:42:27Z"
            },
            {
              "originalPosition": 31,
              "body": "The intended usage is explained above:\r\n> Each `Prg` has two derived class methods. The first is used to derive a fresh seed from an existing one.\r\n\r\nIf you want to see this get used, search for `Prg.derive` in the prio3 section.\r\n\r\nHigh entropy ins't going to be sufficient for all PRGs, in particular for those constructed from a pseudorandom permutation (e.g., AES). I stipulated the same requirement for securely generating seeds as above.",
              "createdAt": "2022-02-25T15:38:44Z",
              "updatedAt": "2022-02-25T15:42:27Z"
            },
            {
              "originalPosition": 37,
              "body": "It depends on the PRG construction, but it should be secure to reuse the same seed with different \"info\" strings. That is, the intent of the \"info\" string is to provide domain separation.\r\n\r\nHere I stipulated the same requirements for generating the seed as above.",
              "createdAt": "2022-02-25T15:42:19Z",
              "updatedAt": "2022-02-25T15:42:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41SfHc",
          "commit": {
            "abbreviatedOid": "5f2e71e"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-25T18:44:28Z",
          "updatedAt": "2022-02-25T18:49:29Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "The current documentation sounds good, thanks!",
              "createdAt": "2022-02-25T18:44:29Z",
              "updatedAt": "2022-02-25T18:49:29Z"
            },
            {
              "originalPosition": 28,
              "body": "Maybe add a note about `info` and domain separation?",
              "createdAt": "2022-02-25T18:48:42Z",
              "updatedAt": "2022-02-25T18:49:29Z"
            },
            {
              "originalPosition": 37,
              "body": "Okay, let's maybe add a short sentence on this to the documentation (see comment above).",
              "createdAt": "2022-02-25T18:49:13Z",
              "updatedAt": "2022-02-25T18:49:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41Sq74",
          "commit": {
            "abbreviatedOid": "5f2e71e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:39:40Z",
          "updatedAt": "2022-02-25T19:39:41Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Done",
              "createdAt": "2022-02-25T19:39:41Z",
              "updatedAt": "2022-02-25T19:39:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 33,
      "id": "PR_kwDOGKuqOc4zfPGd",
      "title": "Acknoweledge Armando",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/33",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-25T21:40:36Z",
      "updatedAt": "2022-05-26T14:58:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "7d74148aa7d2d8b8bfaf0346d0289ee318ed4801",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/ack-armando",
      "headRefOid": "636e7ac818170194489b089a42464537c16a59e0",
      "closedAt": "2022-02-25T21:56:07Z",
      "mergedAt": "2022-02-25T21:56:07Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "03f3ac2114e8e728518728d30b6adb9c8902aedc"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 34,
      "id": "PR_kwDOGKuqOc4zvzEs",
      "title": "poc: Implement the generic FLP",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/34",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "fyi/ @chris-wood",
      "createdAt": "2022-03-01T18:50:27Z",
      "updatedAt": "2022-05-26T14:58:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "5b832679851002485c004c461948491837624102",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/poc-flp-generic",
      "headRefOid": "8a7f6f9e1ac9c122dfb1d02b588f24302e15b42d",
      "closedAt": "2022-03-01T18:52:08Z",
      "mergedAt": "2022-03-01T18:52:08Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "65cc1df73c94a074e6d651b0e831dfe7af80917d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 35,
      "id": "PR_kwDOGKuqOc4zwmLF",
      "title": "prio3: Add domain separation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/35",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Bind the derivation of field elements to the document name and the\r\n\"suite\", consisting of the PRG and FLP.",
      "createdAt": "2022-03-01T23:19:35Z",
      "updatedAt": "2022-05-26T14:58:25Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "7d12cac116bcb084c81d0f1ea64eca9f0fa271ba",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/prio3-test-vec",
      "headRefOid": "573b8be2128537d2a09073a8fbca2ba1224fc2e3",
      "closedAt": "2022-03-01T23:57:14Z",
      "mergedAt": "2022-03-01T23:57:14Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "34a51dd9ac5504e03b2bb5c418677bcea7f1238c"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "fyi/ @tgeoghegan ",
          "createdAt": "2022-03-01T23:19:44Z",
          "updatedAt": "2022-03-01T23:19:44Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 36,
      "id": "PR_kwDOGKuqOc4z2cbN",
      "title": "poc: Library compatibility",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/36",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This fixes a couple hiccups I ran into when running the Sage implementation with some older libraries from my distro. (sagemath 9.0-1ubuntu4 and python3-pycryptodome 3.6.1-2build4) I added a fallback to import PyCryptodome from either of its supported names, and added a conversion from `sage.rings.integer.Integer` to `int` in one place. The second change addresses a ctypes error I got from a PyCryptodome call; presumably newer versions of Sage cooperate with ctypes better on type coercion.",
      "createdAt": "2022-03-02T19:46:31Z",
      "updatedAt": "2022-03-02T23:34:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d8fcbfb639dcdeec80ece097e5012b992dade63e",
      "headRepository": "divergentdave/vdaf",
      "headRefName": "poc-library-compatibility",
      "headRefOid": "ab6d5fc2ae36e293d363952dbb36c982b73e348e",
      "closedAt": "2022-03-02T22:56:10Z",
      "mergedAt": "2022-03-02T22:56:10Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "dff2553f17b13b41a39e66509388a2e29c270df9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc41h_EH",
          "commit": {
            "abbreviatedOid": "ab6d5fc"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-02T19:58:19Z",
          "updatedAt": "2022-03-02T19:58:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 37,
      "id": "PR_kwDOGKuqOc4z-2-t",
      "title": "Edits and test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/37",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-03-05T01:06:59Z",
      "updatedAt": "2022-05-26T14:58:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "29840fd017e6dc9103d1fa996475e0ccaa71d222",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/edit-01",
      "headRefOid": "50717f2d973df8279267dff8a1df28f9f5373ebf",
      "closedAt": "2022-03-05T01:21:39Z",
      "mergedAt": "2022-03-05T01:21:39Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "3a2892a558703f66df671f03355d3e65b86e98fd"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 41,
      "id": "PR_kwDOGKuqOc41LJBc",
      "title": "Small fix to prime selection script",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/41",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This fixes a small bug in the prime searching script. Previously, it would skip candidate q values, since it decremented q by i, rather than check each `2^(n-k)-i`. In the interest of completeness, we now check each possible value.",
      "createdAt": "2022-03-28T17:58:47Z",
      "updatedAt": "2022-06-02T16:37:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d5d51ef9f7e990229ffa4b2fec624634ad398aa6",
      "headRepository": "divergentdave/vdaf",
      "headRefName": "david/prime-search",
      "headRefOid": "784285e500334e1f5cf5769aaa72fc36fb05996b",
      "closedAt": "2022-04-06T19:15:20Z",
      "mergedAt": "2022-04-06T19:15:19Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "439c2fe9ce67fb858bf3f05d84db2682e4e7f84c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc43Iwmv",
          "commit": {
            "abbreviatedOid": "784285e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for checking :) Note that there is still time to pick new primes if we so choose.",
          "createdAt": "2022-03-29T18:12:57Z",
          "updatedAt": "2022-03-29T18:12:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 43,
      "id": "PR_kwDOGKuqOc41ge3l",
      "title": "Editorial changes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/43",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This collects some editorial changes throughout the document.\r\n\r\n1. Mention section 7 in the overview\r\n2. Link syntax\r\n3. Stray punctuation\r\n4. \"values `beta`\" appeared to be a singular/plural disagreement the first time I read it, until later reading that `beta` is itself a pair of values. This change identifies that at its introduction.\r\n5. Wrong variable in pseudocode\r\n6. Further explanation of how the correlation shares could be compressed\r\n7. Typo in pseudocode\r\n8. Copyediting",
      "createdAt": "2022-04-01T18:40:51Z",
      "updatedAt": "2022-06-02T16:37:32Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d5d51ef9f7e990229ffa4b2fec624634ad398aa6",
      "headRepository": "divergentdave/vdaf",
      "headRefName": "david/editorial-revisions",
      "headRefOid": "a8acb4c4402c37f2627135a325ec3b8e6163e434",
      "closedAt": "2022-04-06T19:15:09Z",
      "mergedAt": "2022-04-06T19:15:09Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "6cf02ebad34b670870b9c14a6b4f471ecd065c9b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc43q6YF",
          "commit": {
            "abbreviatedOid": "a8acb4c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-06T19:14:51Z",
          "updatedAt": "2022-04-06T19:14:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 46,
      "id": "PR_kwDOGKuqOc42u5Uw",
      "title": "Update authors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/46",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* Sort authors alphabetically\r\n* Change Chris P.'s email address",
      "createdAt": "2022-04-25T14:51:03Z",
      "updatedAt": "2022-05-26T14:58:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "6904d4a6295da82daf7ecd09c094326db4fb8ccd",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/auth-update",
      "headRefOid": "85474e233519f4abb43ead5600585f46d8b9829f",
      "closedAt": "2022-04-25T15:23:20Z",
      "mergedAt": "2022-04-25T15:23:20Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "15c6abadc46d760a2b39a5708492a195fb4ee2e9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc44vohI",
          "commit": {
            "abbreviatedOid": "85474e2"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-25T14:58:24Z",
          "updatedAt": "2022-04-25T14:58:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc44vzZ5",
          "commit": {
            "abbreviatedOid": "85474e2"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-25T15:23:15Z",
          "updatedAt": "2022-04-25T15:23:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 49,
      "id": "PR_kwDOGKuqOc425hi2",
      "title": "Move draft to CFRG",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/49",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-27T19:54:36Z",
      "updatedAt": "2022-05-26T14:58:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "15c6abadc46d760a2b39a5708492a195fb4ee2e9",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/move-to-cfrg",
      "headRefOid": "f331520a313462d00c2d953c486c475c78fa834b",
      "closedAt": "2022-04-27T20:01:45Z",
      "mergedAt": "2022-04-27T20:01:45Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "404d2e2110d3d3703e2c289bdf6ec25a03939d2d"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation, @schoppmp, FYI: I'm moving this document to draft-irtf-cfrg-vdaf-00.",
          "createdAt": "2022-04-27T20:01:14Z",
          "updatedAt": "2022-04-27T20:01:14Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 50,
      "id": "PR_kwDOGKuqOc425xcU",
      "title": "Update links after moving repo",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/50",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-27T21:14:13Z",
      "updatedAt": "2022-05-26T14:58:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "404d2e2110d3d3703e2c289bdf6ec25a03939d2d",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/update-links",
      "headRefOid": "3ea87c6fad8d0b4d24f0716cd73a00afe1912375",
      "closedAt": "2022-04-27T21:16:01Z",
      "mergedAt": "2022-04-27T21:16:01Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "515905df41d7d8a499480f7ee15d75d975c4ac83"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 52,
      "id": "PR_kwDOGKuqOc426Ooa",
      "title": "fix duplicated JOINT_RAND_LEN",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/52",
      "state": "MERGED",
      "author": "jbr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "closes #51 ",
      "createdAt": "2022-04-28T00:34:18Z",
      "updatedAt": "2022-04-28T03:38:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "515905df41d7d8a499480f7ee15d75d975c4ac83",
      "headRepository": "jbr/draft-irtf-cfrg-vdaf",
      "headRefName": "poc-fix-flp-duplication",
      "headRefOid": "bc64a0bcd926a0bc4b74be255990e680e743c201",
      "closedAt": "2022-04-28T03:38:05Z",
      "mergedAt": "2022-04-28T03:38:05Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "ca421e5064d2767319006cfd8007fa9ad65ef60b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc449oq3",
          "commit": {
            "abbreviatedOid": "bc64a0b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Nice catch. Thanks!",
          "createdAt": "2022-04-28T00:40:41Z",
          "updatedAt": "2022-04-28T00:40:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 53,
      "id": "PR_kwDOGKuqOc43G3Ky",
      "title": "Define DAFs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/53",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #20.\r\n\r\nThis defines syntax for DAFs. They are presented as a simpler alternative to VDAFs that may be suited for some applications. They are defined before VDAFs by way of a \"gentle introduction\". Text in the VDAF section that overlaps significantly with the new DAF text has been removed.\r\n\r\nReviewer note: This PR is broken up into several commits. It may be best to review commit-by-commit.\r\n\r\n2022-05-06: Ready for review.\r\n2022-04-29: WIP, not yet ready for review.",
      "createdAt": "2022-04-30T01:41:22Z",
      "updatedAt": "2022-05-26T14:58:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "28ef0c404c0548b6427c3f2a7e3857640d3a7968",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/daf",
      "headRefOid": "31bc9f32b34967c00e73b9ef6e209818bb065c26",
      "closedAt": "2022-05-13T15:20:06Z",
      "mergedAt": "2022-05-13T15:20:06Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "7ad3aa673c33540c63549062e38223d481ac845b"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @schoppmp, no substantial changes, if you want to inspect the diff you can do\r\n```\r\ngit diff f606049..cjpatton/daf\r\n```\r\n\r\nNote that this inccludes changes after rebasing on `main`.",
          "createdAt": "2022-05-10T19:00:17Z",
          "updatedAt": "2022-05-10T19:00:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc45hmrd",
          "commit": {
            "abbreviatedOid": "f606049"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-06T19:25:30Z",
          "updatedAt": "2022-05-06T20:55:07Z",
          "comments": [
            {
              "originalPosition": 191,
              "body": "```suggestion\r\n{: #daf-param title=\"Constants and types defined by each concrete DAF.\"}\r\n```",
              "createdAt": "2022-05-06T19:25:30Z",
              "updatedAt": "2022-05-06T20:55:07Z"
            },
            {
              "originalPosition": 167,
              "body": "Would it be clearer to say that the mapping may be \"non-deterministic\", rather than \"one-to-many\"?",
              "createdAt": "2022-05-06T19:26:21Z",
              "updatedAt": "2022-05-06T20:55:07Z"
            },
            {
              "originalPosition": 349,
              "body": "nit: spelling\r\n```suggestion\r\nThe inputs to this procedure are the same as the aggregation function computed by\r\n```",
              "createdAt": "2022-05-06T20:19:27Z",
              "updatedAt": "2022-05-06T20:55:07Z"
            },
            {
              "originalPosition": 371,
              "body": "nit: spelling\r\n```suggestion\r\nof the computation's correctness. Accommodating this interaction will require\r\n```",
              "createdAt": "2022-05-06T20:31:36Z",
              "updatedAt": "2022-05-06T20:55:07Z"
            },
            {
              "originalPosition": 446,
              "body": "nit: typo\r\n```suggestion\r\ninput-distribution algorithm takes in the public parameter generated during the\r\n```",
              "createdAt": "2022-05-06T20:33:41Z",
              "updatedAt": "2022-05-06T20:55:08Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\n    # The measurement type.\r\n```",
              "createdAt": "2022-05-06T20:40:40Z",
              "updatedAt": "2022-05-06T20:55:08Z"
            },
            {
              "originalPosition": 55,
              "body": "nit: typo\r\n```suggestion\r\n    # called by the collector.\r\n```",
              "createdAt": "2022-05-06T20:42:30Z",
              "updatedAt": "2022-05-06T20:55:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45iFUs",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-06T22:35:23Z",
          "updatedAt": "2022-05-06T23:11:46Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "In fact, the mapping from (input_share, agg_param) --> out_share is deterministic, i.e., not randomized. I think the wording is confusing here. What I mean is that each agg_param may result in a different out_share. I've tried to clarify the text.",
              "createdAt": "2022-05-06T22:35:24Z",
              "updatedAt": "2022-05-06T23:11:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45iJmx",
          "commit": {
            "abbreviatedOid": "f606049"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-06T23:32:25Z",
          "updatedAt": "2022-05-06T23:32:25Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "Ah, got it, thanks! New text looks good.",
              "createdAt": "2022-05-06T23:32:25Z",
              "updatedAt": "2022-05-06T23:32:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45oJt6",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T20:59:40Z",
          "updatedAt": "2022-05-09T21:32:51Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "What does `Prep.OutShare` refer to? Should that just be `OutShare`?",
              "createdAt": "2022-05-09T20:59:40Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 23,
              "body": "\"may\" and \"optional\" are redundant.",
              "createdAt": "2022-05-09T21:05:57Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 24,
              "body": "\"The semantics of this parameter *are* specific\"\r\n\r\n(GitHub won't let me use the suggestion feature when I review commit-by-commit)",
              "createdAt": "2022-05-09T21:06:50Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 26,
              "body": "Missing period at the end of the line",
              "createdAt": "2022-05-09T21:06:58Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 41,
              "body": "I think this sentence makes sense if we read \"input\" as a verb and not a noun, but it's a bit confusing given that those two words have specific meanings throughout VDAF and DAP. Maybe rephrase to only use one or the other word?",
              "createdAt": "2022-05-09T21:08:21Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 42,
              "body": "\"Unsharding *is* done\"",
              "createdAt": "2022-05-09T21:08:32Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 48,
              "body": "s/tyeps/types",
              "createdAt": "2022-05-09T21:08:56Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 55,
              "body": "Reviewing this table of types and the existing one for VDAFs, it seems odd that we take the care of defining an `OutShare` type but then represent input shares as `Bytes` (e.g., `Vdaf.measurement_to_input_shares(public_param: PublicParam, input: Measurement) -> Vec[Bytes]`). Why not define `InShare`?\r\n\r\nThis wasn't introduced by this PR so feel free to punt with an issue or a TODO (or to disagree with me altogether)",
              "createdAt": "2022-05-09T21:11:59Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 177,
              "body": "update this reference to `draft-ietf-ppm-dap` (and presumably elsewhere in the document where `draft-gpew-priv-ppm` occurs)",
              "createdAt": "2022-05-09T21:15:04Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 96,
              "body": "I think this is adapted from the `run_vdaf` test/illustration, where `outbound` is used to simulate the leader gathering prepare messages from helpers and then broadcasting combined prepare messages back out. That step isn't needed in a DAF (right?), so I wonder if this could be rewritten to make it more clear that each aggregator is independent and doesn't interact with any other during `prepare`? That is, eliminate any value like `outbound` that is shared among aggregators (in this case, each aggregator is represented by one iteration of the `for j in range(Daf.SHARES)` loop).",
              "createdAt": "2022-05-09T21:20:18Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 397,
              "body": "I'm a bit confused about \"one-shot\" vs. \"streaming\". The distinction that I'm aware of between VDAFs is whether the aggregation parameter exists or not. If it does, then aggregation can't start until the collector proves the aggregation parameter. If it does not, then aggregators can aggregate shares immediately upon upload.\r\n\r\nBut I don't think that has anything to do with whether aggregation can be \"streamed\". Let's say we're running `poplar1`, and my aggregator receives 50 shares, and then the collector sends me `agg_param`. Now I can aggregate together those 50 shares, but I'm likely to do so by preparing them individually, independently from each other, summing each output share into an aggregate, which sounds like \"streaming\" to me. Further, my aggregator may continue to receive shares between when it receives `agg_param` (in a DAP `CollectReq`) and when it delivers the aggregate share (which will happen when the collector hits the DAP collect job URI), and I don't think anything stops the aggregator from continuing to incorporate shares into the aggregate -- or _stream_ them.\r\n\r\nI think I know what you mean by \"one-shot\" vs. \"streaming\", but I don't think these are the right words to express it, since the issue here is when the aggregator can expect to have the aggregation parameter and not whether input shares can be aggregated incrementally.",
              "createdAt": "2022-05-09T21:32:13Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45oRT3",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T21:35:33Z",
          "updatedAt": "2022-05-09T21:35:33Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Oh, I think I see now that `Bytes` connotes that the output of the method is a message that can be transmitted on the wire to another protocol participant. I think that's inconsistent though: `AggShare` also has to be encoded to be transmitted from aggregators to the collector, but it gets a rich type definition here. My vote would be to use nice type aliases everywhere and then extend the definition of DAF/VDAF to include methods like `Daf.encode_input_share(InShare) -> Bytes` and `Daf.decode_input_share(Bytes) -> InShare`.",
              "createdAt": "2022-05-09T21:35:33Z",
              "updatedAt": "2022-05-09T21:35:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45oWOO",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T22:03:00Z",
          "updatedAt": "2022-05-09T22:03:01Z",
          "comments": [
            {
              "originalPosition": 397,
              "body": "Both `prio3` and `poplar1` support \"streaming\" aggregation in the sense used here, as both their aggregation operations are effectively vector addition in a vector space over a field. The distinction is that `out_shares_to_agg_share` as given here takes in all output shares at once, and returns an aggregate share, rather than processing output shares only one at a time, updating an accumulator, and returning an aggregate share at the end. For a strawman counterexample, consider a VDAF where `out_shares_to_agg_share` takes the median of numbers from each output share. This would be a non-streaming VDAF, as there's no efficient way to incrementally compute an aggregate share. Instead, the only way to compute the exact median is to keep the multiset of all output shares around until all output shares are received.",
              "createdAt": "2022-05-09T22:03:00Z",
              "updatedAt": "2022-05-09T22:06:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45oVtw",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-05-09T22:00:01Z",
          "updatedAt": "2022-05-09T22:19:53Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "environment",
              "createdAt": "2022-05-09T22:00:02Z",
              "updatedAt": "2022-05-09T22:19:53Z"
            },
            {
              "originalPosition": 55,
              "body": "+1, I would prefer a concrete type for the input shares.",
              "createdAt": "2022-05-09T22:05:43Z",
              "updatedAt": "2022-05-09T22:19:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45oabg",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T22:30:11Z",
          "updatedAt": "2022-05-09T22:33:47Z",
          "comments": [
            {
              "originalPosition": 373,
              "body": "> However, the Preparation stage will require interaction among the Aggregators in order to facilitate verifiability of the computation's correctness.\r\n\r\nI think it makes sense to split up the preparation (as in, turning an input share into an aggregation share), and the verification.\r\nThe reason is that the outer protocol using a VDAF might want to \"opportunistically\" aggregate shares, in particular for Poplar, where there are many rounds of Preparation, Aggregation, and Unsharding. This would save communication rounds, since the verification on one layer (of the Poplar tree) can be done in parallel with computing the aggregation shares on the next layer. In case a share turns out to be invalid, the corresponding aggregation shares can just be subtracted from the aggregated result.",
              "createdAt": "2022-05-09T22:30:12Z",
              "updatedAt": "2022-05-09T22:33:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45oaPI",
          "commit": {
            "abbreviatedOid": "31bc9f3"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T22:28:52Z",
          "updatedAt": "2022-05-09T23:00:56Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Done",
              "createdAt": "2022-05-09T22:28:52Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 23,
              "body": "Done",
              "createdAt": "2022-05-09T22:29:39Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 24,
              "body": "https://english.stackexchange.com/questions/411158/plural-form-of-semantics",
              "createdAt": "2022-05-09T22:30:55Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 26,
              "body": "Done",
              "createdAt": "2022-05-09T22:31:14Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 41,
              "body": "Done, changed to \"measurement\".",
              "createdAt": "2022-05-09T22:31:49Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 42,
              "body": "\"X and Y are done\" follows grammar above. Is this wrong? Should it be \"X and Y is done?\"",
              "createdAt": "2022-05-09T22:32:41Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 48,
              "body": "Done",
              "createdAt": "2022-05-09T22:33:04Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 55,
              "body": "You're right about the inconsistency, however I'm not sure I agree with the solution. Let's move this discussion here: https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/58",
              "createdAt": "2022-05-09T22:40:06Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 177,
              "body": "Ack, will do so after merging this change.",
              "createdAt": "2022-05-09T22:45:59Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 397,
              "body": "Another answer: The intended meaning of the word \"streaming\" is the alternative API discussed here: https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/47",
              "createdAt": "2022-05-09T22:48:18Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 51,
              "body": "Yes, done!",
              "createdAt": "2022-05-09T22:50:46Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 96,
              "body": "Done",
              "createdAt": "2022-05-09T23:00:40Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45olRc",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T23:30:50Z",
          "updatedAt": "2022-05-09T23:30:51Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Hmm, TIL the semantics of the word \"semantics\". Well, maybe the IETF has a style guide that someone can cite from to settle this. For now I say go with whichever you prefer.",
              "createdAt": "2022-05-09T23:30:51Z",
              "updatedAt": "2022-05-09T23:30:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45olho",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T23:31:28Z",
          "updatedAt": "2022-05-09T23:31:28Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "No, you're right, this is correct as-is. I don't have a \"resolve conversation button\" here because ???? so I guess just ignore this thread.",
              "createdAt": "2022-05-09T23:31:28Z",
              "updatedAt": "2022-05-09T23:31:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45onY_",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T23:36:03Z",
          "updatedAt": "2022-05-09T23:36:03Z",
          "comments": [
            {
              "originalPosition": 397,
              "body": "Maybe this is too big of a nomenclature issue to tackle in this particular PR",
              "createdAt": "2022-05-09T23:36:03Z",
              "updatedAt": "2022-05-09T23:36:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45oqBd",
          "commit": {
            "abbreviatedOid": "31bc9f3"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T23:42:25Z",
          "updatedAt": "2022-05-09T23:45:24Z",
          "comments": [
            {
              "originalPosition": 373,
              "body": "To be clear:\r\n* Prepare takes input shares to output shares; and\r\n* Aggregation takes output shares to aggregate shares.\r\n\r\n> [...] the verification on one layer (of the Poplar tree) can be done in parallel with computing the aggregation shares on the next layer. In case a share turns out to be invalid, the corresponding aggregation shares can just be subtracted from the aggregated result.\r\n\r\nVery Interesting idea. The current text points to two reasons for not breaking Prepare abstraction this way:\r\n1. Not every VDAF is compatible with this change. E.g., in Prio+ the output shares are only computed after multiple rounds of interaction.\r\n2. Releasing unverified output shares early may lead to them being misused.\r\n\r\nThus, a change here would be significant and would need to be thought through. I'd suggest we discuss it in a new issue.\r\n\r\n\r\n\r\n\r\n",
              "createdAt": "2022-05-09T23:42:25Z",
              "updatedAt": "2022-05-09T23:45:24Z"
            },
            {
              "originalPosition": 397,
              "body": "It's arguably orthogonal given that \"one-shot\" is the current terminology (i.e., not introduced by this PR). How about adding a comment to #47 about fixing this?",
              "createdAt": "2022-05-09T23:44:36Z",
              "updatedAt": "2022-05-09T23:45:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45tMDw",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-10T17:17:33Z",
          "updatedAt": "2022-05-10T17:17:33Z",
          "comments": [
            {
              "originalPosition": 373,
              "body": "> Not every VDAF is compatible with this change. E.g., in Prio+ the output shares are only computed after multiple rounds of interaction.\r\n\r\nI'm not asking for every VDAF to support this opportunistic aggregation, but instead to *allow* it in places where it's supported by both the VDAF and the outer aggregation protocol.\r\n\r\nI opened https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/61 to continue this discussion.",
              "createdAt": "2022-05-10T17:17:33Z",
              "updatedAt": "2022-05-10T17:17:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45tOkh",
          "commit": {
            "abbreviatedOid": "31bc9f3"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I can't see the diff between my last review and the current state. LGTM assuming there are no substantial changes.",
          "createdAt": "2022-05-10T17:22:01Z",
          "updatedAt": "2022-05-10T17:22:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc459Nxu",
          "commit": {
            "abbreviatedOid": "31bc9f3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-13T14:27:13Z",
          "updatedAt": "2022-05-13T14:27:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 54,
      "id": "PR_kwDOGKuqOc43P_l9",
      "title": "Remove unused g_calls in FlpGeneric.prove",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/54",
      "state": "MERGED",
      "author": "jbr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As far as I can tell this is an unnecessary zip, as `g_calls` is unused in this scope",
      "createdAt": "2022-05-03T19:45:06Z",
      "updatedAt": "2022-05-03T20:01:56Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "ca421e5064d2767319006cfd8007fa9ad65ef60b",
      "headRepository": "jbr/draft-irtf-cfrg-vdaf",
      "headRefName": "remove-unused-valid-gadget-calls",
      "headRefOid": "9061fc1f8711696305784fdae42f46ba425ed47c",
      "closedAt": "2022-05-03T20:01:56Z",
      "mergedAt": "2022-05-03T20:01:56Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "2a5c2dd4720280ea9f9e2ab5a2b5ba5062212d6b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc45RzaU",
          "commit": {
            "abbreviatedOid": "9061fc1"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Right you are!",
          "createdAt": "2022-05-03T20:01:47Z",
          "updatedAt": "2022-05-03T20:01:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 55,
      "id": "PR_kwDOGKuqOc43Qo1w",
      "title": "remove another unused g_calls",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/55",
      "state": "MERGED",
      "author": "jbr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-03T23:01:47Z",
      "updatedAt": "2022-05-04T23:12:41Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "2a5c2dd4720280ea9f9e2ab5a2b5ba5062212d6b",
      "headRepository": "jbr/draft-irtf-cfrg-vdaf",
      "headRefName": "remove-another-unused-g_calls",
      "headRefOid": "30d8013e64cec3ca919274676e7e2b999eb39ec2",
      "closedAt": "2022-05-04T23:12:41Z",
      "mergedAt": "2022-05-04T23:12:41Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "958c619dae34b20cbbac81afed3aa8d4d50829d7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc45Yhqe",
          "commit": {
            "abbreviatedOid": "30d8013"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-04T23:12:35Z",
          "updatedAt": "2022-05-04T23:12:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 56,
      "id": "PR_kwDOGKuqOc43btGQ",
      "title": "gadget_poly_len should not include the wire seed arity",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/56",
      "state": "MERGED",
      "author": "jbr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently `gadget_poly_len` is the same as the total gadget chunk length (proof length for a one-gadget circuit), which is off by the wire seed length/arity. The tests passed because all of the tested circuits have only a single gadget and the wire seed is before the polynomial, so attempting to read off the end of the proof truncated back to the expected length. If there were two gadgets, this would read part of the second gadget's wire seed into the polynomial of the first",
      "createdAt": "2022-05-06T19:02:30Z",
      "updatedAt": "2022-05-09T15:03:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "c1548a7c37a4e11eef9a7ba37c5af3c1bad6134b",
      "headRepository": "jbr/draft-irtf-cfrg-vdaf",
      "headRefName": "correct-gadget-poly-len",
      "headRefOid": "c44c5e10409e3d556b509325f70807cfb1e721ae",
      "closedAt": "2022-05-09T15:03:52Z",
      "mergedAt": "2022-05-09T15:03:52Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "28ef0c404c0548b6427c3f2a7e3857640d3a7968"
      },
      "comments": [
        {
          "author": "jbr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Confirmed manually that the tests failed as follows before this pr:\r\n```\r\n\u276f make test\r\nParsing flp_generic.sage\r\nsage common.sage\r\nsage field.sage\r\nsage flp.sage\r\nsage flp_generic.sage\r\nTestMultiGadget: test 0 failed: proof evaluation resulted in False; want True\r\nsage prg.sage\r\nsage vdaf.sage\r\nsage vdaf_prio3.sage\r\n```\r\n\r\nand with this pr they pass:\r\n```\r\n\u276f make test\r\nParsing flp_generic.sage\r\nsage common.sage\r\nsage field.sage\r\nsage flp.sage\r\nsage flp_generic.sage\r\nsage prg.sage\r\nsage vdaf.sage\r\nsage vdaf_prio3.sage\r\n```\r\n\r\nWould you be interested in a PR that runs the POC tests in GitHub actions as CI?",
          "createdAt": "2022-05-06T23:52:37Z",
          "updatedAt": "2022-05-06T23:52:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Sweet, thanks again.",
          "createdAt": "2022-05-09T15:03:39Z",
          "updatedAt": "2022-05-09T15:03:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc45iIGN",
          "commit": {
            "abbreviatedOid": "aa71d3c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks again @jbr! I merged a test that exercises this bug: https://github.com/cfrg/draft-irtf-cfrg-vdaf/commit/c1548a7c37a4e11eef9a7ba37c5af3c1bad6134b. Two asks:\r\n1. Please rebase on `main` and make sure the fix is sufficient.\r\n2. Please revise the commit message to use a verb, e..g, \"poc: Fix bug in `FlpGeneric` triggered by multiple gadgets\". Also, please add to the commit message a note about what the bug is.\r\n",
          "createdAt": "2022-05-06T23:09:56Z",
          "updatedAt": "2022-05-06T23:09:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc45mJix",
          "commit": {
            "abbreviatedOid": "c44c5e1"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-09T15:03:27Z",
          "updatedAt": "2022-05-09T15:03:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "PR_kwDOGKuqOc43hPpb",
      "title": "poc: Add VerifyParam type annotation to Prio3",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/57",
      "state": "MERGED",
      "author": "jbr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm not certain that this is correct, but it seems like `VerifyParam` isn't the `Vdaf` default of `None` for `Prio3`",
      "createdAt": "2022-05-09T17:36:09Z",
      "updatedAt": "2022-05-10T02:06:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "28ef0c404c0548b6427c3f2a7e3857640d3a7968",
      "headRepository": "jbr/draft-irtf-cfrg-vdaf",
      "headRefName": "pod-vdaf-prio3-add-verify-param-type",
      "headRefOid": "703fd8f3319d0c03adde78c3d37b21d5d69fae78",
      "closedAt": "2022-05-10T02:06:21Z",
      "mergedAt": "2022-05-10T02:06:21Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "b8b1496aeead11d73bae34b8b63ed41f46857367"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc45pAUx",
          "commit": {
            "abbreviatedOid": "23720f0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Yes that's correct. Before merging, would you mind changing the commit message by replacing \"VdafPrio3\" with \"Prio3\"? \"VdafPrio3\" isn't a proper name of something.\r\n\r\nBy the way, I filed https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/59 to investigate where else way may have missed this.",
          "createdAt": "2022-05-10T01:13:49Z",
          "updatedAt": "2022-05-10T01:13:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc45pIsE",
          "commit": {
            "abbreviatedOid": "703fd8f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\u2764\ufe0f ",
          "createdAt": "2022-05-10T02:06:15Z",
          "updatedAt": "2022-05-10T02:06:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 62,
      "id": "PR_kwDOGKuqOc43zOts",
      "title": "Remove public param and simplify verify param",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/62",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #19.\r\n\r\nThere are currently no VDAFs that use the public parameter. As noted\r\nnoted in https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/18 and https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/19, this creates friction for applications like DAP\r\n(formerly known as PPM) that require frequent rotation of the\r\nverification parameter shared by the Aggregators. This change addresses\r\nthis issue by dropping the public parameter from the syntax.\r\n\r\nFor our current set of VDAFs (Prio3 and Poplar1), the verification\r\nparameter held by an Aggregator is basically a shared secret and some\r\nsort of identifier of its role (aggregator 0, aggregator 1, ...). This\r\nchange codifies these two values in the syntax by dropping the\r\nverification parameter and replacing it with a shared \"verification key\"\r\nand an \"aggregator ID\". This allows us to replace the `setup()`\r\nprocedure with simply generating a shared secret, paving the way for a\r\nsolution for https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/18 that doesn't require breaking the abstraction boundary.",
      "createdAt": "2022-05-13T17:58:09Z",
      "updatedAt": "2022-05-26T14:58:31Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "f2c70cc9547333945e287adbbd22ddd81d89a5be",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/pub-param-die-die-die",
      "headRefOid": "902b849a4c0a7591a5899accb031febc96e336d5",
      "closedAt": "2022-05-18T23:12:34Z",
      "mergedAt": "2022-05-18T23:12:33Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "b08c3e9cc0bce68315ead46dafc69a3a7edc7c4a"
      },
      "comments": [
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "There are still a couple of `verify_param` throughout the document, for example under Security Considerations. Do you plan to replace them in this PR?",
          "createdAt": "2022-05-16T23:21:59Z",
          "updatedAt": "2022-05-16T23:21:59Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "There are still a couple of `verify_param` throughout the document, for example under Security Considerations. Do you plan to replace them in this PR?",
          "createdAt": "2022-05-16T23:21:59Z",
          "updatedAt": "2022-05-16T23:21:59Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> There are still a couple of `verify_param` throughout the document, for example under Security Considerations. Do you plan to replace them in this PR?\r\n\r\nI intended to leave the Poplar1 section unchanged, but missed the updates in Security Considerations. Nice catch, fixed.",
          "createdAt": "2022-05-16T23:32:27Z",
          "updatedAt": "2022-05-16T23:32:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc45-lqt",
          "commit": {
            "abbreviatedOid": "fe8a3f3"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-13T19:35:12Z",
          "updatedAt": "2022-05-13T20:31:36Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "nit: typo\r\n```suggestion\r\n  The application MUST ensure that the Aggregator's identifier is equal to the\r\n```",
              "createdAt": "2022-05-13T19:35:12Z",
              "updatedAt": "2022-05-13T20:31:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc46GE55",
          "commit": {
            "abbreviatedOid": "fe8a3f3"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-16T23:32:41Z",
          "updatedAt": "2022-05-16T23:32:41Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "Done.",
              "createdAt": "2022-05-16T23:32:41Z",
              "updatedAt": "2022-05-16T23:32:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc46GFTH",
          "commit": {
            "abbreviatedOid": "8e5e1a5"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-16T23:35:55Z",
          "updatedAt": "2022-05-16T23:35:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc46QxmC",
          "commit": {
            "abbreviatedOid": "93677c0"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-18T19:12:41Z",
          "updatedAt": "2022-05-18T19:13:36Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Nit: Please add spaces below so that the column dividers align.",
              "createdAt": "2022-05-18T19:12:41Z",
              "updatedAt": "2022-05-18T19:13:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc46Rx8D",
          "commit": {
            "abbreviatedOid": "93677c0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-18T23:08:16Z",
          "updatedAt": "2022-05-18T23:08:16Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Done",
              "createdAt": "2022-05-18T23:08:16Z",
              "updatedAt": "2022-05-18T23:08:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDOGKuqOc43_qpl",
      "title": "Prio3: Move proof verifier check to prep_shares_to_prep()",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/64",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Moves the proof verifier check to prep_shares_to_prep() in oder to avoid\r\nincluding the verifier in the unsharded prep message. Now this message\r\nincludes just the joint randomness checker, unless no joint randomness\r\nis required, in which case the unshareded prep message is the empty\r\nstring.",
      "createdAt": "2022-05-18T02:22:28Z",
      "updatedAt": "2022-05-26T14:58:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "3888d46adb568c5ea8e6d276524954172e92d4c6",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/prio3-prep-share",
      "headRefOid": "9b387224c84726c4734327710950357c082f9fe5",
      "closedAt": "2022-05-18T23:12:54Z",
      "mergedAt": "2022-05-18T23:12:54Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "6e1eb6fc296f92ec147c88d8c6e2e9139a1b0ceb"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 65,
      "id": "PR_kwDOGKuqOc44B_Tc",
      "title": "define \"domain separation tag\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/65",
      "state": "CLOSED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@jbr pointed out that the `dst` variables that occur in a few VDAF\r\ninstantiations are a bit inscrutable. This commit adds `DST` associated\r\nconstants to the DAF and VDAF definitions which are then used in PRGs.\r\nThe intent is to (1) provide a clear definition of a DST and (2) reduce\r\nthe number of places where the string `vdaf-00 prio3` has to be updated\r\nto `vdaf-01 prio3`.",
      "createdAt": "2022-05-18T14:22:56Z",
      "updatedAt": "2022-05-18T15:48:07Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "3888d46adb568c5ea8e6d276524954172e92d4c6",
      "headRepository": "tgeoghegan/vdaf",
      "headRefName": "timg/define-dst",
      "headRefOid": "3df27257d2b9ed54018eea794fefa7fd95883e1d",
      "closedAt": "2022-05-18T15:46:38Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Tagging @jbr and @cjpatton: I don't have the privileges to request review on this PR, but PTAL. Chris, if this seems good to you, then I'll make the corresponding changes to the Sage scripts.",
          "createdAt": "2022-05-18T14:26:06Z",
          "updatedAt": "2022-05-18T14:26:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "One more note: I think a comment defining the acronym DST is sufficient.",
          "createdAt": "2022-05-18T15:38:41Z",
          "updatedAt": "2022-05-18T15:38:41Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> One more note: I think a comment defining the acronym DST is sufficient.\r\n\r\nYeah, in the interest of moving forward and not re-writing half the doc and POC, I'm going to close this PR and just add a couple of comments: #66 ",
          "createdAt": "2022-05-18T15:46:38Z",
          "updatedAt": "2022-05-18T15:48:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc46Paw7",
          "commit": {
            "abbreviatedOid": "3df2725"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I agree that DST needs to be defined somewhere and that de-duplicating is desirable. However I don't think this change is at the right level of the \"stack\".\r\n\r\nTwo important things to note here:\r\n(1) Not every (V)DAF will necessarily have a DST that serves the same purpose.\r\n(2) Many DSTs will have a common prefix, e.g., \"vdaf-00\".\r\n\r\nPer (1) I don't think it makes sense to lift the DST to a parameter of the (V)DAF. \r\nPer (2) I think it's a good idea to define the common prefix somewhere.\r\n\r\nWhat do you think about this alternative:\r\n* Define somewhere in the document a global constant `VERSION` whose value is `vdaf-00`. Perhaps this could go in Section 2.\r\n* In the Prio3 definition, let `dst = VERSION + b\" prio3\"`.\r\n\r\n",
          "createdAt": "2022-05-18T14:54:54Z",
          "updatedAt": "2022-05-18T14:54:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 66,
      "id": "PR_kwDOGKuqOc44CXmG",
      "title": "Clarify that `dst` = domain separation tag",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/66",
      "state": "MERGED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-18T15:47:47Z",
      "updatedAt": "2022-05-18T16:05:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "3888d46adb568c5ea8e6d276524954172e92d4c6",
      "headRepository": "tgeoghegan/vdaf",
      "headRefName": "timg/dst-comment",
      "headRefOid": "16ed69280261cbbf7038424458e91725ce07357b",
      "closedAt": "2022-05-18T15:49:04Z",
      "mergedAt": "2022-05-18T15:49:04Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "f2c70cc9547333945e287adbbd22ddd81d89a5be"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc46PwV9",
          "commit": {
            "abbreviatedOid": "16ed692"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-18T15:48:49Z",
          "updatedAt": "2022-05-18T15:48:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 69,
      "id": "PR_kwDOGKuqOc44EQxq",
      "title": "Add Aggregator ID to `Vdaf.prep()`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/69",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #68.\r\n\r\nThis allows DAFs to distinguish between different types of input shares\r\nwithout requiring the input shares themselves to encode the\r\ndistinguisher.",
      "createdAt": "2022-05-18T23:42:44Z",
      "updatedAt": "2022-05-26T14:58:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "6e1eb6fc296f92ec147c88d8c6e2e9139a1b0ceb",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/daf-agg-id",
      "headRefOid": "1a4614c4369d9521399917948c34fca1b71f24a2",
      "closedAt": "2022-05-19T20:45:59Z",
      "mergedAt": "2022-05-19T20:45:59Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "67f12eb900b5c6e7efe2e196eb752ad58044efe4"
      },
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe this also addresses #40, unless there's another spot in VDAF where the leader distinction matters.",
          "createdAt": "2022-05-19T14:37:39Z",
          "updatedAt": "2022-05-19T14:37:39Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think the aggregator ID adequately addresses that issue. The draft may need more guidance on generating input shares, as pointed out by @branlwyd: https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/40#issuecomment-1099719279",
          "createdAt": "2022-05-19T15:55:48Z",
          "updatedAt": "2022-05-19T15:57:35Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 70,
      "id": "PR_kwDOGKuqOc44Ej-H",
      "title": "editorial: Replace double quotes with single quotes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/70",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Backticks get rendered as double quotes in the plaintext version,\r\npotentially colliding with byte string literals in the spec, e.g.:\r\n\r\n    \"b\"vdaf-00\"\"\r\n\r\nBy using single quotes, we ensure this gets rendored instead as\r\n\r\n    \"b'vdaf'00'\"\r\n\r\nwhich is a bit clearer.\r\n\r\nWe may want to consider removing backticks altogether.",
      "createdAt": "2022-05-19T00:31:33Z",
      "updatedAt": "2022-05-26T14:58:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "b1fa888930d2eb6d1c1318ea6a0bfe3509078c27",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/editorial",
      "headRefOid": "4bdabec3af55cd6321c7595f1e4c20fd03baa63d",
      "closedAt": "2022-05-19T00:33:56Z",
      "mergedAt": "2022-05-19T00:33:56Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "6f46b822a760cb6c1ca5a083587719e79dd088d6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 71,
      "id": "PR_kwDOGKuqOc44ElYi",
      "title": "Define global `VERSION` for building domain separation tags",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/71",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #67.",
      "createdAt": "2022-05-19T00:35:33Z",
      "updatedAt": "2022-05-26T14:58:45Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "6f46b822a760cb6c1ca5a083587719e79dd088d6",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/global-vers",
      "headRefOid": "62ec407229b5544c4de947b23479cc1094276505",
      "closedAt": "2022-05-19T00:41:45Z",
      "mergedAt": "2022-05-19T00:41:45Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "180ffa005dcbf9d88341d104b81aef691c23bbd2"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 73,
      "id": "PR_kwDOGKuqOc44E0L0",
      "title": "Have `Vdaf.prep_init()` output first round prep share",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/73",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #60.\r\n\r\nNow that we have defined DAFs explicitly and removed the public\r\nparameter, there is no longer a need to support 0-round VDAFs. This\r\nchange codifies the requirement that ROUNDS >= 1 in the syntax.",
      "createdAt": "2022-05-19T01:11:52Z",
      "updatedAt": "2023-04-24T21:37:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "50e872c2f0d4c1f5cf4d60146bae57d0f8eaa1a6",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/refactor-prep-init",
      "headRefOid": "f3a6f421a37f118899569dc2af09fcc0da7021cf",
      "closedAt": "2022-05-25T17:24:08Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there a reason for requiring at least one verification round? I don't think it's immediately clear why the verification can't be non-interactive (e.g., the client provides separate NIZK proofs to each party).",
          "createdAt": "2022-05-19T21:01:27Z",
          "updatedAt": "2022-05-19T21:01:27Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is there a reason for requiring at least one verification round? I don't think it's immediately clear why the verification can't be non-interactive (e.g., the client provides separate NIZK proofs to each party).\r\n\r\nI agree it's not immediately clear. However, in particular for NIZKs I think the prover would need a public key, right?  In fact, the draft-00 anticipated adapting something like https://isi.jhu.edu/~mgreen/advertising.pdf into a 0-round VDAF. Such a scheme would have used the public parameter to encode one of the Aggregator's public key (whoever does the verifying).\r\n\r\nThe downside to making room for this hypothetical construction is extra complexity for applications: see https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/60#issuecomment-1130733568. At this point, my feeling is if we wanted to a VDAF that uses some form of public key crypto, it ought to be considered a different kind of object. Especially since it's likely to have different applications.\r\n\r\nIf someone comes along with a 0-round VDAF that doesn't use public key crypto, perhaps it would fit more or less into the new DAF syntax?\r\n\r\n",
          "createdAt": "2022-05-19T21:11:55Z",
          "updatedAt": "2022-05-19T21:12:21Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure we should exclude VDAFs based on public-key cryptography. I was under the assumption that the issue with the public parameter was that it would need to be frequently rotated. Even without it, I can imagine a spec for a VDAF that has some out-of-band mechanism of retrieving public keys.\r\n\r\nIn your linked comment, both solutions don't look very complex to me... Is there maybe a way to have the simpler interface you propose in #60 without prescribing at least one communication round between aggregators?\r\n",
          "createdAt": "2022-05-19T21:38:11Z",
          "updatedAt": "2022-05-19T21:38:11Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm not sure we should exclude VDAFs based on public-key cryptography. I was under the assumption that the issue with the public parameter was that it would need to be frequently rotated. Even without it, I can imagine a spec for a VDAF that has some out-of-band mechanism of retrieving public keys.\r\n\r\nI'm not suggesting we exclude this, I'm merely suggesting it can be treated as a different type of primitive, perhaps defined in this draft. Call it a PK-VDAF or something :)\r\n\r\n> In your linked comment, both solutions don't look very complex to me... Is there maybe a way to have the simpler interface you propose in #60 without prescribing at least one communication round between aggregators?\r\n\r\nMaybe! We can hold off on merging this if you want to spend some time thinking about it.\r\n",
          "createdAt": "2022-05-19T21:42:50Z",
          "updatedAt": "2022-05-19T21:42:50Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "FWIW, translating the vdaf-00 syntax into a Rust API unearthed at least one nasty edge case: In some applications it'll be necessary to serialize the Prepare state. (Concretely, consider a DAP helper, who needs to carry state across HTTP requests during the aggregation flow.) However it is never the case that you need to serialize the first state, since you immediately consume it to get the next output bound prep share. See https://github.com/divviup/libprio-rs/pull/218 for details.",
          "createdAt": "2022-05-19T21:47:51Z",
          "updatedAt": "2022-05-19T21:52:11Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> > I'm not sure we should exclude VDAFs based on public-key cryptography. I was under the assumption that the issue with the public parameter was that it would need to be frequently rotated. Even without it, I can imagine a spec for a VDAF that has some out-of-band mechanism of retrieving public keys.\r\n> \r\n> I'm not suggesting we exclude this, I'm merely suggesting it can be treated as a different type of primitive, perhaps defined in this draft. Call it a PK-VDAF or something :)\r\n\r\nWhat I mean is that VDAF should include any DAF that has a verification procedure, even if it's public-key or zero-round. Otherwise I'd worry that standards like DAP could over-optimize towards particular VDAFs and for example be incompatible with your proposed \"PK-VDAF\" or non-interactive verification. So in overall I'd prefer generality when it comes to the VDAF interface, to ensure compatibility of various VDAFs that might be developed in the future with the DAP infrastructure that is being developed right now.\r\n\r\n> However it is never the case that you need to serialize the first state, since you immediately consume it to get the next output bound prep share.\r\n\r\nI can see that this is a bit inefficient, although I don't think this will be a bottle neck in terms of performance. I guess one possibility would be to allow for an OPTIONAL combined function, but that seems like premature optimization to me.",
          "createdAt": "2022-05-23T16:36:26Z",
          "updatedAt": "2022-05-23T16:36:26Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> > I'm not suggesting we exclude this, I'm merely suggesting it can be treated as a different type of primitive, perhaps defined in this draft. Call it a PK-VDAF or something :)\r\n> \r\n> What I mean is that VDAF should include any DAF that has a verification procedure, even if it's public-key or zero-round. Otherwise I'd worry that standards like DAP could over-optimize towards particular VDAFs and for example be incompatible with your proposed \"PK-VDAF\" or non-interactive verification. So in overall I'd prefer generality when it comes to the VDAF interface, to ensure compatibility of various VDAFs that might be developed in the future with the DAP infrastructure that is being developed right now.\r\n\r\nAgreed, we absolutely want to plan for other applications beyond DAP (and even potentially PPM). From this perspective, I wonder if you feel like #62 was a regression after all? The concern would be that the syntax for input-share generation no longer includes an explicit public key.\r\n\r\n#62 solved a specific problem, which is to allow DAP to rotate the verification parameters without having to push a new public parameter to the clients. The need to do so is inherent to a potential public-key VDAF, but not to the VDAFs we have today. The natural question to ask ourselves here is: At what point do we specialize syntax for specific classes of constructions?\r\n\r\nSo far we have addressed this question on a case-by-case basis, which I think is right. My rule of thumb is basically: \"specialize as soon as the generalization creates a rough edge\". In the case of #62, the rough edge was key distribution having different requirements for public-key and non-public-key schemes. Were we to add support for the latter into DAP, I think it would make sense to consider this an alternative \"mode of operation\" for the protocol.\r\n\r\n> > However it is never the case that you need to serialize the first state, since you immediately consume it to get the next output bound prep share.\r\n> \r\n> I can see that this is a bit inefficient, although I don't think this will be a bottle neck in terms of performance. I guess one possibility would be to allow for an OPTIONAL combined function, but that seems like premature optimization to me.\r\n\r\nI agree that would be premature, and to be honest this isn't a problem we need to solve in the VDAF spec. It would be sufficient to make a note about this somewhere, e.g.:\r\n\r\n```\r\nImplementation note: For VDAFs with one round or more, it is necessary in some applications to serialize the Aggregator's Prepare state so that it can be stored while the Aggregator awaits a prepare message from the network. However it is not necessary to serialize the output of `prep_init()`, but only the output of of `prep_next()`.\r\n```",
          "createdAt": "2022-05-24T18:24:16Z",
          "updatedAt": "2022-05-24T18:24:16Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed in favor of #78.",
          "createdAt": "2022-05-25T17:24:08Z",
          "updatedAt": "2022-05-25T17:24:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc46UjtX",
          "commit": {
            "abbreviatedOid": "46d99bf"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-19T12:17:02Z",
          "updatedAt": "2022-05-19T12:17:18Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Nit: I would adjust this so that the `...` is vertically centered between the boxes",
              "createdAt": "2022-05-19T12:17:03Z",
              "updatedAt": "2022-05-19T12:17:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc46XfC8",
          "commit": {
            "abbreviatedOid": "46d99bf"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T20:36:39Z",
          "updatedAt": "2022-05-19T20:36:39Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Done.",
              "createdAt": "2022-05-19T20:36:39Z",
              "updatedAt": "2022-05-19T20:36:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 74,
      "id": "PR_kwDOGKuqOc44IEWZ",
      "title": "poc: Add test for expand_into_vec rejection sampling",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/74",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The inputs for this test were chosen through a brute-force search, so that they exercise the rejection sampling logic.\r\n\r\nI will be submitting PRs with the same test vector to the Rust and TypeScript implementations.",
      "createdAt": "2022-05-19T14:35:18Z",
      "updatedAt": "2022-06-02T16:36:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "67f12eb900b5c6e7efe2e196eb752ad58044efe4",
      "headRepository": "divergentdave/vdaf",
      "headRefName": "rejection-sampling-test",
      "headRefOid": "e59c66f95c68db4a2e160ed761345cd3c741e2f5",
      "closedAt": "2022-05-19T20:55:19Z",
      "mergedAt": "2022-05-19T20:55:19Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "222517a6dc72870924236dd0e6c60c4092c4aa94"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc46V1Vx",
          "commit": {
            "abbreviatedOid": "39cf430"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Nice! One minor ask.",
          "createdAt": "2022-05-19T15:30:41Z",
          "updatedAt": "2022-05-19T15:30:50Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Would you mind copy-pasting this comment here? https://github.com/divviup/libprio-rs/pull/222/files#diff-ee53018b069fa1ccd59e63911e683c27b728af0963b465436b100019b691808eR192-R193",
              "createdAt": "2022-05-19T15:30:41Z",
              "updatedAt": "2022-05-19T15:30:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc46WRKs",
          "commit": {
            "abbreviatedOid": "5c401bf"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Perfect! Please squash changes into a single commit, and I'll merge.",
          "createdAt": "2022-05-19T16:50:06Z",
          "updatedAt": "2022-05-19T16:50:06Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc46XjpK",
          "commit": {
            "abbreviatedOid": "e59c66f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-19T20:55:12Z",
          "updatedAt": "2022-05-19T20:55:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 75,
      "id": "PR_kwDOGKuqOc44JyiW",
      "title": "Specify encoding of aggregate shares",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/75",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-01"
      ],
      "body": "Removes the associated type `AggShare` from `Vdaf` and `Daf` and\r\nmodifies the syntax to treat the aggregate share as an opauqe byte\r\nstring. This is consistent with input shares, which, like the aggregate\r\nshare, are ncessarily transmitted over the network.\r\n\r\nThis partially addresses #58. In the future we may want to define a type\r\nfor every quantity and have that type implement a type whereever\r\napplicable. Or we might decide not to be prescriptive about encoding at\r\nall.\r\n\r\ncc/ @tgeoghegan",
      "createdAt": "2022-05-19T22:53:29Z",
      "updatedAt": "2022-05-26T14:57:54Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "222517a6dc72870924236dd0e6c60c4092c4aa94",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/agg-share-encoding",
      "headRefOid": "b230f1b9b615aaacdf8a6506b3c0a762441d3dd7",
      "closedAt": "2022-05-24T15:06:50Z",
      "mergedAt": "2022-05-24T15:06:50Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "b3f8a8c3f7f457ebf33ca74ea1f0a8346f6eace0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc46hm6Q",
          "commit": {
            "abbreviatedOid": "a7752a4"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-23T14:41:09Z",
          "updatedAt": "2022-05-23T16:23:01Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "```suggestion\r\n    # aggregate result. This is called by the Collector.\r\n```",
              "createdAt": "2022-05-23T14:41:09Z",
              "updatedAt": "2022-05-23T16:23:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 76,
      "id": "PR_kwDOGKuqOc44aATm",
      "title": "Update VERSION and test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/76",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #72.",
      "createdAt": "2022-05-25T02:18:20Z",
      "updatedAt": "2022-05-26T14:57:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "90c7438a25ade85e0ace93d9dcc2044a4be9b753",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/update-test-vec",
      "headRefOid": "f1751a945343db53fa24bbe00eac3159dcaedeb5",
      "closedAt": "2022-05-25T16:17:14Z",
      "mergedAt": "2022-05-25T16:17:13Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "799f16f1e920a4b16b2dcc7557eddef74d1fa6fa"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 78,
      "id": "PR_kwDOGKuqOc44dkC4",
      "title": "Close #60 by doing nothing",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/78",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #60.\r\n\r\nThis issue touches on a broader question, which is how to account for a\r\nvariety of different cryptographic techniques while minimizing burden\r\nfor applications. This question is tracked by #77.",
      "createdAt": "2022-05-25T17:22:47Z",
      "updatedAt": "2022-05-26T14:57:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "799f16f1e920a4b16b2dcc7557eddef74d1fa6fa",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/issue60",
      "headRefOid": "6bbc8f1a39bce7ddfcbc6856590051356038ed54",
      "closedAt": "2022-05-25T17:29:06Z",
      "mergedAt": "2022-05-25T17:29:06Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "481f48e7cec9c7509a6eedcf000ff4a2e84358c7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc46uSZV",
          "commit": {
            "abbreviatedOid": "6bbc8f1"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-25T17:27:52Z",
          "updatedAt": "2022-05-25T17:27:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 79,
      "id": "PR_kwDOGKuqOc44epwe",
      "title": "Change log and various editorial changes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/79",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #72.",
      "createdAt": "2022-05-25T21:23:57Z",
      "updatedAt": "2022-05-26T14:57:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "7a8ca7b5af8af043806c753207cd518a14c84a43",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/01-edit",
      "headRefOid": "760c2d559a14b78727e0ab58ebfff35abcb12507",
      "closedAt": "2022-05-26T14:09:46Z",
      "mergedAt": "2022-05-26T14:09:46Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "a6eb2bc7558d719db6867e753f4808bacb7765ee"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 80,
      "id": "PR_kwDOGKuqOc44iAiz",
      "title": "End each test vector file with a newline",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/80",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc/ @tgeoghegan ",
      "createdAt": "2022-05-26T16:10:33Z",
      "updatedAt": "2022-08-26T18:34:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "3629f1adda261270adaa59fbe1e6713fc5980e14",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/test-vec-newline",
      "headRefOid": "f1e136774822c863fd9b9ae59031e4d7e12de561",
      "closedAt": "2022-05-26T16:28:51Z",
      "mergedAt": "2022-05-26T16:28:51Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "7c58b042d84d46e34b8d41f8deb663670a17a665"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc46zHTA",
          "commit": {
            "abbreviatedOid": "f1e1367"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-26T16:23:52Z",
          "updatedAt": "2022-05-26T16:23:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 81,
      "id": "PR_kwDOGKuqOc44qP3F",
      "title": "Small editorial changes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/81",
      "state": "MERGED",
      "author": "simon-friedberger",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Really just nits",
      "createdAt": "2022-05-30T07:07:00Z",
      "updatedAt": "2022-05-31T15:14:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "7c58b042d84d46e34b8d41f8deb663670a17a665",
      "headRepository": null,
      "headRefName": "main",
      "headRefOid": "313a0ce1a2f3ab41cde9dfb203cd92e6f63e2fee",
      "closedAt": "2022-05-31T15:14:06Z",
      "mergedAt": "2022-05-31T15:14:06Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "ed9b9043f362cb64be8bd6364be9f8e43f8a14b8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc47Cihr",
          "commit": {
            "abbreviatedOid": "313a0ce"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-31T14:06:59Z",
          "updatedAt": "2022-05-31T14:06:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc47C_MM",
          "commit": {
            "abbreviatedOid": "313a0ce"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-31T15:12:10Z",
          "updatedAt": "2022-05-31T15:12:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 85,
      "id": "PR_kwDOGKuqOc45qXPm",
      "title": "poc: Define syntax for IDPFs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/85",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #84.",
      "createdAt": "2022-06-14T20:55:38Z",
      "updatedAt": "2022-06-16T18:57:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "7ad9f0e5c94240674a5881a188bc9aba133353f9",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/idpf-1",
      "headRefOid": "381d8e808549820b0ff74afb134e8099831be38a",
      "closedAt": "2022-06-16T18:57:22Z",
      "mergedAt": "2022-06-16T18:57:22Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "40198da9b45b16eb93d891a6847baa6ce512ff78"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "FYI, I pushed some minor changes to the syntax (https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/85/commits/447b04ca40686a0a951321a4ed68a3a4fdd6fb2d that resulted from having implemented the Poplar IDPF. I will squash the commit once the PR is approved.",
          "createdAt": "2022-06-16T01:44:26Z",
          "updatedAt": "2022-06-16T01:49:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc47_ytG",
          "commit": {
            "abbreviatedOid": "6b41b4a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-14T21:02:01Z",
          "updatedAt": "2022-06-14T21:02:02Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "@schoppmp we had previously talked about allowing each level of the hierarchy to have its own field. I decided to just define two fields, one for the leaves and another for the inner nodes. That's sufficient to admit the construction on the Poplar paper. Do you think more flexibility will be desirable?\r\n\r\nRemoving this flexibility seems useful for keeping things simple.",
              "createdAt": "2022-06-14T21:02:01Z",
              "updatedAt": "2022-06-14T21:02:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48CXj8",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T10:25:32Z",
          "updatedAt": "2022-06-15T13:26:24Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "If it makes things easier, let's stick to two fields.",
              "createdAt": "2022-06-15T10:25:33Z",
              "updatedAt": "2022-06-15T13:26:24Z"
            },
            {
              "originalPosition": 11,
              "body": "Is this assuming that there could be an IDPF with >2 shares?",
              "createdAt": "2022-06-15T10:27:05Z",
              "updatedAt": "2022-06-15T13:26:24Z"
            },
            {
              "originalPosition": 46,
              "body": "How do you plan to implement this? I'm asking because it might make sense to keep intermediate state for the prefixes (i.e., the inner nodes in the DPF evaluation tree). Alternatively, you can always evaluate from the root, but then the total runtime for evaluating all levels sequentially will be quadratic in the number of levels.",
              "createdAt": "2022-06-15T13:25:52Z",
              "updatedAt": "2022-06-15T13:26:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48A6x4",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Here are some typo fixes:",
          "createdAt": "2022-06-15T05:11:10Z",
          "updatedAt": "2022-06-15T14:58:25Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\n    # The finite field used to represent the inner nodes of the IDPF tree.\r\n```",
              "createdAt": "2022-06-15T05:11:10Z",
              "updatedAt": "2022-06-15T14:58:25Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\n    # The type of each key generated by the IDPF-key generation algorithm.\r\n```",
              "createdAt": "2022-06-15T05:11:29Z",
              "updatedAt": "2022-06-15T14:58:25Z"
            },
            {
              "originalPosition": 51,
              "body": "```suggestion\r\n    # An error is raised if any element of `prefixes` is larger than or equal to\r\n```",
              "createdAt": "2022-06-15T05:14:28Z",
              "updatedAt": "2022-06-15T14:58:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48Eacm",
          "commit": {
            "abbreviatedOid": "04f9850"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T16:18:53Z",
          "updatedAt": "2022-06-15T16:20:54Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Yes. Of course for the Poplar IDPF, `SHARES == 2`.\r\n\r\n",
              "createdAt": "2022-06-15T16:18:53Z",
              "updatedAt": "2022-06-15T16:20:54Z"
            },
            {
              "originalPosition": 46,
              "body": "I'm planning on translating Figure 11 more or less directly, including carving out an explicit `EvalNext()` function. In the spec we will certainly want to note that implementations will typically make use of this stateful functionality.",
              "createdAt": "2022-06-15T16:20:38Z",
              "updatedAt": "2022-06-15T16:20:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48EiLP",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T16:43:21Z",
          "updatedAt": "2022-06-15T16:43:22Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Does that mean that `eval_inner` with this signature will usually not be called, and instead people will call `eval_next`? Then why specify `eval_inner`?",
              "createdAt": "2022-06-15T16:43:22Z",
              "updatedAt": "2022-06-15T16:43:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48Ek6N",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T16:52:27Z",
          "updatedAt": "2022-06-15T16:52:27Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Hmm, good question. I suppose `eval_next()` will return either field type, depending on the value of `level`. Under the hood, both `eval_inner()` and `eval_leaf()` will call `eval_next()` some number of times.\r\n\r\nPerhaps it would make sense to just unify `eval_inner()` and `eval_leaf()` into one function that returns either field type, as in the paper. Thinking about the eventual Poplar1 spec, I think this would be a bit awkward.",
              "createdAt": "2022-06-15T16:52:27Z",
              "updatedAt": "2022-06-15T16:52:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48ErV_",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T17:13:33Z",
          "updatedAt": "2022-06-15T17:13:33Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> Perhaps it would make sense to just unify eval_inner() and eval_leaf() into one function that returns either field type, as in the paper. Thinking about the eventual Poplar1 spec, I think this would be a bit awkward.\r\n\r\nI think it's fine to have two functions for the two fields (in C++ I used a single templated function, I guess generics would work in Rust as well).\r\n\r\n> Under the hood, both eval_inner() and eval_leaf() will call eval_next() some number of times.\r\n\r\nMy point is that if you want to have a sequence of calls `eval_inner(key, 1, ...)`,  `eval_inner(key, 2, ...)`, ..., `eval_leaf(key, ...)`, the number of calls you'd have to make to `eval_next` would be quadratic in the number of levels if you don't save state between the `eval_inner` calls and pass it to the next call.\r\n",
              "createdAt": "2022-06-15T17:13:33Z",
              "updatedAt": "2022-06-15T17:13:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48Eule",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T17:23:19Z",
          "updatedAt": "2022-06-15T17:23:19Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Right, but the question is whether to address this in the syntax (by having `eval_inner()` output state to use in the next round) or leave to implementations. It sounds like you'd prefer the former?\r\n\r\nI'm good either way, though I have a weak preference for the latter, since it's slightly easier to present. One thing to keep in mind is that the VDAF syntax isn't stateful, so `Poplar1.prep_init()` will take as input a set of candidate prefixes and will end up with the quadratic explosion. Thus we will need to make a note there that `Poplar1` SHOULD be implemented in a way that avoids this.",
              "createdAt": "2022-06-15T17:23:19Z",
              "updatedAt": "2022-06-15T17:24:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48Ev9E",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T17:27:57Z",
          "updatedAt": "2022-06-15T17:27:57Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Remember that for the reference implementation we're after the clearest implementation, not necessarily the most efficient.",
              "createdAt": "2022-06-15T17:27:57Z",
              "updatedAt": "2022-06-15T17:27:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48E5tb",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T18:01:12Z",
          "updatedAt": "2022-06-15T18:01:13Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> Thus we will need to make a note there that Poplar1 SHOULD be implemented in a way that avoids this.\r\n\r\nCan you elaborate on how you'd implement this optimized version?\r\n\r\nI was thinking of passing the state into and out of the VDAF interface by appropriately defined input/output shares. In fact, in the C++ DPF library, I use an [`EvaluationContext`](https://github.com/google/distributed_point_functions/blob/0f7f758d2c67092c05a3b93ff4ae9ad00cca1487/dpf/distributed_point_function.proto#L156=) object as the input to [`EvaluateNext`](https://github.com/google/distributed_point_functions/blob/0f7f758d2c67092c05a3b93ff4ae9ad00cca1487/dpf/distributed_point_function.h#L307=)/[`EvaluateUntil`](https://github.com/google/distributed_point_functions/blob/0f7f758d2c67092c05a3b93ff4ae9ad00cca1487/dpf/distributed_point_function.h#L302=), which wraps a [`DpfKey`](https://github.com/google/distributed_point_functions/blob/0f7f758d2c67092c05a3b93ff4ae9ad00cca1487/dpf/distributed_point_function.proto#L129=) and additionally keeps state between iterations.\r\n\r\n> Remember that for the reference implementation we're after the clearest implementation, not necessarily the most efficient.\r\n\r\nAgreed, let's focus on simplicity and clarity over speed in the reference implementation. I just want to make sure that we don't rule out these efficient implementations via the syntax.",
              "createdAt": "2022-06-15T18:01:13Z",
              "updatedAt": "2022-06-15T18:01:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48E85c",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T18:12:48Z",
          "updatedAt": "2022-06-15T18:12:48Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> Can you elaborate on how you'd implement this optimized version?\r\n> \r\n> I was thinking of passing the state into and out of the VDAF interface by appropriately defined input/output shares. In fact, in the C++ DPF library, I use an [`EvaluationContext`](https://github.com/google/distributed_point_functions/blob/0f7f758d2c67092c05a3b93ff4ae9ad00cca1487/dpf/distributed_point_function.proto#L156=) object as the input to [`EvaluateNext`](https://github.com/google/distributed_point_functions/blob/0f7f758d2c67092c05a3b93ff4ae9ad00cca1487/dpf/distributed_point_function.h#L307=)/[`EvaluateUntil`](https://github.com/google/distributed_point_functions/blob/0f7f758d2c67092c05a3b93ff4ae9ad00cca1487/dpf/distributed_point_function.h#L302=), which wraps a [`DpfKey`](https://github.com/google/distributed_point_functions/blob/0f7f758d2c67092c05a3b93ff4ae9ad00cca1487/dpf/distributed_point_function.proto#L129=) and additionally keeps state between iterations.\r\n\r\nYeah this is more or less what I would do in an efficient implementation of `Poplar1`. The [current API for libprio-rs](https://github.com/divviup/libprio-rs/blob/main/src/vdaf.rs#L164-L174) is too strict and will need to be changed in order to allow `prepare_init()` to to update this `EvaluationContext`.",
              "createdAt": "2022-06-15T18:12:48Z",
              "updatedAt": "2022-06-15T18:12:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48IiBk",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T11:00:50Z",
          "updatedAt": "2022-06-16T11:00:50Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Okay, as long as this can still be implemented while being standard-compliant, I'm fine with it.",
              "createdAt": "2022-06-16T11:00:50Z",
              "updatedAt": "2022-06-16T11:00:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48IiWr",
          "commit": {
            "abbreviatedOid": "f5c0bf6"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T11:02:08Z",
          "updatedAt": "2022-06-16T11:03:44Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Does `Unsigned` here have a limit on the bit length? For large domains (e.g. 256 bits), `Bytes` might be more appropriate.",
              "createdAt": "2022-06-16T11:02:08Z",
              "updatedAt": "2022-06-16T11:03:44Z"
            },
            {
              "originalPosition": 42,
              "body": "Is there a particular reason for this change? It forces the caller to repeatedly deserialize `key`, right?",
              "createdAt": "2022-06-16T11:03:40Z",
              "updatedAt": "2022-06-16T11:03:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48JteE",
          "commit": {
            "abbreviatedOid": "f5c0bf6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T14:55:22Z",
          "updatedAt": "2022-06-16T14:55:22Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "No it doesn't. This seemed like a reasonable way to represent the input string and candidate prefixes, but I'm open to alternatives. One concern I have about `Bytes` is that we need to represent bit strings whose length are not a multiple of 8.\r\n\r\nOf course, the input string and prefixes need not have the same type. We could have the input string be `Bytes` (this will be perfectly fine for most applications, if not all) and we could define the candidate prefixes as `Unsigned` (and leave it to implementations to deal with larger domains).",
              "createdAt": "2022-06-16T14:55:22Z",
              "updatedAt": "2022-06-16T14:55:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48JuFL",
          "commit": {
            "abbreviatedOid": "f5c0bf6"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T14:56:59Z",
          "updatedAt": "2022-06-16T14:57:00Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Alright, if `Unsigned` doesn't have a limit then let's keep it, I agree that being able to specify the bit-length makes it a better choice than `Bytes`.",
              "createdAt": "2022-06-16T14:56:59Z",
              "updatedAt": "2022-06-16T14:57:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48Ju9r",
          "commit": {
            "abbreviatedOid": "f5c0bf6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T14:59:16Z",
          "updatedAt": "2022-06-16T14:59:16Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "This is consistent with the (current) convention that anything that needs to be written to the network is dealt with explicitly as a `Bytes`. We might change this convention in the future, see https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/58. In any case, I think it's reasonable to leave this to implementations.",
              "createdAt": "2022-06-16T14:59:16Z",
              "updatedAt": "2022-06-16T14:59:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48JwJo",
          "commit": {
            "abbreviatedOid": "f5c0bf6"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T15:02:29Z",
          "updatedAt": "2022-06-16T15:02:29Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "SG",
              "createdAt": "2022-06-16T15:02:29Z",
              "updatedAt": "2022-06-16T15:02:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48JwV5",
          "commit": {
            "abbreviatedOid": "f5c0bf6"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-16T15:03:01Z",
          "updatedAt": "2022-06-16T15:03:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 86,
      "id": "PR_kwDOGKuqOc45vuQ6",
      "title": "poc: Add `OUT_LEN` parameter to IDPF syntax",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/86",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #85 (merge that first).\r\n\r\nSpecifies that the output type is a vector over a finite field. This\r\nallows IDPFs to be specified that are more naturally integrated with the\r\nPoplar secure sketching scheme where one of the programmed outputs is\r\n`1` and the other is a random \"authenticator\" value.",
      "createdAt": "2022-06-16T02:46:27Z",
      "updatedAt": "2022-08-26T18:34:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "cjpatton/idpf-1",
      "baseRefOid": "381d8e808549820b0ff74afb134e8099831be38a",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/idpf-2",
      "headRefOid": "579bc3666311d36bea72062ae53a3ad29c61116d",
      "closedAt": "2022-06-16T18:59:11Z",
      "mergedAt": "2022-06-16T18:59:10Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "fbf37e01440ddc1ee51198d2e2a4fa9b467ea4c3"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Merged into the wrong branch!",
          "createdAt": "2022-06-16T19:02:48Z",
          "updatedAt": "2022-06-16T19:02:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc48JECD",
          "commit": {
            "abbreviatedOid": "e7e20a0"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T13:04:45Z",
          "updatedAt": "2022-06-16T13:06:03Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Doesn't the output length depend on the number of prefixes? Or is this to support tuples as values?",
              "createdAt": "2022-06-16T13:04:46Z",
              "updatedAt": "2022-06-16T13:06:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48JvP0",
          "commit": {
            "abbreviatedOid": "e7e20a0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T14:59:58Z",
          "updatedAt": "2022-06-16T14:59:58Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "This is to support tuples as values. I guess the comments need to be clearer ...",
              "createdAt": "2022-06-16T14:59:58Z",
              "updatedAt": "2022-06-16T14:59:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48Jw4L",
          "commit": {
            "abbreviatedOid": "e7e20a0"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T15:04:34Z",
          "updatedAt": "2022-06-16T15:04:34Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Maybe call it `VALUE_LEN` then, since it's the length of one output value, not the entire output?",
              "createdAt": "2022-06-16T15:04:34Z",
              "updatedAt": "2022-06-16T15:04:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48Jw9B",
          "commit": {
            "abbreviatedOid": "e7e20a0"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-16T15:04:46Z",
          "updatedAt": "2022-06-16T15:04:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc48JxOF",
          "commit": {
            "abbreviatedOid": "e7e20a0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T15:05:30Z",
          "updatedAt": "2022-06-16T15:05:31Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Oh that's better.",
              "createdAt": "2022-06-16T15:05:30Z",
              "updatedAt": "2022-06-16T15:05:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48LJS8",
          "commit": {
            "abbreviatedOid": "e7e20a0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T18:58:47Z",
          "updatedAt": "2022-06-16T18:58:47Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Done.",
              "createdAt": "2022-06-16T18:58:47Z",
              "updatedAt": "2022-06-16T18:58:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 87,
      "id": "PR_kwDOGKuqOc45zD9b",
      "title": "poc: Add `VALUE_LEN` parameter to IDPF syntax",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/87",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Specifies that the output type is a vector over a finite field. This\r\nallows IDPFs to be defined that are more naturally integrated with the\r\nPoplar secure sketching scheme.",
      "createdAt": "2022-06-16T19:05:22Z",
      "updatedAt": "2022-08-26T18:34:29Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "40198da9b45b16eb93d891a6847baa6ce512ff78",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/idpf-2-retry",
      "headRefOid": "3c3049a5f1fd09c9411b4bc8dba9d0edd3edb2b4",
      "closedAt": "2022-06-16T19:08:41Z",
      "mergedAt": "2022-06-16T19:08:41Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "485e7c4cab08f0d0a1a763b423b265f222ba832e"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Replaces https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/86, which I merged into the wrong branch.",
          "createdAt": "2022-06-16T19:05:50Z",
          "updatedAt": "2022-06-16T19:06:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 88,
      "id": "PR_kwDOGKuqOc45z_cv",
      "title": "poc: Implement the Poplar IDPF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/88",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #22.\r\nPartially addresses #84.\r\n\r\n\r\nImplement the Poplar IDPF, extended to allow the outputs to be tuples.\r\nThis required a few minor changes:\r\n\r\n* Extend the IPDF syntax so that `eval()` takes as input the Aggregator\r\n  ID. (This would be passed via `Poplar1.prep_init()`.)\r\n\r\n* Refactor `Prg` by adding a derived method, `next_vec()`, that outputs\r\n  a vector of field elements and updates the PRG state.\r\n\r\n* Allow fields to be defined that aren't suitable for FFT.",
      "createdAt": "2022-06-17T00:07:07Z",
      "updatedAt": "2022-08-26T18:34:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "3a4a167c1696b18c2f2dbf2b197b1e5428e6d619",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/idpf-3",
      "headRefOid": "abc10d841d69926c8bd4960027a39f5dd091c340",
      "closedAt": "2022-06-22T15:19:38Z",
      "mergedAt": "2022-06-22T15:19:37Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "e74218c3551f58e6c28b912ce4e2b59b1bb2c157"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc48MUkr",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-17T00:15:05Z",
          "updatedAt": "2022-06-17T00:15:05Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "@armfazh I was hoping you can double check that the encoding we specify here for `GF(2^255-19)` will be convenient for existing implementations of this field.",
              "createdAt": "2022-06-17T00:15:05Z",
              "updatedAt": "2022-06-17T00:15:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48MUto",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-17T00:16:32Z",
          "updatedAt": "2022-06-17T00:16:32Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "See `Field.encode_vec()` in `field.sage` for the encoding.",
              "createdAt": "2022-06-17T00:16:32Z",
              "updatedAt": "2022-06-17T00:16:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48MWAb",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-17T00:29:23Z",
          "updatedAt": "2022-06-17T00:29:23Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "that function is using I2OSP, which is an encoding in big-endian format, while most implementations of Fp25519 use little-endian format.\r\nRelated: there is no check while decoding whether the numbers are fully reduced mod p.",
              "createdAt": "2022-06-17T00:29:23Z",
              "updatedAt": "2022-06-17T00:29:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48MXBT",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-17T00:39:54Z",
          "updatedAt": "2022-06-17T00:39:54Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "* Do you think it would be worth going to little-endian for compaitibility with existing implementations? Did you consider this in the hash-to-curve draft?\r\n* Good point about checking that the inputs are reduced mod p. Raised https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/89.",
              "createdAt": "2022-06-17T00:39:54Z",
              "updatedAt": "2022-06-17T00:39:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48QDQB",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-17T17:27:39Z",
          "updatedAt": "2022-06-17T17:27:40Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Ok, if we decide to use Fp25519 (as opposed to some other field of similar size), then we'll have to make accommodations. I will file an issue once this PR lands.",
              "createdAt": "2022-06-17T17:27:39Z",
              "updatedAt": "2022-06-17T17:27:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48QDwB",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-17T17:29:51Z",
          "updatedAt": "2022-06-17T17:29:51Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Precedent (thanks @armfazh): https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-voprf#section-4.1.1",
              "createdAt": "2022-06-17T17:29:51Z",
              "updatedAt": "2022-06-17T17:29:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48QD2Q",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-17T17:30:16Z",
          "updatedAt": "2022-06-17T17:30:17Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "For example, in the [VOPRF draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-voprf#section-4.1.1), it is considered the encoding of fp25519 as little-endian.",
              "createdAt": "2022-06-17T17:30:16Z",
              "updatedAt": "2022-06-17T17:30:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48OAcL",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-17T10:15:35Z",
          "updatedAt": "2022-06-20T16:23:05Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I don't think this is computing \"the smallest power of 2 that is larger than or equal to n\".",
              "createdAt": "2022-06-17T10:15:35Z",
              "updatedAt": "2022-06-20T16:23:06Z"
            },
            {
              "originalPosition": 27,
              "body": "Here, \"prefix\" means bits starting from least significant to most significant, right? This should be explicitly documented.\r\nAlso, it seems like this just ignores the higher-level bits of `prefix`, so `is_prefix(0xABCD, 0xDECD, 1)` would return `True` (which might be intentional but again should be documented).",
              "createdAt": "2022-06-20T11:37:30Z",
              "updatedAt": "2022-06-20T16:23:06Z"
            },
            {
              "originalPosition": 65,
              "body": "... or too short",
              "createdAt": "2022-06-20T13:29:25Z",
              "updatedAt": "2022-06-20T16:23:06Z"
            },
            {
              "originalPosition": 58,
              "body": "Since we have a PRG with arbitrary stretch, we could go with the variant described in the last paragraph of Section C.2 in the paper. That is, instead of expanding the seed into two seeds and then expanding one seed to a group element and the \"actual\" seed again, we can generate the group element (of the current level) in parallel with the expansion of seeds for the next level. This saves at least one AES call per expansion. It's probably more relevant for `eval` than `gen`, but has to be considered in both places since the two variants are incompatible. This incompatibility also means that this needs to be decided sooner rather than later, unless we want to standardize both variants.",
              "createdAt": "2022-06-20T13:47:26Z",
              "updatedAt": "2022-06-20T16:23:06Z"
            },
            {
              "originalPosition": 83,
              "body": "Can you add a comment to the base class documentation what exactly the elements in `prefixes` are?",
              "createdAt": "2022-06-20T15:46:22Z",
              "updatedAt": "2022-06-20T16:23:06Z"
            },
            {
              "originalPosition": 27,
              "body": "One thing to consider is that with this notion of prefix, the leaves of the DPF tree do not enumerate the domain in order, but instead in bit-flipped order. I.e., the leftmost two leaves are 0 and 1 << l, not 0 and 1. This has implications for how the DPF evaluation depends on the location of non-zeros in the domain, i.e., how many non-zero prefixes you'll find in the part of the DPF evaluation trree close to the root.",
              "createdAt": "2022-06-20T15:53:04Z",
              "updatedAt": "2022-06-20T16:23:06Z"
            },
            {
              "originalPosition": 176,
              "body": "The fact that a part of the DPF keys is shared by aggregators has security implications for Poplar, so it would be good to emphasize this. If this is not enforced by the syntax (i.e., a malicious client could submit different correction words to the aggregators), then the aggregators need to check the CWs are the same at verification time.",
              "createdAt": "2022-06-20T16:21:23Z",
              "updatedAt": "2022-06-20T16:23:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48WrR3",
          "commit": {
            "abbreviatedOid": "429422e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-20T17:20:19Z",
          "updatedAt": "2022-06-20T22:40:34Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "It seems to work for n > 0:\r\n* Suppose 2^k-1 < n < 2^k for some k > 0. Then (n-1).nbits() = k, thus next_power_of_2(n) = 2^k.\r\n* Suppose n = 2^k for some k >= 0. Then (n-1).nbits() = k, thus next_power_of_2(n) = 2^k.\r\n\r\nNote that nbits() is the number of bits required to encode the number. For example, (2^32-1).nbits() would be 32, but 2^32.nbits() would be 33.\r\n\r\nI added an assertion that n > 0. For context, this needed to change because sage can't precisely compute log(n) / log(2) for elements of field as large as `GF(2^255-19)`.",
              "createdAt": "2022-06-20T17:20:19Z",
              "updatedAt": "2022-06-20T22:40:34Z"
            },
            {
              "originalPosition": 65,
              "body": "Done",
              "createdAt": "2022-06-20T17:40:35Z",
              "updatedAt": "2022-06-20T22:40:35Z"
            },
            {
              "originalPosition": 83,
              "body": "Done",
              "createdAt": "2022-06-20T20:26:06Z",
              "updatedAt": "2022-06-20T22:40:35Z"
            },
            {
              "originalPosition": 27,
              "body": "I've modified the code to traverse `alpha` beginning with the most significant bit. This leads to a more natural definition of \"prefix\", which has been updated.",
              "createdAt": "2022-06-20T20:29:03Z",
              "updatedAt": "2022-06-20T22:40:34Z"
            },
            {
              "originalPosition": 176,
              "body": "Do you have an attack in mind? I thought that the \"secure sketch\" scheme would handle this.\r\n\r\nIn any case, a syntactic change seems useful here. However unless this really is a security issue for Poplar1,  then I would say let's hold off and do it in a future PR.",
              "createdAt": "2022-06-20T21:28:07Z",
              "updatedAt": "2022-06-20T22:40:35Z"
            },
            {
              "originalPosition": 58,
              "body": "I think only one variant should be specified. I don't quite understand the optimization, but would be happy to consider it in a future PR. I've added a TODO to consider this later.\r\n\r\n",
              "createdAt": "2022-06-20T22:40:14Z",
              "updatedAt": "2022-06-20T22:40:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48Xqle",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T00:36:49Z",
          "updatedAt": "2022-06-21T00:36:50Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "@schoppmp if you have no objection to using this particular field, I will open an issue to discuss what to do about endianness. Basically our options are:\r\n1. Use big-endian for all fields (status quo). This seems \"standard\", but would be slightly inconvenient for anyone using an existing implementation of Fp25519.\r\n2. Use little-endian for all fields. My impression is that this would be somewhat non-standard, as many CFRG things use I2OSP() for encoding numbers.\r\n3. Allow each field to specify its own `encode_vec()`.\r\n4. If we decide to not be prescriptive about encoding (cf. #58), then this is a non-issue.",
              "createdAt": "2022-06-21T00:36:50Z",
              "updatedAt": "2022-06-21T00:36:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48aPiy",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T12:28:21Z",
          "updatedAt": "2022-06-21T12:28:22Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I have no objections to using this field.",
              "createdAt": "2022-06-21T12:28:21Z",
              "updatedAt": "2022-06-21T12:28:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48aQUd",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T12:30:36Z",
          "updatedAt": "2022-06-21T12:30:36Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "You are right, I somehow misread this as `(1<<(n-1)).nbits()`.",
              "createdAt": "2022-06-21T12:30:36Z",
              "updatedAt": "2022-06-21T12:30:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48aRES",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T12:32:48Z",
          "updatedAt": "2022-06-21T12:32:48Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I suggest adding parentheses or spaces, even though the operator precedence is pretty clear in this case.",
              "createdAt": "2022-06-21T12:32:48Z",
              "updatedAt": "2022-06-21T12:32:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48aSYV",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T12:36:31Z",
          "updatedAt": "2022-06-21T12:36:32Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "The security issue is described in Appendix D in the paper. Basically, a malicious client could create a DPF that has non-zero output in two location instead of one when the correction words given to each aggregator are different.",
              "createdAt": "2022-06-21T12:36:32Z",
              "updatedAt": "2022-06-21T12:36:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48aTAP",
          "commit": {
            "abbreviatedOid": "d3a7889"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T12:38:21Z",
          "updatedAt": "2022-06-21T13:56:29Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "As written in the older comment, I suggest adding parentheses:\r\n`2 ** ((n - 1).nbits())`",
              "createdAt": "2022-06-21T12:38:21Z",
              "updatedAt": "2022-06-21T13:56:29Z"
            },
            {
              "originalPosition": 16,
              "body": "Does the notion of \"most significant bit\" not depend on the integer type? I.e., for a 8-bit integer with value 6 (00000110), the MSB is 0, and it would not be a prefix of the 8-bit integer 25 (00011001). Maybe you can say \"is equal to the most significant `L` bits among the `BITS` least significant bits of `y`.\"? In that case, 6 would be a prefix of 25 again if `BITS == 5`.",
              "createdAt": "2022-06-21T12:46:28Z",
              "updatedAt": "2022-06-21T13:56:29Z"
            },
            {
              "originalPosition": 42,
              "body": "See above.",
              "createdAt": "2022-06-21T12:47:53Z",
              "updatedAt": "2022-06-21T13:56:29Z"
            },
            {
              "originalPosition": 45,
              "body": "Maybe add an assertion that `L >= IdpfPoplar.BITS` (or whatever error handling you want to use in this reference implementation)",
              "createdAt": "2022-06-21T12:49:45Z",
              "updatedAt": "2022-06-21T13:56:29Z"
            },
            {
              "originalPosition": 50,
              "body": "```suggestion\r\n    # the end of [BBCGGI21, Appendix C.3]. This could on average reduce the number of\r\n```",
              "createdAt": "2022-06-21T13:56:17Z",
              "updatedAt": "2022-06-21T13:56:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48dSbv",
          "commit": {
            "abbreviatedOid": "6572ae0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T22:22:08Z",
          "updatedAt": "2022-06-22T01:03:46Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Done.",
              "createdAt": "2022-06-21T22:22:08Z",
              "updatedAt": "2022-06-22T01:03:46Z"
            },
            {
              "originalPosition": 16,
              "body": "Nice catch. In fact we need to refine this a bit more, since we care about the `L` least significant bits of `x`. (See updated definition.)\r\n\r\nTaking a step back: Is this the right way to define prefixes? What's nice about it is that each prefix at tree level `level` can be expressed as an `L`-bit integer.",
              "createdAt": "2022-06-21T22:41:44Z",
              "updatedAt": "2022-06-22T01:03:46Z"
            },
            {
              "originalPosition": 42,
              "body": "Done.",
              "createdAt": "2022-06-21T22:41:52Z",
              "updatedAt": "2022-06-22T01:03:46Z"
            },
            {
              "originalPosition": 45,
              "body": "Added an assertion that `0 < L and L < IdpfPoplar.BITS`. I don't think this going to end up appearing in the spec (maybe it will?) so an `assert` is sufficient.",
              "createdAt": "2022-06-21T22:43:46Z",
              "updatedAt": "2022-06-22T01:03:46Z"
            },
            {
              "originalPosition": 23,
              "body": "Raised https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/90.",
              "createdAt": "2022-06-21T23:47:54Z",
              "updatedAt": "2022-06-22T01:03:46Z"
            },
            {
              "originalPosition": 58,
              "body": "Bump :)",
              "createdAt": "2022-06-21T23:48:11Z",
              "updatedAt": "2022-06-22T01:03:46Z"
            },
            {
              "originalPosition": 176,
              "body": "Got it, nice catch. Let's be sure to address this now. I crated https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/91 and rebased this PR on top.\r\n\r\nA potential way to solve this without syntax changes would be to have the Aggregators exchange the hash of the correction words during preparation. This seems a little hacky to me. Plus, as pointed out in the TODO encoding the correction words in each input share is wasteful.\r\n",
              "createdAt": "2022-06-21T23:51:02Z",
              "updatedAt": "2022-06-22T01:03:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48doUI",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T01:04:55Z",
          "updatedAt": "2022-06-22T01:04:56Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "I have rebase on top of #91. For your convenience, you can see the changes by looking at `git pull && git diff 6a51ac1..6572ae0`",
              "createdAt": "2022-06-22T01:04:56Z",
              "updatedAt": "2022-06-22T01:04:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48doW3",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T01:05:21Z",
          "updatedAt": "2022-06-22T01:05:21Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done.",
              "createdAt": "2022-06-22T01:05:21Z",
              "updatedAt": "2022-06-22T01:05:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48dpIH",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T01:10:11Z",
          "updatedAt": "2022-06-22T01:10:12Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Bump",
              "createdAt": "2022-06-22T01:10:11Z",
              "updatedAt": "2022-06-22T01:10:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48ficO",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T10:12:01Z",
          "updatedAt": "2022-06-22T10:12:01Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "The new definition of prefix sounds good.",
              "createdAt": "2022-06-22T10:12:01Z",
              "updatedAt": "2022-06-22T10:12:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48fijO",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T10:12:22Z",
          "updatedAt": "2022-06-22T10:12:22Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Sounds good.",
              "createdAt": "2022-06-22T10:12:22Z",
              "updatedAt": "2022-06-22T10:12:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48fj-L",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T10:16:31Z",
          "updatedAt": "2022-06-22T10:16:32Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Thanks! #91 looks good to me.",
              "createdAt": "2022-06-22T10:16:32Z",
              "updatedAt": "2022-06-22T10:16:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48fk0R",
          "commit": {
            "abbreviatedOid": "d3a7889"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T10:18:24Z",
          "updatedAt": "2022-06-22T10:18:24Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "> Taking a step back: Is this the right way to define prefixes? What's nice about it is that each prefix at tree level level can be expressed as an L-bit integer.\r\n\r\nI agree it's quite complicated, but I also haven't found an easier way to express it. Maybe if we went to a \"bit vector\" type instead of numbers for alpha and prefixes?",
              "createdAt": "2022-06-22T10:18:24Z",
              "updatedAt": "2022-06-22T10:18:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48ftf8",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T10:43:43Z",
          "updatedAt": "2022-06-22T10:43:44Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "> For your convenience, you can see the changes by looking at git pull && git diff 6a51ac1..6572ae0\r\n\r\nThis doesn't work for me, as `6a51ac1` is not part of any active branch (I hadn't pulled the previous version).\r\nWould it work to defer rebasing until the commit is fully reviewed? Then the GH web interface shows the diff nicely.",
              "createdAt": "2022-06-22T10:43:44Z",
              "updatedAt": "2022-06-22T10:43:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48fttX",
          "commit": {
            "abbreviatedOid": "d3a7889"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T10:44:28Z",
          "updatedAt": "2022-06-22T10:44:28Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Either way I think this can be addressed in a future PR.",
              "createdAt": "2022-06-22T10:44:28Z",
              "updatedAt": "2022-06-22T10:44:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48ft1l",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T10:44:56Z",
          "updatedAt": "2022-06-22T10:44:57Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Either way, this PR looks good assuming no substantial changes beyond what's commented on.",
              "createdAt": "2022-06-22T10:44:57Z",
              "updatedAt": "2022-06-22T10:44:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48ft6y",
          "commit": {
            "abbreviatedOid": "6572ae0"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-22T10:45:13Z",
          "updatedAt": "2022-06-22T10:45:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc48hYVU",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T15:15:43Z",
          "updatedAt": "2022-06-22T15:15:44Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Ohhh, `6a51ac1` only exists in my reflog. I thought pushing would have also pushed that head.\r\n\r\nI typically try to hold off on rebasing until review is done, but in this instance we needed to rebase on #91. This would all be much easier if we had Gerrit..\r\n\r\nIn any case, there were no significant changes. Here's the patch:\r\n```\r\ndiff --git a/poc/idpf.sage b/poc/idpf.sage\r\nindex 4191c4f..e95637f 100644\r\n--- a/poc/idpf.sage\r\n+++ b/poc/idpf.sage\r\n@@ -91,7 +91,7 @@ def test_idpf_exhaustive(Idpf, alpha):\r\n     beta_leaf = Idpf.FieldLeaf.rand_vec(Idpf.VALUE_LEN)\r\n\r\n     # Generate the IDPF keys.\r\n-    keys = Idpf.gen(alpha, beta_inner, beta_leaf)\r\n+    (public_share, keys) = Idpf.gen(alpha, beta_inner, beta_leaf)\r\n\r\n     # Evaluate the IDPF at every node of the tree.\r\n     for level in range(Idpf.BITS):\r\n@@ -100,7 +100,9 @@ def test_idpf_exhaustive(Idpf, alpha):\r\n\r\n         out_shares = []\r\n         for agg_id in range(Idpf.SHARES):\r\n-            out_shares.append(Idpf.eval(agg_id, keys[agg_id], level, prefixes))\r\n+            out_shares.append(\r\n+                Idpf.eval(agg_id, public_share,\r\n+                          keys[agg_id], level, prefixes))\r\n\r\n         # Check that each set of output shares for each prefix sums up to the\r\n         # correct value.\r\ndiff --git a/poc/idpf_poplar.sage b/poc/idpf_poplar.sage\r\nindex e0c33ac..2f71e96 100644\r\n--- a/poc/idpf_poplar.sage\r\n+++ b/poc/idpf_poplar.sage\r\n@@ -69,16 +69,17 @@ class IdpfPoplar(Idpf):\r\n                 w_cw = vec_neg(w_cw)\r\n             correction_words.append((seed_cw, ctrl_cw, w_cw))\r\n\r\n-        return IdpfPoplar.encode_keys(correction_words, init_seed)\r\n+        public_share = IdpfPoplar.encode_public_share(correction_words)\r\n+        return (public_share, init_seed)\r\n\r\n     @classmethod\r\n-    def eval(IdpfPoplar, agg_id, key, level, prefixes):\r\n+    def eval(IdpfPoplar, agg_id, public_share, init_seed, level, prefixes):\r\n         if agg_id >= IdpfPoplar.SHARES:\r\n             raise ERR_INPUT # invalid aggregator ID\r\n         if level >= IdpfPoplar.BITS:\r\n             raise ERR_INPUT # level too deep\r\n\r\n-        (correction_words, init_seed) = IdpfPoplar.decode_key(key)\r\n+        correction_words = IdpfPoplar.decode_public_share(public_share)\r\n         out_share = []\r\n         for prefix in prefixes:\r\n             if prefix >= 2^level:\r\n@@ -156,28 +157,23 @@ class IdpfPoplar(Idpf):\r\n         return (next_seed, w)\r\n\r\n     @classmethod\r\n-    def encode_keys(IdpfPoplar, correction_words, init_seed):\r\n+    def encode_public_share(IdpfPoplar, correction_words):\r\n         encoded = Bytes()\r\n         for (level, (seed_cw, ctrl_cw, w_cw)) in enumerate(correction_words):\r\n             encoded += seed_cw\r\n-            # TODO Packing only two control bits into a byte is wasteful.\r\n-            # Consider packing them more tightly.\r\n+            # TODO Consider packing the correction bits more tightly. This\r\n+            # encoding is designed to make it convenient for implementations to\r\n+            # \"throw away\" correction words they know they're no longer going to\r\n+            # need. However, using a byte to encode two bits is slightly\r\n+            # wasteful.\r\n             encoded += byte(ctrl_cw[0].as_unsigned() | \\\r\n                            (ctrl_cw[1].as_unsigned() << 1))\r\n             Field = IdpfPoplar.current_field(level)\r\n             encoded += Field.encode_vec(w_cw)\r\n-        # TODO The correction words vector needs to be encoded by both IPDF key\r\n-        # shares so that both Aggregators have access to it. This is wasteful\r\n-        # for applications like DAP in which the VDAF input shares are encrypted\r\n-        # and sent to one Aggregator: The correction words vector ends up\r\n-        # getting sent twice when sending them once would have been sufficient.\r\n-        #\r\n-        # Consider modifying the VDAF syntax so that the sharding algorithm\r\n-        # outputs a public value shared by all Aggregators.\r\n-        return [encoded + init_seed[0], encoded + init_seed[1]]\r\n+        return encoded\r\n\r\n     @classmethod\r\n-    def decode_key(IdpfPoplar, encoded):\r\n+    def decode_public_share(IdpfPoplar, encoded):\r\n         correction_words = []\r\n         for level in range(IdpfPoplar.BITS):\r\n             l = IdpfPoplar.Prg.SEED_SIZE\r\n@@ -189,11 +185,9 @@ class IdpfPoplar(Idpf):\r\n             encoded_w_cw, encoded = encoded[:l], encoded[l:]\r\n             w_cw = Field.decode_vec(encoded_w_cw)\r\n             correction_words.append((seed_cw, ctrl_cw, w_cw))\r\n-        l = IdpfPoplar.Prg.SEED_SIZE\r\n-        seed, encoded = encoded[:l], encoded[l:]\r\n         if len(encoded) != 0:\r\n             raise ERR_DECODE\r\n-        return (correction_words, seed)\r\n+        return correction_words\r\n\r\n     @classmethod\r\n     def with_prg(IdpfPoplar, Prg):\r\n```",
              "createdAt": "2022-06-22T15:15:43Z",
              "updatedAt": "2022-06-22T15:15:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48hZOu",
          "commit": {
            "abbreviatedOid": "d3a7889"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T15:17:21Z",
          "updatedAt": "2022-06-22T15:17:21Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I think an explicit \"bit-vector\" representation would end up being cumbersome. It's complicated, and therefore needs to be explained well, but it seems like the best option to me.",
              "createdAt": "2022-06-22T15:17:21Z",
              "updatedAt": "2022-06-22T15:17:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 91,
      "id": "PR_kwDOGKuqOc46EuE6",
      "title": "Add public share to sharding algorithm",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/91",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #84.\r\n\r\nModifies the syntax for (V)DAFs to allow the Client to generate a\r\n\"public share\" that is distributed to all of the Aggregators. This is to\r\nsupport VDAFs such as Poplar1 that require an IDPF. (See see [BBCGGI21,\r\nAppendix D].)",
      "createdAt": "2022-06-22T00:14:19Z",
      "updatedAt": "2022-08-26T18:34:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "485e7c4cab08f0d0a1a763b423b265f222ba832e",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/idpf-3-public-share",
      "headRefOid": "64ed2762dd74cb680b6233f41d8fc26c929933ff",
      "closedAt": "2022-06-22T15:08:58Z",
      "mergedAt": "2022-06-22T15:08:57Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "3a4a167c1696b18c2f2dbf2b197b1e5428e6d619"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc48dn9N",
          "commit": {
            "abbreviatedOid": "9a15373"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T01:01:55Z",
          "updatedAt": "2022-06-22T01:01:55Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\n  Aggregators, and a corresponding sequence of input shares, one for each\r\n```",
              "createdAt": "2022-06-22T01:01:55Z",
              "updatedAt": "2022-06-22T01:01:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48fjg1",
          "commit": {
            "abbreviatedOid": "9a15373"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-22T10:14:59Z",
          "updatedAt": "2022-06-22T10:14:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 93,
      "id": "PR_kwDOGKuqOc46bfEb",
      "title": "Update Poplar1 syntax to match VDAF definition",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/93",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-06-27T16:35:25Z",
      "updatedAt": "2024-07-02T21:50:25Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d272ec9d17e61205da5189c124ba7687b23f8dfd",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "schoppmp/poplar1",
      "headRefOid": "9d75d1a7e08f9cf5d5ca0c207b6349ae8f231599",
      "closedAt": "2022-06-28T15:32:08Z",
      "mergedAt": "2022-06-28T15:32:08Z",
      "mergedBy": "schoppmp",
      "mergeCommit": {
        "oid": "bd63d077e9e67b8792fb3fe767bf21fa13a5ab07"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "For the record, this partially addresses #84.",
          "createdAt": "2022-06-29T16:26:08Z",
          "updatedAt": "2022-06-29T16:26:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc481Nv2",
          "commit": {
            "abbreviatedOid": "04da027"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This is definitely moving in the right direction. One open question before we merge: Should `level` be in range `[1, BITS]` or `[0, BITS)`? The latter is used in the reference code, if I remember right.",
          "createdAt": "2022-06-27T18:02:06Z",
          "updatedAt": "2022-06-27T18:17:03Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n`beta`, one for each \"level\" `1 <= L <= BITS`. The key generation algorithm generates two\r\n```",
              "createdAt": "2022-06-27T18:02:06Z",
              "updatedAt": "2022-06-27T18:17:03Z"
            },
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nIDPF keys, one for each Aggregator. When evaluated at level `L` and index `0 <= x < 2^L`, each\r\n```",
              "createdAt": "2022-06-27T18:02:54Z",
              "updatedAt": "2022-06-27T18:17:03Z"
            },
            {
              "originalPosition": 39,
              "body": "Ack, feel free to remove my comment.",
              "createdAt": "2022-06-27T18:04:12Z",
              "updatedAt": "2022-06-27T18:17:03Z"
            },
            {
              "originalPosition": 52,
              "body": "nit: Remove colon (\":\") and put the function definition on a single line. https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/draft-irtf-cfrg-vdaf.md?plain=1#L476\r\n\r\nHere and below.",
              "createdAt": "2022-06-27T18:10:10Z",
              "updatedAt": "2022-06-27T18:17:03Z"
            },
            {
              "originalPosition": 70,
              "body": "The reference implementation begins indexing the levels at `0` rather than `1`. I don't care which we go with, as long as we're consistent. If you want to change this, either file an issue to fix the reference implementation or fix the reference implementation in this PR.",
              "createdAt": "2022-06-27T18:12:24Z",
              "updatedAt": "2022-06-27T18:17:03Z"
            },
            {
              "originalPosition": 81,
              "body": "```suggestion\r\n  associated constants as `Field` in {{field}}.\r\n```",
              "createdAt": "2022-06-27T18:13:10Z",
              "updatedAt": "2022-06-27T18:17:03Z"
            },
            {
              "originalPosition": 141,
              "body": "```suggestion\r\n  (key_0, key_1) = Idpf.gen(alpha, beta[:-1], beta[-1])\r\n```",
              "createdAt": "2022-06-27T18:14:05Z",
              "updatedAt": "2022-06-27T18:17:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc485EHQ",
          "commit": {
            "abbreviatedOid": "04da027"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-28T11:45:33Z",
          "updatedAt": "2022-06-28T11:45:33Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Done.",
              "createdAt": "2022-06-28T11:45:33Z",
              "updatedAt": "2022-06-28T11:45:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc485EJI",
          "commit": {
            "abbreviatedOid": "04da027"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-28T11:45:39Z",
          "updatedAt": "2022-06-28T11:45:40Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Done.",
              "createdAt": "2022-06-28T11:45:39Z",
              "updatedAt": "2022-06-28T11:45:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc485Ec3",
          "commit": {
            "abbreviatedOid": "04da027"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-28T11:46:47Z",
          "updatedAt": "2022-06-28T11:46:47Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Changed it, now levels begin at 0.",
              "createdAt": "2022-06-28T11:46:47Z",
              "updatedAt": "2022-06-28T11:46:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc486NxM",
          "commit": {
            "abbreviatedOid": "9d75d1a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Approving to unblock this merge so that you can go on PTO with a clean plate. This is a great start!\r\n\r\nWould you mind squashing before merging?",
          "createdAt": "2022-06-28T14:54:39Z",
          "updatedAt": "2022-06-28T14:54:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 95,
      "id": "PR_kwDOGKuqOc46mkc0",
      "title": "Pass num_measurements when computing AggResult, add decode methods",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/95",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This implements the change proposed by #92, passing `num_measurements` to `agg_shares_to_result()`. For Prio3, I decided to thread this through both the FLP and validity circuit layers, in new `decode()` methods. With this change, `encode()`, `truncate()`, and `decode()` now give us a more complete API for Prio's AFEs. To test this, I wrote a quick Average type that makes use of the new argument. I also took advantage of the new flexibility in `Prio3.AggResult` to change the output types of Prio3Aes128Count and Prio3Aes128Sum to be `Unsigned`, as it's more intuitive and ergonomic. (If we don't like that last bit, it's separated out in the commit history already)",
      "createdAt": "2022-06-29T23:01:06Z",
      "updatedAt": "2022-07-08T17:01:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "bd63d077e9e67b8792fb3fe767bf21fa13a5ab07",
      "headRepository": "divergentdave/vdaf",
      "headRefName": "afe-decode-with-number-of-measurements",
      "headRefOid": "9eed57da7d68c64e49a42ce08ff5dcb724ecf844",
      "closedAt": "2022-07-08T17:01:47Z",
      "mergedAt": "2022-07-08T17:01:47Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "a363a96268edbb2fedac26766696efaddcde0f70"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @divergentdave! Please squash the last commit (\"Review comments\") before merging. Great work.",
          "createdAt": "2022-07-08T14:32:29Z",
          "updatedAt": "2022-07-08T14:32:29Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "I rebased to clean up the commit history, and also added an editorial change to the spec (propagating the x => bucket_count change) and fixed two associated types in test-only classes. https://github.com/cfrg/draft-irtf-cfrg-vdaf/compare/5e772df22a071f8fab828073a361805424399ff8..9eed57da7d68c64e49a42ce08ff5dcb724ecf844",
          "createdAt": "2022-07-08T15:51:07Z",
          "updatedAt": "2022-07-08T15:51:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc49Csm2",
          "commit": {
            "abbreviatedOid": "e29d2df"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks @divergentdave! I massively appreciate your thoroughness and attention to detail here. Adding test code to exercise the new logic is particularly appreciated.\r\n\r\nI will give this a thorough review next Thursday, 7/7, when I'm back from PTO. In the meantime, a few high-level things:\r\n* I'm a bit weary of the reference implementation defining the VDAF `Prio3Aes128Average` without also defining it in the draft itself. That said it's definitely useful to exercise the API changes that are introduced in this change. We should either add it it to the draft or rename it to something like `TestPrio3Aes128Average` (to suggest that it's there for testing, but may eventually go in the draft).\r\n* Don't worry about updating the change log. We'll wait to do so until we're ready to cut the next draft.",
          "createdAt": "2022-06-29T23:44:23Z",
          "updatedAt": "2022-06-29T23:47:20Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Does this method actually need to be re-implemented?",
              "createdAt": "2022-06-29T23:44:23Z",
              "updatedAt": "2022-06-29T23:47:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49CwPd",
          "commit": {
            "abbreviatedOid": "e29d2df"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-30T00:17:37Z",
          "updatedAt": "2022-06-30T00:17:37Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I re-implemented it to swap out `flp_generic.Sum` for `flp_generic.Average`. I could possibly define some new members on `Prio3Aes128Sum`, and and override a member for the validity circuit instead, but I figure the separate factory classmethod is less invasive.",
              "createdAt": "2022-06-30T00:17:37Z",
              "updatedAt": "2022-06-30T00:17:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49h1rf",
          "commit": {
            "abbreviatedOid": "dd81b5c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Excellent work! Just a few minor comments and this'll be ready to merge.",
          "createdAt": "2022-07-08T00:29:36Z",
          "updatedAt": "2022-07-08T00:41:08Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "nit: Since this parameter gets ignored here, prefix it with `_`. ",
              "createdAt": "2022-07-08T00:29:36Z",
              "updatedAt": "2022-07-08T00:41:08Z"
            },
            {
              "originalPosition": 103,
              "body": "A more descriptive name than `x` would be useful. How about `bucket_count`?",
              "createdAt": "2022-07-08T00:33:03Z",
              "updatedAt": "2022-07-08T00:41:08Z"
            },
            {
              "originalPosition": 115,
              "body": "I'm not sure we should have `float` as the result type, since the measurements are `Unsigned` and thus have a different precisison. What about defining this aggregation function as `floor(average(measurements))` and letting `AggResult = Unsigned`.",
              "createdAt": "2022-07-08T00:37:15Z",
              "updatedAt": "2022-07-08T00:41:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49klPy",
          "commit": {
            "abbreviatedOid": "5e772df"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-08T14:31:52Z",
          "updatedAt": "2022-07-08T14:31:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 96,
      "id": "PR_kwDOGKuqOc47Hs73",
      "title": "Revert \"Pass num_measurements when computing AggResult, add decode methods\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/96",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Reverts cfrg/draft-irtf-cfrg-vdaf#95. This was reviewed and ready for approval, but I got punchy and merged before @nakatsuka-y had a chance to squash.",
      "createdAt": "2022-07-08T17:03:41Z",
      "updatedAt": "2022-08-26T18:34:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "a363a96268edbb2fedac26766696efaddcde0f70",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "revert-95-afe-decode-with-number-of-measurements",
      "headRefOid": "b0d8e24ca426fdf6f4f05b52b043ecb74fc2a100",
      "closedAt": "2022-07-08T17:03:49Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 97,
      "id": "PR_kwDOGKuqOc47JZA-",
      "title": "Complete spec of Poplar1",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/97",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #84.\r\nCloses #44.\r\n\r\nCompletes the specification of Poplar1, including the reference\r\nimplementation and test vectors.\r\n\r\n* poc: Add additional tests for IdpfPoplar.\r\n* poc: Modify Idpf syntax so that the size of the keys is defined. This\r\n  is needed for decoding the keysfrom the Poplar1 input share.\r\n* poc: Fix a minor bug in IdpfPoplar that caused `eval()` to throw an\r\n  error when it shouldn't.\r\n* poc: Have `eval()` check that the prefixes are unique. This is needed\r\n  for Poplar1, which checks for one-hotness of the output shares.\r\n* poc: Fix various typos.\r\n* poc: Implement Poplar1 and add code for generating test vectors.\r\n* Add new field `Field255`, as required for IdpfPoplar.\r\n* Refactor Prg interface to align with reference implementation.\r\n* Re-generate test vectors and add test vectors for Poplar1Aes128.",
      "createdAt": "2022-07-09T23:04:45Z",
      "updatedAt": "2022-08-26T18:34:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "a363a96268edbb2fedac26766696efaddcde0f70",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/84/1",
      "headRefOid": "352a8d2db8c447c119f663650f7b198e562895cb",
      "closedAt": "2022-07-11T21:00:31Z",
      "mergedAt": "2022-07-11T21:00:31Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "a88e2cef27b754677e2a6c30bc1e070f75f9012a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc49qe6R",
          "commit": {
            "abbreviatedOid": "e3b465c"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good, I left remarks with a variety of small cleanups. I'm excited!",
          "createdAt": "2022-07-11T15:34:24Z",
          "updatedAt": "2022-07-11T19:02:42Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This reflects a change I made in #95, which is not in draft-01. I see the `01` directory is named after the draft number, so I think the `agg_result`-unwrapping part of this should be backed out, and the new Poplar1 test vectors should go in a different directory. (\"latest\"? \"next\"? \"02\"?)",
              "createdAt": "2022-07-11T15:34:24Z",
              "updatedAt": "2022-07-11T19:02:42Z"
            },
            {
              "originalPosition": 199,
              "body": "nit\r\n```suggestion\r\n  The type of the output depends on the value of `level`: If `level < Idpf.BITS-1`,\r\n```",
              "createdAt": "2022-07-11T16:05:25Z",
              "updatedAt": "2022-07-11T19:02:42Z"
            },
            {
              "originalPosition": 201,
              "body": "For consistency:\r\n```suggestion\r\n  `Vec[Idpf.FieldInner]`; otherwise, if `level == Idpf.BITS-1`, then the output is\r\n```",
              "createdAt": "2022-07-11T16:05:56Z",
              "updatedAt": "2022-07-11T19:02:42Z"
            },
            {
              "originalPosition": 202,
              "body": "Should we make the two layers of `Vec` explicit here?\r\n```suggestion\r\n  `Vec[Vec[Idpf.FieldInner]]`; otherwise, if `level == BITS-1`, then the output is\r\n  the value for a leaf node, which has type `Vec[Vec[Idpf.FieldLeaf]]`.\r\n```",
              "createdAt": "2022-07-11T16:07:30Z",
              "updatedAt": "2022-07-11T19:02:42Z"
            },
            {
              "originalPosition": 411,
              "body": "nit\r\n```suggestion\r\n    # requires expanding PRG seeds into a vector of field elements\r\n```",
              "createdAt": "2022-07-11T17:25:19Z",
              "updatedAt": "2022-07-11T19:02:42Z"
            },
            {
              "originalPosition": 814,
              "body": "I think this got left over from the prior section.\r\n```suggestion\r\nThe description of the IDPF evaluation algorithm makes use\r\n```",
              "createdAt": "2022-07-11T18:32:41Z",
              "updatedAt": "2022-07-11T19:02:42Z"
            },
            {
              "originalPosition": 849,
              "body": "I think the prefix-of relationship is backwards here.\r\n```suggestion\r\n            # example, when using `IdpfPoplar` to compute heavy\r\n            # hitters, a string whose hit count exceeded the given\r\n            # threshold in the last round would be the prefix of each\r\n            # `prefix` in the current round. (See\r\n```",
              "createdAt": "2022-07-11T18:37:28Z",
              "updatedAt": "2022-07-11T19:02:42Z"
            },
            {
              "originalPosition": 867,
              "body": "Should this refer to C.2? C.3 is just a proof.\r\n```suggestion\r\n# discussed at the end of [BBCGGI21, Appendix C.2]. This could on\r\n```",
              "createdAt": "2022-07-11T18:42:10Z",
              "updatedAt": "2022-07-11T19:02:42Z"
            },
            {
              "originalPosition": 961,
              "body": "See my comment regarding the Prio3 test vector files",
              "createdAt": "2022-07-11T18:49:08Z",
              "updatedAt": "2022-07-11T19:02:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49riC0",
          "commit": {
            "abbreviatedOid": "e3b465c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Couple of high-level notes, otherwise LGTM",
          "createdAt": "2022-07-11T19:17:57Z",
          "updatedAt": "2022-07-11T19:31:18Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "I note that before you say `1 <= L <= BITS` and here you say `[0, BITS)`.  The latter is the former shifted by one.  Just making sure this is correct.",
              "createdAt": "2022-07-11T19:17:57Z",
              "updatedAt": "2022-07-11T19:31:18Z"
            },
            {
              "originalPosition": 173,
              "body": "`alpha` is the index being sharded here, right?  If so, it would be clearer to call it a bit string, not an integer, since that's how it is referred to above.  (Maybe internally to the function it is converted to an integer, but that doesn't really matter as long as all participants put the bits in the same order.)\r\n\r\nWhere do the `beta` values come from?  If they're computed from `alpha`, it seems like there's a missing step for that.  If they're constant / defined by the IDPF, then it seems like they can be treated as internal to the function, not arguments.",
              "createdAt": "2022-07-11T19:29:57Z",
              "updatedAt": "2022-07-11T19:31:18Z"
            },
            {
              "originalPosition": 233,
              "body": "```suggestion\r\n```",
              "createdAt": "2022-07-11T19:30:34Z",
              "updatedAt": "2022-07-11T19:31:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49ryz1",
          "commit": {
            "abbreviatedOid": "80904de"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-11T20:24:51Z",
          "updatedAt": "2022-07-11T20:24:52Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Right now the plan is for the test vectors to match a tag of the repo. For example, test_vec/01 will matches `draft-irtf-cfrg-vdaf-01`. Moreover, I plan to remove test vectors from old versions from the repo as changes are made. (See #100). Thus these \"in-between\" changes to the test vectors don't matter much for interop.",
              "createdAt": "2022-07-11T20:24:51Z",
              "updatedAt": "2022-07-11T20:24:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49rzay",
          "commit": {
            "abbreviatedOid": "80904de"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-11T20:27:16Z",
          "updatedAt": "2022-07-11T20:27:16Z",
          "comments": [
            {
              "originalPosition": 202,
              "body": "Yes, nice catch.",
              "createdAt": "2022-07-11T20:27:16Z",
              "updatedAt": "2022-07-11T20:27:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49rz0E",
          "commit": {
            "abbreviatedOid": "e3b465c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-11T20:28:52Z",
          "updatedAt": "2022-07-11T20:28:52Z",
          "comments": [
            {
              "originalPosition": 814,
              "body": "\u2764\ufe0f ",
              "createdAt": "2022-07-11T20:28:52Z",
              "updatedAt": "2022-07-11T20:28:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49r3LW",
          "commit": {
            "abbreviatedOid": "e3b465c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-11T20:41:28Z",
          "updatedAt": "2022-07-11T20:41:28Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "The level SHOULD be in range `[0, BITS)`. Looking at all instances of \"BITS\" in the doc, I believe this is consistent. However I did spot a range bug in the definition of \"prefix\" below. Fixed now.",
              "createdAt": "2022-07-11T20:41:28Z",
              "updatedAt": "2022-07-11T20:41:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49r3fm",
          "commit": {
            "abbreviatedOid": "e3b465c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-11T20:42:41Z",
          "updatedAt": "2022-07-11T20:42:42Z",
          "comments": [
            {
              "originalPosition": 233,
              "body": "Done, here and elsewhere.",
              "createdAt": "2022-07-11T20:42:41Z",
              "updatedAt": "2022-07-11T20:42:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49r5IU",
          "commit": {
            "abbreviatedOid": "e3b465c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-11T20:49:13Z",
          "updatedAt": "2022-07-11T20:49:13Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "> `alpha` is the index being sharded here, right? If so, it would be clearer to call it a bit string, not an integer, since that's how it is referred to above. (Maybe internally to the function it is converted to an integer, but that doesn't really matter as long as all participants put the bits in the same order.)\r\n\r\n@schoppmp and I discussed this a bit and decided that `Unsigned` was the best representation of the input. A couple of alternatives:\r\n* `Bytes` - This is the most intuitive, however it has the problem of not being able to represent a bit strings whose length is not a multiple of 8. Of course we could consider requiring input strings be a multiple 8. This would probably be fine for most applications.\r\n* Define some sort of `BitString` type, perhaps even making use of ASN.1. We decided this would be a bit too complicated.\r\n \r\n> Where do the `beta` values come from? If they're computed from `alpha`, it seems like there's a missing step for that. If they're constant / defined by the IDPF, then it seems like they can be treated as internal to the function, not arguments.\r\n\r\nThe `beta` values are arbitrary and are picked by the caller. In `Poplar1`, they are chosen in a particular way.\r\n\r\n",
              "createdAt": "2022-07-11T20:49:13Z",
              "updatedAt": "2022-07-11T20:49:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49sCWy",
          "commit": {
            "abbreviatedOid": "e3b465c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-11T21:29:10Z",
          "updatedAt": "2022-07-11T21:29:10Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "On the first point: I'm not overly picky here.  Maybe you could just say somewhere that the Unsigned value is the input bit string of length `BITS`, interpreted as a `BITS`-bit big-endian integer (or whatever, doesn't really matter).\r\n\r\nOn the second point: If they're (a) generated unilaterally by the caller and (b) not used elsewhere, they should get generated internally to `gen`, not passed in as arguments.",
              "createdAt": "2022-07-11T21:29:10Z",
              "updatedAt": "2022-07-11T21:29:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49sEJf",
          "commit": {
            "abbreviatedOid": "e3b465c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-11T21:38:10Z",
          "updatedAt": "2022-07-11T21:38:10Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "> On the first point: I'm not overly picky here. Maybe you could just say somewhere that the Unsigned value is the input bit string of length `BITS`, interpreted as a `BITS`-bit big-endian integer (or whatever, doesn't really matter).\r\n\r\nYeah we should provide some guidance here, but at this point I'm not sure what to recommend here. Really any encoding is fine, so long as the application is consistent.\r\n\r\n\r\n> On the second point: If they're (a) generated unilaterally by the caller and (b) not used elsewhere, they should get generated internally to `gen`, not passed in as arguments.\r\n\r\nWell, one could imagine different applications for IDPFs that call for different values to be \"programmed\". For Poplar1, the programmed values are pairs `(1, k)` where `k` is a random field element used for verifying the output shares. When used in a plain DAF, there would be no need for the random field element. One could also imagine an application in which \"weighted\" inputs are used, i.e., rather than always output `1`, output some integer in range `[0, c)` chosen by the user.\r\n\r\nAnother thing to note is that the current IDPF syntax more or less matches the paper.\r\n",
              "createdAt": "2022-07-11T21:38:10Z",
              "updatedAt": "2022-07-11T21:38:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 98,
      "id": "PR_kwDOGKuqOc47JZzg",
      "title": "IdpfPoplar: Pack control bits more tightly in public share",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/98",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Merge #97 first.\r\n\r\nWhile at it, add the public share to the test vectors.",
      "createdAt": "2022-07-09T23:42:34Z",
      "updatedAt": "2022-08-26T18:34:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "a88e2cef27b754677e2a6c30bc1e070f75f9012a",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/84/2",
      "headRefOid": "2e86acce649d7f815e6bbac8b6415e4145f19e5b",
      "closedAt": "2022-07-11T21:05:37Z",
      "mergedAt": "2022-07-11T21:05:37Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "e2ab413e9268f8e0ea0630489d7c033c99a3749e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc49rlxL",
          "commit": {
            "abbreviatedOid": "67d213d"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-11T19:33:07Z",
          "updatedAt": "2022-07-11T19:33:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 99,
      "id": "PR_kwDOGKuqOc47JaE8",
      "title": "Check that field elements are fully reduced while decoding",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/99",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #89.\r\nMerge #98 first.",
      "createdAt": "2022-07-09T23:55:38Z",
      "updatedAt": "2022-08-26T18:34:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "e2ab413e9268f8e0ea0630489d7c033c99a3749e",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/89",
      "headRefOid": "f612338b31b41382c9d6baae72d5fe2fbd12d076",
      "closedAt": "2022-07-11T21:13:02Z",
      "mergedAt": "2022-07-11T21:13:02Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "26365db5cbbc995c9a7daa1017505076fdf1bf02"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 100,
      "id": "PR_kwDOGKuqOc47Nmdx",
      "title": "Prepare to cut draft-02",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/100",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Merge #99 first.\r\n\r\nChanges for draft-02, including:\r\n\r\n* Bump VERSION\r\n* Update Change Log\r\n* Update test vectors",
      "createdAt": "2022-07-11T18:28:45Z",
      "updatedAt": "2022-08-26T18:34:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "26365db5cbbc995c9a7daa1017505076fdf1bf02",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/draft-02",
      "headRefOid": "ed7d2d40dc1f988a94f159dbc5843c5a1c866264",
      "closedAt": "2022-07-11T21:18:17Z",
      "mergedAt": "2022-07-11T21:18:17Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "5bfef02e11ac27de5106d013ce0c2e879f3883b4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 104,
      "id": "PR_kwDOGKuqOc49Nd_O",
      "title": "Define codepoints for (V)DAFs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/104",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #102.\r\n\r\nEach (V)DAF defines a 32-bit codepoint used to uniquely identify it. The\r\ncurrent scheme is as follows:\r\n\r\n* The first 3 nibbles are used to identify the VDAF \"class\", e.g.,\r\n  Prio3Aes128 or Poplar1Aes128.\r\n* The remaining 5 nibbles are reserved for particular \"instances\",\r\n  e.g., Prio3Aes128Count, Prio3Aes128Sum, etc.\r\n\r\nWhile at it, incorporate the codepoints into domain separation tags\r\n(DSTs) in Prio3 and Poplar1. This is needed primarily for Prio3. (See\r\nissue#102.)",
      "createdAt": "2022-08-15T22:11:31Z",
      "updatedAt": "2022-08-26T18:34:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "5bfef02e11ac27de5106d013ce0c2e879f3883b4",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/102/codepoints",
      "headRefOid": "875da0e4804e03977a584ca39c3b563412078cc4",
      "closedAt": "2022-08-24T21:38:51Z",
      "mergedAt": "2022-08-24T21:38:51Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "0f5c636383acc6637bc837cd234cb2e1fd88087f"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> This seems good enough for now. We can always change the shape of these later on. One question I might consider asking is whether or not you want the draft version to be part of the DST, if it's not already, just in case things change over time.\r\n\r\nThe version (literally `b'vdaf-02'`) is the prefix of the DST :)\r\n",
          "createdAt": "2022-08-16T21:15:21Z",
          "updatedAt": "2022-08-16T21:15:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "\ud83e\udd86",
          "createdAt": "2022-08-16T21:16:00Z",
          "updatedAt": "2022-08-16T21:16:00Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't love the division of the algorithm identifier into high- and low-order nibbles. Why not just have two identifiers here, say a 2-byte VDAF class and a 4-byte algorithm identifier within that class? There crypto things we're dealing with here are so gigantic that a couple of bytes doesn't seem likely to be noticeable.\r\n\r\nPrio3 has a large class of variants; Poplar1 does not. In general I would expect many VDAFs to have no variants, and some to have many. I figured merging \"class\" and \"variant\" into the same codepoint would allow us to more fully utilize the codepoint space.\r\n\r\nAlternatively, we could make the codepoint 2 bytes for the class and then add more bytes as needed for VDAFs with lots of variants. This is doable, but might make the spec a bit more complicated. On balance I think I would prefer the current PR. What do you think @bifurcation?",
          "createdAt": "2022-08-23T16:15:38Z",
          "updatedAt": "2022-08-23T16:15:38Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "If you don't think that this variant pattern is going to be common for other VDAFs, then yeah, we shouldn't structure the code points around it.  But at the same time, you're not going to have 2^32 Prio variants, so I would suggest being a little more restrained, since (a) you're not going to have 2^20 Prio variants and (b) you can always grab more space later.  Maybe something like:\r\n\r\n* 0x00000000 - 0x000000FF - Prio variants\r\n* 0x00000100 - Poplar\r\n* 0xFFFF0000 - 0xFFFFFFFF reserved for private use\r\n\r\n(It is traditional to put reserved space at the high end, see, e.g., [TLS ciphersuites](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4).) ",
          "createdAt": "2022-08-24T16:26:28Z",
          "updatedAt": "2022-08-24T16:26:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5AC-ii",
          "commit": {
            "abbreviatedOid": "d684990"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T17:33:42Z",
          "updatedAt": "2022-08-16T17:34:27Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "I think it'd be a good idea to reserve everything with the prefix `0x000` for testing, just in case someone has a test scenario that requires multiple fake (V)DAFs interacting somehow.",
              "createdAt": "2022-08-16T17:33:42Z",
              "updatedAt": "2022-08-16T17:34:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ADAcj",
          "commit": {
            "abbreviatedOid": "d684990"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T17:40:25Z",
          "updatedAt": "2022-08-16T17:40:25Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "We can probably do that. Once concern I have is that 32 bits might be too large. Typically codepoints are just 8-16 bits, in which case we wouldn't be able to afford allocating lots of space.",
              "createdAt": "2022-08-16T17:40:25Z",
              "updatedAt": "2022-08-16T17:40:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ADL4x",
          "commit": {
            "abbreviatedOid": "d684990"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T18:20:05Z",
          "updatedAt": "2022-08-16T18:20:06Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Then reserving `0x000000XX` should suffice. ",
              "createdAt": "2022-08-16T18:20:05Z",
              "updatedAt": "2022-08-16T18:20:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ADOPP",
          "commit": {
            "abbreviatedOid": "d684990"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T18:28:28Z",
          "updatedAt": "2022-08-16T18:28:28Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Will do.\u00a0First I want to see if anyone objects to 32 bits :)",
              "createdAt": "2022-08-16T18:28:28Z",
              "updatedAt": "2022-08-16T18:28:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5AD77Q",
          "commit": {
            "abbreviatedOid": "d684990"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "This seems good enough for now. We can always change the shape of these later on. One question I might consider asking is whether or not you want the draft version to be part of the DST, if it's not already, just in case things change over time.",
          "createdAt": "2022-08-16T21:02:43Z",
          "updatedAt": "2022-08-16T21:03:50Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "I would leave it as-is for now. I don't know see any reason why an application would want to be opinionated about the PRG, so it makes sense to me that we pick one or maybe two variants that work well for all.",
              "createdAt": "2022-08-16T21:02:43Z",
              "updatedAt": "2022-08-16T21:03:50Z"
            },
            {
              "originalPosition": 185,
              "body": "I would leave it as-is for now. I don't know see any reason why an application would want to be opinionated about the PRG, so it makes sense to me that we pick one or maybe two variants that work well for all.",
              "createdAt": "2022-08-16T21:02:45Z",
              "updatedAt": "2022-08-16T21:03:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5AEAZE",
          "commit": {
            "abbreviatedOid": "d684990"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T21:21:58Z",
          "updatedAt": "2022-08-16T21:21:59Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "I think there are a couple potential reasons for this:\r\n1. It's useful to be able to reuse existing primitives whenever possible. (For instance, @simon-friedberger found himself in the position of having to re-implement `PrgAes128` from primitives in NSS.) This suggests to me that there may eventually be a preference to build something from, say, HMAC. (HKDF is not particularly well suited here, given its relatively short output length.)\r\n2. In #32 we're discussing an alternative AES-based PRG. One might have a preference to stick with what we have today. (I hope not, though.)\r\n\r\nIn any case, we can cross this bridge later.",
              "createdAt": "2022-08-16T21:21:59Z",
              "updatedAt": "2022-08-16T21:21:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5AED1p",
          "commit": {
            "abbreviatedOid": "d684990"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T21:37:44Z",
          "updatedAt": "2022-08-16T21:37:44Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Done",
              "createdAt": "2022-08-16T21:37:44Z",
              "updatedAt": "2022-08-16T21:37:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5AJaPV",
          "commit": {
            "abbreviatedOid": "6da1b7a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This seems fine, but could be aligned better with the usual patterns for IANA language.\r\n\r\nI don't love the division of the algorithm identifier into high- and low-order nibbles.  Why not just have two identifiers here, say a 2-byte VDAF class and a 4-byte algorithm identifier within that class?  There crypto things we're dealing with here are so gigantic that a couple of bytes doesn't seem likely to be noticeable.",
          "createdAt": "2022-08-17T18:21:11Z",
          "updatedAt": "2022-08-17T18:26:41Z",
          "comments": [
            {
              "originalPosition": 171,
              "body": "You probably want to structure this section a little differently.  You're providing instructions to IANA: Create X, Y, Z, registries; add entries to Q registry; etc.  So I would have a top-level summary here, and then a subsection for each registry you're creating / touching.  You should be able to basically copy/paste the prose you need from MLS:\r\n\r\nhttps://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#name-iana-considerations",
              "createdAt": "2022-08-17T18:21:11Z",
              "updatedAt": "2022-08-17T18:26:41Z"
            },
            {
              "originalPosition": 176,
              "body": "The more common way to specify test code points is as a range, so `0x00000000 - 0x000000ff` here (as in the prose above).\r\n\r\nAlso, usually a reservation like this is made not just for testing, but for \"vendor specific usage\" -- whatever you want to do for your own products that you don't expect to generally interop.",
              "createdAt": "2022-08-17T18:21:56Z",
              "updatedAt": "2022-08-17T18:26:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5AhNpH",
          "commit": {
            "abbreviatedOid": "6da1b7a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-23T16:00:45Z",
          "updatedAt": "2022-08-23T16:00:46Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Good catch. I'm also going to bump the range to 0x00000000 - 0x0000FFFF so that there's more room for \"vendor specific usage\".",
              "createdAt": "2022-08-23T16:00:45Z",
              "updatedAt": "2022-08-23T16:00:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5AhTNa",
          "commit": {
            "abbreviatedOid": "6da1b7a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-23T16:15:35Z",
          "updatedAt": "2022-08-23T16:15:36Z",
          "comments": [
            {
              "originalPosition": 171,
              "body": "Thanks, @bifurcation! The immediate need for codepoints is to address #102. I filed #110 to address this later on.",
              "createdAt": "2022-08-23T16:15:35Z",
              "updatedAt": "2022-08-23T16:15:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 105,
      "id": "PR_kwDOGKuqOc49N8Gw",
      "title": "Prio3: Align spec with revised paper",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/105",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #102.\r\n\r\nA bug was found in [BBCGGI+19] that leads to an attack on the robustness\r\nof Prio3. The attack is based on an observation in Appendix A of the\r\npaper \"A New Paradigm for Collision-Free Hashing: Incrementality at\r\nReduced Cost\" from Bellare and Micciancio (Eurocrypt 1997). In short,\r\nthe attack allows a malicious Client to construct invalid input shares\r\nfor which the Aggregators would compute a `k_joint_rand` of its\r\nchoosing.\r\n\r\nThis bug was patched in Section 6.2.3 of\r\nhttps://eprint.iacr.org/archive/2019/188/20220727:184451 as follows:\r\nInstead of XORing joint randomness shares computed by the\r\nAggregators, `k_joint_rand` is computed by hashing the shares. This\r\nchange patches the Prio3 spec in kind.",
      "createdAt": "2022-08-16T02:05:11Z",
      "updatedAt": "2022-08-26T18:33:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "0f5c636383acc6637bc837cd234cb2e1fd88087f",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/102/bug-fix/1",
      "headRefOid": "529c503b922c164f23e4066a4eaaf880e880ab76",
      "closedAt": "2022-08-24T21:47:11Z",
      "mergedAt": "2022-08-24T21:47:11Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "adce91e25a235ce33c48b63587597e3d511cb81b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5ACD1M",
          "commit": {
            "abbreviatedOid": "d99544a"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T15:00:44Z",
          "updatedAt": "2022-08-16T15:00:44Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "I don't think this could work, as it would fall prey to the same attack. The attacker would still be able to choose an output value for the XOR operation, and then hash it before deriving the joint randomness elements it generates. Then, they could do the same Gaussian reduction to select shares that would result in the chosen XOR output. In effect, this change would just change the random oracle from expand_into_vec to derive_seed composed with expand_into_vec. We need to get rid of the linearity of the XOR operation entirely, as that's what gives the attacker an advantage.\r\n\r\nOne idea for an alternative scheme, with lower overhead: The client includes the joint randomness seed in each report, computed as H(...H(H(H(share 1 || blinding nonce 1) || share 2 || blinding nonce 2) || share 3 || blinding nonce 3) ... || share n || blinding nonce n). The client also sends hash i-1 and hash i from this chain of hashes (if i-1 is in bounds) as part of each report i. Then, the aggregators use the joint randomness seed in their calculation, confirm that hash i == H(hash i-1 || share i || blinding nonce n) based on the view of its report share, and broadcast hash i-1 and hash i from its report share, along with the joint randomness seed they used. During preprocessing, the leader verifies that each aggregator reported that its check of the next hash evaluation was valid on its report share, verifies that all consecutive aggregators agree on their views of successive hash values, and that each aggregator's view of the joint randomness seed was equal to the final hash value. This would only require sending 2 or 3 seeds in each direction, rather than n-1. (This could probably be optimized a bit more, but it follows the guideline of hashing everything to produce the public coin)",
              "createdAt": "2022-08-16T15:00:44Z",
              "updatedAt": "2022-08-16T15:00:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ACbzb",
          "commit": {
            "abbreviatedOid": "d99544a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T15:54:21Z",
          "updatedAt": "2022-08-16T15:54:21Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "This seems like it would definitely improve communication overhead for large n, but in most applications I think we're still expecting n to be small, say 2 or 3.",
              "createdAt": "2022-08-16T15:54:21Z",
              "updatedAt": "2022-08-16T15:54:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5AC8J7",
          "commit": {
            "abbreviatedOid": "c2ea50c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T17:25:42Z",
          "updatedAt": "2022-08-16T17:25:43Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Filed https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/106.",
              "createdAt": "2022-08-16T17:25:42Z",
              "updatedAt": "2022-08-16T17:25:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ADBJL",
          "commit": {
            "abbreviatedOid": "c2ea50c"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T17:42:51Z",
          "updatedAt": "2022-08-16T18:13:15Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Don't you need to inserting the helper's joint_rand_parts at index `j+1`? Otherwise the first helper's joint rand part will be overwritten by the leader's, below, when you insert at index 0 on line 1464.",
              "createdAt": "2022-08-16T17:42:51Z",
              "updatedAt": "2022-08-16T18:13:15Z"
            },
            {
              "originalPosition": 105,
              "body": "Isn't `j+2` going to go past the end of `k_joint_rand_parts` most of the time?",
              "createdAt": "2022-08-16T17:53:03Z",
              "updatedAt": "2022-08-16T18:13:15Z"
            },
            {
              "originalPosition": 166,
              "body": "What do the enclosing `[]` denote on this line? `k_joint_rand_part` is already a `Bytes` (`def derive_seed(Prg, seed: Bytes, info: Bytes) -> bytes`), so can't it already be concatenated with the elements of `k_hint`?",
              "createdAt": "2022-08-16T18:07:02Z",
              "updatedAt": "2022-08-16T18:13:15Z"
            },
            {
              "originalPosition": 214,
              "body": "This isn't really an issue with this PR, but is there a reason these function declarations can't have type annotations on their arguments, like we do for `derive_seed` or `expand_into_vec` in the PRG section? It would be a big help to readers trying to understand if `k_joint_rand_parts` is a `Bytes` (all parts already concatenated) or a `[Bytes]` (each element is a part) or some other thing.",
              "createdAt": "2022-08-16T18:09:31Z",
              "updatedAt": "2022-08-16T18:13:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ADKnV",
          "commit": {
            "abbreviatedOid": "c2ea50c"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T18:15:32Z",
          "updatedAt": "2022-08-16T18:15:33Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "Oh, no, never mind, Python's slice operator doesn't care:\r\n```\r\nPython 3.10.6 (main, Aug  2 2022, 00:00:00) [GCC 12.1.1 20220507 (Red Hat 12.1.1-1)] on linux\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> the_list = [1, 2, 3]\r\n>>> the_list[100:]\r\n[]\r\n```\r\n",
              "createdAt": "2022-08-16T18:15:32Z",
              "updatedAt": "2022-08-16T18:15:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ADK6c",
          "commit": {
            "abbreviatedOid": "c2ea50c"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T18:16:38Z",
          "updatedAt": "2022-08-16T18:16:38Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "The list's insert method shifts all later list elements to higher indices, so we won't lose the first helper's contribution.",
              "createdAt": "2022-08-16T18:16:38Z",
              "updatedAt": "2022-08-16T18:16:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ADLbn",
          "commit": {
            "abbreviatedOid": "c2ea50c"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T18:18:29Z",
          "updatedAt": "2022-08-16T18:18:29Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Oh, once again, I have misunderstood Python list semantics: `list.insert(0, val)` will put the new value at 0 and push existing values to the right. ",
              "createdAt": "2022-08-16T18:18:29Z",
              "updatedAt": "2022-08-16T18:18:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ADL41",
          "commit": {
            "abbreviatedOid": "c2ea50c"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T18:20:05Z",
          "updatedAt": "2022-08-16T18:20:06Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "The plus operators here are acting as list concatenation -- the first and last arguments are slices of the k_hint list, so they are both lists of Bytes. The middle argument is a list literal, consisting of just the `k_join_rand_part` Bytes object.",
              "createdAt": "2022-08-16T18:20:06Z",
              "updatedAt": "2022-08-16T18:20:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ADYEK",
          "commit": {
            "abbreviatedOid": "c2ea50c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T18:56:10Z",
          "updatedAt": "2022-08-16T18:56:10Z",
          "comments": [
            {
              "originalPosition": 214,
              "body": "There's no rhyme or reason for this. I'm happy to add type hints here.\r\n",
              "createdAt": "2022-08-16T18:56:10Z",
              "updatedAt": "2022-08-16T18:56:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5AI9yX",
          "commit": {
            "abbreviatedOid": "4f569cb"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-08-17T16:48:51Z",
          "updatedAt": "2022-08-17T16:49:05Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Nit: this import is unused now\r\n```suggestion\r\n                           gen_rand, vec_add, vec_sub, zeros\r\n```",
              "createdAt": "2022-08-17T16:48:51Z",
              "updatedAt": "2022-08-17T16:49:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ApOhT",
          "commit": {
            "abbreviatedOid": "4f569cb"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-24T21:46:36Z",
          "updatedAt": "2022-08-24T21:46:36Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Done!",
              "createdAt": "2022-08-24T21:46:36Z",
              "updatedAt": "2022-08-24T21:46:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 107,
      "id": "PR_kwDOGKuqOc49RSq_",
      "title": "Editorial feedback from HCG",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/107",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #105 (merge that first).\r\nPartially addresses #102.",
      "createdAt": "2022-08-16T18:27:25Z",
      "updatedAt": "2022-08-26T18:33:04Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "adce91e25a235ce33c48b63587597e3d511cb81b",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/102/editorial",
      "headRefOid": "66d2df00e91f4d27f97d33197a83e454bb2ef6f2",
      "closedAt": "2022-08-24T21:50:31Z",
      "mergedAt": "2022-08-24T21:50:31Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "7502ea4daf0cd4775d060e026ef5493e66f6acd0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 108,
      "id": "PR_kwDOGKuqOc49SOmQ",
      "title": "Prio3: prep_init(): Remove intermediate `k_query_rand`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/108",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #107 (merge that first).\r\n\r\nInstead, derive the query randomness from `verify_key` directly.",
      "createdAt": "2022-08-17T00:25:28Z",
      "updatedAt": "2022-08-26T18:33:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "7502ea4daf0cd4775d060e026ef5493e66f6acd0",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/draft03/1",
      "headRefOid": "f71ed01a8a48714d1d7ae2f45c3edea5f9ef0999",
      "closedAt": "2022-08-24T21:52:50Z",
      "mergedAt": "2022-08-24T21:52:50Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "caee9bc8cb8eef7e747e626e2fe539c93f961f33"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 111,
      "id": "PR_kwDOGKuqOc49q3r7",
      "title": "Generate test vectors for draft 03",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/111",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #108 (merge that first).",
      "createdAt": "2022-08-23T19:58:18Z",
      "updatedAt": "2022-08-26T18:33:02Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "caee9bc8cb8eef7e747e626e2fe539c93f961f33",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/draft03/2",
      "headRefOid": "477f0b851435effe16ef194e29b034fbe2221319",
      "closedAt": "2022-08-24T22:10:03Z",
      "mergedAt": "2022-08-24T22:10:03Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "21569b2e9479ca81b98c3f8ac3a15fd03ddbf250"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 112,
      "id": "PR_kwDOGKuqOc49wNy2",
      "title": "Misc changes for draft 03",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/112",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-08-24T22:30:15Z",
      "updatedAt": "2022-08-26T18:33:01Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "21569b2e9479ca81b98c3f8ac3a15fd03ddbf250",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/draft03/3",
      "headRefOid": "8ffb03fe2fdc9101aeda7e042aa443c9d7ba0e8b",
      "closedAt": "2022-08-24T22:35:58Z",
      "mergedAt": "2022-08-24T22:35:58Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "74d8d23666896a7609712ca384e287557a905398"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 117,
      "id": "PR_kwDOGKuqOc4--fxb",
      "title": "Add nonces to VDAF sharding syntax & Prio3",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/117",
      "state": "MERGED",
      "author": "hannahdaviscrypto",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #119.\r\n\r\nI came across a concern about the robustness of Prio3.The construction uses a PRG to derive joint randomness from the input shares that is used by the client and all aggregators. If a client uploads the same set of input shares twice under distinct nonces, the aggregators will derive the same joint randomness in both preparation phases.Intuitively, this violates the expectation that the joint randomness is pseudorandom, or at least not completely controllable by an attacker. \r\nMore formally, there is a degenerate FLP that is sound  with L bits of security when each set of input shares is submitted at most once, but is vulnerable to an 2^(L/2)-query attack if they can be submitted under many nonces. \r\n\r\nThis PR mitigates the attack by including the nonce in the joint randomness derivation so that if input shares are submitted under two different nonces, they will go through preparation with independent joint randomness. It requires changing VDAF syntax so that Shard takes the nonce as input. There shouldn't be any change to communication as a result, and the operational cost to Prio3 is at worst 1 additional AES call per party.",
      "createdAt": "2022-09-14T21:02:09Z",
      "updatedAt": "2022-09-30T21:17:24Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "74d8d23666896a7609712ca384e287557a905398",
      "headRepository": "hannahdaviscrypto/draft-irtf-cfrg-vdaf",
      "headRefName": "main",
      "headRefOid": "8ffee4c168ad61b02e8e734fbf312536f2a4e2dc",
      "closedAt": "2022-09-30T21:17:24Z",
      "mergedAt": "2022-09-30T21:17:24Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "126da84300830694619f85ad36051c8ee37e9a79"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Looking good! However, CI is still complaining about spurious whitespace: https://github.com/cfrg/draft-irtf-cfrg-vdaf/actions/runs/3063497529/jobs/4945718835",
          "createdAt": "2022-09-15T20:38:29Z",
          "updatedAt": "2022-09-15T20:38:29Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Looking good! One minor nit, then we'll need to \"squash\" the commits on this branch into a single one. This can be done with an \"interactive rebase\":\r\n\r\n```\r\n$ git rebase main -i\r\n```\r\n\r\nThis will pull up your editor and give you instructions for how to carry out the rebase. You will \"pick\" the first commit, then \"squash\" each subsequent commit into the first. You will have a chance to edit the commit title and message: Make sure the title is succinct (the title of this PR works perfectly fine) and that the message is complete. By \"complete\" I mean that it should be evident to the reader what has changed and why.\r\n\r\nAlso, this PR includes an orthogonal change to poc/README.md that fixes some typos. It's great to pick up these kinds of changes in PRs. However, it's important that the commit history reflects all changes, even minimal ones. There are two ways we can address this:\r\n1. (ideal) Pull the change out into a separate commit\r\n2. (perfectly fine, especially for a spec) Note in the commit message that the commit also includes minor editorial changes.\r\n\r\nFinally, once the rebase is complete, you will have to \"force-push\" your branch. Be careful because this rewrites history. (git provides a backup if needed.)\r\n\r\n```\r\n$ git push -f\r\n```\r\n\r\nOnce done, ping me and I will verify the delta after force-push.",
          "createdAt": "2022-09-20T19:38:42Z",
          "updatedAt": "2022-09-20T19:39:32Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5CDwS1",
          "commit": {
            "abbreviatedOid": "b84c82d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks Hannah! This PR will need a couple more things before it can be merged:\r\n1. The definition of Poplar1 needs to be updated to pass `nonce` to `measurement_to_input_shares()`. It's fine that it ignores it, but we want to keep the API boundaries consistent nonetheless.\r\n2. The reference implementation needs to be updated to match. (See the `poc/` folder.) When making a change like this, typically the first step is to update the reference implementation, make sure the tests pass, then copy the updated definitions into the draft.",
          "createdAt": "2022-09-14T22:24:08Z",
          "updatedAt": "2022-09-14T22:31:10Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "You can remove the change log update; we typically wait to do this until the next draft is cut.\r\n\r\nFWIW, I would summarize the Prio3 change as follows:\r\n\r\n> Prio3: Add the nonce to the transcript for joint randomness computation. This improves the provable security bound for robustness.",
              "createdAt": "2022-09-14T22:24:08Z",
              "updatedAt": "2022-09-14T22:35:34Z"
            },
            {
              "originalPosition": 22,
              "body": "I don't think this is all that useful here. \r\n```suggestion\r\n```",
              "createdAt": "2022-09-14T22:27:35Z",
              "updatedAt": "2022-09-14T22:31:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5CJTzr",
          "commit": {
            "abbreviatedOid": "f895012"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-09-15T19:30:29Z",
          "updatedAt": "2022-09-15T19:40:32Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Let's revert this, as `TEST_VECTOR == True` is only needed for generating test vectors.",
              "createdAt": "2022-09-15T19:30:29Z",
              "updatedAt": "2022-09-15T19:40:32Z"
            },
            {
              "originalPosition": 9,
              "body": "Let's revert this. Bumping the version is usually a chore saved until just before cutting the draft.",
              "createdAt": "2022-09-15T19:31:08Z",
              "updatedAt": "2022-09-15T19:40:32Z"
            },
            {
              "originalPosition": 1,
              "body": "There might be other breaking changes for VDAF-04, so we'll wait to update the test vectors until just before cutting.",
              "createdAt": "2022-09-15T19:31:34Z",
              "updatedAt": "2022-09-15T19:40:32Z"
            },
            {
              "originalPosition": 7,
              "body": "The spacing here is a bit odd. \r\n```suggestion\r\n                                    nonce: Bytes) -> (Bytes, Vec[Bytes]):\r\n```",
              "createdAt": "2022-09-15T19:34:36Z",
              "updatedAt": "2022-09-15T19:40:32Z"
            },
            {
              "originalPosition": 5,
              "body": "nit: In Python (i.e., Sage :D) it's conventional to prefix ignored parameters with an underscore.\r\n```suggestion\r\n    def measurement_to_input_shares(Poplar1, measurement, _nonce):\r\n```",
              "createdAt": "2022-09-15T19:35:54Z",
              "updatedAt": "2022-09-15T19:40:32Z"
            },
            {
              "originalPosition": 10,
              "body": "```suggestion\r\n(cf. {{sec-daf-shard}}); in addition, it takes a nonce as input and \r\n```",
              "createdAt": "2022-09-15T19:36:57Z",
              "updatedAt": "2022-09-15T19:40:32Z"
            },
            {
              "originalPosition": 78,
              "body": "```suggestion\r\ndef measurement_to_input_shares(Poplar1, measurement, _nonce):\r\n```",
              "createdAt": "2022-09-15T19:37:39Z",
              "updatedAt": "2022-09-15T19:40:32Z"
            },
            {
              "originalPosition": 5,
              "body": "Let's revert this. We only want to set `TEST_VECTOR == True` when we want to generate the test vectors; otherwise, the tests use truly random bits, which is what we want.",
              "createdAt": "2022-09-15T19:38:37Z",
              "updatedAt": "2022-09-15T19:40:32Z"
            },
            {
              "originalPosition": 15,
              "body": "* `make` fails if a line ends with trailing white space:\r\n  ```\r\n  $ make\r\n  757:Sharding transforms a measurement into input shares as it does in DAFs\r\n  758:(cf. {{sec-daf-shard}}); in VDAFs it additionally takes a nonce as input and\r\n  761:* `Vdaf.measurement_to_input_shares(measurement: Measurement, nonce: Bytes) ->\r\n  763:  Client. It consumes the measurement and the nonce and\r\n  draft-irtf-cfrg-vdaf.md contains trailing whitespace\r\n  *** Run 'make fix-lint' to automatically fix some errors\r\n  make: *** [lint-whitespace] Error 1\r\n  ```\r\n\r\n* Also, lines should break at 80 characters.\r\n\r\n```suggestion\r\n  Client. It consumes the measurement and the nonce and\r\n```",
              "createdAt": "2022-09-15T19:39:49Z",
              "updatedAt": "2022-09-15T19:40:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5CJiV5",
          "commit": {
            "abbreviatedOid": "f895012"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-15T20:27:24Z",
          "updatedAt": "2022-09-15T20:27:25Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done",
              "createdAt": "2022-09-15T20:27:24Z",
              "updatedAt": "2022-09-15T20:27:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Ca_bP",
          "commit": {
            "abbreviatedOid": "047787c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T19:32:53Z",
          "updatedAt": "2022-09-28T20:53:04Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "nit: Lines need to wrap at 80 characters. You will need to fix up this entire paragraph so that each line is properly justified.",
              "createdAt": "2022-09-20T19:32:53Z",
              "updatedAt": "2022-09-28T20:53:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5DMfS0",
          "commit": {
            "abbreviatedOid": "8ffee4c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Nice work!",
          "createdAt": "2022-09-30T20:49:27Z",
          "updatedAt": "2022-09-30T20:49:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 120,
      "id": "PR_kwDOGKuqOc4_zwZG",
      "title": "Improved verification scheme for Poplar1",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/120",
      "state": "CLOSED",
      "author": "hannahdaviscrypto",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-28T20:52:02Z",
      "updatedAt": "2022-11-04T22:24:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "74d8d23666896a7609712ca384e287557a905398",
      "headRepository": "hannahdaviscrypto/draft-irtf-cfrg-vdaf",
      "headRefName": "new-verif",
      "headRefOid": "e48c7e31b848451283d6cf776bc864347c3c3f0f",
      "closedAt": "2022-11-04T22:24:36Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The protocol that this pull request was designed to implement has privacy issues; closing it while we develop an alternative.",
          "createdAt": "2022-11-04T22:24:36Z",
          "updatedAt": "2022-11-04T22:24:36Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5DHQDw",
          "commit": {
            "abbreviatedOid": "a8864c8"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This looks to be mostly correct to me. A couple of high level things:\r\n\r\n1. Looks like this only supports checking that the non-zero element of the vector is in range [0, 1). In fact, the new scheme supports [0, k) for any small k. I think we should incorporate that generalization here. (Remember that the hash sequence sent to the peer needs to be shifted by a random amount.)\r\n\r\n2. Tests are failing on my machine:\r\n```\r\n$ make && sage vdaf_poplar1.sage\r\nmake: Nothing to be done for `pyfiles'.\r\nrandomness\t: 14474163779119285356\r\nrandomness\t: 23710317869799874109156653167373759793599482990239257754186445210723389039029\r\nauth_sum:\t 14474163779119285356\r\nauth_sum:\t 0\r\ninbound:\t 95eec14105e696c84525532a65df37fd533d9ce30896df1db60bc754fb26d8de\r\ncheck_bound:\t 95eec14105e696c84525532a65df37fd\r\nTraceback (most recent call last):\r\n  File \"/Users/chris/github.com/cfrg/draft-irtf-cfrg-vdaf/poc/vdaf_poplar1.sage.py\", line 350, in <module>\r\n    test_vdaf(Poplar1Aes128.with_bits(_sage_const_2 ),\r\n  File \"/Users/chris/github.com/cfrg/draft-irtf-cfrg-vdaf/poc/sagelib/vdaf.py\", line 373, in test_vdaf\r\n    agg_result = run_vdaf(Vdaf,\r\n  File \"/Users/chris/github.com/cfrg/draft-irtf-cfrg-vdaf/poc/sagelib/vdaf.py\", line 173, in run_vdaf\r\n    out = Vdaf.prep_next(prep_states[j], inbound)\r\n  File \"/Users/chris/github.com/cfrg/draft-irtf-cfrg-vdaf/poc/vdaf_poplar1.sage.py\", line 173, in prep_next\r\n    raise ERR_VERIFY #Input is one-hot but the entry is not 1\r\nsagelib.common.Error: verification of the user's input failed\r\n```",
          "createdAt": "2022-09-29T20:42:58Z",
          "updatedAt": "2022-09-29T21:34:05Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "nit: Remove spurious newline (here and below)",
              "createdAt": "2022-09-29T20:42:58Z",
              "updatedAt": "2022-09-29T21:34:05Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n        w += prg.next_vec(Field2, 1) # indicator vector\r\n```\r\nAlso, add a space after start of comment above.",
              "createdAt": "2022-09-29T20:43:43Z",
              "updatedAt": "2022-09-29T21:34:05Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n            encoded += Field.encode_vec(w_cw[:2]) # data, auth vector\r\n            encoded += Field2.encode_vec(w_cw[2:]) # indicator vector\r\n```",
              "createdAt": "2022-09-29T20:44:44Z",
              "updatedAt": "2022-09-29T21:34:05Z"
            },
            {
              "originalPosition": 21,
              "body": "Oofta, this is hairy. Here's how I suggest we fix it.\r\n\r\nA concrete `Idpf` defines two value \"types\", one for the the inner nodes and another for the leaves:\r\n\r\n```python\r\nclass Idpf:\r\n  ...\r\n  # The value type for inner nodes.\r\n  InnerValue: Vec[field.Field] = None\r\n\r\n  # The value type for leaf nodes.\r\n  LeafValue: Vec[field.Field] = None\r\n  ...\r\n```\r\n\r\nBasically the `InnerValue` and `LeafValue` define, respectively, a sequence of fields to generate the inner values and outer values. IIUC, this is sufficiently general for the new verification scheme. Now, in `IdpfPoplar`, we would wnat to generate values and correction words like so (compare to `IdpfPoplar.convert()`):\r\n\r\n```python\r\nValue = IdpfPoplar.current_value_type(level) # Either InnerValue or LeafValue\r\nw = []\r\nfor Field in Value:\r\n   w += Field.next_vec(Field, 1)\r\n```\r\n\r\nBy the way, I now see the value of nuking the `Idpf` syntax from the spec. Nevertheless, this is a bigger change that I think we need to defer to later on.",
              "createdAt": "2022-09-29T20:55:56Z",
              "updatedAt": "2022-09-29T21:34:05Z"
            },
            {
              "originalPosition": 57,
              "body": "Following my suggestion above, here we would have something like\r\n\r\n```python\r\n    cls = IdpfPoplar \\\r\n                .with_prg(prg.PrgAes128) \\\r\n                .with_inner_value_type(Field64, Field64, Field2) \\\r\n                .with_outer_value_type(Field255, Field255, Field2)\r\n```",
              "createdAt": "2022-09-29T21:01:35Z",
              "updatedAt": "2022-09-29T21:34:05Z"
            },
            {
              "originalPosition": 33,
              "body": "Perhaps we should rename `corr_seed`? `auth_seed`, maybe?",
              "createdAt": "2022-09-29T21:04:55Z",
              "updatedAt": "2022-09-29T21:34:05Z"
            },
            {
              "originalPosition": 62,
              "body": "This comment is no longer applicable.",
              "createdAt": "2022-09-29T21:06:37Z",
              "updatedAt": "2022-09-29T21:34:05Z"
            },
            {
              "originalPosition": 102,
              "body": "Isn't the correction word `w` supposed to be the XOR of the hashes, not the concatenation?",
              "createdAt": "2022-09-29T21:19:06Z",
              "updatedAt": "2022-09-29T21:34:05Z"
            },
            {
              "originalPosition": 172,
              "body": "```suggestion\r\n        # Leader expands randomness\r\n```",
              "createdAt": "2022-09-29T21:20:30Z",
              "updatedAt": "2022-09-29T21:34:05Z"
            },
            {
              "originalPosition": 204,
              "body": "```suggestion\r\n            data_sum -= z * data_share\r\n```",
              "createdAt": "2022-09-29T21:32:46Z",
              "updatedAt": "2022-09-29T21:34:05Z"
            },
            {
              "originalPosition": 245,
              "body": "Unnecessary paranetheses (here and below)\r\n```suggestion\r\n            if agg_id == 0:\r\n```",
              "createdAt": "2022-09-29T21:33:28Z",
              "updatedAt": "2022-09-29T21:34:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5DRe_K",
          "commit": {
            "abbreviatedOid": "a8864c8"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-03T16:04:54Z",
          "updatedAt": "2022-10-03T16:04:55Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "It's not the XOR or the concatenation, it's the sum (we're working with additive shares not boolean hence the change from Mike's writeup)",
              "createdAt": "2022-10-03T16:04:55Z",
              "updatedAt": "2022-10-03T16:04:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5DX3VQ",
          "commit": {
            "abbreviatedOid": "b8531df"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-04T17:05:49Z",
          "updatedAt": "2022-10-04T18:18:17Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "When possible, it's best to rely on types instead of values for validating inputs. The latter is prone to bugs, especially in Python where types are meaningless :D\r\n\r\n```suggestion\r\n            if len(b) != len(IdpfPoplar.current_value_type(level)):\r\n```",
              "createdAt": "2022-10-04T17:05:49Z",
              "updatedAt": "2022-10-04T18:18:17Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\n            w += prg.next_vec(Field, 1)\r\n```",
              "createdAt": "2022-10-04T17:06:56Z",
              "updatedAt": "2022-10-04T18:18:17Z"
            },
            {
              "originalPosition": 51,
              "body": "```suggestion\r\n                encoded += Field.encode_vec(v)\r\n```",
              "createdAt": "2022-10-04T17:07:34Z",
              "updatedAt": "2022-10-04T18:18:17Z"
            },
            {
              "originalPosition": 49,
              "body": "Use an iterator here to improve readability:\r\n```suggestion\r\n            for (Field, elem) in zip(Value, w_cw):\r\n                 encoded += Field.encode_vec([elem])\r\n```",
              "createdAt": "2022-10-04T17:09:35Z",
              "updatedAt": "2022-10-04T18:18:18Z"
            },
            {
              "originalPosition": 90,
              "body": "Hmm, should we assert that len(value_inner) == len(value_leaf)?",
              "createdAt": "2022-10-04T17:11:11Z",
              "updatedAt": "2022-10-04T18:18:18Z"
            },
            {
              "originalPosition": 38,
              "body": "We likely ahve use cases where we would want to add weight to the output share",
              "createdAt": "2022-10-04T18:18:14Z",
              "updatedAt": "2022-10-04T18:18:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5De4_i",
          "commit": {
            "abbreviatedOid": "b8531df"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-06T00:07:53Z",
          "updatedAt": "2022-10-06T00:07:54Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "Is the Field type is not necessarily the same for data and auth?",
              "createdAt": "2022-10-06T00:07:53Z",
              "updatedAt": "2022-10-06T00:07:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5De6Sj",
          "commit": {
            "abbreviatedOid": "b8531df"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-06T00:19:17Z",
          "updatedAt": "2022-10-06T00:19:18Z",
          "comments": [
            {
              "originalPosition": 431,
              "body": "Please relabel parameter to make this easier to read\r\n```suggestion\r\n    def hash1(Poplar1, level, prefix, elems):\r\n```",
              "createdAt": "2022-10-06T00:19:18Z",
              "updatedAt": "2022-10-06T00:19:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5DfIb7",
          "commit": {
            "abbreviatedOid": "b8531df"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-06T02:27:26Z",
          "updatedAt": "2022-10-06T02:27:26Z",
          "comments": [
            {
              "originalPosition": 299,
              "body": "I think the upper bound should be strict. That is, the range check should assert that the value is in range [0..k).",
              "createdAt": "2022-10-06T02:27:26Z",
              "updatedAt": "2022-10-06T02:27:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5DfIg7",
          "commit": {
            "abbreviatedOid": "b8531df"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-06T02:27:57Z",
          "updatedAt": "2022-10-06T02:27:57Z",
          "comments": [
            {
              "originalPosition": 233,
              "body": "Can we de-duplicate this code?",
              "createdAt": "2022-10-06T02:27:57Z",
              "updatedAt": "2022-10-06T02:27:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5DfXVP",
          "commit": {
            "abbreviatedOid": "b8531df"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-06T04:35:46Z",
          "updatedAt": "2022-10-06T04:35:47Z",
          "comments": [
            {
              "originalPosition": 237,
              "body": "Doesn't `hash2()` need to be a random hash function unknown to the attacker? I.e., don't we want to pass in something dervied from `verify_key` here?",
              "createdAt": "2022-10-06T04:35:47Z",
              "updatedAt": "2022-10-06T04:35:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Djmoy",
          "commit": {
            "abbreviatedOid": "b8531df"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-06T17:39:59Z",
          "updatedAt": "2022-10-06T17:40:00Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "That doesn't seem necessary to me. The two lengths need to be the same in our Poplar1 scheme, but only in the sense that they both need to equal 4 and it would seem too specific to assert that. I don't see a reason, especially in the leaf-is-k-bounded and inner-vals-are-1-bounded world that we couldn't have the leaves include multiple group elements, each of which are k-bounded. ",
              "createdAt": "2022-10-06T17:39:59Z",
              "updatedAt": "2022-10-06T17:40:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Djm6P",
          "commit": {
            "abbreviatedOid": "b8531df"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-06T17:40:55Z",
          "updatedAt": "2022-10-06T17:40:55Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "It should be the same type because auth is supposed to equal delta * (data) and this operation is only defined if they're the same type.",
              "createdAt": "2022-10-06T17:40:55Z",
              "updatedAt": "2022-10-06T17:40:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Djop0",
          "commit": {
            "abbreviatedOid": "b8531df"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-06T17:46:34Z",
          "updatedAt": "2022-10-06T17:46:34Z",
          "comments": [
            {
              "originalPosition": 237,
              "body": "I don't think it does? Hash_2 needs to be a random oracle for Privacy, in which case the attacker is Bob who knows verify_key (and the hash isn't private anyway), and for soundness, where the attacker genuinely has no reason to know H, we only require collision resistance.",
              "createdAt": "2022-10-06T17:46:34Z",
              "updatedAt": "2022-10-06T17:46:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 121,
      "id": "PR_kwDOGKuqOc5AV3zE",
      "title": "[poc] Prio3 improvements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/121",
      "state": "MERGED",
      "author": "hannahdaviscrypto",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In Prio3, a single PRG is used to derive random coins for several different purposes. These are differentiated using a domain separation string \"dst\" and a single byte. This byte is set to the aggregator index when deriving joint randomness parts, and to 255 for joint randomness seeds and query randomness, but it is omitted for joint randomness and prover randomness. I propose to include this byte in every PRG call, and to set it to 254 for joint randomness, and 253 for query and prover randomness. This will help in the eventual modeling of the PRG as a random oracle (as in Issue [#106](https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/106). ",
      "createdAt": "2022-10-06T18:59:48Z",
      "updatedAt": "2023-01-06T22:57:26Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "f676b839cb3de4525aa1e209074b65892b3dc690",
      "headRepository": "hannahdaviscrypto/draft-irtf-cfrg-vdaf",
      "headRefName": "prio3-domsep",
      "headRefOid": "c61f113acd5a2c7d04af66fa9cf2e6967021afa8",
      "closedAt": "2023-01-06T22:57:26Z",
      "mergedAt": "2023-01-06T22:57:26Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "a8e0f3e17651ee4591ca15c2971a377158957f5c"
      },
      "comments": [
        {
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Two more Prio3 changes added to this pull request: (1) a minor terminology change to distinguish between the aggregators' input shares and the measurement shares that the input shares contain, and (2) a moving joint randomness hints to the public share, which decreases total communication costs whenever there are more than two aggregators. (2) was discussed in Issue #114 along with the above domain separation change.",
          "createdAt": "2023-01-06T00:36:37Z",
          "updatedAt": "2023-01-06T00:36:37Z"
        },
        {
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Short answer, yes, it is best for all the tags to be the same length because they need to be prefix-free and having them be the same length makes that apparent. Also in some cases we use longer domain separation tags of the format dst + (usage byte) + (more stuff, often the aggregator's ID) and it's easier to argue separation for those if we don't have to worry about the byte alignment of the \"more stuff\". The global variable idea is a good one, I'll set that up.",
          "createdAt": "2023-01-06T19:22:41Z",
          "updatedAt": "2023-01-06T19:22:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5J23KO",
          "commit": {
            "abbreviatedOid": "ed72b36"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Looking great so far. One high-level comment: Using fixed constants, e.g., `251`, for the domain separators makes the spec difficult to read. I think we should replace these something that specifies what the derived bytes are used for, e.g., instead of `251` we have something like `\"query randomness\"`.\r\n\r\nHere's an important question: In your opinion, should each of these tags be equal length? If so, what we could do is keep them as single byte constants, but define the constants as global variables. For instance:\r\n\r\n```python\r\nDST_QUERY_RANDOMNESS = byte(251)\r\n```\r\n\r\nWhat do you think?",
          "createdAt": "2023-01-06T17:02:29Z",
          "updatedAt": "2023-01-06T17:22:53Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "nit: Column alignment can improve readability\r\n```suggestion\r\n                                               helper_measurement_share)\r\n```",
              "createdAt": "2023-01-06T17:02:29Z",
              "updatedAt": "2023-01-06T17:22:54Z"
            },
            {
              "originalPosition": 110,
              "body": "For consistency with the sharding algorithm. Alternatively we could use `k_hint` there instead of `k_joint_rand_parts`.\r\n```suggestion\r\n        k_joint_rand_parts = Prio3.decode_public_share(public_share, agg_id)\r\n```",
              "createdAt": "2023-01-06T17:12:00Z",
              "updatedAt": "2023-01-06T17:22:54Z"
            },
            {
              "originalPosition": 230,
              "body": "```suggestion\r\n        k_joint_rand_parts = None\r\n```",
              "createdAt": "2023-01-06T17:13:22Z",
              "updatedAt": "2023-01-06T17:22:54Z"
            },
            {
              "originalPosition": 221,
              "body": "```suggestion\r\n                            k_joint_rand_parts):\r\n```",
              "createdAt": "2023-01-06T17:14:59Z",
              "updatedAt": "2023-01-06T17:22:54Z"
            },
            {
              "originalPosition": 237,
              "body": "It's slightly odd to skip the the aggregator's part while decoding. I think it would be cleaner to decode all of the parts here, then overwrite it later like we do in the paper.",
              "createdAt": "2023-01-06T17:17:06Z",
              "updatedAt": "2023-01-06T17:22:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5J3g74",
          "commit": {
            "abbreviatedOid": "ed72b36"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-06T19:33:23Z",
          "updatedAt": "2023-01-06T19:33:24Z",
          "comments": [
            {
              "originalPosition": 237,
              "body": "Sure, done.",
              "createdAt": "2023-01-06T19:33:24Z",
              "updatedAt": "2023-01-06T19:33:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5J3jSX",
          "commit": {
            "abbreviatedOid": "ed72b36"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-06T19:43:14Z",
          "updatedAt": "2023-01-06T19:43:15Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "Sure",
              "createdAt": "2023-01-06T19:43:14Z",
              "updatedAt": "2023-01-06T19:43:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5J3miv",
          "commit": {
            "abbreviatedOid": "26b2a26"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-06T19:57:52Z",
          "updatedAt": "2023-01-06T20:14:43Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Since these tags no longer collide with the aggregator ID (right?), we might as well renumber them 0 to 7\r\n```suggestion\r\nDST_JOINT_RAND_HINT = byte(0)\r\n```",
              "createdAt": "2023-01-06T19:57:52Z",
              "updatedAt": "2023-01-06T20:14:43Z"
            },
            {
              "originalPosition": 138,
              "body": "I would give this variable a name that distinguishes it from `k_joint_rand_parts` parsed from the public share. Maybe something like `k_checked_joint_rand_parts`? Accordingly, maybe `k_joint_rand` should be renamed to `k_checked_joint_rand`?",
              "createdAt": "2023-01-06T20:07:47Z",
              "updatedAt": "2023-01-06T20:14:43Z"
            },
            {
              "originalPosition": 1,
              "body": "This won't compile because `byte` is not in scope yet. We need to move the constants after the imports.",
              "createdAt": "2023-01-06T20:08:44Z",
              "updatedAt": "2023-01-06T20:14:43Z"
            },
            {
              "originalPosition": 269,
              "body": "The control flow in this function makes it difficult to modify later on. In particular, here you are doing:\r\n```python\r\nthing = X\r\nif not special_case:\r\n    consume_buffer\r\n    thing = Y\r\nensure_buffer_is_empty\r\nreturn thing\r\n```\r\n\r\nThe following control flow is preferable, as it makes failures more obvious:\r\n```python\r\nif special_case:\r\n   ensure_buffer_is_empty\r\n   return X\r\n\r\nconsume_buffer\r\nensure_buffer_is_empty\r\nreturn Y\r\n```",
              "createdAt": "2023-01-06T20:14:13Z",
              "updatedAt": "2023-01-06T20:15:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5J3v8F",
          "commit": {
            "abbreviatedOid": "26b2a26"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-06T20:20:32Z",
          "updatedAt": "2023-01-06T20:20:32Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Can we do 1-7 to match the paper?",
              "createdAt": "2023-01-06T20:20:32Z",
              "updatedAt": "2023-01-06T20:20:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5J3wg0",
          "commit": {
            "abbreviatedOid": "26b2a26"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-06T20:21:34Z",
          "updatedAt": "2023-01-06T20:21:34Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Works for me",
              "createdAt": "2023-01-06T20:21:34Z",
              "updatedAt": "2023-01-06T20:21:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5J35fl",
          "commit": {
            "abbreviatedOid": "26b2a26"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-06T20:50:22Z",
          "updatedAt": "2023-01-06T20:50:22Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "I think k_checked_joint_rand would get confusing since we already have k_joint_rand_check. Trying \"corrected\" instead since we're actually overwriting.",
              "createdAt": "2023-01-06T20:50:22Z",
              "updatedAt": "2023-01-06T20:50:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5J36-Y",
          "commit": {
            "abbreviatedOid": "26b2a26"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-06T20:55:01Z",
          "updatedAt": "2023-01-06T20:55:02Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "ah, yes. good catch",
              "createdAt": "2023-01-06T20:55:01Z",
              "updatedAt": "2023-01-06T20:55:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5J4KiU",
          "commit": {
            "abbreviatedOid": "14c4c15"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-06T21:51:11Z",
          "updatedAt": "2023-01-06T22:07:51Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "nit: It would be a bit neater to group this with the other randomnesses.",
              "createdAt": "2023-01-06T21:51:11Z",
              "updatedAt": "2023-01-06T22:07:52Z"
            },
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nDST_JOINT_RAND_PART = byte(7)\r\n```",
              "createdAt": "2023-01-06T21:53:52Z",
              "updatedAt": "2023-01-06T22:07:52Z"
            },
            {
              "originalPosition": 7,
              "body": "To match part-of-speech for DST_QUERY_RANDOMNESS (verb rather than noun)\r\n```suggestion\r\nDST_PROVE_RANDOMNESS = byte(4)\r\n```",
              "createdAt": "2023-01-06T21:54:38Z",
              "updatedAt": "2023-01-06T22:07:52Z"
            },
            {
              "originalPosition": 91,
              "body": "nit: Break lines at 80 characters\r\n```suggestion\r\n        # proof share, and blind. The public share contains all aggregators'\r\n        # joint randomness parts.\r\n```",
              "createdAt": "2023-01-06T21:55:48Z",
              "updatedAt": "2023-01-06T22:07:52Z"
            },
            {
              "originalPosition": 235,
              "body": "While technically correct, this code makes it look as if `-23` might be a valid value for `JOINT_RAND_LEN`. (Similarly below.)\r\n```suggestion\r\n        if Prio3.Flp.JOINT_RAND_LEN == 0:\r\n```",
              "createdAt": "2023-01-06T22:02:58Z",
              "updatedAt": "2023-01-06T22:07:52Z"
            },
            {
              "originalPosition": 283,
              "body": "```suggestion\r\n        if Prio3.Flp.JOINT_RAND_LEN == 0:\r\n```",
              "createdAt": "2023-01-06T22:05:18Z",
              "updatedAt": "2023-01-06T22:07:52Z"
            },
            {
              "originalPosition": 308,
              "body": "```suggestion\r\n        if Prio3.Flp.JOINT_RAND_LEN == 0:\r\n```",
              "createdAt": "2023-01-06T22:06:24Z",
              "updatedAt": "2023-01-06T22:07:52Z"
            },
            {
              "originalPosition": 331,
              "body": "```suggestion\r\n        if Prio3.Flp.JOINT_RAND_LEN == 0:\r\n```",
              "createdAt": "2023-01-06T22:07:23Z",
              "updatedAt": "2023-01-06T22:07:52Z"
            },
            {
              "originalPosition": 348,
              "body": "```suggestion\r\n        if Prio3.Flp.JOINT_RAND_LEN == 0:\r\n```",
              "createdAt": "2023-01-06T22:07:42Z",
              "updatedAt": "2023-01-06T22:07:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5J4O2H",
          "commit": {
            "abbreviatedOid": "14c4c15"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-06T22:15:10Z",
          "updatedAt": "2023-01-06T22:15:10Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Ok. we should make a note to change the paper before it gets published then.",
              "createdAt": "2023-01-06T22:15:10Z",
              "updatedAt": "2023-01-06T22:15:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5J4PUh",
          "commit": {
            "abbreviatedOid": "14c4c15"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-06T22:18:09Z",
          "updatedAt": "2023-01-06T22:18:09Z",
          "comments": [
            {
              "originalPosition": 235,
              "body": "Funnily enough, i started with == and then changed it, in the hopes that if -23 showed up as an invalid value it would cause an ERR_DECODE.",
              "createdAt": "2023-01-06T22:18:09Z",
              "updatedAt": "2023-01-06T22:18:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5J4P4p",
          "commit": {
            "abbreviatedOid": "ab1e0e4"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Looks good to me! Last step: Please squash the commits and fix up the commit message. In the body of the message, make sure to list the things that are changing.",
          "createdAt": "2023-01-06T22:21:59Z",
          "updatedAt": "2023-01-06T22:21:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5J4VZ7",
          "commit": {
            "abbreviatedOid": "c61f113"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Approved. Thanks for making VDAFs better, @hannahdaviscrypto !",
          "createdAt": "2023-01-06T22:57:17Z",
          "updatedAt": "2023-01-06T22:57:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 123,
      "id": "PR_kwDOGKuqOc5CFjC5",
      "title": "Fix: Format test vector out shares as hex strings",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/123",
      "state": "MERGED",
      "author": "jbr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Although large integers are not excluded from the json spec, many languages such as javascript do not correctly parse them into a type that can correctly represent these numbers. This commit changes those large integers into hex strings, as per #116.\r\n\r\nCloses #116\r\n\r\nExample change to the output json:\r\n```diff\r\ndiff --git a/poc/test_vec/03/Prio3Aes128Histogram_0.json b/poc/test_vec/03/Prio3Aes128Histogram_0.json\r\nindex f5476455fa53ba563338721391f6f8d15f8c7f46..7bdfc4ef6e54edeed1c595be7cbe926e9cbeea30 100644\r\n--- a/poc/test_vec/03/Prio3Aes128Histogram_0.json\r\n+++ b/poc/test_vec/03/Prio3Aes128Histogram_0.json\r\n@@ -25,16 +25,16 @@\r\n             \"nonce\": \"01010101010101010101010101010101\",\r\n             \"out_shares\": [\r\n                 [\r\n-                    316441748434879643753815489063091297628,\r\n-                    208470253761472213750543248431791209107,\r\n-                    245951175238245845331446316072865931791,\r\n-                    133415875449384174923011884997795018199\r\n+                    \"ee1076c1ebc2d48a557a71031bc9dd5c\",\r\n+                    \"9cd5e91180bbb51f4ac366946bcbfa93\",\r\n+                    \"b908792bd15d402f4ac8da264e24a20f\",\r\n+                    \"645ef68472180c5894bac704ae0675d7\"\r\n                 ],\r\n                 [\r\n-                    23840618486058819193050284304809468581,\r\n-                    131812113159466249196322524936109557102,\r\n-                    94331191682692617615419457295034834419,\r\n-                    206866491471554288023853888370105748010\r\n+                    \"11ef893e143d2b59aa858efce43622a5\",\r\n+                    \"632a16ee7f444ac4b53c996b9434056e\",\r\n+                    \"46f786d42ea2bfb4b53725d9b1db5df3\",\r\n+                    \"9ba1097b8de7f38b6b4538fb51f98a2a\"\r\n                 ]\r\n             ],\r\n             \"prep_messages\": [\r\n```",
      "createdAt": "2022-11-02T19:49:17Z",
      "updatedAt": "2022-11-03T00:04:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "126da84300830694619f85ad36051c8ee37e9a79",
      "headRepository": "jbr/draft-irtf-cfrg-vdaf",
      "headRefName": "format-test-vector-big-ints-as-hex-strings",
      "headRefOid": "96b1abd1d21da2be5368183059c270b9d21ae270",
      "closedAt": "2022-11-03T00:04:21Z",
      "mergedAt": "2022-11-03T00:04:21Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "ee2db723e121dbe068b504d423c0426bac538669"
      },
      "comments": [
        {
          "author": "jbr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As far as I know, the other numbers are small enough to be safe in IEE754 representation (< 2^53)",
          "createdAt": "2022-11-02T23:21:01Z",
          "updatedAt": "2022-11-02T23:21:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5FgNKO",
          "commit": {
            "abbreviatedOid": "96b1abd"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks! Any concerns about smaller numbers, such as the aggregate result in each set of test vectors?",
          "createdAt": "2022-11-02T22:10:25Z",
          "updatedAt": "2022-11-02T22:10:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 126,
      "id": "PR_kwDOGKuqOc5E8nj9",
      "title": "Change TestVdaf.AggResult to Unsigned",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/126",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR updates `TestVdaf` in the proof of concept implementation so that `AggResult` is a bare integer, instead of a vector of integers of length one. At the time this class was written, the aggregate result type wasn't configurable, and this hasn't been updated to take advantage of that yet. This came up during discussion on divviup/divviup-ts#157.",
      "createdAt": "2022-12-09T21:50:35Z",
      "updatedAt": "2022-12-14T00:30:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "ee2db723e121dbe068b504d423c0426bac538669",
      "headRepository": "divergentdave/vdaf",
      "headRefName": "david/simplify-TestVdaf-agg-result",
      "headRefOid": "23dbe1e97467afe2f1e161def1f5131a3b15b051",
      "closedAt": "2022-12-14T00:30:06Z",
      "mergedAt": "2022-12-14T00:30:06Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "1744d259f6f67f5a165d994434103e054c03073e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5IhAoA",
          "commit": {
            "abbreviatedOid": "23dbe1e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-14T00:30:01Z",
          "updatedAt": "2022-12-14T00:30:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 128,
      "id": "PR_kwDOGKuqOc5Glorr",
      "title": "fix poc: \"ipdf\" instead of \"idpf\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/128",
      "state": "MERGED",
      "author": "jbr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Noticed a typo in the poplar POC",
      "createdAt": "2023-01-04T04:25:32Z",
      "updatedAt": "2023-01-04T21:48:07Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "1744d259f6f67f5a165d994434103e054c03073e",
      "headRepository": "jbr/draft-irtf-cfrg-vdaf",
      "headRefName": "ipdf",
      "headRefOid": "dd1cd076b8809ce09bc92f1939ea6470a044dee1",
      "closedAt": "2023-01-04T21:48:07Z",
      "mergedAt": "2023-01-04T21:48:07Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "f676b839cb3de4525aa1e209074b65892b3dc690"
      },
      "comments": [
        {
          "author": "jbr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see any other uses of \"ipdf\" in the repository",
          "createdAt": "2023-01-04T20:37:04Z",
          "updatedAt": "2023-01-04T20:37:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5JrvLl",
          "commit": {
            "abbreviatedOid": "dd1cd07"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "\ud83d\udc4d thanks! Can you check to see if this needs to be fixed in the actual spec as well (draft-irtf-cfrg-vdaf.md)?",
          "createdAt": "2023-01-04T17:01:44Z",
          "updatedAt": "2023-01-04T17:01:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5Js90f",
          "commit": {
            "abbreviatedOid": "dd1cd07"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-04T21:48:02Z",
          "updatedAt": "2023-01-04T21:48:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 129,
      "id": "PR_kwDOGKuqOc5HBq3A",
      "title": "poc: Prio3: Reuse the same seed for multiple functions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/129",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Each input share includes a blinding factor, a PRG seed used to derive the Aggregator's part of the joint randomness. In addition, each Helper share includes two seeds, one for its measurement share and another for its proof share.\r\n\r\nIn the (not yet published) analysis of Prio3, it was found that, as long as a distinct domain separation tag is used for each of these functions, it is safe to use the same seed for deriving the input share, proof share, and joint randomness part. This improves communication cost slightly and simplifies the algorithm.\r\n\r\ncc/ @hannahdaviscrypto \r\n\r\n",
      "createdAt": "2023-01-09T23:51:33Z",
      "updatedAt": "2023-04-24T21:37:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "7103e1e9f2ae7d564153d688f21e914d30a1427c",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/poc-prio3-one-seed",
      "headRefOid": "e3411d403af734d67cc597a764d50697badd0b48",
      "closedAt": "2023-03-02T01:21:03Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we should put a pause on this for now; this change needs a little more formal security analysis before we move forward.\r\n\r\nIn a scheme that derives the secret input share and proof share from the same seed as the public joint randomness part,  a malicious aggregator has the ability to perform a brute-force search for the input share by repeatedly guessing a seed, rederiving the joint randomness hint, and comparing its result with the public share. If the seed is sufficiently high entropy, the scheme may still be considered secure and we may want to make this change regardless, but it's going to change the security analysis a little and we should address that first.\r\n\r\nThis concern likely does not extend to Doplar because the joint randomness hints there also depend on secret VIDPF keys.",
          "createdAt": "2023-01-13T21:46:47Z",
          "updatedAt": "2023-01-13T21:46:47Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Filed #185 to track this.",
          "createdAt": "2023-03-02T01:21:03Z",
          "updatedAt": "2023-03-02T01:21:03Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 130,
      "id": "PR_kwDOGKuqOc5HBwXQ",
      "title": "poc: Prio3: Increase upper bound on share count to 256",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/130",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is thereotically possible now that we don't need this byte for domain separation.\r\n\r\ncc/ @hannahdaviscrypto ",
      "createdAt": "2023-01-10T00:22:28Z",
      "updatedAt": "2023-04-24T21:37:07Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "7103e1e9f2ae7d564153d688f21e914d30a1427c",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/prio3-num-shares",
      "headRefOid": "cce001d1d1b0e0a5f34d8fc0a41a445cdb7ae166",
      "closedAt": "2023-02-02T14:54:36Z",
      "mergedAt": "2023-02-02T14:54:36Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "308afe18abd938e82a79aec9cd8159e29d45c087"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 131,
      "id": "PR_kwDOGKuqOc5HB6du",
      "title": "poc: IdpfPoplar: Avoid branching on control bits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/131",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Control bits are secret, so in order to reduce the risk of leaking them via a timing channel, implementations need to avoid branching on them. This is somewhat subtle, so spell out constant-time algorithms in a few places in the IDPF implementation.\r\n\r\nCredit to @divergentdave for pointing out this deficiency in the spec, and for devising a couple of the algorithms.",
      "createdAt": "2023-01-10T01:13:04Z",
      "updatedAt": "2023-04-24T21:37:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "7103e1e9f2ae7d564153d688f21e914d30a1427c",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/idpf-constant",
      "headRefOid": "23b0407c5d307ab83e9b908f953727c2a722e22c",
      "closedAt": "2023-01-13T22:01:18Z",
      "mergedAt": "2023-01-13T22:01:18Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "dc5b2ca59efce9cde8267df59667a3d30282e4e2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5KDskk",
          "commit": {
            "abbreviatedOid": "a187d95"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "There's one more conditional we should transform, then the extracts in the spec can be updated too.",
          "createdAt": "2023-01-10T15:45:06Z",
          "updatedAt": "2023-01-10T15:55:39Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "We should make similar bit-to-mask changes for the \"if prev_ctrl...\" block above.",
              "createdAt": "2023-01-10T15:45:06Z",
              "updatedAt": "2023-01-10T15:55:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5KFhEW",
          "commit": {
            "abbreviatedOid": "7f91b9b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-10T20:58:26Z",
          "updatedAt": "2023-01-10T20:58:26Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Done, good catch.",
              "createdAt": "2023-01-10T20:58:26Z",
              "updatedAt": "2023-01-10T20:58:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5KFz4n",
          "commit": {
            "abbreviatedOid": "aeabb3b"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-10T22:03:50Z",
          "updatedAt": "2023-01-10T22:04:35Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "```suggestion\r\n        # Implementation note: Here we add the correction word to the\r\n```",
              "createdAt": "2023-01-10T22:03:50Z",
              "updatedAt": "2023-01-10T22:04:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5KGuct",
          "commit": {
            "abbreviatedOid": "5d53303"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-11T04:38:21Z",
          "updatedAt": "2023-01-11T04:38:22Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "This is sometimes called [\"conditional select\"](https://docs.rs/subtle/latest/subtle/trait.ConditionallySelectable.html). I'm not sure if there is a widely used term for this.",
              "createdAt": "2023-01-11T04:38:21Z",
              "updatedAt": "2023-01-11T04:38:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5KaysN",
          "commit": {
            "abbreviatedOid": "5d53303"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-13T21:11:49Z",
          "updatedAt": "2023-01-13T21:27:44Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I think `conditional_select` is more descriptive.",
              "createdAt": "2023-01-13T21:11:49Z",
              "updatedAt": "2023-01-13T21:27:44Z"
            },
            {
              "originalPosition": 63,
              "body": "In other languages, there might be a concern that the compiler \"optimizes\" this to `y[i] = 0 if mask == 0 else w_cw[i]` or something similar, in particular if checking for zero is cheaper than multiplication. Not sure if that's the case with Sage.",
              "createdAt": "2023-01-13T21:27:01Z",
              "updatedAt": "2023-01-13T21:27:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Ka9-0",
          "commit": {
            "abbreviatedOid": "5d53303"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T21:55:25Z",
          "updatedAt": "2023-01-13T21:55:25Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done.",
              "createdAt": "2023-01-13T21:55:25Z",
              "updatedAt": "2023-01-13T21:55:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Ka-uT",
          "commit": {
            "abbreviatedOid": "5d53303"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T21:57:05Z",
          "updatedAt": "2023-01-13T21:57:05Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Hmm yeah. Though I think this falls into the category of \"finite field arithmetic needs to be constant time\", i.e., https://github.com/divviup/libprio-rs/blob/main/src/fp.rs#L81.",
              "createdAt": "2023-01-13T21:57:05Z",
              "updatedAt": "2023-01-13T21:57:05Z"
            }
          ]
        }
      ]
    },
    {
      "number": 132,
      "id": "PR_kwDOGKuqOc5HHIn3",
      "title": "poc: Generate test vectors for IdpfPoplar",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/132",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For a given input `alpha`, generate the expected public and key shares.",
      "createdAt": "2023-01-10T23:54:48Z",
      "updatedAt": "2023-04-24T21:37:02Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "dc5b2ca59efce9cde8267df59667a3d30282e4e2",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/idpf-test-vec",
      "headRefOid": "a7a97a608e5faa5f961068c6e9719fa5d4fa1664",
      "closedAt": "2023-02-28T15:40:43Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "cc/ @divergentdave this might help you get going. Note that the public share looks highly non-random because the IPDF key shares are identical:\r\n```\r\n{\r\n    \"beta_inner\": [\r\n        [\r\n            1,\r\n            1\r\n        ],\r\n        [\r\n            1,\r\n            1\r\n        ],\r\n        [\r\n            1,\r\n            1\r\n        ],\r\n        [\r\n            1,\r\n            1\r\n        ],\r\n        [\r\n            1,\r\n            1\r\n        ],\r\n        [\r\n            1,\r\n            1\r\n        ],\r\n        [\r\n            1,\r\n            1\r\n        ],\r\n        [\r\n            1,\r\n            1\r\n        ],\r\n        [\r\n            1,\r\n            1\r\n        ]\r\n    ],\r\n    \"beta_leaf\": [\r\n        1,\r\n        1\r\n    ],\r\n    \"keys\": [\r\n        \"01010101010101010101010101010101\",\r\n        \"01010101010101010101010101010101\"\r\n    ],\r\n    \"public_share\": \"055555000000000000000000000000000000000000000000000001000000000000000100000000000000000000000000000000ffffffff00000000ffffffff0000000000000000000000000000000000000000ffffffff00000000ffffffff0000000000000000000000000000000000000000ffffffff00000000ffffffff0000000000000000000000000000000000000000ffffffff00000000ffffffff000000000000000000000000000000000000000000000000000000010000000000000001000000000000000000000000000000000000000000000001000000000000000100000000000000000000000000000000000000000000000100000000000000010000000000000000000000000000000000000000000000010000000000000001000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec\"\r\n}\r\n```",
          "createdAt": "2023-01-10T23:56:24Z",
          "updatedAt": "2023-01-10T23:56:24Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@divergentdave just a heads up that I update the value of `alpha` used for unit tests so that bit order is easier to test.",
          "createdAt": "2023-01-17T22:27:48Z",
          "updatedAt": "2023-01-17T22:27:48Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "- [ ] To make this more useful, the key shares should be distinct strings so that the correction words don't end up canceling out.",
          "createdAt": "2023-01-17T22:53:47Z",
          "updatedAt": "2023-01-17T22:53:47Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed in favor of #162.",
          "createdAt": "2023-02-28T15:40:43Z",
          "updatedAt": "2023-02-28T15:40:43Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5KaxC8",
          "commit": {
            "abbreviatedOid": "4935b67"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T21:08:12Z",
          "updatedAt": "2023-01-13T21:08:13Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "These should be stringified to avoid JSON library compatibility issues",
              "createdAt": "2023-01-13T21:08:13Z",
              "updatedAt": "2023-01-13T21:08:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Ka5Ou",
          "commit": {
            "abbreviatedOid": "4935b67"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T21:38:21Z",
          "updatedAt": "2023-01-13T21:38:21Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "The test vector should include alpha as well, so that it's self-contained. (Perhaps as an array of `0` and `1`?)",
              "createdAt": "2023-01-13T21:38:21Z",
              "updatedAt": "2023-01-13T21:38:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Ka86x",
          "commit": {
            "abbreviatedOid": "4935b67"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T21:52:28Z",
          "updatedAt": "2023-01-13T21:52:28Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Are you alright with an unsinged integer here? From the spec perspective, this is the most natural way to represent `alpha`.",
              "createdAt": "2023-01-13T21:52:28Z",
              "updatedAt": "2023-01-13T21:52:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Ka_nE",
          "commit": {
            "abbreviatedOid": "4935b67"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T21:59:41Z",
          "updatedAt": "2023-01-13T21:59:41Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "If we included `bits` as a number and `alpha` as a number-as-a-string, that would work.",
              "createdAt": "2023-01-13T21:59:41Z",
              "updatedAt": "2023-01-13T21:59:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5KbEM6",
          "commit": {
            "abbreviatedOid": "4935b67"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:14:53Z",
          "updatedAt": "2023-01-13T22:14:53Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Done.",
              "createdAt": "2023-01-13T22:14:53Z",
              "updatedAt": "2023-01-13T22:14:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5KbEO1",
          "commit": {
            "abbreviatedOid": "4935b67"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:15:02Z",
          "updatedAt": "2023-01-13T22:15:03Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Done.",
              "createdAt": "2023-01-13T22:15:02Z",
              "updatedAt": "2023-01-13T22:15:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5KmucK",
          "commit": {
            "abbreviatedOid": "3d2fa90"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-01-17T14:32:09Z",
          "updatedAt": "2023-01-17T14:41:35Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\n        'bits': int(Idpf.BITS),\r\n        'alpha': str(alpha),\r\n        'beta_inner': printable_beta_inner,\r\n```",
              "createdAt": "2023-01-17T14:32:09Z",
              "updatedAt": "2023-01-17T14:41:35Z"
            },
            {
              "originalPosition": 35,
              "body": "We can punt on this for now, but we'll soon need to include the PRG name here.",
              "createdAt": "2023-01-17T14:39:21Z",
              "updatedAt": "2023-01-17T14:41:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5KqDpw",
          "commit": {
            "abbreviatedOid": "3d2fa90"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-17T22:18:34Z",
          "updatedAt": "2023-01-17T22:18:34Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Done.",
              "createdAt": "2023-01-17T22:18:34Z",
              "updatedAt": "2023-01-17T22:18:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5KqIjF",
          "commit": {
            "abbreviatedOid": "a7a97a6"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-17T22:40:23Z",
          "updatedAt": "2023-01-17T22:40:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 133,
      "id": "PR_kwDOGKuqOc5IKXML",
      "title": "Check unused bits when decoding IDPF public share",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/133",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This updates the IdpfPoplar public share decoding algorithm to check that any unused bits alongside the packed control bits are zero.",
      "createdAt": "2023-01-19T19:56:49Z",
      "updatedAt": "2023-05-01T17:00:45Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "dc5b2ca59efce9cde8267df59667a3d30282e4e2",
      "headRepository": "divergentdave/vdaf",
      "headRefName": "unused-packed-bits",
      "headRefOid": "11e86e9dd0512e76b5867541d53d97e3ec7e0822",
      "closedAt": "2023-01-20T02:43:17Z",
      "mergedAt": "2023-01-20T02:43:17Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "bab84920c4286fa5e9aa1f93126f4d9a0ec2bf78"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5LQzdQ",
          "commit": {
            "abbreviatedOid": "e317e98"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-01-19T22:00:51Z",
          "updatedAt": "2023-01-19T22:01:03Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "More concise.\r\n```suggestion\r\n    if packed_ctrl != 0 or len(encoded) != 0:\r\n```",
              "createdAt": "2023-01-19T22:00:51Z",
              "updatedAt": "2023-01-19T22:01:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5LRnmw",
          "commit": {
            "abbreviatedOid": "11e86e9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks again!",
          "createdAt": "2023-01-20T02:43:06Z",
          "updatedAt": "2023-01-20T02:43:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 135,
      "id": "PR_kwDOGKuqOc5JIXyB",
      "title": "Update spec to match reference code",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/135",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "All planned changes to Prio3 have been implemented in the reference code; propagate these changes to the document itself. Pick up some changes for Poplar1 as well.\r\n\r\nChanges to the reference code were required in order to make it render nicely in the dcocument. However the algorithms themselves have not changed.\r\n\r\nThis change also breaks up the auxiliary functions sections into subsections: One for joint randomness computation, another for serialization, and a new subsection for enumerating the constants.",
      "createdAt": "2023-02-02T17:13:06Z",
      "updatedAt": "2023-04-24T21:37:01Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "308afe18abd938e82a79aec9cd8159e29d45c087",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-04/1/prio3",
      "headRefOid": "233556675c2e330874e27a0337826815e2aa1e00",
      "closedAt": "2023-02-08T18:18:52Z",
      "mergedAt": "2023-02-08T18:18:52Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "d0d77593f87b81fb81878d53be226e83cbf17d3f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5M2uBL",
          "commit": {
            "abbreviatedOid": "5850994"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-08T15:24:01Z",
          "updatedAt": "2023-02-08T15:28:30Z",
          "comments": [
            {
              "originalPosition": 401,
              "body": "Moving these up, next to the variables, would help with understanding the code.",
              "createdAt": "2023-02-08T15:26:46Z",
              "updatedAt": "2023-02-08T15:28:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5M3-Nj",
          "commit": {
            "abbreviatedOid": "5850994"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-08T18:14:50Z",
          "updatedAt": "2023-02-08T18:14:51Z",
          "comments": [
            {
              "originalPosition": 401,
              "body": "Good call. They are referenced in multiple subsections, so I put these at the top of the Prio3 section.",
              "createdAt": "2023-02-08T18:14:50Z",
              "updatedAt": "2023-02-08T18:14:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 136,
      "id": "PR_kwDOGKuqOc5JLHwn",
      "title": "Use SHA-3 to instantiate the PRG and improve domain separation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/136",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #135 (merge that first).\r\nCloses #106.\r\n\r\nReplace `PrgAes128` with a new scheme, `PrgSha3`, that uses SHA-3 in the cSHAKE128 mode of operation. Existing analysis models this object as a random oracle, and SHA-3 is a safer way to instantiate it.\r\n\r\nWhenever the PRG is used to map a seed and some context to a finite domain, e.g., derive a fresh seed or a vector of field elements, the analysis models this function as an independent random oracle. One consequence of this is that we need to take care to ensure domain separation for each distinct usage of PRG. In particular, we need to format the inputs to the random oracle so that they are decodable.\r\n\r\nTo make this easier, we split the current \"info string\" into two components: The \"context string\" and the \"binder string\". The context string encodes the document version, algorithm, and some usage information; all of which was previously packed into the prefix of the info string. The \"binder string\" is an optional ephemeral artifact that we want to bind ot the output, e.g., the measurement shares in Prio3.\r\n\r\nWe set cSHAKE128's \"customization string\" to the context string. The seed is set to the start of the \"main input\" of cSHAKE128; and the remainder is the binder string. This is useful because the binder string may have arbitrary length; because the seed is always fixed length, it can always be decoded from the main input.",
      "createdAt": "2023-02-03T06:27:32Z",
      "updatedAt": "2023-04-24T21:37:00Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "b4c355fc3304f4eb5602c19ff33a1ba0701328fa",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-04/2/sha3",
      "headRefOid": "ad08bca7a7bbd6d204d9dad8f0d1e2b26f36580d",
      "closedAt": "2023-02-09T02:58:48Z",
      "mergedAt": "2023-02-09T02:58:48Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "c658bb9ca765f73c980bc948172034d031d1aa9a"
      },
      "comments": [
        {
          "author": "simon-friedberger",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure what exactly the distinction between the context string and binder string is.\r\n1. Is the intent is to use the context string for domain separation and to add Fiat-Shamir transform inputs into the binder string?\r\n2. There are instances where `binder=byte(agg_id)` or similar which look like this should actually be domain separation. Is that intentional?\r\n4. Can we just replace \"context string\" by \"customization string\" which is also used in the cSHAKE definition?",
          "createdAt": "2023-02-06T09:00:30Z",
          "updatedAt": "2023-02-06T09:00:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm not sure what exactly the distinction between the context string and binder string is.\r\n> \r\n>     1. Is the intent is to use the context string for domain separation and to add Fiat-Shamir transform inputs into the binder string?\r\n\r\nYes, that's the basic idea :)\r\n\r\nContext:\r\n1. version (\"VDAF-04\")\r\n2. Algorithm (prio3count, prio3sum, poplar1,...)\r\n3. \"usage\" (\"joint randomness\" for prio3, \"verifier randomness\" for poplar1, ...)\r\n\r\nBasically all the information that is sufficient to ensure that, if a seed gets reused, the derived outputs are independent.\r\n\r\nBinder: Some \"runtime artifact\", like a nonce or an input share (as for Fiat-Shamir).\r\n\r\n>     2. There are instances where `binder=byte(agg_id)` or similar which look like this should actually be domain separation. Is that intentional?\r\n\r\nHmm interesting point. I was thinking agg_id as something to \"bind to\", but it arguably makes more sense as context. I could go either way here. Do you have a strong preference?\r\n\r\n>     3. Can we just replace \"context string\" by \"customization string\" which is also used in the cSHAKE definition?\r\n\r\nYeah I'm cool with that \ud83d\udc4d \r\n",
          "createdAt": "2023-02-06T15:43:43Z",
          "updatedAt": "2023-02-06T15:43:43Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@simon-friedberger I renamed \"context\" to \"custom\". I kept the aggregator ID in the binder instead of the customization string because not every call to `Prg` takes the aggregator ID as a parameter, and I didn't want to add an optional parameter to `format_custom`.",
          "createdAt": "2023-02-06T16:08:11Z",
          "updatedAt": "2023-02-06T16:08:11Z"
        },
        {
          "author": "simon-friedberger",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is fine for now. I still dislike that we are hard-coding SHA-3 but we can fix that if it ever becomes really necessary.",
          "createdAt": "2023-02-08T10:39:07Z",
          "updatedAt": "2023-02-08T10:39:07Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think this is fine for now. I still dislike that we are hard-coding SHA-3 but we can fix that if it ever becomes really necessary.\r\n\r\nThanks Simon! You're right that isn't strictly necessary. When the editors last spoke about this, we decided to move in a direction of reducing agility. That said, this PR keeps the `Prg` API intact, which should make it easy to swap out SHA-3 with something else in an implementation.\r\n\r\nIn any case, I removed the inline \"TODO\" regarding removing the `Prg` API. We should ask the RG for guidance on whether to remove or add agility.",
          "createdAt": "2023-02-08T16:13:36Z",
          "updatedAt": "2023-02-08T16:13:36Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased and squashed.",
          "createdAt": "2023-02-08T18:23:47Z",
          "updatedAt": "2023-02-08T18:23:47Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5Mn4y-",
          "commit": {
            "abbreviatedOid": "1464ece"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-06T16:09:13Z",
          "updatedAt": "2023-02-06T16:09:14Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Reviewer note: I'll update this once we get through reviews. Updates needed so far:\r\n\r\n- [x] s/context/customization (also change the text).\r\n",
              "createdAt": "2023-02-06T16:09:13Z",
              "updatedAt": "2023-02-07T23:16:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5M3zV6",
          "commit": {
            "abbreviatedOid": "e4c7c9b"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-08T17:44:54Z",
          "updatedAt": "2023-02-08T17:44:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5M5Wqs",
          "commit": {
            "abbreviatedOid": "f2a8ed8"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-08T22:37:34Z",
          "updatedAt": "2023-02-08T23:53:21Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "This name shadowing makes me wary. We could probably drop this whole class definition, as it was originally only introduced to get the PRG name into benchmark filenames.",
              "createdAt": "2023-02-08T22:37:34Z",
              "updatedAt": "2023-02-08T23:53:21Z"
            },
            {
              "originalPosition": 95,
              "body": "nit: typo\r\n```suggestion\r\n    binder = b'a string that binds some protocol artifact to the output'\r\n```",
              "createdAt": "2023-02-08T22:48:07Z",
              "updatedAt": "2023-02-08T23:53:21Z"
            },
            {
              "originalPosition": 32,
              "body": "FYI `bytes` does not support a type parameter in type hints. I see that this may be useful for documentation purposes, and it's certainly not the first place we diverge from type-checkability in here, so I'm OK leaving it.",
              "createdAt": "2023-02-08T23:43:48Z",
              "updatedAt": "2023-02-08T23:53:21Z"
            },
            {
              "originalPosition": 145,
              "body": "```suggestion\r\nThe following algorithm is used in the remainder of this document in order to format the\r\ncustomization string:\r\n```",
              "createdAt": "2023-02-08T23:46:52Z",
              "updatedAt": "2023-02-08T23:53:21Z"
            },
            {
              "originalPosition": 794,
              "body": "nit: typo\r\n```suggestion\r\ndef custom(Poplar1, usage):\r\n```",
              "createdAt": "2023-02-08T23:50:51Z",
              "updatedAt": "2023-02-08T23:53:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5M6TJL",
          "commit": {
            "abbreviatedOid": "f2a8ed8"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-09T02:49:19Z",
          "updatedAt": "2023-02-09T02:57:27Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Oofta, I didn't even noticed. Deleted, and moved `with_bits()` to the superclass.",
              "createdAt": "2023-02-09T02:49:20Z",
              "updatedAt": "2023-02-09T02:57:28Z"
            },
            {
              "originalPosition": 794,
              "body": "Here and elsewhere",
              "createdAt": "2023-02-09T02:51:09Z",
              "updatedAt": "2023-02-09T02:57:28Z"
            },
            {
              "originalPosition": 32,
              "body": "Right, the primary purpose is to make the expected input values more explicit. We are abusing type hints all over the place so far. It was pointed out before that we should probably enforce type checking for the reference code: https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/59.",
              "createdAt": "2023-02-09T02:54:44Z",
              "updatedAt": "2023-02-09T02:57:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 137,
      "id": "PR_kwDOGKuqOc5JeT6y",
      "title": "Poplar1: Split PRG for leaf/inner sketch offsets",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/137",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #136 (merge that first).\r\nPartially addresses #134.\r\n\r\nUse a different `Prg` instance for the inner and leaf nodes when generating shares of the offsets for the sketch computation (i.e., the `(a, b, c)` triples). This change is meant to reduce implementation complexity. In particular, for performance reasons it is desirable to buffer the seed stream output by the `Prg` prior to doing rejection sampling. The buffer size is picked based the size of the field elements; changing the field size is fiddly, as this requires us to copy the unused part of the buffer to the beginning when we wrap around the end. For details, see:\r\nhttps://github.com/divviup/libprio-rs/pull/429",
      "createdAt": "2023-02-07T22:38:50Z",
      "updatedAt": "2023-04-24T21:37:00Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "c658bb9ca765f73c980bc948172034d031d1aa9a",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-04/3/poplar1/1",
      "headRefOid": "454f74752e8a599e4687fa460ed62ee1ab32c964",
      "closedAt": "2023-02-11T00:01:15Z",
      "mergedAt": "2023-02-11T00:01:15Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "bc9b5eee5e8a2a87fdc821e5f54fe532d9553174"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Squashed, rebased, and moved the constants table as requested by @schoppmp here: https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/135#discussion_r1100296697",
          "createdAt": "2023-02-08T18:35:29Z",
          "updatedAt": "2023-02-08T18:35:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5M_cJM",
          "commit": {
            "abbreviatedOid": "454f747"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me. I think the hit of performing an extra PRG derivation is probably worth it for simplifying analysis and flexibility for implementations.",
          "createdAt": "2023-02-09T17:50:18Z",
          "updatedAt": "2023-02-09T17:50:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 138,
      "id": "PR_kwDOGKuqOc5JehT5",
      "title": "Poplar1: Don't derive verifier randomness from prefixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/138",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #137 (merge that first).\r\nPartially addresses #134.\r\n\r\nSecurity requirements will require us to restrict preparation so that the sketch computed only once per level of the IDPF tree. Remove the prefixes from the verifier randomness derivation, as this will not be needed.",
      "createdAt": "2023-02-07T23:29:58Z",
      "updatedAt": "2023-04-24T21:36:57Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "bc9b5eee5e8a2a87fdc821e5f54fe532d9553174",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-04/4/poplar1/2",
      "headRefOid": "649b94909999ee017506699744c270ffdc88f657",
      "closedAt": "2023-02-14T15:36:46Z",
      "mergedAt": "2023-02-14T15:36:46Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "29bb82071b7a33b87af5a7083eda5d3d8e29c0e7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5NPuRm",
          "commit": {
            "abbreviatedOid": "1a6df4d"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-13T16:03:40Z",
          "updatedAt": "2023-02-13T16:06:45Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nThe algorithms below make use of the auxiliary function `decode_input_share()`\r\n```",
              "createdAt": "2023-02-13T16:03:41Z",
              "updatedAt": "2023-02-13T16:06:45Z"
            },
            {
              "originalPosition": 16,
              "body": "Note: It looks like the nonce length will be fixed here one way or the other, based on #127, so it's OK to not length-prefix `nonce`.",
              "createdAt": "2023-02-13T16:06:02Z",
              "updatedAt": "2023-02-13T16:06:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 139,
      "id": "PR_kwDOGKuqOc5JenR8",
      "title": "Poplar1: Enforce prefix uniqueness",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/139",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #138 (merge that first).\r\nPartially addresses #134.\r\n\r\nIf the candidate prefixes are not unique, then the refined measurement may not be a one-hot vector. This would cause the Aggregators to fail sketch verification when it would have otherwise passed.",
      "createdAt": "2023-02-07T23:59:36Z",
      "updatedAt": "2023-04-24T21:36:57Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "29bb82071b7a33b87af5a7083eda5d3d8e29c0e7",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-04/5/poplar1/unique-prefixes",
      "headRefOid": "c137f425f77dff251b416e2d946239362a4f3bad",
      "closedAt": "2023-02-14T15:46:15Z",
      "mergedAt": "2023-02-14T15:46:15Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "458872426c4793ad2c3bebe61543b56527a5d36d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5M4oYm",
          "commit": {
            "abbreviatedOid": "5509cda"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-08T19:57:18Z",
          "updatedAt": "2023-02-08T19:57:19Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Reviewer note: We might consider adding this check to aggregation parameter encoding as well.",
              "createdAt": "2023-02-08T19:57:18Z",
              "updatedAt": "2023-02-08T19:57:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5NPxO5",
          "commit": {
            "abbreviatedOid": "8dd7fd3"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-13T16:10:07Z",
          "updatedAt": "2023-02-14T15:28:10Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "nit: spelling\r\n```suggestion\r\nbut this does allow uniqueness to be determined more efficiently.\r\n```",
              "createdAt": "2023-02-13T16:10:07Z",
              "updatedAt": "2023-02-14T15:28:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 143,
      "id": "PR_kwDOGKuqOc5JfNew",
      "title": "Poplar1: Increase candidate prefix count encoding",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/143",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #139 (merge that first).\r\nPartially addresses #134.\r\n\r\nUse 32 bits to encode the number of prefixes rather than 16. We don't want 2^16-1 to be a hard limit.\r\n\r\nWhile at it, add some roundtrip tests for aggregation parameter serialization.",
      "createdAt": "2023-02-08T03:27:02Z",
      "updatedAt": "2023-04-24T21:36:56Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "458872426c4793ad2c3bebe61543b56527a5d36d",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-04/6/poplar1/agg-param",
      "headRefOid": "6efe240782d596cc02cd3298da3c93b82a5036a4",
      "closedAt": "2023-02-14T16:04:59Z",
      "mergedAt": "2023-02-14T16:04:59Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "d3fd488d700b0e8d7136093cfdacfed7afac7a9f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5NXGe1",
          "commit": {
            "abbreviatedOid": "6efe240"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-14T15:57:33Z",
          "updatedAt": "2023-02-14T15:57:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 144,
      "id": "PR_kwDOGKuqOc5JjVS3",
      "title": "Update authors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/144",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds my name to the authors list.",
      "createdAt": "2023-02-08T18:48:16Z",
      "updatedAt": "2023-05-01T17:01:29Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d0d77593f87b81fb81878d53be226e83cbf17d3f",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/add-self-to-authors",
      "headRefOid": "60659c6300710810949394ad43490c05f376d58d",
      "closedAt": "2023-02-08T19:09:14Z",
      "mergedAt": "2023-02-08T19:09:14Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b4c355fc3304f4eb5602c19ff33a1ba0701328fa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5M4Jvz",
          "commit": {
            "abbreviatedOid": "60659c6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-08T18:48:53Z",
          "updatedAt": "2023-02-08T18:48:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5M4RKi",
          "commit": {
            "abbreviatedOid": "60659c6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-08T19:09:08Z",
          "updatedAt": "2023-02-08T19:09:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 145,
      "id": "PR_kwDOGKuqOc5Jjsda",
      "title": "Poplar1: Add an implementation note about \"updating\" the prefix tree",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/145",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #143 (merge that first).\r\nPartially addresses #134.",
      "createdAt": "2023-02-08T20:05:19Z",
      "updatedAt": "2023-04-24T21:36:55Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d3fd488d700b0e8d7136093cfdacfed7afac7a9f",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-04/7/poplar1/agg-param-updates",
      "headRefOid": "c4cb8f10c5cf084f36306ab63792c458a3d5629e",
      "closedAt": "2023-02-14T16:08:42Z",
      "mergedAt": "2023-02-14T16:08:42Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "9078a65d40cfc23becc8aea723b8a0116529b437"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5M4tqt",
          "commit": {
            "abbreviatedOid": "b7b5e8e"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-08T20:14:22Z",
          "updatedAt": "2023-02-08T20:14:23Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Small clarification:\r\n```suggestion\r\nindices from the previous execution will have their children included in the next. This would\r\n```",
              "createdAt": "2023-02-08T20:14:22Z",
              "updatedAt": "2023-02-08T20:14:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5M5SzM",
          "commit": {
            "abbreviatedOid": "800621c"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-08T22:20:59Z",
          "updatedAt": "2023-02-08T22:21:47Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "nit: typo\n```suggestion\nnext. This would help reduce communication overhead.\n```\n",
              "createdAt": "2023-02-08T22:21:00Z",
              "updatedAt": "2023-02-08T22:21:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 146,
      "id": "PR_kwDOGKuqOc5JkYd9",
      "title": "A bit of tidying up",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/146",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-02-08T23:17:04Z",
      "updatedAt": "2023-04-24T21:36:50Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "9078a65d40cfc23becc8aea723b8a0116529b437",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-04/8/cleanup",
      "headRefOid": "be3e95938454f374eb68948e8c8cdfb524853cf0",
      "closedAt": "2023-02-14T16:12:15Z",
      "mergedAt": "2023-02-14T16:12:15Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "acc37b3b8188977eeb77c9b118bd7d152e49f8b1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5NXJ0u",
          "commit": {
            "abbreviatedOid": "09c743a"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-14T16:03:45Z",
          "updatedAt": "2023-02-14T16:03:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 148,
      "id": "PR_kwDOGKuqOc5KD9Eh",
      "title": "Poplar1: Bind nonce to correlated randomness derivation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/148",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Append the nonce to the binder string for deriving the offsets for the sketch computation. That way if the Aggregators use a nonce to verify a report other than the one that was picked by the Client, verification will likely fail.\r\n\r\nThis change is about defense-in-depth. We don't yet have an analysis to suggest this is necessary for either privacy or robustness. However given the importance of this binding for Prio3 (specifically for the joint randomness), it seems like a sensible change.",
      "createdAt": "2023-02-15T18:57:43Z",
      "updatedAt": "2023-04-24T21:36:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "acc37b3b8188977eeb77c9b118bd7d152e49f8b1",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-04/9/poplar1/use-nonce",
      "headRefOid": "4547d059db82fcf24757685fa77e6132ba8a0f78",
      "closedAt": "2023-02-16T23:37:25Z",
      "mergedAt": "2023-02-16T23:37:25Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "0abd8c850e162ab615a1ba92679809e0333fec65"
      },
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think the analogy to Prio3 joint randomness works. The Prio3 joint randomness derivation is part of a Fiat-Shamir transformation. On the other hand, to the best of my knowledge, this PRG instance is used for compression of client-chosen randomness, not Fiat-Shamir. Moreover, the seed is already chosen by the client, so I'm not sure whether it's worth it to additionally mix in the client-generated nonce.",
          "createdAt": "2023-02-15T21:15:51Z",
          "updatedAt": "2023-02-15T21:15:51Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't think the analogy to Prio3 joint randomness works. The Prio3 joint randomness derivation is part of a Fiat-Shamir transformation. On the other hand, to the best of my knowledge, this PRG instance is used for compression of client-chosen randomness, not Fiat-Shamir. Moreover, the seed is already chosen by the client, so I'm not sure whether it's worth it to additionally mix in the client-generated nonce.\r\n\r\nYeah the analogy to Prio3 isn't quite right. Basically what I like about this change is that the Aggregators are forced to use the nonce the Client picked in order to consume the report. Without it, the Aggregators could use a different nonce. I don't know if this feature leads to an attack, but it strikes me as slightly worrisome. In any case, I think it's cheap enough to implement without any trouble (in particular for SHA3, this shouldn't add any new rounds of Keccak).",
          "createdAt": "2023-02-15T21:37:05Z",
          "updatedAt": "2023-02-15T21:37:05Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5NoZFh",
          "commit": {
            "abbreviatedOid": "4547d05"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I think this makes sense as a defense-in-depth measure.",
          "createdAt": "2023-02-16T23:29:06Z",
          "updatedAt": "2023-02-16T23:29:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 149,
      "id": "PR_kwDOGKuqOc5KE78o",
      "title": "Have each `Vdaf` specify its nonce size",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/149",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #127.\r\n\r\nAdd associated parameter `NONCE_SIZE` to the `Vdaf` API that determines the nonce size for that VDAF. For `Prio3` and `Poplar1`, pick a nonce length of 16 bytes.\r\n\r\nTo make the API self-documenting, we use Python3's type hints to indicate that the `Vdaf` member functions\r\n(`measurement_to_input_shares()` and `prep_init()` in particular) expect a nonce of length `NONCE_SIZE`. The intent is to indicate that only nonces of that length are allowed. This change also adjusted the type of hint for `verify_key` accordingly.",
      "createdAt": "2023-02-15T22:31:06Z",
      "updatedAt": "2023-04-24T21:36:48Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "5c2225df2364e149f5b584ae2d02ed976602081a",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-04/10/nonce-length",
      "headRefOid": "39bfad5ea1b8b69a18bfd9829217009e67b80ed7",
      "closedAt": "2023-02-21T17:07:31Z",
      "mergedAt": "2023-02-21T17:07:31Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "3c23d7ab8e1de963a471f10a0db19884c9aab1be"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5NodgW",
          "commit": {
            "abbreviatedOid": "ff21461"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-16T23:54:48Z",
          "updatedAt": "2023-02-17T00:03:26Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "nit: missing space, not related to this change\r\n```suggestion\r\n  to verify the recovered output shares (e.g., the \"proof shares\" in Prio3\r\n```",
              "createdAt": "2023-02-16T23:54:48Z",
              "updatedAt": "2023-02-17T00:03:26Z"
            },
            {
              "originalPosition": 59,
              "body": "nit: run-on sentence, not related to this change.\r\n```suggestion\r\n  {{run-vdaf}}), the public share (`public_share`), and one of the input\r\n```",
              "createdAt": "2023-02-16T23:57:20Z",
              "updatedAt": "2023-02-17T00:03:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 150,
      "id": "PR_kwDOGKuqOc5KFbml",
      "title": "Revise security considerations for nonces",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/150",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #141.\r\n\r\nNew guidance:\r\n\r\n* Clients MUST choose the nonce at random (required for privacy as defined in {{DPRS23}}).\r\n\r\nUpdated guidance:\r\n\r\n* Currently we say \"for robustness, Aggregators MUST NOT aggregate two reports with the same nonce\". In reality the situation is more subtle: The robustness game of {{DPRS23}} allows the the attacker to process any report with any initial state (i.e., aggregation parameter), so long as the sequence of initial states with which that report was processed is \"allowed\", as determined by the specific VDAF. This sequence of initial states is determined by the nonces provided with reports. We will clarify this as part of issue 142.\r\n\r\n  That said, report replay is important for other security properties, like differential privacy. Thus, RECOMMEND that the nonce be used for replay protection.",
      "createdAt": "2023-02-16T00:55:57Z",
      "updatedAt": "2023-04-24T21:36:25Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "3c23d7ab8e1de963a471f10a0db19884c9aab1be",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-04/11/nonce-rand",
      "headRefOid": "3def24487337baf6fd7a03447c44f24e23cbfc98",
      "closedAt": "2023-02-21T17:38:25Z",
      "mergedAt": "2023-02-21T17:38:25Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "01be54a5edf17c84e72a8c8b9818cdecc9531ddc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5NohK7",
          "commit": {
            "abbreviatedOid": "88954f7"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-17T00:17:28Z",
          "updatedAt": "2023-02-17T00:17:55Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Small clarification:\r\n```suggestion\r\nOther security considerations may require the nonce to be non-repeating. For\r\nexample, to achieve differential privacy it is necessary to avoid \"over\r\nexposing\" a measurement by including it too many times in a single batch or\r\nacross multiple batches. It is RECOMMENDED that the nonce generated by the\r\nClient be used by Aggregators for replay protection.\r\n```",
              "createdAt": "2023-02-17T00:17:28Z",
              "updatedAt": "2023-02-17T00:17:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 151,
      "id": "PR_kwDOGKuqOc5KKXTd",
      "title": "IDPF: Change byte order of packed control bits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/151",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This changes the byte order of the packed control bits in the IdpfPoplar public share. The order of bits within each byte is the same, but control bits for the first level will now be encoded in the first byte of the public share.\r\n\r\nCloses #147.",
      "createdAt": "2023-02-16T19:56:15Z",
      "updatedAt": "2023-02-22T21:53:55Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "acc37b3b8188977eeb77c9b118bd7d152e49f8b1",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/idpf-public-share-flip-bits",
      "headRefOid": "308a1829acdf41527684d9fc37b3be3993c9057f",
      "closedAt": "2023-02-21T22:16:57Z",
      "mergedAt": "2023-02-21T22:16:57Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "1e0fd1bfaf37e979b031dae72b6e4316a958a694"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Please squash before merging! ",
          "createdAt": "2023-02-21T22:06:13Z",
          "updatedAt": "2023-02-21T22:06:13Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5NoFTz",
          "commit": {
            "abbreviatedOid": "02b53a1"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Hmm, I wonder if this would a bit easier to read if we wrote it in terms of some function for encoding a sequence of bits (i.e., `Field2` elements). Something like:\r\n```python\r\nbits = list(map(lambda cw: cw[1], correction_words))\r\nencoded += pack_bits(bits)\r\n```\r\n\r\nwhere `pack_bits(bits: Vec[Field2]) -> Bytes`. Unpacking would require the expected length, e.g., `unpack_bits(packed_bits: Bytes, length: Unsigned) -> Vec[Field2]`.",
          "createdAt": "2023-02-16T22:07:51Z",
          "updatedAt": "2023-02-16T22:07:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5N9NjU",
          "commit": {
            "abbreviatedOid": "f1fa8a4"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-21T17:34:41Z",
          "updatedAt": "2023-02-21T17:38:07Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "If my suggestion above is taken, then let's move these to common.sage.",
              "createdAt": "2023-02-21T17:34:41Z",
              "updatedAt": "2023-02-21T17:38:07Z"
            },
            {
              "originalPosition": 48,
              "body": "I'd suggest moving these definitions to the preliminaries section and specifying them in English. Too much code runs the risk of making the spec less accessible. Since this method is relatively simple, a prose description of these methods would be sufficient in my opinion. (An implementer could refer to the reference code.)\r\n\r\n",
              "createdAt": "2023-02-21T17:38:04Z",
              "updatedAt": "2023-02-21T17:38:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5N9c27",
          "commit": {
            "abbreviatedOid": "f1fa8a4"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-21T18:21:19Z",
          "updatedAt": "2023-02-21T18:21:20Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "`unpack_bits()` uses the `Field2` constructor, so I can't directly move it to common.sage without hacks. field.sage already imports items from common.sage, so attempting to import Field2 at top level would create a circular import. Importing the field module at the top of the function would work, but I'd rather not do that. We could leave the functions where they are, or move them to field.sage, or make them deal in integers and move them to common.sage. I'll try out the last option.",
              "createdAt": "2023-02-21T18:21:20Z",
              "updatedAt": "2023-02-21T18:21:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5N9doz",
          "commit": {
            "abbreviatedOid": "f1fa8a4"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-21T18:23:51Z",
          "updatedAt": "2023-02-21T18:23:52Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Good catch. I think we should keep them where they are then. I would still describe them in prose.",
              "createdAt": "2023-02-21T18:23:51Z",
              "updatedAt": "2023-02-21T18:23:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5N91ar",
          "commit": {
            "abbreviatedOid": "f33bfea"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Nice! One last question: What do you think about shifting the left-over bits check into `unpack_bits()`? It seems like we would always want to enforce that the end of the last byte is 0.",
          "createdAt": "2023-02-21T19:36:21Z",
          "updatedAt": "2023-02-21T19:36:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5N-gt4",
          "commit": {
            "abbreviatedOid": "308a182"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-21T22:06:00Z",
          "updatedAt": "2023-02-21T22:06:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 152,
      "id": "PR_kwDOGKuqOc5KKYuN",
      "title": "Fix PRG test vector generation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/152",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This updates the PRG test vector generation code to match changes made in #136.",
      "createdAt": "2023-02-16T20:00:21Z",
      "updatedAt": "2023-05-01T17:01:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "acc37b3b8188977eeb77c9b118bd7d152e49f8b1",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/prg-fix-test-vector-generation",
      "headRefOid": "b267cae6bf7a7f0b404046f288b1f05f660047be",
      "closedAt": "2023-02-16T23:37:41Z",
      "mergedAt": "2023-02-16T23:37:41Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "5c2225df2364e149f5b584ae2d02ed976602081a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5Nn7IF",
          "commit": {
            "abbreviatedOid": "b267cae"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-16T21:34:29Z",
          "updatedAt": "2023-02-16T21:34:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 153,
      "id": "PR_kwDOGKuqOc5KLLTh",
      "title": "Revise security considerations for verification key",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/153",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #150 (merge that first).\r\nCloses #140.\r\n\r\nPreviously we had RECOMMENDED that the verification key be chosen only after the reports are generated. This guidance was meant to provide \"defense-in-depth\" for robustness, as it would make it impossible for a malicious Aggregator to reveal the key to Clients prior to submission.\r\n\r\nBased on the analysis of Prio3 in {{DPRS23}}, we cannot rule out attacks on privacy if the verification key can be picked by the attacker *and8 the verification key can depend on the random coins of the experiment. If we wish to allow the attacker to control the verification key, then we must force the attacker to \"commit\" to the key prior to generating reports. (We also require the nonce to be picked at random.)\r\n\r\nRemove this RECOMMENDATION and add that the Aggregators MUST commit to the key before processing reports. Add a suggestion about how task configuration in DAP-03 might be implemented to support this.",
      "createdAt": "2023-02-16T23:35:20Z",
      "updatedAt": "2023-04-24T21:36:24Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "01be54a5edf17c84e72a8c8b9818cdecc9531ddc",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-04/12/verify-key-considerations",
      "headRefOid": "4af99bfcc6af935555971c2651aed60ebba79418",
      "closedAt": "2023-02-21T17:54:14Z",
      "mergedAt": "2023-02-21T17:54:13Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "73961e4d265766615b95623274a202ff0fca3fb4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5NolTi",
          "commit": {
            "abbreviatedOid": "e82b647"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-17T00:42:48Z",
          "updatedAt": "2023-02-17T00:42:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5N9TMN",
          "commit": {
            "abbreviatedOid": "4af99bf"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-21T17:51:10Z",
          "updatedAt": "2023-02-21T17:51:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 154,
      "id": "PR_kwDOGKuqOc5KLQ2w",
      "title": "Clean up security considerations a bit",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/154",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #153 (merge that first).\r\n\r\n* Remove a few out-of-date NOTEs\r\n\r\n* Nit-pick the wording a bit\r\n\r\n* Ack Hannah and Mike for security analysis",
      "createdAt": "2023-02-17T00:07:59Z",
      "updatedAt": "2023-04-24T21:36:19Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "73961e4d265766615b95623274a202ff0fca3fb4",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-04/13/security-cleanup",
      "headRefOid": "6d25b879f6ead17bbd47c02d9b13a420b01166b7",
      "closedAt": "2023-02-21T18:26:22Z",
      "mergedAt": "2023-02-21T18:26:22Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "949fbbdc1a6c1493bb55c223ae8fad31e03faaa9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5Ns9sD",
          "commit": {
            "abbreviatedOid": "6f78258"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-17T15:11:59Z",
          "updatedAt": "2023-02-17T15:11:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 155,
      "id": "PR_kwDOGKuqOc5KQZ-s",
      "title": "Add rejection sampling test for PrgSha3",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/155",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds an additional test of the rejection sampling behavior, using `PrgSha3` instead of `PrgAes128`.",
      "createdAt": "2023-02-17T23:33:03Z",
      "updatedAt": "2023-05-01T17:01:39Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "5c2225df2364e149f5b584ae2d02ed976602081a",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/rejection-sampling-test-sha3",
      "headRefOid": "c0587f0e6347af55bfd108913aa11cc60c35d5d0",
      "closedAt": "2023-02-21T17:43:37Z",
      "mergedAt": "2023-02-21T17:43:37Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "e2c9bbf2de04dd6ea4dead569b12387fadff3238"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5N9QhS",
          "commit": {
            "abbreviatedOid": "c0587f0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-21T17:43:28Z",
          "updatedAt": "2023-02-21T17:43:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 157,
      "id": "PR_kwDOGKuqOc5KdYH8",
      "title": "poc: Ensure the customizer for PrgAes128 is decoable",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/157",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "fyi/ @simon-friedberger: @divergentdave thought it would be sensible to add a length prefix to the customization string.",
      "createdAt": "2023-02-21T20:14:04Z",
      "updatedAt": "2023-04-24T21:36:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "949fbbdc1a6c1493bb55c223ae8fad31e03faaa9",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/prg-aes128-decodable-customizer",
      "headRefOid": "dadfc61ff0a44ee34df300f22a309661d6646d85",
      "closedAt": "2023-02-23T03:06:24Z",
      "mergedAt": "2023-02-23T03:06:24Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "bfec9707cdf3cc1eb5789a954b75436e80c6d1aa"
      },
      "comments": [
        {
          "author": "simon-friedberger",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't understand the title of the PR.\r\nThis seems like a good change but doesn't it also need to be changed here: https://cfrg.github.io/draft-irtf-cfrg-vdaf/draft-irtf-cfrg-vdaf.html#section-6.2.2-4\r\nI thought the sage code was non-normative.",
          "createdAt": "2023-02-23T08:40:15Z",
          "updatedAt": "2023-02-23T08:40:15Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> This seems like a good change but doesn't it also need to be changed here: https://cfrg.github.io/draft-irtf-cfrg-vdaf/draft-irtf-cfrg-vdaf.html#section-6.2.2-4\r\n\r\nNo, that section describes how the customization string is constructed; this PR changes how we encode that string in the input to CMAC in PrgAes128.\r\n\r\n> I thought the sage code was non-normative.\r\n\r\nYou're right. The change here is to PrgAes128, which as of the next draft is no longer \"standard\".\r\n\r\n",
          "createdAt": "2023-02-23T15:14:16Z",
          "updatedAt": "2023-02-23T15:14:16Z"
        },
        {
          "author": "simon-friedberger",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should add something to the spec even if we remove it again because we want to remove the AES PRG. Maybe we end up not doing that or adding some other construction that would also benefit from this.",
          "createdAt": "2023-02-23T23:40:02Z",
          "updatedAt": "2023-02-23T23:40:02Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I think I'd rather remove it if we're not using it right now. Better to have less cruft in the spec if we can!",
          "createdAt": "2023-02-23T23:52:40Z",
          "updatedAt": "2023-02-23T23:52:40Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5N-A-w",
          "commit": {
            "abbreviatedOid": "dadfc61"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-21T20:16:11Z",
          "updatedAt": "2023-02-21T20:16:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 158,
      "id": "PR_kwDOGKuqOc5KkXw_",
      "title": "Update Change Log for 04",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/158",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #156.",
      "createdAt": "2023-02-23T03:10:41Z",
      "updatedAt": "2023-04-24T21:36:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "bfec9707cdf3cc1eb5789a954b75436e80c6d1aa",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-04/14/change-log",
      "headRefOid": "a15a18bac3802542aa405610fdb1f9193b4a7ae8",
      "closedAt": "2023-02-23T23:33:58Z",
      "mergedAt": "2023-02-23T23:33:57Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "8228c9db122d798b0c0cf3702215446d0114a514"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5OMqiM",
          "commit": {
            "abbreviatedOid": "a15a18b"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-23T18:47:47Z",
          "updatedAt": "2023-02-23T18:47:47Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5ONklv",
          "commit": {
            "abbreviatedOid": "a15a18b"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-23T21:38:34Z",
          "updatedAt": "2023-02-23T21:38:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 160,
      "id": "PR_kwDOGKuqOc5KpLCW",
      "title": "Bump version, regenerate test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/160",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This updates `VERSION` and regenerates test vectors. I also tweaked the test vector generation code to zero-pad hex-encoded output share elements, for consistency.",
      "createdAt": "2023-02-23T21:32:48Z",
      "updatedAt": "2023-02-24T16:05:50Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "bfec9707cdf3cc1eb5789a954b75436e80c6d1aa",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/vdaf-04-test-vectors",
      "headRefOid": "3ede5eba505fb16666261b94b7a6578f202dacf8",
      "closedAt": "2023-02-24T04:34:09Z",
      "mergedAt": "2023-02-24T04:34:09Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "3352a58d3cc228de345f88170df14ee89d65bf42"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5ON_PX",
          "commit": {
            "abbreviatedOid": "3ede5eb"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-23T23:23:34Z",
          "updatedAt": "2023-02-23T23:23:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 161,
      "id": "PR_kwDOGKuqOc5KpZEB",
      "title": "Add definition of validity scopes over aggregation parameters.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/161",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For Poplar1, this ensures that any given input share will only be used once at a given level.\r\n\r\nFixes #142.",
      "createdAt": "2023-02-23T22:38:50Z",
      "updatedAt": "2024-06-08T19:54:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "bfec9707cdf3cc1eb5789a954b75436e80c6d1aa",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "schoppmp/issue-142",
      "headRefOid": "77a1be5989d11feeaf47a1c6ab33bcc33a787012",
      "closedAt": "2023-02-24T22:34:31Z",
      "mergedAt": "2023-02-24T22:34:31Z",
      "mergedBy": "schoppmp",
      "mergeCommit": {
        "oid": "de2c5f717cdd652d0518a612a0c86e67f10d754f"
      },
      "comments": [
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good, currently working on this. Do we want `VDAF.validity_scope` to be defined for any VDAF, or only for ones that actually make use of validity scopes? For Prio3, I could always return an empty byte string, or simply not define that function.",
          "createdAt": "2023-02-24T19:28:47Z",
          "updatedAt": "2023-02-24T19:28:47Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "To put it another way: Do we want a default `validity_scope` implementation (implemented in the Daf/Vdaf classes in the reference code), or do we want to require that to be implemented by every DAF/VDAF?",
          "createdAt": "2023-02-24T19:32:03Z",
          "updatedAt": "2023-02-24T19:32:03Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For some context, what I want to avoid is text in DAP (and corresponding code in DAP implementations) that has to do something like `if vdaf.is_poplar1() { check_validity_scope() } else { pass }`. So I believe we need an interface that can be implemented on all DAFs and VDAFs and generically executed by higher level protocols like DAP.\r\n\r\nSo I think the way forward is:\r\n\r\n- [V]DAFs must define an associated type `ValidityScope`. `ValidityScope` in turn must define a method `ValidityScope.conflicts_with(other: ValidityScope) -> boolean`.\r\n- [V]DAFs must define a method `[V]DAF.validity_scope(AggParam) -> ValidityScope`.\r\n\r\nThen, when aggregating a report, DAP implementations would check every other aggregation parameter the report has ever been aggregated with and do:\r\n\r\n```\r\nVDAF.validity_scope(incoming_aggregation_parameter)\r\n    .conflicts_with(VDAF.validity_scope(existing_aggregation_parameter))\r\n```\r\n\r\nFor Poplar1, `ValidityScope.conflicts_with` checks the level. For Prio3, it always returns true (you may never re-prepare reports in Prio3).\r\n\r\nThere's a bunch of different ways to spell this -- you could choose different verbs or put the methods in different places -- but I think that's what we need.",
          "createdAt": "2023-02-24T19:46:36Z",
          "updatedAt": "2023-02-24T19:46:36Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "We decided to go with something even simpler. We'll define a function `Vdaf.is_valid(agg_param: AggParam, previous_agg_params: Vec[AggParam]) -> Bool`, that already checks `agg_param` against all `previous_agg_params`. WDYT @tgeoghegan ?",
          "createdAt": "2023-02-24T20:34:01Z",
          "updatedAt": "2023-02-24T20:34:01Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that also matches what @simon-friedberger had planned [here](https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/pull/410).",
          "createdAt": "2023-02-24T20:35:44Z",
          "updatedAt": "2023-02-24T20:35:44Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I think that works nicely!",
          "createdAt": "2023-02-24T20:37:27Z",
          "updatedAt": "2023-02-24T20:37:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5OOBX_",
          "commit": {
            "abbreviatedOid": "0aaac7c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I think this is the right approach. It's not overly cumbersome but clear enough. That said, we should solicit feedback from @tgeoghegan, who in all likelihood will be tasked with translating this into language in the DAP spec.\r\n\r\nA few high level things:\r\n\r\n1. In security considerations, I think we should talk about what attacks the requirements around the validity scope are meant to prevent.\r\n2. Although it's somewhat redundant, I think we should redefine validity scope for VDAFs as well. Primarily because the language is not generic: Instead of `Daf.prep()`, the requirement applies to `Vdaf.prep_init() / Vdaf.prep_next()`.\r\n* Should we say explicitly that Prio3 has no validity scope? I wonder if readers will wonder whether the absence of this definition is an oversight.",
          "createdAt": "2023-02-23T23:35:43Z",
          "updatedAt": "2023-02-23T23:42:26Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "nit: The I-D tools don't render this as bold-face text as you would hope. It will instead leave these asterisks as they are. I would replace with quotations.\r\n\r\n```suggestion\r\nConcrete DAFs implementations MAY also specify a \"validity scope\" for\r\n```",
              "createdAt": "2023-02-23T23:35:44Z",
              "updatedAt": "2023-02-23T23:42:26Z"
            },
            {
              "originalPosition": 17,
              "body": "Given the importance of this text, I think we should lift it to a subsection somewhere. We want to make sure it's not buried ",
              "createdAt": "2023-02-23T23:38:09Z",
              "updatedAt": "2023-02-23T23:42:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5OVBzU",
          "commit": {
            "abbreviatedOid": "b43d782"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I agree with Chris that this needs to cover VDAFs as well as DAFs. Additionally, I think this needs to add the `VDAF.validity_scope` function sketched out [here](https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/pull/410#discussion_r1117246959) because otherwise I don't think DAP will be able to enforce this requirement, since from DAP's point of view, the aggregation parameter is opaque.",
          "createdAt": "2023-02-24T19:24:18Z",
          "updatedAt": "2023-02-24T19:24:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5OVeu8",
          "commit": {
            "abbreviatedOid": "0aaac7c"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-24T21:09:49Z",
          "updatedAt": "2023-02-24T21:09:49Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Done.",
              "createdAt": "2023-02-24T21:09:49Z",
              "updatedAt": "2023-02-24T21:09:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5OVf0u",
          "commit": {
            "abbreviatedOid": "98ccb3b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, just a couple nits (take them or leave them). ",
          "createdAt": "2023-02-24T21:12:43Z",
          "updatedAt": "2023-02-24T21:14:28Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "nit (totally feel free to ignore)\r\n```suggestion\r\n    return len(previous_agg_params) == 0\r\n```",
              "createdAt": "2023-02-24T21:12:44Z",
              "updatedAt": "2023-02-24T21:14:28Z"
            },
            {
              "originalPosition": 94,
              "body": "```suggestion\r\nAs described in {{sec-daf-validity-scopes}} and {{sec-vdaf-validity-scopes}} respectively, DAFs and VDAFs may impose\r\n```",
              "createdAt": "2023-02-24T21:13:43Z",
              "updatedAt": "2023-02-24T21:14:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5OVgUJ",
          "commit": {
            "abbreviatedOid": "98ccb3b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-24T21:14:39Z",
          "updatedAt": "2023-02-24T21:14:39Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Here and below.",
              "createdAt": "2023-02-24T21:14:39Z",
              "updatedAt": "2023-02-24T21:14:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5OVhPp",
          "commit": {
            "abbreviatedOid": "98ccb3b"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-24T21:18:00Z",
          "updatedAt": "2023-02-24T21:18:00Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Done.",
              "createdAt": "2023-02-24T21:18:00Z",
              "updatedAt": "2023-02-24T21:18:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5OVhH1",
          "commit": {
            "abbreviatedOid": "ede4c15"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-24T21:17:26Z",
          "updatedAt": "2023-02-24T21:33:21Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "nit: link points to wrong section\r\n```suggestion\r\nSimilar to DAFs (see {{sec-daf-validity-scopes}}), VDAFs MAY impose\r\n```",
              "createdAt": "2023-02-24T21:17:26Z",
              "updatedAt": "2023-02-24T21:33:21Z"
            },
            {
              "originalPosition": 31,
              "body": "nit: copyedit\r\n```suggestion\r\nMUST ensure that for each input share and aggregation parameter `agg_param`, the\r\n```",
              "createdAt": "2023-02-24T21:18:42Z",
              "updatedAt": "2023-02-24T21:33:21Z"
            },
            {
              "originalPosition": 71,
              "body": "nit: unnecessary comma\r\n```suggestion\r\nAggregation parameters are valid for a given input share if no aggregation\r\n```",
              "createdAt": "2023-02-24T21:25:15Z",
              "updatedAt": "2023-02-24T21:33:21Z"
            },
            {
              "originalPosition": 80,
              "body": "This may be more idiomatic and clearer.\r\n```suggestion\r\n    return all(\r\n        level != other_level\r\n        for (other_level, _) in previous_agg_params\r\n    )\r\n```",
              "createdAt": "2023-02-24T21:30:37Z",
              "updatedAt": "2023-02-24T21:33:21Z"
            },
            {
              "originalPosition": 100,
              "body": "nit: rephrasing\r\n```suggestion\r\nProtocols that make use of VDAFs therefore MUST call `Vdaf.is_valid`\r\n```",
              "createdAt": "2023-02-24T21:33:00Z",
              "updatedAt": "2023-02-24T21:33:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5OVsGe",
          "commit": {
            "abbreviatedOid": "ede4c15"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-24T21:57:12Z",
          "updatedAt": "2023-02-24T21:57:13Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "Done.",
              "createdAt": "2023-02-24T21:57:13Z",
              "updatedAt": "2023-02-24T21:57:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 162,
      "id": "PR_kwDOGKuqOc5KpgZn",
      "title": "Add IDPF test vector",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/162",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a refresh of #132, rebased on top of #160. I changed it to conditionally override one of the IDPF keys to be `b\"\\x02\" * length`, so that we get a more interesting public share, without runs of zeros. I also checked in the resulting test vector. This has knock-on effects on the Poplar1 test vector, naturally.",
      "createdAt": "2023-02-23T23:18:22Z",
      "updatedAt": "2023-03-01T20:06:50Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "b11da1cbc65b876d4c668395e4270e57d93dbd1c",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/idpf-test-vector",
      "headRefOid": "bf31fa934882c676c0eada20856ebc05d9826618",
      "closedAt": "2023-03-01T20:06:50Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Here is my pitch for fixing up the test vectors.\r\n\r\nUpdate the `Vdaf` API so that `measurement_to_input_shares` takes in `rand: Bytes[Vdaf.RAND_SIZE]`. Normally we would pick this value by calling `gen_rand(Vdaf.RAND_SIZE]`; but for test vectors, we fix the value.\r\n\r\nThis would allow us to exercise what we need for the IDPF correction words. It's not the *minimal* change required for this I think, but it's the easiest to understand.\r\n\r\nHow does this sound?\r\n\r\nIf you agree, let's close this PR and I'll open up a new one. (You can also handle it if you'd like to, but no pressure. I think your time is better spent updating libprio.)",
          "createdAt": "2023-02-28T15:46:56Z",
          "updatedAt": "2023-02-28T15:46:56Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm, I suppose if we want to specify which random bytes go where, then making it an explicit input is the simplest way to do so. Sounds good to me.",
          "createdAt": "2023-02-28T16:05:06Z",
          "updatedAt": "2023-02-28T16:05:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Oops, actually we will want to re-open this once I've addressed #173.",
          "createdAt": "2023-03-01T00:40:53Z",
          "updatedAt": "2023-03-01T00:40:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5ON_pk",
          "commit": {
            "abbreviatedOid": "74f4de0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This seems mostly reasonable. My only concern is that the exception in the test vector generation code contradicts this statement in the spec:\r\n\r\n> To make the tests deterministic, `gen_rand()` was replaced with a function that returns the requested number of octets.\r\n\r\nWe need to figure out a way to spell out how the random values are picked.\r\n\r\nIt may not be strictly necessary to fix this for 04, but it would certainly be nice to have by 05.",
          "createdAt": "2023-02-23T23:25:51Z",
          "updatedAt": "2023-02-23T23:33:36Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "To remind us to delete these lines before copy-pasting into the spec.\r\n```suggestion\r\n        # REMOVE ME\r\n        if TEST_VECTOR:\r\n```",
              "createdAt": "2023-02-23T23:25:51Z",
              "updatedAt": "2023-02-23T23:33:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 164,
      "id": "PR_kwDOGKuqOc5KtxIQ",
      "title": "Add PrgSha3 test vector",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/164",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds a PrgSha3 test vector in addition to the PrgAes128 test vector. This is stacked on top of #162.",
      "createdAt": "2023-02-24T16:04:39Z",
      "updatedAt": "2023-03-01T20:28:19Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "david/idpf-test-vector",
      "baseRefOid": "bf31fa934882c676c0eada20856ebc05d9826618",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/prgsha3-test-vector",
      "headRefOid": "75568deb5a99c2e1e976dd728de83bed73ee1219",
      "closedAt": "2023-03-01T20:09:56Z",
      "mergedAt": "2023-03-01T20:09:56Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "ab599e958a26d71e7725fa2b46554cf3c5a357d5"
      },
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Whoops, this was still pointed at another branch. I'll rebase and recreate it.",
          "createdAt": "2023-03-01T20:11:34Z",
          "updatedAt": "2023-03-01T20:11:34Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "My mistake :( forgot to check the base",
          "createdAt": "2023-03-01T20:25:48Z",
          "updatedAt": "2023-03-01T20:25:48Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "By the way I took over david/idpf-test-vec and have force-pushed it. I realize now that I have created a bit of a mess by doing this ... we will need to cherry-pick this commit onto main. I can handle the clean up.",
          "createdAt": "2023-03-01T20:28:18Z",
          "updatedAt": "2023-03-01T20:28:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5OtgNw",
          "commit": {
            "abbreviatedOid": "75568de"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-01T20:09:39Z",
          "updatedAt": "2023-03-01T20:09:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 165,
      "id": "PR_kwDOGKuqOc5Kuudg",
      "title": "Spellcheck changes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/165",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Some small editorial fixes:",
      "createdAt": "2023-02-24T19:42:02Z",
      "updatedAt": "2023-02-24T20:22:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "3352a58d3cc228de345f88170df14ee89d65bf42",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/vdaf-04-spellcheck",
      "headRefOid": "81519c2eff4769c51bae151f7d9d51b9bbe6d0fd",
      "closedAt": "2023-02-24T20:22:30Z",
      "mergedAt": "2023-02-24T20:22:30Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "fe176384216a2063c2eef0dccc47b90b37f7bba0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5OVSBF",
          "commit": {
            "abbreviatedOid": "81519c2"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-24T20:21:14Z",
          "updatedAt": "2023-02-24T20:21:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 166,
      "id": "PR_kwDOGKuqOc5KvKnP",
      "title": "Update POC to add `is_valid` to DAFs and VDAFs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/166",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Merge after #161.",
      "createdAt": "2023-02-24T21:50:50Z",
      "updatedAt": "2024-07-02T21:50:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "de2c5f717cdd652d0518a612a0c86e67f10d754f",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "schoppmp/update-poc-after-161",
      "headRefOid": "4d3ebd0324be344c4190fcb560126e3500fa3480",
      "closedAt": "2023-02-24T22:46:13Z",
      "mergedAt": "2023-02-24T22:46:13Z",
      "mergedBy": "schoppmp",
      "mergeCommit": {
        "oid": "f6c5269b3d110bca89148bff10ce241290f10729"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Nice. Will approve once we merge the base and rebase.",
          "createdAt": "2023-02-24T22:04:58Z",
          "updatedAt": "2023-02-24T22:04:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5OV1ba",
          "commit": {
            "abbreviatedOid": "4d3ebd0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-24T22:44:39Z",
          "updatedAt": "2023-02-24T22:44:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 167,
      "id": "PR_kwDOGKuqOc5KvW89",
      "title": "Remove an out-of-date OPEN ISSUE",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/167",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Would have been nice to clean this up before 04 but \ud83e\udd37 \r\n",
      "createdAt": "2023-02-24T23:03:54Z",
      "updatedAt": "2023-04-24T21:36:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "f6c5269b3d110bca89148bff10ce241290f10729",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-05/0/clean-up",
      "headRefOid": "89cc74a8ae8347b561c34718a7b7868bc5650204",
      "closedAt": "2023-02-28T01:21:30Z",
      "mergedAt": "2023-02-28T01:21:30Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "a1c7ee995750ab7f09c9dde0757a42e0a4a316f2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5OehCU",
          "commit": {
            "abbreviatedOid": "89cc74a"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-28T00:15:19Z",
          "updatedAt": "2023-02-28T00:15:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 170,
      "id": "PR_kwDOGKuqOc5K3ZhE",
      "title": "Editorial things",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/170",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #113.\r\nCloses #168.",
      "createdAt": "2023-02-27T19:36:46Z",
      "updatedAt": "2023-02-27T19:57:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "f6c5269b3d110bca89148bff10ce241290f10729",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-05/1/editorial",
      "headRefOid": "5a99727aa954268994968f3c7b512e8b90d44122",
      "closedAt": "2023-02-27T19:57:51Z",
      "mergedAt": "2023-02-27T19:57:50Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "ce70c92f1d934f6180063bfad3338a02cb0d8f0e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5OdW8P",
          "commit": {
            "abbreviatedOid": "81da1ea"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-27T19:43:47Z",
          "updatedAt": "2023-02-27T19:46:11Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think we still want to point to the section above, not the field parameters table.",
              "createdAt": "2023-02-27T19:43:48Z",
              "updatedAt": "2023-02-27T19:46:11Z"
            },
            {
              "originalPosition": 60,
              "body": "This should point to `#field` as well, as that's where the class is defined.",
              "createdAt": "2023-02-27T19:45:29Z",
              "updatedAt": "2023-02-27T19:46:11Z"
            },
            {
              "originalPosition": 158,
              "body": "Ditto",
              "createdAt": "2023-02-27T19:45:59Z",
              "updatedAt": "2023-02-27T19:46:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5OdY8M",
          "commit": {
            "abbreviatedOid": "81da1ea"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-27T19:49:14Z",
          "updatedAt": "2023-02-27T19:49:14Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Whoopsies, this is a regex whoopsy daisy! Thanks",
              "createdAt": "2023-02-27T19:49:14Z",
              "updatedAt": "2023-02-27T19:49:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5OdaBp",
          "commit": {
            "abbreviatedOid": "81da1ea"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-27T19:51:29Z",
          "updatedAt": "2023-02-27T19:51:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This one should get rolled back too",
              "createdAt": "2023-02-27T19:51:29Z",
              "updatedAt": "2023-02-27T19:51:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5OdbZr",
          "commit": {
            "abbreviatedOid": "5a99727"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-27T19:55:29Z",
          "updatedAt": "2023-02-27T19:55:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 171,
      "id": "PR_kwDOGKuqOc5K3uER",
      "title": "Specify nonce sizes for Prio3 and Poplar1",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/171",
      "state": "MERGED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Set `NONCE_SIZE` in the Prio3 and Poplar1 constructions, as required by the VDAF definition. The nonces are 16 bytes long, matching the existing Sage reference implementations.\r\n\r\nRelated to #127",
      "createdAt": "2023-02-27T20:45:16Z",
      "updatedAt": "2023-02-27T21:01:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "ce70c92f1d934f6180063bfad3338a02cb0d8f0e",
      "headRepository": "tgeoghegan/vdaf",
      "headRefName": "timg/prio3-poplar1-nonce-sizes",
      "headRefOid": "5e5043fc54acb727270cccd3bfd0fb95612fc6d2",
      "closedAt": "2023-02-27T21:01:33Z",
      "mergedAt": "2023-02-27T21:01:32Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "840e823b7e53681c972d58787b53f046b980a3a0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5Odtbj",
          "commit": {
            "abbreviatedOid": "5e5043f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Nice catch! We had changed this in the reference code but neglected to specify it in the doc itself.",
          "createdAt": "2023-02-27T20:47:59Z",
          "updatedAt": "2023-02-27T20:47:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 172,
      "id": "PR_kwDOGKuqOc5K4tId",
      "title": "nit: Remove a spurious backtick",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/172",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-02-28T01:22:46Z",
      "updatedAt": "2023-04-24T21:36:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "a1c7ee995750ab7f09c9dde0757a42e0a4a316f2",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-05/2/editorial",
      "headRefOid": "07df2bed2e63ca62333c7f7a113d23e5e4c94939",
      "closedAt": "2023-02-28T01:27:00Z",
      "mergedAt": "2023-02-28T01:27:00Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "10249a87c17454e0bce52efc3cf2ddc608f5184f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5Oes4i",
          "commit": {
            "abbreviatedOid": "07df2be"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-28T01:23:19Z",
          "updatedAt": "2023-02-28T01:23:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 174,
      "id": "PR_kwDOGKuqOc5K8yaN",
      "title": "Poplar1: Hoist sketch check to prep_shares_to_prep",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/174",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This hoists the final sketch verification check from `prep_next()` to `prep_shares_to_prep()`. As a result, the round 2 prepare message will always be the empty string, if it doesn't raise an error. (Previously, it could have been the empty string or a 32-byte encoded field element)\r\n\r\nCloses #169.",
      "createdAt": "2023-02-28T16:47:43Z",
      "updatedAt": "2023-05-01T17:02:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "10249a87c17454e0bce52efc3cf2ddc608f5184f",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/poplar1-prepare-message",
      "headRefOid": "be5c1f915a2cafb4d27f4efd7d8d6ff3eaf535b9",
      "closedAt": "2023-02-28T21:12:48Z",
      "mergedAt": "2023-02-28T21:12:48Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "378677075be6cda9d556438ebda543dd2aa24852"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5OlVT9",
          "commit": {
            "abbreviatedOid": "be5c1f9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\ud83d\udc4d ",
          "createdAt": "2023-02-28T19:22:49Z",
          "updatedAt": "2023-02-28T19:22:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 175,
      "id": "PR_kwDOGKuqOc5K9vRD",
      "title": "Use littlen-endian byte-order for fields",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/175",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #90 \r\n\r\nAdd methods to_le_bytes/from_le_bytes for encoding/decoding unsigned\r\nintegers as little-endian bytes and use these for field element\r\nserialization. This change is meant to improve alignment of the spec\r\nwith implementations, which largely prefer little endian to big endian\r\nfor representing field elements.\r\n\r\nFor consistency, rename I2OSP/OS2IP to to_be_bytes/from_be_bytes.\r\n\r\nWhile at it, check in David's script for generating the PRG rejection\r\ntest case. This is not strictly needed, since we could just reverse the\r\norder of the bytes in the test seed, but it will be useful later on.",
      "createdAt": "2023-02-28T19:46:11Z",
      "updatedAt": "2023-04-24T21:36:14Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "b11da1cbc65b876d4c668395e4270e57d93dbd1c",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-05/3/endian",
      "headRefOid": "63dc0ab382ebe035ff87b76ca42f0ab8aa2744f0",
      "closedAt": "2023-03-01T16:18:16Z",
      "mergedAt": "2023-03-01T16:18:16Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "9bea04c400b4f8ccf7de4df8e29569dfcabedc9b"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Ready for review. @divergentdave note that I have changed the scope of the wire changes to just using little endian for finite fields. Given that there are places in IDPF land where we want big endian, it makes sense to keep the change minimal in my opinion.",
          "createdAt": "2023-03-01T03:45:54Z",
          "updatedAt": "2023-03-01T03:45:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5OljUO",
          "commit": {
            "abbreviatedOid": "b222ede"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-28T19:47:33Z",
          "updatedAt": "2023-02-28T19:51:47Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Reviewer note: I plan to propagate these changes to the draft before merging this PR. For now, the PR is marked as draft until we've decided whether to reverse the IDPF index bit order (see below).",
              "createdAt": "2023-02-28T19:47:33Z",
              "updatedAt": "2023-02-28T19:51:47Z"
            },
            {
              "originalPosition": 65,
              "body": "Reviewer note: For this test to pass it is necessary to interpret the input measurements and candidate prefixes as big-endian integers. This is because of the order in which we traverse the bits of the IDPF index in the IDPF key-generation algorithm.\r\n\r\nIf we reversed the order, then we change `int.from_bytes(b'00000000', byteorder='big')` to `from_le_bytes(b'00000000')` and so on.",
              "createdAt": "2023-02-28T19:51:13Z",
              "updatedAt": "2023-02-28T19:51:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Ol1MG",
          "commit": {
            "abbreviatedOid": "b222ede"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-28T20:20:08Z",
          "updatedAt": "2023-03-01T00:32:24Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Agreed, using big-endian decoding here is coupled to how the bits get pulled out of the integers down the line. I think it makes sense to focus this change on just field elements, (plus binder strings, etc.) and not IDPF inputs/indices.",
              "createdAt": "2023-02-28T20:20:08Z",
              "updatedAt": "2023-03-01T00:32:24Z"
            },
            {
              "originalPosition": 35,
              "body": "I think we should avoid switching the endianness of this, because it would result in encoding candidate prefixes with a confusing combination of bit and byte orders. For example, taking a test input from below:\r\n\r\n```\r\n# With PR\r\nsage: sagelib.vdaf_poplar1.Poplar1().with_bits(128).encode_agg_param(127, [int.from_bytes(b'0123456789abcdef', byteorder='big')])\r\nb'\\x7f\\x00\\x01\\x00\\x00\\x00fedcba9876543210'\r\n\r\n# With `main`\r\nsage: sagelib.vdaf_poplar1.Poplar1().with_bits(128).encode_agg_param(127, [int.from_bytes(b'0123456789abcdef', byteorder='big')])\r\nb'\\x00\\x7f\\x00\\x00\\x00\\x010123456789abcdef'\r\n```",
              "createdAt": "2023-03-01T00:20:50Z",
              "updatedAt": "2023-03-01T00:32:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5OnHHk",
          "commit": {
            "abbreviatedOid": "b222ede"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T00:43:04Z",
          "updatedAt": "2023-03-01T00:43:04Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "ACK, I'll add back `to_be_bytes()` and revert this. Thanks for the careful feedback here.",
              "createdAt": "2023-03-01T00:43:04Z",
              "updatedAt": "2023-03-01T00:43:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5OnHML",
          "commit": {
            "abbreviatedOid": "b222ede"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T00:43:30Z",
          "updatedAt": "2023-03-01T00:43:31Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "SGTM, I'll refocus and ping you when I'm ready for a full review.",
              "createdAt": "2023-03-01T00:43:30Z",
              "updatedAt": "2023-03-01T00:43:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Or4mT",
          "commit": {
            "abbreviatedOid": "63dc0ab"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-01T15:47:38Z",
          "updatedAt": "2023-03-01T15:47:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 178,
      "id": "PR_kwDOGKuqOc5K-ZiL",
      "title": "Make a note about merging aggregate shares",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/178",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #47.",
      "createdAt": "2023-02-28T22:16:21Z",
      "updatedAt": "2023-04-24T21:36:14Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "378677075be6cda9d556438ebda543dd2aa24852",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-05/4/merging-agg-shares",
      "headRefOid": "a5cf96df2c00230b250bfa289076bd7d455e2f0d",
      "closedAt": "2023-02-28T23:19:37Z",
      "mergedAt": "2023-02-28T23:19:37Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "b11da1cbc65b876d4c668395e4270e57d93dbd1c"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "cc/ @tgeoghegan for approval.",
          "createdAt": "2023-02-28T22:16:46Z",
          "updatedAt": "2023-02-28T22:16:46Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5Om0sJ",
          "commit": {
            "abbreviatedOid": "a5cf96d"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-28T23:01:22Z",
          "updatedAt": "2023-02-28T23:01:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5Om1hx",
          "commit": {
            "abbreviatedOid": "a5cf96d"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-28T23:05:30Z",
          "updatedAt": "2023-02-28T23:05:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 180,
      "id": "PR_kwDOGKuqOc5K-upg",
      "title": "Define the IDPF \"prefix tree\" and add privacy considerations for it",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/180",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #102.\r\n\r\nIn general the ability to aggregate a batch multiple times with different aggregation parameters may lead to unintended leakage. We don't really have a great solution for this right now, but point to what we know about this.",
      "createdAt": "2023-03-01T00:01:28Z",
      "updatedAt": "2023-04-24T21:36:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "1d5003afbaa5386c345976053dae3a698f9fee19",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-05/5/poplar1-hcg-feedback",
      "headRefOid": "46d241871647c3b0a9d927928658d7ae24d5ea5d",
      "closedAt": "2023-03-10T16:58:13Z",
      "mergedAt": "2023-03-10T16:58:13Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "78f14c1954b418f6a67e3b4c87de27cd4e42d4cf"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Squashed and rebased.",
          "createdAt": "2023-03-10T16:35:25Z",
          "updatedAt": "2023-03-10T16:35:25Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed a couple of typos.",
          "createdAt": "2023-03-10T16:38:22Z",
          "updatedAt": "2023-03-10T16:38:22Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5O0D3v",
          "commit": {
            "abbreviatedOid": "436d106"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-02T17:11:03Z",
          "updatedAt": "2023-03-02T19:44:28Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "nit: typo\r\n```suggestion\r\nThis functionality is the core component of the Poplar protocol {{BBCGGI21}},\r\n```",
              "createdAt": "2023-03-02T17:11:03Z",
              "updatedAt": "2023-03-02T19:44:29Z"
            },
            {
              "originalPosition": 34,
              "body": "This line wrapping revealed a classic repeated word typo\r\n```suggestion\r\nto a non-zero value; otherwise it evaluates to zero. This structure allows an\r\n```",
              "createdAt": "2023-03-02T18:59:52Z",
              "updatedAt": "2023-03-02T19:44:29Z"
            },
            {
              "originalPosition": 67,
              "body": "```suggestion\r\nprefix, which would be leaked by a prefix tree with a sufficiently small\r\n```",
              "createdAt": "2023-03-02T19:44:05Z",
              "updatedAt": "2023-03-02T19:44:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 181,
      "id": "PR_kwDOGKuqOc5LEMWl",
      "title": "Add PrgSha3 test vector",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/181",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a rebased version of #164. I regenerated the test vectors to confirm they haven't changed after the rebase.",
      "createdAt": "2023-03-01T20:17:43Z",
      "updatedAt": "2023-05-01T17:02:31Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "9bea04c400b4f8ccf7de4df8e29569dfcabedc9b",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/prgsha3-test-vector",
      "headRefOid": "7ab38562f0540e474744151f9e71050c0224f7f3",
      "closedAt": "2023-03-01T20:29:48Z",
      "mergedAt": "2023-03-01T20:29:48Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "d9d6881d6d1f15ce4c1e668a4fa2a029fe4ff886"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5Otmbw",
          "commit": {
            "abbreviatedOid": "7ab3856"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-01T20:29:42Z",
          "updatedAt": "2023-03-01T20:29:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 182,
      "id": "PR_kwDOGKuqOc5LErYD",
      "title": "Change rejection sampling test to use Field64",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/182",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This changes out the rejection sampling test to use Field64, which is actually in the document. There's less of a gap between the Field64 modulus and the largest 64-bit integer than in the Field96 case, so I wrote a small Rust program to do so, instead of using Python. (the search takes about ~30s on eight cores with this, it was too slow with Python) For what it's worth, finding similar test vectors for Field128 and Field255/GF(2^255-19) is infeasible to practically impossible.",
      "createdAt": "2023-03-01T22:21:39Z",
      "updatedAt": "2023-05-01T17:02:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d9d6881d6d1f15ce4c1e668a4fa2a029fe4ff886",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/rejection-sampling-test-field64",
      "headRefOid": "de11c1b7c59bcf7421024d3f3ef361a682484782",
      "closedAt": "2023-03-02T00:08:36Z",
      "mergedAt": "2023-03-02T00:08:36Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "b774d5aa6e686a9c9003f492e18a2cf5a48ca69e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5OuJPl",
          "commit": {
            "abbreviatedOid": "3824c5e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T22:30:40Z",
          "updatedAt": "2023-03-01T22:30:43Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "^ We might as well dump probe_for_rejection as well.",
              "createdAt": "2023-03-01T22:30:40Z",
              "updatedAt": "2023-03-01T22:30:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5OuK4c",
          "commit": {
            "abbreviatedOid": "de11c1b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-01T22:37:05Z",
          "updatedAt": "2023-03-01T22:37:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 183,
      "id": "PR_kwDOGKuqOc5LFMDA",
      "title": "poc: Generate test vectors for IdpfPoplar",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/183",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For a given input `alpha`, and values `beta_inner` and `beta_leaf`, generate the expected public and key shares.",
      "createdAt": "2023-03-02T00:11:47Z",
      "updatedAt": "2023-04-24T21:36:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "b774d5aa6e686a9c9003f492e18a2cf5a48ca69e",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/idpf-test-vector",
      "headRefOid": "fb12cf7bd1d64b2f994e9d7323759b5b866f8dbe",
      "closedAt": "2023-03-02T00:31:39Z",
      "mergedAt": "2023-03-02T00:31:39Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "b62e88ea41690d4fdfb48c29ce81d463ce2832ea"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5OuoRR",
          "commit": {
            "abbreviatedOid": "fb12cf7"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-02T00:13:26Z",
          "updatedAt": "2023-03-02T00:13:27Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "In order to make sure we properly test the inputs to PRG are constructed prooperly, we'll need the IDPF keys for the two aggregators to be different. This will be fixed in #173.",
              "createdAt": "2023-03-02T00:13:26Z",
              "updatedAt": "2023-03-02T00:13:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5OupfB",
          "commit": {
            "abbreviatedOid": "fb12cf7"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-02T00:17:48Z",
          "updatedAt": "2023-03-02T00:17:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 184,
      "id": "PR_kwDOGKuqOc5LFS-D",
      "title": "poc: Replace \"deepcopy\" pattern for class factories",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/184",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #163.\r\n\r\nProperly construct a subclass instead of attempting to deep copy the superclass. The old pattern did not have the intended effect, which results in some subtle bugs.",
      "createdAt": "2023-03-02T00:51:41Z",
      "updatedAt": "2023-04-24T21:36:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "b62e88ea41690d4fdfb48c29ce81d463ce2832ea",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-05/6/factory",
      "headRefOid": "636d29c3440fbb5b4c16fd34d5f96a9b7513a9ff",
      "closedAt": "2023-03-02T17:48:18Z",
      "mergedAt": "2023-03-02T17:48:18Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "03e018e218f39597b826841f56f4fe72320ba0ba"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Reviewer note: As a side-effect of subclassing, rather than deepcopying the object, the name of the class we construct is different. This means the test vector files now have new, strange names:\r\n```\r\n18:41:19:~/github.com/cfrg/draft-irtf-cfrg-vdaf/poc $ ls test_vec/04/\r\nIdpfPoplarWithBits_0.json Poplar1WithBits_1.json    Poplar1WithBits_3.json    PrgSha3.json\r\nPoplar1WithBits_0.json    Poplar1WithBits_2.json    PrgAes128.json            Prio3WithShares_0.json\r\n```\r\n\r\nTo address this, we'll want to rework the test vector code to not use `Vdaf.__name__` as the file name.",
          "createdAt": "2023-03-02T02:42:36Z",
          "updatedAt": "2023-03-02T02:42:36Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> Reviewer note: As a side-effect of subclassing, rather than deepcopying the object, the name of the class we construct is different. This means the test vector files now have new, strange names:\r\n> \r\n> ```\r\n> 18:41:19:~/github.com/cfrg/draft-irtf-cfrg-vdaf/poc $ ls test_vec/04/\r\n> IdpfPoplarWithBits_0.json Poplar1WithBits_1.json    Poplar1WithBits_3.json    PrgSha3.json\r\n> Poplar1WithBits_0.json    Poplar1WithBits_2.json    PrgAes128.json            Prio3WithShares_0.json\r\n> ```\r\n> \r\n> To address this, we'll want to rework the test vector code to not use `Vdaf.__name__` as the file name.\r\n\r\nResolved by https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/188.",
          "createdAt": "2023-03-02T15:54:22Z",
          "updatedAt": "2023-03-02T15:54:22Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5Ozpzj",
          "commit": {
            "abbreviatedOid": "636d29c"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-02T16:16:37Z",
          "updatedAt": "2023-03-02T16:16:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 186,
      "id": "PR_kwDOGKuqOc5LFckS",
      "title": "poc: Plumb coins to `measurement_to_input_shares()`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/186",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #184 (merge that first).\r\nPartially addresses #173.\r\n\r\nTo improve test vector quality, we will need to be able to specify a particular sequence of random coins used by the Client to split its measurement.\r\n\r\nAdd a paramter to `Daf.measurmeent_to_input_shares()` and `Vdaf.measurmeent_to_input_shares()` for the random coins. In addition, have the object specify the size of the byte string it expects. Similarly for `Idpf`.\r\n\r\nAccordingly, remove all calls to `gen_rand()` from `Prio3`, `Poplar1`, and `IdpfPoplar` and instead use the coins passed to the API.",
      "createdAt": "2023-03-02T01:54:28Z",
      "updatedAt": "2023-04-24T21:36:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "03e018e218f39597b826841f56f4fe72320ba0ba",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-05/7/test-vec-rand",
      "headRefOid": "e49104a2e25ed9342d81b2b79b9c0d93040ef668",
      "closedAt": "2023-03-02T18:03:21Z",
      "mergedAt": "2023-03-02T18:03:21Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "8764f2d4f8fa9c38d32cf3cdfd43eacdeec3d7fe"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5Oz5zy",
          "commit": {
            "abbreviatedOid": "2d6f1af"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-02T16:49:02Z",
          "updatedAt": "2023-03-02T17:00:47Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "nit: typo\r\n```suggestion\r\n        # correlated randomness, and sharding.\r\n```",
              "createdAt": "2023-03-02T16:49:02Z",
              "updatedAt": "2023-03-02T17:00:47Z"
            },
            {
              "originalPosition": 44,
              "body": "We should check if `len(rand) == self.RAND_SIZE` just in case before this. If it's too short, the last seed could wind up with a truncated value.",
              "createdAt": "2023-03-02T16:51:11Z",
              "updatedAt": "2023-03-02T17:00:47Z"
            },
            {
              "originalPosition": 55,
              "body": "Same here, we should check the length of rand instead of the length of seeds.",
              "createdAt": "2023-03-02T16:55:34Z",
              "updatedAt": "2023-03-02T17:00:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 187,
      "id": "PR_kwDOGKuqOc5LFiqe",
      "title": "poc: Use an increasing sequence for test vector `gen_rand()`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/187",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #186 (merge that first).\r\nPartially addresses #173.\r\n\r\nInstead of outputting `01010101...`, `gen_rand()` now outputs `00010203...`. This ensures that the IDPF key shares generated for the test vectors are distinct, thereby improving coverage of the vectors.",
      "createdAt": "2023-03-02T02:34:57Z",
      "updatedAt": "2023-04-24T21:36:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "8764f2d4f8fa9c38d32cf3cdfd43eacdeec3d7fe",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-05/8/test-vec",
      "headRefOid": "433825a97657de129840809be29a0bc92c5e7761",
      "closedAt": "2023-03-02T18:19:47Z",
      "mergedAt": "2023-03-02T18:19:47Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "dcf8a61c62793be8fe760538ebfff1f1c5c629df"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5O0WT9",
          "commit": {
            "abbreviatedOid": "6309028"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-02T17:56:39Z",
          "updatedAt": "2023-03-02T17:57:22Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "`i % length` seems strange, as it will never wrap around\r\n```suggestion\r\n        return bytes(int(i & 0xff) for i in range(length))\r\n```",
              "createdAt": "2023-03-02T17:56:40Z",
              "updatedAt": "2023-03-02T17:57:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5O0Zv5",
          "commit": {
            "abbreviatedOid": "6309028"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-02T18:04:10Z",
          "updatedAt": "2023-03-02T18:04:10Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Uhhh yup, this was supposed to be `256`. Good catch.",
              "createdAt": "2023-03-02T18:04:10Z",
              "updatedAt": "2023-03-02T18:04:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5O0bEz",
          "commit": {
            "abbreviatedOid": "433825a"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-02T18:08:01Z",
          "updatedAt": "2023-03-02T18:08:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 188,
      "id": "PR_kwDOGKuqOc5LJHEM",
      "title": "poc: Don't use class name for test vector name",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/188",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #187 (merge that first).\r\nPartially addresses #173.\r\n\r\nWe currently use the class name to name the file containing teste vectors for it. We create subclasses to specialize a `Vdaf` (or `Prg`, `Idpf`, etc.) with a given parameter. It is helpful to have that subclass have a distinguished name, e.g., `Prio3SumWithShares`. However, this name is not particularly helpful as a name for the file.\r\n\r\nTo fix this, add a `test_vec_name` class parameter to each class for which we generate test vectors and use that as the filename instead of `__class__`.",
      "createdAt": "2023-03-02T15:52:57Z",
      "updatedAt": "2023-04-24T21:36:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "dcf8a61c62793be8fe760538ebfff1f1c5c629df",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-05/9/test-vec-names",
      "headRefOid": "225fa2f02dac8c0b2dc8967c0bdade88b55db39b",
      "closedAt": "2023-03-02T18:36:18Z",
      "mergedAt": "2023-03-02T18:36:18Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "a51acd377375f1342747587c055a0d30989eb6e3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5OzqZa",
          "commit": {
            "abbreviatedOid": "b495e62"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-02T16:17:55Z",
          "updatedAt": "2023-03-02T16:17:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 189,
      "id": "PR_kwDOGKuqOc5LPvc1",
      "title": "Propagate changes to randomness handling to spec",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/189",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #173.\r\n\r\n* Add a parameter to all randomized algorithms that consists of the random coins consumed by that algorithm. Namely:\r\n\r\n  * `Daf.measurement_to_input_shares()`\r\n  * `Vdaf.measurement_to_input_shares()`\r\n  * `Idpf.gen()`\r\n\r\n  Have the algorithm specify the required length of the random istring.\r\n\r\n* Update `Prio3`, `Poplar1`, and `IdpfPoplar` accordingly.\r\n\r\n* Update `run_daf()` and `run_vdaf()` accordingly.\r\n\r\n* Revise description of fixed random coins used for generating test vectors.\r\n\r\nWhile at it, pick up a couple small editorial things:\r\n\r\n* Replace instances of \"input-distribution algorithm\" with \"sharding algorithm\" for consistency.\r\n\r\n* poc: Fix typo in a comment in `run_daf()`.",
      "createdAt": "2023-03-03T17:30:53Z",
      "updatedAt": "2023-04-24T21:36:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "a51acd377375f1342747587c055a0d30989eb6e3",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-05/10/propagate-alg-changes",
      "headRefOid": "195c21d0a1347a3fa318fc31c3a5cd4935b2fa40",
      "closedAt": "2023-03-03T18:28:23Z",
      "mergedAt": "2023-03-03T18:28:23Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "a39c87b496a25118ffb6c900608932d16e80d404"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5O8JWn",
          "commit": {
            "abbreviatedOid": "0e39c14"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-03T18:06:12Z",
          "updatedAt": "2023-03-03T18:06:34Z",
          "comments": [
            {
              "originalPosition": 334,
              "body": "nit: copyedit\r\n```suggestion\r\nByte strings are encoded in hexadecimal. To make the tests deterministic, the\r\nrandom inputs of randomized algorithms were fixed to the byte sequence starting\r\nwith `0`, incrementing by `1`, and wrapping at `256`:\r\n\r\n~~~\r\n0, 1, 2, ..., 255, 0, 1, 2, ...\r\n~~~\r\n```",
              "createdAt": "2023-03-03T18:06:12Z",
              "updatedAt": "2023-03-03T18:06:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 191,
      "id": "PR_kwDOGKuqOc5Lhdv6",
      "title": "draft-05 chores",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/191",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #190.\r\n\r\n* Bump version\r\n* Update change log\r\n* Run spellcheck",
      "createdAt": "2023-03-07T22:57:04Z",
      "updatedAt": "2023-04-24T21:36:07Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "a39c87b496a25118ffb6c900608932d16e80d404",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-05/12/chores",
      "headRefOid": "f0c31777dbb1bdfae88584cde42f573bb107c2e8",
      "closedAt": "2023-03-07T23:00:14Z",
      "mergedAt": "2023-03-07T23:00:14Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "3a1eba82b10842d3c80b91bc838aa48c8a608a3d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5PQWfP",
          "commit": {
            "abbreviatedOid": "f0c3177"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-07T22:59:28Z",
          "updatedAt": "2023-03-07T22:59:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 192,
      "id": "PR_kwDOGKuqOc5Ll7rw",
      "title": "Fix encoding of output shares in test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/192",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There's a stray big-endian encoding of field elements in the test vector formatting code, this PR fixes it and brings it in line with how the other fields are encoded.",
      "createdAt": "2023-03-08T17:56:16Z",
      "updatedAt": "2023-05-01T17:02:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "3a1eba82b10842d3c80b91bc838aa48c8a608a3d",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/fix-test-vec-output-share-endian",
      "headRefOid": "c936cc19c7848eca91305d9176507803145b1b82",
      "closedAt": "2023-03-09T16:02:37Z",
      "mergedAt": "2023-03-09T16:02:37Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "1d5003afbaa5386c345976053dae3a698f9fee19"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5PWDC0",
          "commit": {
            "abbreviatedOid": "c936cc1"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\ud83d\udc4d \r\n",
          "createdAt": "2023-03-08T18:02:44Z",
          "updatedAt": "2023-03-08T18:02:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 193,
      "id": "PR_kwDOGKuqOc5LoJx1",
      "title": "Add fixed-key AES specification",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/193",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #32.",
      "createdAt": "2023-03-09T03:33:11Z",
      "updatedAt": "2023-04-24T21:36:00Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "71b88d6e238f3f91bb24b5d6efc110cc8d7310f0",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "schoppmp/fixed_key_aes",
      "headRefOid": "4ba234faa54761463623faa7e8dc07173d513a10",
      "closedAt": "2023-03-13T15:16:20Z",
      "mergedAt": "2023-03-13T15:16:20Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "87e691d7f40a6d70946c3243bd1e674c5ea99a0d"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's make sure to ACK whoever you worked with on this.",
          "createdAt": "2023-03-11T04:45:07Z",
          "updatedAt": "2023-03-11T04:45:07Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> Let's make sure to ACK whoever you worked with on this.\r\n\r\nDone.",
          "createdAt": "2023-03-13T02:24:32Z",
          "updatedAt": "2023-03-13T02:24:32Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "The current version looks great, thanks for the help!",
          "createdAt": "2023-03-13T02:26:15Z",
          "updatedAt": "2023-03-13T02:26:15Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Squashed.",
          "createdAt": "2023-03-13T15:14:38Z",
          "updatedAt": "2023-03-13T15:14:38Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5Peh8s",
          "commit": {
            "abbreviatedOid": "f4cd43d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I\u2019m still working through the PR, but looking good so far. I should have a full pass done by the time we meet. In the meantime, three high-level things:\r\n\r\n1. In the markdown version of PrgSha3 I replaced the PyCryptodome APIs with the functions as defined in the SHA-3 spec. Could we do the same for PrgFixedKeyAes128?\r\n2. I think we should \"fix\" PrgFixedKeyAes128 as the only Prg used for IdpfPoplar. The main reason is that we want to generate test vectors for this, since we'll have to implement it elsewhere (in libprio-rs in particular).\r\n3.  You mentioned you consulted with one of the authors of {{GKWWY?20}} -- it would be appropraite to acknowledge them in the Acknwledgements section.",
          "createdAt": "2023-03-09T17:45:14Z",
          "updatedAt": "2023-03-09T18:45:42Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Can we plumb this into IdpfPoplar? We want to be able to generate test vectors for it. I would also suggest we *fix* this as the only `Prg` implementation for IdpfPoplar.",
              "createdAt": "2023-03-09T17:45:15Z",
              "updatedAt": "2023-03-09T18:45:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Pf6jw",
          "commit": {
            "abbreviatedOid": "f4cd43d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-09T20:38:57Z",
          "updatedAt": "2023-03-09T20:43:24Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "nit: Rather than define this inline, I think it would make more sense as a helper function defined in the main scope.",
              "createdAt": "2023-03-09T20:38:57Z",
              "updatedAt": "2023-03-09T20:43:24Z"
            },
            {
              "originalPosition": 210,
              "body": "The end of this section should point to the OPEN ISSUE of #159.",
              "createdAt": "2023-03-09T20:40:46Z",
              "updatedAt": "2023-03-09T20:43:24Z"
            },
            {
              "originalPosition": 202,
              "body": "* No need to capitalize this IMO (here and below)\r\n* We should add a reference for a definition of \"random oracle\". BR93 (\"Random Oracles are Practical\") would be sufficient, or maybe there's a section in {{GKWW20}} we could point to?\r\n```suggestion\r\nof them are modeled as random oracles {{needs-ref}}. For these use cases, we want to be\r\n```",
              "createdAt": "2023-03-09T20:41:13Z",
              "updatedAt": "2023-03-09T20:43:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Pnoq_",
          "commit": {
            "abbreviatedOid": "89ab4de"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-11T01:31:13Z",
          "updatedAt": "2023-03-11T01:31:13Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "This should be clarified to say that Poplar1 is instantiated with PrgSha3 for the VDAF itself, and the IdpfPoplar inside is instantiated with PrgFixedKeyAes128.",
              "createdAt": "2023-03-11T01:31:13Z",
              "updatedAt": "2023-03-11T01:31:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5PmM3M",
          "commit": {
            "abbreviatedOid": "f3aaf03"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I've made addressed some of the comments and have pushed a few changes. I think this is in decent shape, but I would appreciate careful feedback before reviewing. And of course if there are any changes I made that you don't like, feel free to override me.\r\n\r\nNon-blocking comments in-line.",
          "createdAt": "2023-03-10T18:36:39Z",
          "updatedAt": "2023-03-11T04:31:52Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Which string?",
              "createdAt": "2023-03-10T18:36:39Z",
              "updatedAt": "2023-03-11T04:31:52Z"
            },
            {
              "originalPosition": 189,
              "body": "Replaced the reference here with PrgSha3.",
              "createdAt": "2023-03-11T04:06:05Z",
              "updatedAt": "2023-03-11T04:31:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5PpDEZ",
          "commit": {
            "abbreviatedOid": "4a6c2f9"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T02:24:14Z",
          "updatedAt": "2023-03-13T02:24:15Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "The binder string. Updated it.",
              "createdAt": "2023-03-13T02:24:14Z",
              "updatedAt": "2023-03-13T02:24:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5PpGoC",
          "commit": {
            "abbreviatedOid": "f4cd43d"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T02:36:31Z",
          "updatedAt": "2023-03-13T02:36:32Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "Done.",
              "createdAt": "2023-03-13T02:36:31Z",
              "updatedAt": "2023-03-13T02:36:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5PwmJe",
          "commit": {
            "abbreviatedOid": "4ba234f"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T23:43:17Z",
          "updatedAt": "2023-03-13T23:45:19Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Is the '+' operator here a concatenation?  It might be better to make that explicit because I came away with the distinct impression that you were losing the upper bits of the value here.",
              "createdAt": "2023-03-13T23:43:17Z",
              "updatedAt": "2023-03-13T23:45:19Z"
            },
            {
              "originalPosition": 78,
              "body": "sigma is a function, not a variable, so perhaps you could frame it that way",
              "createdAt": "2023-03-13T23:43:56Z",
              "updatedAt": "2023-03-13T23:45:19Z"
            },
            {
              "originalPosition": 73,
              "body": "I don't see any tweaking going on here.",
              "createdAt": "2023-03-13T23:44:18Z",
              "updatedAt": "2023-03-13T23:45:19Z"
            },
            {
              "originalPosition": 55,
              "body": "Does this really need to use a hash function that barely anyone has?  I know that ... shiny... but this is a bit of a pain.",
              "createdAt": "2023-03-13T23:45:00Z",
              "updatedAt": "2023-03-13T23:45:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Pwo3J",
          "commit": {
            "abbreviatedOid": "4ba234f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T23:50:17Z",
          "updatedAt": "2023-03-13T23:50:18Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "* Yes, \"+\" means concatenation here. We can replace with \"concat()\" for clarity?\r\n* Actually, sigma is meant to be a variable (it is input to AES, then xored with the output).",
              "createdAt": "2023-03-13T23:50:17Z",
              "updatedAt": "2023-03-13T23:50:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5PwpBb",
          "commit": {
            "abbreviatedOid": "4ba234f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T23:50:43Z",
          "updatedAt": "2023-03-13T23:50:44Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "cc/ @schoppmp ",
              "createdAt": "2023-03-13T23:50:44Z",
              "updatedAt": "2023-03-13T23:50:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5PwqTt",
          "commit": {
            "abbreviatedOid": "4ba234f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T23:54:03Z",
          "updatedAt": "2023-03-13T23:54:03Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Do you mean SHA-3 or cSHAKE in particular?\r\n\r\nWe're using SHA-3 because we needed an XOF. We looked at using HKDF-SHA-256 as an alternative, but the performance was pretty bad. Plus, we have some cases where we need longer outputs than HKDF permits.\r\n\r\nWe're using cSHAKE for PrgSha3 as well. What's nice about it is that we get distinct notions of \"customization\" and \"binder\" strings. (See https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-05#section-6.2.3.) ",
              "createdAt": "2023-03-13T23:54:03Z",
              "updatedAt": "2023-03-13T23:54:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5PwqaI",
          "commit": {
            "abbreviatedOid": "4ba234f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T23:54:19Z",
          "updatedAt": "2023-03-13T23:54:19Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "FWIW, @simon-friedberger may be planning to implement this in NSS :)",
              "createdAt": "2023-03-13T23:54:19Z",
              "updatedAt": "2023-03-13T23:54:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5PwsEQ",
          "commit": {
            "abbreviatedOid": "4ba234f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T23:58:29Z",
          "updatedAt": "2023-03-13T23:58:29Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "We could use SHA-2 here if for example you waned PrgFixedKeyAes128 but not PrgSha3.",
              "createdAt": "2023-03-13T23:58:29Z",
              "updatedAt": "2023-03-13T23:58:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5PxFaW",
          "commit": {
            "abbreviatedOid": "4ba234f"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-14T01:14:45Z",
          "updatedAt": "2023-03-14T01:14:45Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "https://eprint.iacr.org/2019/074.pdf Section 7.3 (last paragraph, \"Instantiating $sigma$\") has it as a function.  That function needs to be a linear orthomorphism, as this is.  The value that is input to AES is the output of that function (which I guess you can call sigma too if you like).",
              "createdAt": "2023-03-14T01:14:45Z",
              "updatedAt": "2023-03-14T01:14:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5PxFkz",
          "commit": {
            "abbreviatedOid": "4ba234f"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-14T01:15:51Z",
          "updatedAt": "2023-03-14T01:15:51Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Simon already reached out about the nasty complexity that this produces for us.  I think that the current approach involves a bunch of non-NSS crypto, which is sort-of fine, but suboptimal.\r\n\r\nI realize that there are advantages to using the new stuff, but that doesn't make it less awkward.",
              "createdAt": "2023-03-14T01:15:51Z",
              "updatedAt": "2023-03-14T01:15:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5PxFvO",
          "commit": {
            "abbreviatedOid": "4ba234f"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-14T01:16:59Z",
          "updatedAt": "2023-03-14T01:17:00Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Oh, I should say, why are you concerned about the performance of something that you instantiate so few times during a protocol run?  We're using HKDF with SHA-256 in our prototypes of IPA and it's in the noise, even for tiny runs.",
              "createdAt": "2023-03-14T01:16:59Z",
              "updatedAt": "2023-03-14T01:17:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5PyuHx",
          "commit": {
            "abbreviatedOid": "4ba234f"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-14T08:21:40Z",
          "updatedAt": "2023-03-14T08:21:40Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Agreed, explicitly calling `concat` would be better here. We can call the variable `sigma_block` or so to emphasize that it is the function sigma evaluated on `block`?",
              "createdAt": "2023-03-14T08:21:40Z",
              "updatedAt": "2023-03-14T08:21:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Pyyyb",
          "commit": {
            "abbreviatedOid": "4ba234f"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-14T08:31:50Z",
          "updatedAt": "2023-03-14T08:31:50Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "If you look at Section 4.2 in https://eprint.iacr.org/2019/1168.pdf, the tweak i is passed as the key to the block cipher. So for a single client, the tweak stays the same, but it differs across clients.",
              "createdAt": "2023-03-14T08:31:50Z",
              "updatedAt": "2023-03-14T08:31:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Py1w0",
          "commit": {
            "abbreviatedOid": "4ba234f"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-14T08:39:28Z",
          "updatedAt": "2023-03-14T08:39:28Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "The reason I chose cSHAKE here was to be consistent with PrgSha3 and not require yet another hash function dependency. If this is creating problems for implementations, I don't have a problem with switching to HKDF-SHA-256, or even simply SHA-256/128. We just want the AES key to be random for each client and don't require anything else from the hash function.",
              "createdAt": "2023-03-14T08:39:28Z",
              "updatedAt": "2023-03-14T08:39:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Pzy-n",
          "commit": {
            "abbreviatedOid": "4ba234f"
          },
          "author": "simon-friedberger",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-14T10:45:33Z",
          "updatedAt": "2023-03-14T10:45:33Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "It's reasonable to rely on the same primitive here. If we ever allow more options for the PrgSha3 this should be updated as well but it's fine for now.",
              "createdAt": "2023-03-14T10:45:33Z",
              "updatedAt": "2023-03-14T10:45:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5P1yWc",
          "commit": {
            "abbreviatedOid": "4ba234f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-14T14:55:54Z",
          "updatedAt": "2023-03-14T14:55:55Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "@martinthomson the performance issue with HKDF comes up when we need an XOF, like we need in Prio3. (See https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/106#issuecomment-1397492095.) I agree the performance cost would be negligible, and I also think plain SHA-2 would be fine.",
              "createdAt": "2023-03-14T14:55:54Z",
              "updatedAt": "2023-03-14T14:55:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 194,
      "id": "PR_kwDOGKuqOc5LuH_Z",
      "title": "Prio3: Change order of seeds in random coins",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/194",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR rearranges the order in which Prio3 is defined to take seeds for various purposes from its random input string. This will change test vector output. This change is intended to simplify implementation in libprio-rs, see divviup/libprio-rs#499 for prior discussion. The key changes are that a) helper measurement shares and proof shares are interleaved, b) helper joint randomness blinds are also interleaved after other per-helper seeds, if present, (both to keep related seeds near each other) c) the leader joint randomness blind comes after all helper-related seeds (since it will naturally be used last, as its measurement share must be computed last), d) the proof randomness seed is taken from the last seed in the random input. (since it's used last)\r\n\r\nAs a nice side benefit, the variable `k_blinds` in the proof-of-concept implementation is split up, so array indexes now line up.",
      "createdAt": "2023-03-09T22:25:43Z",
      "updatedAt": "2023-05-01T17:02:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "1d5003afbaa5386c345976053dae3a698f9fee19",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/prio3-rearrange-coins",
      "headRefOid": "ba46b91f905bcedbd989d62f7134643f033b7f38",
      "closedAt": "2023-03-10T17:27:03Z",
      "mergedAt": "2023-03-10T17:27:03Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "71b88d6e238f3f91bb24b5d6efc110cc8d7310f0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5PgeL4",
          "commit": {
            "abbreviatedOid": "ba46b91"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Cool!",
          "createdAt": "2023-03-09T22:32:38Z",
          "updatedAt": "2023-03-09T22:32:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 195,
      "id": "PR_kwDOGKuqOc5Lyuqo",
      "title": "Update test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/195",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #190.\r\nBased on #193 (merge that first).\r\n\r\nRemove the test vectors for the previous version and re-generate them for the new version.",
      "createdAt": "2023-03-10T18:48:43Z",
      "updatedAt": "2023-04-24T21:35:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "87e691d7f40a6d70946c3243bd1e674c5ea99a0d",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-05/testvec",
      "headRefOid": "acca7ea0c2bbf227ce9d05df67e2fb1a06a85792",
      "closedAt": "2023-03-13T15:43:35Z",
      "mergedAt": "2023-03-13T15:43:35Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "ae567abc4a511f52c73ccd78aa4cb68eed260d44"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Work in progress: Still need to propagate the vectors to the draft itself.",
          "createdAt": "2023-03-10T18:49:18Z",
          "updatedAt": "2023-03-10T18:49:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased and verified the test vectors haven't changed.",
          "createdAt": "2023-03-13T15:23:09Z",
          "updatedAt": "2023-03-13T15:23:09Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5Ptogi",
          "commit": {
            "abbreviatedOid": "acca7ea"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-13T15:34:52Z",
          "updatedAt": "2023-03-13T15:34:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5Ptsnr",
          "commit": {
            "abbreviatedOid": "acca7ea"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-13T15:41:57Z",
          "updatedAt": "2023-03-13T15:41:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 196,
      "id": "PR_kwDOGKuqOc5L0G_-",
      "title": "Update change log",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/196",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #190.\r\nBased on #195 (merge that first)",
      "createdAt": "2023-03-11T04:46:45Z",
      "updatedAt": "2023-04-24T21:35:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "ae567abc4a511f52c73ccd78aa4cb68eed260d44",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-05/changelog",
      "headRefOid": "1a0b2fe3db71550a06449dfd8251d34c1ac8b4de",
      "closedAt": "2023-03-13T15:45:35Z",
      "mergedAt": "2023-03-13T15:45:35Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "116b53d5f33d94bf291e539a2524a4948627f49d"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased.",
          "createdAt": "2023-03-13T15:25:53Z",
          "updatedAt": "2023-03-13T15:25:53Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Squashed.",
          "createdAt": "2023-03-13T15:44:41Z",
          "updatedAt": "2023-03-13T15:44:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5PtkWl",
          "commit": {
            "abbreviatedOid": "3c83775"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-13T15:26:59Z",
          "updatedAt": "2023-03-13T15:27:30Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "nit: spelling\r\n```suggestion\r\n  improve performance of IDPF evaluation. Note that the new PRG is not suitable\r\n```",
              "createdAt": "2023-03-13T15:26:59Z",
              "updatedAt": "2023-03-13T15:27:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5PtoEb",
          "commit": {
            "abbreviatedOid": "3c83775"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T15:33:59Z",
          "updatedAt": "2023-03-13T15:34:00Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "\ud83d\udc4d ",
              "createdAt": "2023-03-13T15:34:00Z",
              "updatedAt": "2023-03-13T15:34:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Ptorg",
          "commit": {
            "abbreviatedOid": "79861c4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-13T15:35:09Z",
          "updatedAt": "2023-03-13T15:35:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 197,
      "id": "PR_kwDOGKuqOc5L6EEF",
      "title": "Run spellcheck",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/197",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #196.",
      "createdAt": "2023-03-13T15:32:52Z",
      "updatedAt": "2023-04-24T21:35:58Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "116b53d5f33d94bf291e539a2524a4948627f49d",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-05/spellcheck",
      "headRefOid": "ee2ebd5df71145c6364eb217af83bb08475523b1",
      "closedAt": "2023-03-13T15:48:30Z",
      "mergedAt": "2023-03-13T15:48:30Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "936b2471f21609e996103b621283b25953abbf0a"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased.",
          "createdAt": "2023-03-13T15:47:38Z",
          "updatedAt": "2023-03-13T15:47:38Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5Ptnz2",
          "commit": {
            "abbreviatedOid": "6069fe8"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-13T15:33:31Z",
          "updatedAt": "2023-03-13T15:33:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 198,
      "id": "PR_kwDOGKuqOc5L6KZx",
      "title": "Fix a typo",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/198",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a small editorial fix",
      "createdAt": "2023-03-13T15:49:20Z",
      "updatedAt": "2023-03-13T15:52:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "936b2471f21609e996103b621283b25953abbf0a",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/fix-ipdf-typo",
      "headRefOid": "000710d84a236725cbacfd128ba5df6a4c605575",
      "closedAt": "2023-03-13T15:52:34Z",
      "mergedAt": "2023-03-13T15:52:34Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "410b639b37f8443f66f2f854f6bca0d0a1b1eeaa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5PtytX",
          "commit": {
            "abbreviatedOid": "000710d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-13T15:52:28Z",
          "updatedAt": "2023-03-13T15:52:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 199,
      "id": "PR_kwDOGKuqOc5MA9gW",
      "title": "Include binder in IDPF test vector",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/199",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds the binder input to the IDPF test vector, since it's now an input to the key generation function.",
      "createdAt": "2023-03-14T16:01:40Z",
      "updatedAt": "2023-03-14T17:13:58Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "410b639b37f8443f66f2f854f6bca0d0a1b1eeaa",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/idpf-test-vec-binder",
      "headRefOid": "888a0131c9f6a85bcae844c981ce8fc968b2cfef",
      "closedAt": "2023-03-14T17:13:51Z",
      "mergedAt": "2023-03-14T17:13:50Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "35bab299bfe4298624842d3723cd88db2636e560"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5P29Xe",
          "commit": {
            "abbreviatedOid": "888a013"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-14T16:59:52Z",
          "updatedAt": "2023-03-14T16:59:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 201,
      "id": "PR_kwDOGKuqOc5MO1EB",
      "title": "Add a typo linting check to CI",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/201",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds a check for re-occurrence of a common typo.",
      "createdAt": "2023-03-16T16:44:16Z",
      "updatedAt": "2023-03-20T21:18:29Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "35bab299bfe4298624842d3723cd88db2636e560",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/typo-check-ci",
      "headRefOid": "8962db6e707079461b3737703cf57e3a487b8036",
      "closedAt": "2023-03-20T21:18:25Z",
      "mergedAt": "2023-03-20T21:18:25Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "86dfa09e7530490d4716a794c298fb8868c0b420"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't object, but I worry that this is going to clutter our CI very quickly as we discover additional \"common\" typos. One would suggestion is to check in a list of typos that we can update directly instead of updating github actions.",
          "createdAt": "2023-03-16T19:39:22Z",
          "updatedAt": "2023-03-16T19:44:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5QayEn",
          "commit": {
            "abbreviatedOid": "8962db6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-20T18:41:32Z",
          "updatedAt": "2023-03-20T18:41:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 202,
      "id": "PR_kwDOGKuqOc5MO5cH",
      "title": "Editorial changes for fixed-key AES",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/202",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #200.",
      "createdAt": "2023-03-16T16:56:35Z",
      "updatedAt": "2024-07-02T21:50:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "35bab299bfe4298624842d3723cd88db2636e560",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "schoppmp/fixed_key_aes_editorial",
      "headRefOid": "89b4b8c9d0425dde62211bce82c1a43189b61a91",
      "closedAt": "2023-03-16T16:59:34Z",
      "mergedAt": "2023-03-16T16:59:34Z",
      "mergedBy": "schoppmp",
      "mergeCommit": {
        "oid": "4578087adcc5705d2ee3938fdaa6397839b2da0b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5QIMdh",
          "commit": {
            "abbreviatedOid": "89b4b8c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-16T16:58:14Z",
          "updatedAt": "2023-03-16T16:58:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 203,
      "id": "PR_kwDOGKuqOc5MPiF7",
      "title": "Remove improper use of copy.deepcopy in flp.sage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/203",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a follow-up to #184, rewriting one test-only class factory class method. Closes #163.",
      "createdAt": "2023-03-16T18:58:37Z",
      "updatedAt": "2023-05-01T17:02:47Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "4578087adcc5705d2ee3938fdaa6397839b2da0b",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/remove-flp-deepcopy",
      "headRefOid": "3e6474e6679c3fd7b43c60d52ff36ff97ec6838a",
      "closedAt": "2023-03-16T19:42:07Z",
      "mergedAt": "2023-03-16T19:42:07Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "f58debffd8cc9a4647771046e55ce0af858d779b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5QJMqL",
          "commit": {
            "abbreviatedOid": "3e6474e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-16T19:38:08Z",
          "updatedAt": "2023-03-16T19:38:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 205,
      "id": "PR_kwDOGKuqOc5MU6rU",
      "title": "Convert common.sage to Python",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/205",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This converts `common.sage` to Python, as a first incremental step towards #204. This required two `^` changes, and then adjustments to import statements in other files.",
      "createdAt": "2023-03-17T17:42:22Z",
      "updatedAt": "2023-03-21T19:32:43Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "f58debffd8cc9a4647771046e55ce0af858d779b",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/python-conversion-common",
      "headRefOid": "ef1bdb36edb655535e9d3adb37bc0dce3cbbf881",
      "closedAt": "2023-03-21T19:31:02Z",
      "mergedAt": "2023-03-21T19:31:01Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "ee4562a26c707df03232e0b5708c8b1e0a3576cf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5QihLf",
          "commit": {
            "abbreviatedOid": "ef1bdb3"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Let's do it!",
          "createdAt": "2023-03-21T19:12:21Z",
          "updatedAt": "2023-03-21T19:12:30Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "FWIW I started moving each imported thing onto its own light, in order to more easily maintain alphabetical order:\r\n```python\r\nfrom common import \\\r\n     TEST_VECTOR \\\r\n     VERSION \\\r\n...\r\n```",
              "createdAt": "2023-03-21T19:12:21Z",
              "updatedAt": "2023-03-21T19:12:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5QijRh",
          "commit": {
            "abbreviatedOid": "ef1bdb3"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-21T19:18:08Z",
          "updatedAt": "2023-03-21T19:18:08Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "~~I think I'll just run `isort` on this. It'll use parentheses instead of backslash escaping newlines, FWIW.~~\n\nOh right, these imports are still in sage files for now",
              "createdAt": "2023-03-21T19:18:08Z",
              "updatedAt": "2023-03-21T19:20:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Qinuu",
          "commit": {
            "abbreviatedOid": "ef1bdb3"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-21T19:30:45Z",
          "updatedAt": "2023-03-21T19:30:46Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I think I'm going to leave the import statements as-is for now. In the future, maybe we could add `autopep8` and `isort` to a Makefile target, and automate this formatting.",
              "createdAt": "2023-03-21T19:30:45Z",
              "updatedAt": "2023-03-21T19:30:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Qioqq",
          "commit": {
            "abbreviatedOid": "ef1bdb3"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-21T19:32:42Z",
          "updatedAt": "2023-03-21T19:32:43Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Sounds like  plan to me.",
              "createdAt": "2023-03-21T19:32:42Z",
              "updatedAt": "2023-03-21T19:32:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 206,
      "id": "PR_kwDOGKuqOc5MgCFM",
      "title": "editorial: Fix up sections in Security Considerations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/206",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* Make the stuff about the IDPF prefix tree leakage a subsection of the aggregation parameter section\r\n\r\n* Capitalize \"Random Oracle\" in the section title",
      "createdAt": "2023-03-21T00:16:49Z",
      "updatedAt": "2023-04-24T21:35:57Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "86dfa09e7530490d4716a794c298fb8868c0b420",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/edit",
      "headRefOid": "e834bdc75474ea745db988567ae94bede22b4bcf",
      "closedAt": "2023-03-21T18:58:42Z",
      "mergedAt": "2023-03-21T18:58:42Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "5b35f4da0b8788a12442d83a487e110d1b226e35"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5QiCYv",
          "commit": {
            "abbreviatedOid": "e834bdc"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-21T17:53:59Z",
          "updatedAt": "2023-03-21T17:53:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 207,
      "id": "PR_kwDOGKuqOc5MkN9u",
      "title": "Delete obsolete TODO about fixed key AES PRG",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/207",
      "state": "MERGED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Issue #32 has been resolved so this TODO can be deleted.",
      "createdAt": "2023-03-21T16:25:28Z",
      "updatedAt": "2023-03-21T16:27:24Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "86dfa09e7530490d4716a794c298fb8868c0b420",
      "headRepository": "tgeoghegan/vdaf",
      "headRefName": "timg/obsolete-todo-fixed-key-aes",
      "headRefOid": "0598e4aa1742affcb63ec8fa3a0fcb32cfad47e8",
      "closedAt": "2023-03-21T16:27:24Z",
      "mergedAt": "2023-03-21T16:27:24Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "2e4214aef80509bfaeaf6c4f4db518618b704882"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5QhV3U",
          "commit": {
            "abbreviatedOid": "0598e4a"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-21T16:26:43Z",
          "updatedAt": "2023-03-21T16:26:43Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5QhWKJ",
          "commit": {
            "abbreviatedOid": "0598e4a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-21T16:27:18Z",
          "updatedAt": "2023-03-21T16:27:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 208,
      "id": "PR_kwDOGKuqOc5Ml3Sq",
      "title": "Run Sage tests in CI",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/208",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This installs Sage and runs the test suite. See discussion on #204.",
      "createdAt": "2023-03-21T22:30:02Z",
      "updatedAt": "2023-03-22T21:54:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "ee4562a26c707df03232e0b5708c8b1e0a3576cf",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/ci-run-tests",
      "headRefOid": "4b7c33113b79130d201ce75819b26c116a55db41",
      "closedAt": "2023-03-22T21:54:41Z",
      "mergedAt": "2023-03-22T21:54:40Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "ebfdf86f20875075fbeaa89d228754e084fad17d"
      },
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "This is repeatably failing with a 404 when fetching one package, but I can't reproduce the 404 locally. I may try again tomorrow in case this is a package caching issue.\r\n\r\n(I didn't go with Docker initially because `sagemath/sagemath:9.6` doesn't include GNU make in its image)",
          "createdAt": "2023-03-21T22:38:29Z",
          "updatedAt": "2023-03-21T22:38:29Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "The Ubuntu images don't have Homebrew installed, and I decided against using macOS runners because the VMs are more scarce.\r\n\r\nI got past the 404 by doing `apt-get update`, presumably an older version of a package got purged from the internal-facing CDN faster than the external-facing one.\r\n\r\nI ran into an issue with PyCryptodome's fallback usage of ctypes, which I got around by installing cffi. Upon reflection, I was probably passing `Integer(8)` to `ctypes.create_string_buffer()`, and not `8`, but this works for now.",
          "createdAt": "2023-03-22T15:52:37Z",
          "updatedAt": "2023-03-22T15:52:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Take a look at what @dconnolly set up for FROST: https://github.com/cfrg/draft-irtf-cfrg-frost/blob/master/.github/workflows/poc.yml",
          "createdAt": "2023-03-22T16:53:51Z",
          "updatedAt": "2023-03-22T16:53:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5Qp8pa",
          "commit": {
            "abbreviatedOid": "ebd3dde"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-03-22T17:47:35Z",
          "updatedAt": "2023-03-22T17:47:47Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n    name: \"Run unit tests for reference code\"\r\n```",
              "createdAt": "2023-03-22T17:47:35Z",
              "updatedAt": "2023-03-22T17:47:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5QqBo6",
          "commit": {
            "abbreviatedOid": "4b7c331"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-22T18:00:19Z",
          "updatedAt": "2023-03-22T18:00:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 210,
      "id": "PR_kwDOGKuqOc5Mrzo4",
      "title": "poc: Change superclass of Error to Exception",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/210",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This changes the superclass of `Error` to be `Exception` instead of `BaseException`. The [exception documentation](https://docs.python.org/3/library/exceptions.html) says that new exception types should typically do so. Inheriting directly from `BaseException` is reserved for special things like `GeneratorExit`, `KeyboardInterrupt`, `SystemExit`, etc.",
      "createdAt": "2023-03-22T22:05:05Z",
      "updatedAt": "2023-03-23T15:28:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "ebfdf86f20875075fbeaa89d228754e084fad17d",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/error-no-baseexception",
      "headRefOid": "80f21b4a15ada3890796f30a76921c8b5830f6d6",
      "closedAt": "2023-03-23T15:28:16Z",
      "mergedAt": "2023-03-23T15:28:16Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "d25c1e79b65e9123a52de85ae3574af7267e9461"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5QwRux",
          "commit": {
            "abbreviatedOid": "80f21b4"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "At some point we should consider revisiting error handling: as it is, it's not very helpful with actually debugging. However this would impact the spec, so perhaps best to raise an issue  if we want to work on this.",
          "createdAt": "2023-03-23T14:58:31Z",
          "updatedAt": "2023-03-23T14:58:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 211,
      "id": "PR_kwDOGKuqOc5Mr3Lt",
      "title": "Use bytes.join in common.py",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/211",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This replaces some concatenations using `+` with `bytes.join`. This'll be a bit more efficient, because it creates fewer temporary objects.",
      "createdAt": "2023-03-22T22:20:12Z",
      "updatedAt": "2023-05-01T17:03:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "ebfdf86f20875075fbeaa89d228754e084fad17d",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/use-bytes-join",
      "headRefOid": "473c780b16d598d16617e42755557be5faa10b8f",
      "closedAt": "2023-03-23T15:37:51Z",
      "mergedAt": "2023-03-23T15:37:51Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "a960126ba9d4ef05a2c564ad48f61052b8cee9af"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5QwSgb",
          "commit": {
            "abbreviatedOid": "2ec6ce7"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-03-23T14:59:57Z",
          "updatedAt": "2023-03-23T15:00:01Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "* We have been using single quotes for strings rather than double quotes.\r\n* Can we use concat() here instead?\r\n* This needs to be propagated to spec.",
              "createdAt": "2023-03-23T14:59:57Z",
              "updatedAt": "2023-03-23T15:00:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5QwmC-",
          "commit": {
            "abbreviatedOid": "473c780"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-23T15:36:35Z",
          "updatedAt": "2023-03-23T15:36:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 212,
      "id": "PR_kwDOGKuqOc5Mr7rL",
      "title": "Simplify print_wrapped_line()",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/212",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This simplifies `print_wrapped_line()`: we don't need to use `min()` because string slicing in Python automatically truncates.",
      "createdAt": "2023-03-22T22:38:21Z",
      "updatedAt": "2023-03-23T15:28:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "ebfdf86f20875075fbeaa89d228754e084fad17d",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/simplify-print_wrapped_line",
      "headRefOid": "2e136d938a93db591c4ecf1aed71a5478d2c6e23",
      "closedAt": "2023-03-23T15:28:45Z",
      "mergedAt": "2023-03-23T15:28:45Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "1bd2d7fcbf5300b859425c94a3f5dbe379a836ca"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5QwS78",
          "commit": {
            "abbreviatedOid": "2e136d9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-23T15:00:42Z",
          "updatedAt": "2023-03-23T15:00:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 213,
      "id": "PR_kwDOGKuqOc5Mr_k_",
      "title": "common.py: Move comments to docstrings",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/213",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This moves comments describing methods into docstrings, so they'll appear in IDEs, etc.",
      "createdAt": "2023-03-22T23:03:23Z",
      "updatedAt": "2023-03-24T19:54:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "a960126ba9d4ef05a2c564ad48f61052b8cee9af",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/common-doc-strings",
      "headRefOid": "60d2f23830999dc68d67d8316294bfa861b963bd",
      "closedAt": "2023-03-24T19:54:08Z",
      "mergedAt": "2023-03-24T19:54:08Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "4bd49d6345a67552a8e6c3ad76d41167d5e7b335"
      },
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "FWIW, some external references regarding quotes: [PEP 257](https://peps.python.org/pep-0257/#what-is-a-docstring) recommends triple double quotes for docstrings. (though any string literal would work, syntactically) The opinionated [Black formatter](https://black.readthedocs.io/en/stable/the_black_code_style/current_style.html#strings) prefers double-quoted string literals everywhere unless a single-quoted literal would need less escapes.",
          "createdAt": "2023-03-24T19:47:03Z",
          "updatedAt": "2023-03-24T19:47:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5Qwr6a",
          "commit": {
            "abbreviatedOid": "9f9872d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I would like to be consistent about double quotes versus single quotes. Double quotes for docucomments seem fine, let's just use them consistently.",
          "createdAt": "2023-03-23T15:47:47Z",
          "updatedAt": "2023-03-23T15:47:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 214,
      "id": "PR_kwDOGKuqOc5NRbY9",
      "title": "Move comments to docstrings",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/214",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This moves comments before classes/functions/methods to docstrings in all Sage files. I also did the same in the document, where the existing extracts already included such comments.",
      "createdAt": "2023-03-30T15:05:19Z",
      "updatedAt": "2023-04-04T17:55:00Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "4bd49d6345a67552a8e6c3ad76d41167d5e7b335",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/docstrings",
      "headRefOid": "52dd1b0b41d4e401cd758bdd3ee03d88cf53d975",
      "closedAt": "2023-04-04T17:54:47Z",
      "mergedAt": "2023-04-04T17:54:47Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "d192c43ebb92759a16f8cd308d4b16fe284af6a4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5RYZmD",
          "commit": {
            "abbreviatedOid": "52dd1b0"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Reviewer notes:",
          "createdAt": "2023-03-30T15:06:23Z",
          "updatedAt": "2023-03-30T15:15:33Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This function is not used anywhere, and no longer appears in the proof of concept implementation, so I deleted it rather than update it.",
              "createdAt": "2023-03-30T15:06:24Z",
              "updatedAt": "2023-03-30T15:15:33Z"
            },
            {
              "originalPosition": 111,
              "body": "This second paragraph is copied from the corresponding comment in the Markdown file.",
              "createdAt": "2023-03-30T15:07:07Z",
              "updatedAt": "2023-03-30T15:15:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5RbCPc",
          "commit": {
            "abbreviatedOid": "52dd1b0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-30T22:53:34Z",
          "updatedAt": "2023-03-30T22:54:59Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Consistency: Do we prefer a blankline after docucomment or not?",
              "createdAt": "2023-03-30T22:53:34Z",
              "updatedAt": "2023-03-30T22:54:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5RbFO1",
          "commit": {
            "abbreviatedOid": "52dd1b0"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-30T23:11:25Z",
          "updatedAt": "2023-03-30T23:11:25Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "I'm not aware of a norm regarding this, I looked around in the `requests` codebase as an example and saw a combination. I tried to include a blank line when it helped with clarity, such as when a line comment immediately followed, or the function was big enough that it already had some blank lines. I think this gets treated as a special case of blank lines within a function/method body (as the docstring is technically a statement containing a string literal expression) and left up to the author's discretion.",
              "createdAt": "2023-03-30T23:11:25Z",
              "updatedAt": "2023-03-30T23:11:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 221,
      "id": "PR_kwDOGKuqOc5OXjmk",
      "title": "Convert daf and vdaf modules to python",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/221",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is part of #204. These two modules are mostly abstract base classes, so this conversion was straightforward.",
      "createdAt": "2023-04-14T22:43:54Z",
      "updatedAt": "2023-04-14T23:36:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d192c43ebb92759a16f8cd308d4b16fe284af6a4",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/daf-vdaf-python-conversion",
      "headRefOid": "f91c05621e450cf6d50464a6c81186fe824ab750",
      "closedAt": "2023-04-14T23:36:46Z",
      "mergedAt": "2023-04-14T23:36:46Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "186618ef8b7c63077380923a901aa4a2e3b10ff5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5SoKIm",
          "commit": {
            "abbreviatedOid": "f91c056"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-14T23:27:28Z",
          "updatedAt": "2023-04-14T23:27:39Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "nit nit nit: In `common.py` you'll see we're overriding native types with capitalized versions, e.g., `Bool` instead of `bool`. If we wanted to be consistent we would do the same for `tuple`.\r\n\r\nHere's my question to you: Is this a terrible idea? Visually it's nice to be able to distinguish types from variables using camel and snake case respectively. However, arguably we should just be following Python's lead here and using lower case for primitive types.\r\n\r\nWDYT:\r\n1. `tuple` -> `Tuple` for consistency; or\r\n2. leave as is and file an issue to use native type names (i.e., `bool` instead of `Bool`)?\r\n\r\nI'm leaning towards 2.",
              "createdAt": "2023-04-14T23:27:28Z",
              "updatedAt": "2023-04-14T23:27:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5SoKbw",
          "commit": {
            "abbreviatedOid": "f91c056"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-14T23:31:36Z",
          "updatedAt": "2023-04-14T23:31:37Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Same, I'd prefer to drop the aliases.",
              "createdAt": "2023-04-14T23:31:36Z",
              "updatedAt": "2023-04-14T23:31:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 228,
      "id": "PR_kwDOGKuqOc5PDRNq",
      "title": "Apply some minor editorial suggestions from @chris-wood",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/228",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-04-24T23:04:21Z",
      "updatedAt": "2024-05-01T20:18:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "186618ef8b7c63077380923a901aa4a2e3b10ff5",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/review/05/caw/edit",
      "headRefOid": "edcc04c7b16ed1203b2480da3dfbad7782bcb589",
      "closedAt": "2023-04-25T16:26:27Z",
      "mergedAt": "2023-04-25T16:26:27Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "da8ff98aefc31d369403cf887cdf4f057179709d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5TYg8C",
          "commit": {
            "abbreviatedOid": "2704f7d"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-24T23:26:57Z",
          "updatedAt": "2023-04-24T23:36:14Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "nit: two commas around this clause\r\n```suggestion\r\nIn addition to these MPC-style security goals, privacy and robustness, VDAFs can\r\n```",
              "createdAt": "2023-04-24T23:26:57Z",
              "updatedAt": "2023-04-24T23:36:14Z"
            },
            {
              "originalPosition": 351,
              "body": "We should replicate these changes in the `poc` directory so we don't accidentally undo them by copying in the other direction later.",
              "createdAt": "2023-04-24T23:36:08Z",
              "updatedAt": "2023-04-24T23:36:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Tb0Zl",
          "commit": {
            "abbreviatedOid": "2704f7d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-25T12:24:50Z",
          "updatedAt": "2023-04-25T12:25:54Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Do you mean \"the MPC-style goals are privacy and robustness\" or \"In addition to (MPC, privacy, robustness)\"? In the former case I would suggest using parens or dashes.  I don't think there's a clear solution using commas; you get Oxford comma ambiguity.  In the latter case, you should use an Oxford comma.\r\n\r\n![image](https://user-images.githubusercontent.com/75597/234275182-7c6e6152-1b2d-40f8-bbb5-ea4af80ab05b.png)\r\n",
              "createdAt": "2023-04-25T12:24:50Z",
              "updatedAt": "2023-04-25T12:25:54Z"
            },
            {
              "originalPosition": 74,
              "body": "At some point, it would be nice to clean up the ragged right edge here.",
              "createdAt": "2023-04-25T12:25:27Z",
              "updatedAt": "2023-04-25T12:25:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 229,
      "id": "PR_kwDOGKuqOc5PanfZ",
      "title": "Capitalize client consistently",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/229",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This capitalizes \"Client\" in various places, closing #218. I left the abstract and introduction as-is, because the protocol participants haven't been introduced and defined yet, and much of the introduction is talking about previous work anyhow.",
      "createdAt": "2023-04-28T20:42:23Z",
      "updatedAt": "2023-05-01T21:46:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "da8ff98aefc31d369403cf887cdf4f057179709d",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/capitalize-client",
      "headRefOid": "5fe16870b0d6dc00a1e5ef0bcc3a66a86e240797",
      "closedAt": "2023-05-01T21:46:08Z",
      "mergedAt": "2023-05-01T21:46:08Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "dfe9ce69582d006755acd9caa2f72c67fb61d356"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5T1wXI",
          "commit": {
            "abbreviatedOid": "5fe1687"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-28T21:02:05Z",
          "updatedAt": "2023-04-28T21:02:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 230,
      "id": "PR_kwDOGKuqOc5Pap_l",
      "title": "Specify RAND_SIZE for each algorithm",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/230",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #225.",
      "createdAt": "2023-04-28T20:56:09Z",
      "updatedAt": "2023-05-01T17:58:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "da8ff98aefc31d369403cf887cdf4f057179709d",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/specify-rand-size",
      "headRefOid": "ae68f21243b14854267e851feec4004570e381f9",
      "closedAt": "2023-05-01T17:58:25Z",
      "mergedAt": "2023-05-01T17:58:24Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "51afa4a341ca0ce02acca07d22349ccbc14cb3d8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5T1wLb",
          "commit": {
            "abbreviatedOid": "930f74b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-28T21:01:17Z",
          "updatedAt": "2023-04-28T21:01:27Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "One caveat here is that this value of `RAND_SIZE` is larger than we need if no joint randomness is generated. I think this is fine, but depending on we resolve https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/215 we may be able to tighten this.",
              "createdAt": "2023-04-28T21:01:17Z",
              "updatedAt": "2023-04-28T21:01:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5T14dD",
          "commit": {
            "abbreviatedOid": "930f74b"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-28T21:45:01Z",
          "updatedAt": "2023-04-28T21:45:02Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Whoops, I missed that, the size may be too low. Requiring extra randomness might be a good way to clean things up for #215 though.",
              "createdAt": "2023-04-28T21:45:01Z",
              "updatedAt": "2023-04-28T21:45:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5T1-ou",
          "commit": {
            "abbreviatedOid": "ae68f21"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-28T22:22:26Z",
          "updatedAt": "2023-04-28T22:22:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 231,
      "id": "PR_kwDOGKuqOc5Pa9XS",
      "title": "Rename customization string to domain separation tag",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/231",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I also renamed the `DST_...` constants to `USAGE_...` for consistency. Closes #224.",
      "createdAt": "2023-04-28T22:26:37Z",
      "updatedAt": "2023-05-02T21:12:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "da8ff98aefc31d369403cf887cdf4f057179709d",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/dst",
      "headRefOid": "766c04d9a4e44f11539171953d172e107a5f0681",
      "closedAt": "2023-05-02T21:12:17Z",
      "mergedAt": "2023-05-02T21:12:17Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "0d7a3d2b91c740a559f26798fa22507028986f72"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5T2AQ-",
          "commit": {
            "abbreviatedOid": "766c04d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-28T22:31:24Z",
          "updatedAt": "2023-04-28T22:31:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 232,
      "id": "PR_kwDOGKuqOc5PbIJW",
      "title": "Split up inputs and proofs in run_flp()",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/232",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This improves `run_flp()` to actually split the input and proof into shares, query each, and reassemble the verifier before running the decision algorithm.\r\n\r\nFixes #227.",
      "createdAt": "2023-04-28T23:43:42Z",
      "updatedAt": "2023-05-01T20:49:29Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "da8ff98aefc31d369403cf887cdf4f057179709d",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/run-flp-secret-share",
      "headRefOid": "a5acb9bb4dacd9db9758b02937bc4e2fa8adf285",
      "closedAt": "2023-05-01T20:49:26Z",
      "mergedAt": "2023-05-01T20:49:26Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "b333d025ec1849f273db4cbbb0bc9172a9d20cc1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5T6NSV",
          "commit": {
            "abbreviatedOid": "2020160"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-05-01T15:56:31Z",
          "updatedAt": "2023-05-01T15:56:55Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "It's pretty self-explanatory what `linear_secret_share` does, but it's a good idea to at least define it somewhere in prose for completeness. One option is to stick in the list of functions in {{conventions-and-definitions}}. In particular we should define what we mean by \"linear\" and \"secret share\".",
              "createdAt": "2023-05-01T15:56:32Z",
              "updatedAt": "2023-05-01T15:56:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5T6awy",
          "commit": {
            "abbreviatedOid": "2020160"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-01T16:49:05Z",
          "updatedAt": "2023-05-01T16:49:06Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Sounds good. I think I should also be calling it \"additive secret sharing\", as it's more specific.",
              "createdAt": "2023-05-01T16:49:05Z",
              "updatedAt": "2023-05-01T16:49:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5T6bAg",
          "commit": {
            "abbreviatedOid": "2020160"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-01T16:50:10Z",
          "updatedAt": "2023-05-01T16:50:10Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Agreed. These are sometimes used interchangeably, but it's good for the standard to be specific.",
              "createdAt": "2023-05-01T16:50:10Z",
              "updatedAt": "2023-05-01T16:50:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5T6tNr",
          "commit": {
            "abbreviatedOid": "05e34e4"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-01T18:00:37Z",
          "updatedAt": "2023-05-01T18:00:46Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Hmm, this API is a bit odd, as we want input `vec` and the output to have time `field`, but the given type is `Field`. I wonder if we can think of a way to express this constraint better.\r\n\r\nWhat we have done elsewhere is pass in the type as a parameter without a type hint: https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/draft-irtf-cfrg-vdaf.md?plain=1#L1227-L1231\r\n\r\nI'm not sure if this is exactly what we want, but I think it provides slightly better signaling.\r\n\r\n",
              "createdAt": "2023-05-01T18:00:37Z",
              "updatedAt": "2023-05-01T18:00:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5T6wnN",
          "commit": {
            "abbreviatedOid": "05e34e4"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-01T18:13:34Z",
          "updatedAt": "2023-05-01T18:13:34Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I don't think we can express in Python that the type of an argument or return value is related to the value of a type object argument passed in to the function. That would require dependent types more powerful than what type hints can currently express. For example, the following passes `mypy`:\r\n\r\n```\r\nclass A:\r\n    pass\r\n\r\n\r\nclass B(A):\r\n    pass\r\n\r\n\r\ndef func(thetype: type, arg: A) -> A:\r\n    return arg\r\n\r\n\r\nfunc(B, B())\r\n```\r\n\r\nChanging the signature to `def func(thetype: type, arg: thetype) -> thetype` or `def func(thetype: type, arg: \"thetype\") -> \"thetype\"` results in an error, `error: Name \"thetype\" is not defined`.\r\n\r\nMoreover, in `encode_vec`, the argument `Field` is shadowing the class definition `Field`, so the type hint in the function parameter points to the class, while the `Field.ENCODED_SIZE` attribute access inside the function body points to the argument. We should get rid of variable name shadowing as a general matter.",
              "createdAt": "2023-05-01T18:13:34Z",
              "updatedAt": "2023-05-01T18:13:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5T67eL",
          "commit": {
            "abbreviatedOid": "05e34e4"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-01T18:56:53Z",
          "updatedAt": "2023-05-01T18:57:15Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n  and each proper subset of the vectors are indistinguishable from random.\r\n```",
              "createdAt": "2023-05-01T18:56:53Z",
              "updatedAt": "2023-05-01T18:57:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 234,
      "id": "PR_kwDOGKuqOc5PrpJg",
      "title": "Python conversion: flp.sage and idpf.sage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/234",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This converts two more files that are mostly abstract base classes. Part of #204.",
      "createdAt": "2023-05-03T14:47:02Z",
      "updatedAt": "2023-05-03T15:40:26Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "0d7a3d2b91c740a559f26798fa22507028986f72",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/python-conversion-base-classes",
      "headRefOid": "2b60f0331f0d517899f6fe9ad8abc466bcadb8c0",
      "closedAt": "2023-05-03T15:40:23Z",
      "mergedAt": "2023-05-03T15:40:22Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "fd6f4ea2708f1ecd07df48fd5246a8e08359807f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5UHK1q",
          "commit": {
            "abbreviatedOid": "b818335"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-03T15:29:55Z",
          "updatedAt": "2023-05-03T15:29:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 235,
      "id": "PR_kwDOGKuqOc5P3_3I",
      "title": "Change is_valid() argument from list to set",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/235",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This changes the second argument to `is_valid()` from a list of aggregation parameters to a set of aggregation parameters, closing #220. I also had to change Poplar1's aggregation parameter to use a tuple of prefixes, instead of a list, because lists are mutable, and therefore not hashable.",
      "createdAt": "2023-05-05T15:50:30Z",
      "updatedAt": "2023-05-08T18:55:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "fd6f4ea2708f1ecd07df48fd5246a8e08359807f",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/isvalid-aggparam-set",
      "headRefOid": "506f457326a7566f471b56a803be1a34dc014666",
      "closedAt": "2023-05-08T18:55:05Z",
      "mergedAt": "2023-05-08T18:55:05Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "5d5a0d75b3574ef2d8ab74344e452a2221c78236"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5UWSsg",
          "commit": {
            "abbreviatedOid": "506f457"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM.",
          "createdAt": "2023-05-05T16:52:13Z",
          "updatedAt": "2023-05-05T16:52:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 236,
      "id": "PR_kwDOGKuqOc5P4Jlo",
      "title": "Convert prg.sage to Python",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/236",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Part of #204. I replaced divisions that resulted in Sage rational numbers followed by `int()` casts with `__floordiv__` division. An int cast is needed when using `Field.ENCODED_SIZE`, as that's still a Sage integer for the time being, and some Pycryptodome methods using FFI calls are not tolerant of Sage integers.",
      "createdAt": "2023-05-05T16:26:48Z",
      "updatedAt": "2023-05-05T23:05:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "fd6f4ea2708f1ecd07df48fd5246a8e08359807f",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/prg-python",
      "headRefOid": "c36079e2f6825257fa39e877b58f00150deb98ef",
      "closedAt": "2023-05-05T23:05:48Z",
      "mergedAt": "2023-05-05T23:05:48Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "ee8a6f66e39ea7adf2eab959f949b733df54f670"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5UWSEP",
          "commit": {
            "abbreviatedOid": "c36079e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-05T16:50:06Z",
          "updatedAt": "2023-05-05T16:50:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 237,
      "id": "PR_kwDOGKuqOc5QAypy",
      "title": "Convert field.sage to Python",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/237",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Part of #204.",
      "createdAt": "2023-05-08T15:32:55Z",
      "updatedAt": "2024-07-02T21:38:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "ee8a6f66e39ea7adf2eab959f949b733df54f670",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/convert-field-python",
      "headRefOid": "6fb4e5e623885ef6e602ee3b800f870a51467c88",
      "closedAt": "2023-05-22T20:45:56Z",
      "mergedAt": "2023-05-22T20:45:56Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "690f59a6c2fe94a3b3647b190c2a5c5d1a8fc28f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5Vrj3S",
          "commit": {
            "abbreviatedOid": "fecd893"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-22T20:37:04Z",
          "updatedAt": "2023-05-22T20:37:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 238,
      "id": "PR_kwDOGKuqOc5QhbZn",
      "title": "poc: Use built in exceptions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/238",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Stacked on #237\r\n\r\nThis replaces some custom exceptions with more idiomatic built in exceptions.",
      "createdAt": "2023-05-15T14:44:05Z",
      "updatedAt": "2024-07-02T21:38:50Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "david/convert-field-python",
      "baseRefOid": "fecd893cb4c7cc461f1d1cebf144f439dda8b0f8",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/built-in-exceptions",
      "headRefOid": "2fa8d843425082a447f560d6139fb96328548e0b",
      "closedAt": "2023-05-22T20:38:11Z",
      "mergedAt": "2023-05-22T20:38:11Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "6fb4e5e623885ef6e602ee3b800f870a51467c88"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5VrkaO",
          "commit": {
            "abbreviatedOid": "2fa8d84"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-22T20:37:31Z",
          "updatedAt": "2023-05-22T20:37:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 240,
      "id": "PR_kwDOGKuqOc5RFWoT",
      "title": "Describe the ping-pong communication pattern used in DAP",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/240",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Defines three new API calls on `Vdaf` used to describe state transitions while preparing a report.\r\n\r\n1. `prep_start()` is a derived method that defines the initial state transition `START` -> `CONTINUED(host_prep_state)`\r\n\r\n2. `ping_pong_prep_next()` is a derived method that defines all subsequent state transitions `CONTINUED(host_prep_state)` -> `FINISHED(out_share)` in the \"ping pong\" flow being discussed for DAP-05 (https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/pull/393).\r\n\r\n3. `prep_size()` is a required method that indicates the size of the prep message for a given round. This is needed in order to coalesce prep shares and prep messages into the same, opaque byte string.\r\n\r\nThis allows us to expose the simplest possible interface to DAP.",
      "createdAt": "2023-05-23T00:22:05Z",
      "updatedAt": "2024-05-01T20:18:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "b3e4c28b5a51a5ecb1ce7b6b484fa8f703adf437",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/pingpong",
      "headRefOid": "3e580e6a80f028bc8e5dea7fe7e36ad14adda430",
      "closedAt": "2023-06-14T15:19:27Z",
      "mergedAt": "2023-06-14T15:19:27Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "d79ae4a2b7f0561ffa9784bc532353783c4a3dba"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@branlwyd PTAL to make sure this is correct. If so, then I think we'd remove the state machine from https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/pull/461, merge, then rewrite https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/pull/393 to use this new API.",
          "createdAt": "2023-05-23T00:26:48Z",
          "updatedAt": "2023-05-23T00:26:48Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I've updated this PR (https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/240/commits/2faf238312af61b95460ac99a9e96593b638f1ae) and harmonized the DAP change (https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/pull/393/commits/4fe9db2052249a0acf008844a15892f303664046) please take a look.",
          "createdAt": "2023-06-06T22:50:45Z",
          "updatedAt": "2023-06-06T22:50:45Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I like the usage of TLS syntax -- I was wary of suggesting it as I thought that to be too DAP-specific, but if you are happy with it then so am I.\r\n\r\n\r\nYeah I was wary of doing this as well, but I think here it solves the problem so let's just do it :)",
          "createdAt": "2023-06-08T20:50:03Z",
          "updatedAt": "2023-06-08T20:50:03Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased and squashed.",
          "createdAt": "2023-06-14T15:04:37Z",
          "updatedAt": "2023-06-14T15:04:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Nits from self-review.",
          "createdAt": "2023-06-14T15:18:28Z",
          "updatedAt": "2023-06-14T15:18:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5VtTvu",
          "commit": {
            "abbreviatedOid": "5ed710c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-23T00:24:31Z",
          "updatedAt": "2023-05-23T00:24:32Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Reviewer note: This obviously is not grammatically correct Python. Our goal thus far was to have all pseudocode in the draft be runnable, so we might consider how to do so neatly.",
              "createdAt": "2023-05-23T00:24:31Z",
              "updatedAt": "2023-05-23T04:15:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5VtVLu",
          "commit": {
            "abbreviatedOid": "a6482ff"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-23T00:32:53Z",
          "updatedAt": "2023-05-23T00:34:27Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "@branlwyd note that we're coalescing the previous prep message with the next prep share here. This is a change from https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/pull/461.",
              "createdAt": "2023-05-23T00:32:53Z",
              "updatedAt": "2023-05-23T00:34:27Z"
            },
            {
              "originalPosition": 117,
              "body": "@branlwyd to ensure that the round number is computed properly I believe we need increment the counter here. Please double check my math here. (This is a change from https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/pull/461.)",
              "createdAt": "2023-05-23T00:34:23Z",
              "updatedAt": "2023-05-23T00:34:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5V2cUl",
          "commit": {
            "abbreviatedOid": "a6482ff"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-23T18:27:29Z",
          "updatedAt": "2023-05-23T22:45:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n  deterministic function that indicates the size (in bytes) of the preparation\r\n```",
              "createdAt": "2023-05-23T18:27:29Z",
              "updatedAt": "2023-05-23T22:45:29Z"
            },
            {
              "originalPosition": 55,
              "body": "This is only applicable if SHARES is 2, which suggests it should be moved into the next section.",
              "createdAt": "2023-05-23T19:09:24Z",
              "updatedAt": "2023-05-23T22:45:29Z"
            },
            {
              "originalPosition": 61,
              "body": "It appears that `prep_start` is a near-transparent wrapper of `prep_init`, with the addition of this state transition annotation, and one before the method definition. Given that `Vdaf` is stateless throughout the rest of the pseudocode, it might make more sense to pass in a 'state' as an argument, and return another out, to hopefully make it clearer what's going on. (or, define some other class to represent the state, and turn the state machine transition procedures into methods on that class)",
              "createdAt": "2023-05-23T19:11:25Z",
              "updatedAt": "2023-05-23T22:45:29Z"
            },
            {
              "originalPosition": 87,
              "body": "nit: typo\r\n```suggestion\r\n* For a 2-round VDAF (e.g., Poplar1 ({{poplar1}})), the Leader sends its\r\n```",
              "createdAt": "2023-05-23T22:14:23Z",
              "updatedAt": "2023-05-23T22:45:29Z"
            },
            {
              "originalPosition": 170,
              "body": "This should probably be reworded, \"to initialize preparation\" seems to be counter to already being in the state CONTINUED. If anything is initializing preparation, it seems like it ought to be `prep_start`. Maybe, \"At the start of a request/response cycle, ...\"?",
              "createdAt": "2023-05-23T22:37:43Z",
              "updatedAt": "2023-05-23T22:45:29Z"
            },
            {
              "originalPosition": 172,
              "body": "Shouldn't the outbound type be known based on the number of rounds and the current round? This sentence seems to hedge enough that we could probably delete it.",
              "createdAt": "2023-05-23T22:40:04Z",
              "updatedAt": "2023-05-23T22:45:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5V14jS",
          "commit": {
            "abbreviatedOid": "a6482ff"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-05-23T16:48:26Z",
          "updatedAt": "2023-05-23T22:57:56Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "```suggestion\r\n* For a 2-round VDAF (e.g., Poplar1 ({{poplar1}})), the Leader sends its\r\n```",
              "createdAt": "2023-05-23T16:48:26Z",
              "updatedAt": "2023-05-23T22:57:57Z"
            },
            {
              "originalPosition": 116,
              "body": "style nit: if we're writing pseudocode, I would understand an enumerated type which holds a (typed) tuple of the necessary messages better than string slicing to express this idea. (e.g. instead of returning `(\"continue\", host_prep_share)` we'd return something like `Continue(host_prep_share)`, and pull the required values out of the enumerated value here). [other than being clearer, I think this would let us remove the `prep_size` function from the `Vdaf` interface, and I suppose let us off the hook from needing to precisely calculate the size of a preparation message]",
              "createdAt": "2023-05-23T16:56:27Z",
              "updatedAt": "2023-05-23T22:57:57Z"
            },
            {
              "originalPosition": 117,
              "body": "Thinking to a large-round VDAF, this round-counting scheme tracks a consistent sequence of rounds between the Leader & Helper; specifically 1\u21923\u21925\u2192...\r\n\r\nBut I think this line should be dropped, so that \"continue\" messages only increment the round counter once, and the Leader & Helper compute the round sequence 1\u21922\u21923\u2192...\r\n\r\nThe reason I think this is a good change is that the purpose of the round-counter is to track progress/allow for retries at the level of the VDAF-evaluation protocol (e.g. DAP). If the sequence of rounds is 1\u21923\u21925\u2192..., then the higher-level protocol has a failure mode if an attempt is made to retry/advance to an even-numbered round; this failure mode does not exist if the round sequence is 1\u21922\u21923\u2192...\r\n\r\n(I'm not sure we need to include round counting at all in these functions. I'd be happy if these functions defined the sequence of VDAF calls, and left the definition of any retry mechanisms up to the VDAF-evaluation protocol. ISTM that a hypothetical DAP-competitor protocol might define a different retry mechanism, at which point this round-counting is vestigal. Also, these functions are defining a round counter for each report, while even DAP tracks round at the level of an aggregation job, i.e. across many reports.)",
              "createdAt": "2023-05-23T22:57:27Z",
              "updatedAt": "2023-05-23T22:57:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5V30ou",
          "commit": {
            "abbreviatedOid": "75a992f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-23T23:22:04Z",
          "updatedAt": "2023-05-23T23:23:08Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "Right, my goal here was to have `round_num` match the VDAF round, not the ping-pong round. If we go with your suggestion then we'd need to change\r\n```python\r\nif round_num == Vdaf.ROUNDS:\r\n```\r\nto\r\n```python\r\nif round_num = ceil((Vdaf.ROUNDS+1)/2):\r\n```\r\nDoes that sound right?",
              "createdAt": "2023-05-23T23:22:05Z",
              "updatedAt": "2023-05-23T23:23:08Z"
            },
            {
              "originalPosition": 116,
              "body": "This is tricky because we're trying to get as close to runnable code as possible. But your suggestion here matches @divergentdave's suggestion above pretty well, so let me see if I can finesse this.",
              "createdAt": "2023-05-23T23:23:03Z",
              "updatedAt": "2023-05-23T23:23:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5V33DY",
          "commit": {
            "abbreviatedOid": "a6482ff"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-23T23:27:28Z",
          "updatedAt": "2023-05-23T23:27:29Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Sorry, I'm not sure I understand this comment.",
              "createdAt": "2023-05-23T23:27:28Z",
              "updatedAt": "2023-05-23T23:27:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5V39gR",
          "commit": {
            "abbreviatedOid": "a6482ff"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-23T23:41:56Z",
          "updatedAt": "2023-05-23T23:41:56Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Since prep_start can only pass an aggregator ID of 0 or 1 to prep_init, it should go under \"Ping-Pong Topology (Only Two Aggregators)\", rather than this more generic section.",
              "createdAt": "2023-05-23T23:41:56Z",
              "updatedAt": "2023-05-23T23:41:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5V3_tP",
          "commit": {
            "abbreviatedOid": "a6482ff"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-23T23:47:20Z",
          "updatedAt": "2023-05-23T23:47:21Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Ohhhhh good call!",
              "createdAt": "2023-05-23T23:47:20Z",
              "updatedAt": "2023-05-23T23:47:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5V4BEr",
          "commit": {
            "abbreviatedOid": "a6482ff"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-23T23:55:45Z",
          "updatedAt": "2023-05-23T23:55:45Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "Done. Changed to \"At the start of the **first** request/response cycle...\"",
              "createdAt": "2023-05-23T23:55:45Z",
              "updatedAt": "2023-05-23T23:55:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5V4BPQ",
          "commit": {
            "abbreviatedOid": "a6482ff"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-23T23:56:44Z",
          "updatedAt": "2023-05-23T23:56:44Z",
          "comments": [
            {
              "originalPosition": 172,
              "body": "Following @branlwyd's suggestion I just dropped the inbound/outbound type indication and simplified the text here.",
              "createdAt": "2023-05-23T23:56:44Z",
              "updatedAt": "2023-05-23T23:56:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5V4AxT",
          "commit": {
            "abbreviatedOid": "52671b8"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-23T23:53:40Z",
          "updatedAt": "2023-05-23T23:57:16Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "If the goal of `round_num` is solely to track the VDAF round rather than for use in retry for the evaluation protocol, why not drop round counting entirely and base the is-this-the-last-round decision on what type of value is returned from `Vdaf.prep_next`?\r\n\r\nWe are already assuming that we'll get `(state, prep_share)` for all but the last call to `prep_next` and `(out_share)` for the last call to `prep_next`; indeed, `Vdaf.prep_next` is defined to work this way (in [section 5.2](https://cfrg.github.io/draft-irtf-cfrg-vdaf/draft-irtf-cfrg-vdaf.html#name-preparation-2)). I don't see how tracking an explicit round counter is necessary.",
              "createdAt": "2023-05-23T23:53:41Z",
              "updatedAt": "2023-05-23T23:57:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5V4CZK",
          "commit": {
            "abbreviatedOid": "a6482ff"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T00:04:55Z",
          "updatedAt": "2023-05-24T00:04:56Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "Ahhh you're right! What would be useful for DAP would be the \"request number\" instead of the round number. I started working on this change but found a problem: We now have a callback on `Vdaf` for getting the size of the prep message (`Vdaf.prep_size()`) and unfortunately this needs the round number as input.",
              "createdAt": "2023-05-24T00:04:55Z",
              "updatedAt": "2023-05-24T00:04:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5V4Ckx",
          "commit": {
            "abbreviatedOid": "a6482ff"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T00:06:08Z",
          "updatedAt": "2023-05-24T00:06:09Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "One way around this would be to length-prefix the prep message in the coalesced `Continue` message type so that we can parse the two. It sort of breaks with the design pattern we've been following for VDAF but I'd be fine with this if you think tracking the request number would be useful.",
              "createdAt": "2023-05-24T00:06:08Z",
              "updatedAt": "2023-05-24T00:06:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5V4FYz",
          "commit": {
            "abbreviatedOid": "6f6e202"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T00:23:46Z",
          "updatedAt": "2023-05-24T16:26:32Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "I think this needs to include the `prep_msg` as well.",
              "createdAt": "2023-05-24T00:23:46Z",
              "updatedAt": "2023-05-24T16:26:32Z"
            },
            {
              "originalPosition": 117,
              "body": "It looks like `prep_size` is only used to determine how to split the `inbound` message into a `prep_msg` and a `prep_share` (correct me if I'm wrong there).\r\n\r\nIf so, I think we should use an enumerated type containing strongly-typed values for the messages, such that inbound is written something like `ContinueMessage(prep_msg, prep_share)`, with no need to specify how to serialize/deserialize the message. Serialization is probably best left up to the higher-level protocol. Practically, in DAP, I would likely specify a small section that defines the translation of `Initialize/Continue/FinishMessage` into a structure very much like a `PrepareStep`.\r\n\r\nI think counting the \"request number\" should be specified in DAP rather than VDAF. But I don't want to suggest that counting & storing in state the VDAF round number is necessary, as this will duplicate the request number in DAP (that is, a DAP implementation can figure out the correct VDAF round numbers to use from its request number, if we do keep `prep_size`).",
              "createdAt": "2023-05-24T00:39:35Z",
              "updatedAt": "2023-05-24T16:51:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5V_u4W",
          "commit": {
            "abbreviatedOid": "6f6e202"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T21:24:33Z",
          "updatedAt": "2023-05-24T21:24:49Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "Good call :)\r\n\r\nI've removed `Vdaf.prep_size()` and removed the round counter from the state.",
              "createdAt": "2023-05-24T21:24:33Z",
              "updatedAt": "2023-05-24T21:24:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5V_0Bm",
          "commit": {
            "abbreviatedOid": "1fd194c"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T21:45:19Z",
          "updatedAt": "2023-05-24T22:25:50Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\ncannot be processed any further; and `Finished(out_share)` where `out_share` is\r\n```",
              "createdAt": "2023-05-24T21:45:19Z",
              "updatedAt": "2023-05-24T22:25:50Z"
            },
            {
              "originalPosition": 16,
              "body": "We should show a loop edge on the Continued node, to cover multi-round VDAFs.",
              "createdAt": "2023-05-24T21:48:57Z",
              "updatedAt": "2023-05-24T22:25:50Z"
            },
            {
              "originalPosition": 67,
              "body": "nit: capitalization\r\n```suggestion\r\n* For a 1-round VDAF (e.g., Prio3 ({{prio3}})), the Leader sends its prep share\r\n```",
              "createdAt": "2023-05-24T21:56:07Z",
              "updatedAt": "2023-05-24T22:25:50Z"
            },
            {
              "originalPosition": 100,
              "body": "These ought to match\r\n```suggestion\r\n        prep_msg, peer_prep_share = inbound.prep_msg, inbound.prep_share\r\n```",
              "createdAt": "2023-05-24T22:00:56Z",
              "updatedAt": "2023-05-24T22:25:50Z"
            },
            {
              "originalPosition": 108,
              "body": "nit: better parallelism (\"this\" refers to what round it is earlier in the sentence, not `prep_msg`)\r\n```suggestion\r\n        # first round. Otherwise, `prep_msg` is the prep message\r\n```",
              "createdAt": "2023-05-24T22:03:00Z",
              "updatedAt": "2023-05-24T22:25:50Z"
            },
            {
              "originalPosition": 115,
              "body": "We should probably enumerate and describe the different message types before this pseudocode, because the difference between FinishMessage and FinishedMessage is easy to miss.",
              "createdAt": "2023-05-24T22:10:21Z",
              "updatedAt": "2023-05-24T22:25:50Z"
            },
            {
              "originalPosition": 103,
              "body": "We should be explicit about what message type this branch is for, for clarity.",
              "createdAt": "2023-05-24T22:10:51Z",
              "updatedAt": "2023-05-24T22:25:50Z"
            },
            {
              "originalPosition": 160,
              "body": "nit: missing the state argument\r\n```suggestion\r\ntransitions are computed by calling `Vdaf.ping_pong_next(is_leader, state, agg_param,\r\n```",
              "createdAt": "2023-05-24T22:22:20Z",
              "updatedAt": "2023-05-24T22:25:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WABhe",
          "commit": {
            "abbreviatedOid": "1fd194c"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T22:49:07Z",
          "updatedAt": "2023-05-24T22:52:04Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "I agree -- it would be very nice to describe these messages along with their purpose/contents.",
              "createdAt": "2023-05-24T22:49:07Z",
              "updatedAt": "2023-05-24T22:52:04Z"
            },
            {
              "originalPosition": 144,
              "body": "nit: `state` comes before `is_leader`, here and on L1341.",
              "createdAt": "2023-05-24T22:50:57Z",
              "updatedAt": "2023-05-24T22:52:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WACR4",
          "commit": {
            "abbreviatedOid": "1fd194c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T22:53:42Z",
          "updatedAt": "2023-05-24T22:53:42Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "\ud83d\ude2c ",
              "createdAt": "2023-05-24T22:53:42Z",
              "updatedAt": "2023-05-24T22:53:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WAEc9",
          "commit": {
            "abbreviatedOid": "1fd194c"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T23:05:48Z",
          "updatedAt": "2023-05-24T23:14:09Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nbroadcast channel functionality in protocols that use VDAFs.\r\n```",
              "createdAt": "2023-05-24T23:05:48Z",
              "updatedAt": "2023-05-24T23:14:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WAELv",
          "commit": {
            "abbreviatedOid": "1fd194c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T23:04:04Z",
          "updatedAt": "2023-05-24T23:25:10Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Done.",
              "createdAt": "2023-05-24T23:04:04Z",
              "updatedAt": "2023-05-24T23:25:10Z"
            },
            {
              "originalPosition": 67,
              "body": "Done.",
              "createdAt": "2023-05-24T23:04:59Z",
              "updatedAt": "2023-05-24T23:25:10Z"
            },
            {
              "originalPosition": 100,
              "body": "Done.",
              "createdAt": "2023-05-24T23:05:25Z",
              "updatedAt": "2023-05-24T23:25:10Z"
            },
            {
              "originalPosition": 103,
              "body": "Added a comment (should be `inbound == None` and `type(inbound) == FinishedMessage()`",
              "createdAt": "2023-05-24T23:06:44Z",
              "updatedAt": "2023-05-24T23:25:10Z"
            },
            {
              "originalPosition": 108,
              "body": "Done. I also put prep_msg == None above in backticks.",
              "createdAt": "2023-05-24T23:07:34Z",
              "updatedAt": "2023-05-24T23:25:10Z"
            },
            {
              "originalPosition": 144,
              "body": "Good catch.",
              "createdAt": "2023-05-24T23:20:42Z",
              "updatedAt": "2023-05-24T23:25:10Z"
            },
            {
              "originalPosition": 160,
              "body": "Done.",
              "createdAt": "2023-05-24T23:21:18Z",
              "updatedAt": "2023-05-24T23:25:10Z"
            },
            {
              "originalPosition": 115,
              "body": "Done! While at it I realized we maybe don't need `FinishedMessage` at this level of abstraction-- We could just have the Helper respond with `None`. Of course, in DAP we'll have to distinguish between \"finish(prep_msg)\" and \"finished\" in the wire protocol.\r\n\r\nLet me know what you think -- if desired I can add this back in, I don't feel strongly about it either way.",
              "createdAt": "2023-05-24T23:25:03Z",
              "updatedAt": "2023-05-24T23:25:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WAJQK",
          "commit": {
            "abbreviatedOid": "47f3922"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T23:28:30Z",
          "updatedAt": "2023-05-24T23:28:30Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "WDTA about \"InitializeMessage\" -> \"PingPongInitialize\", etc.?",
              "createdAt": "2023-05-24T23:28:30Z",
              "updatedAt": "2023-05-24T23:28:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WALT-",
          "commit": {
            "abbreviatedOid": "47f3922"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM, with one suggestion (happy to review another round if you decide to take it).",
          "createdAt": "2023-05-24T23:42:08Z",
          "updatedAt": "2023-05-24T23:43:07Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "What do you think about changing the `None` case to be an explicit `FinishedMessage`? This would mirror what's in DAP, and would make it much clearer here which case is being handled. In practice, any request/response protocol will need to send _some_ message, so I think it makes some sense to define what that message is as `FinishedMessage`. (name is up for debate, just suggesting what we went with in the analogous scenario in DAP)",
              "createdAt": "2023-05-24T23:42:08Z",
              "updatedAt": "2023-05-24T23:43:07Z"
            },
            {
              "originalPosition": 95,
              "body": "SGTM, reduces the odds that these names somehow conflict with another part of the document.",
              "createdAt": "2023-05-24T23:42:45Z",
              "updatedAt": "2023-05-24T23:43:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WAMQw",
          "commit": {
            "abbreviatedOid": "47f3922"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T23:44:49Z",
          "updatedAt": "2023-05-24T23:44:50Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "See this comment: https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/240#discussion_r1204848392. I'll add it back.",
              "createdAt": "2023-05-24T23:44:50Z",
              "updatedAt": "2023-05-24T23:44:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WAMq0",
          "commit": {
            "abbreviatedOid": "47f3922"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T23:45:37Z",
          "updatedAt": "2023-05-24T23:45:38Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "Done!",
              "createdAt": "2023-05-24T23:45:37Z",
              "updatedAt": "2023-05-24T23:45:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WANHV",
          "commit": {
            "abbreviatedOid": "47f3922"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T23:48:35Z",
          "updatedAt": "2023-05-24T23:48:35Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Done.",
              "createdAt": "2023-05-24T23:48:35Z",
              "updatedAt": "2023-05-24T23:48:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WANOX",
          "commit": {
            "abbreviatedOid": "b7bfc74"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-24T23:49:19Z",
          "updatedAt": "2023-05-24T23:49:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5WE2Si",
          "commit": {
            "abbreviatedOid": "9d94e1b"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-25T15:05:24Z",
          "updatedAt": "2023-05-25T17:32:41Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "This additional context may help\r\n```suggestion\r\nThe first state transition, from `Start` to `Continued` or `Rejected`, is induced by the following transition rule. No messages are sent or received during this transition.\r\n```",
              "createdAt": "2023-05-25T15:05:25Z",
              "updatedAt": "2023-05-25T17:32:41Z"
            },
            {
              "originalPosition": 125,
              "body": "I think `type(inbound) == PingPongFinished` here should be unreachable when executing this between two honest aggregators. (setting that aside, calling prep_next in such a situation would be incorrect) Only the helper sends PingPongFinished, thus only the leader can receive it. Walking backwards in the protocol, the leader would have transitioned to the Finished state before sending PingPongFinish for the prior round, so the leader would no longer be in the Continued state. Thus, if the leader receives a PingPongFinished message, it will not be calling `ping_pong_next()` with it as the inbound message.\r\n\r\nWe should have a separate branch here that transitions to Rejected and returns if either aggregator receives PingPongFinished while they're still in the Continued state.",
              "createdAt": "2023-05-25T17:18:36Z",
              "updatedAt": "2023-05-25T17:32:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WHfqr",
          "commit": {
            "abbreviatedOid": "9d94e1b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T00:28:57Z",
          "updatedAt": "2023-05-26T00:28:57Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Done. I added the rejection branch, but did not condition on being in the Continued state, since we don't expect ping_pong_next() to be called in any other state.",
              "createdAt": "2023-05-26T00:28:57Z",
              "updatedAt": "2023-05-26T00:29:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WHf0Q",
          "commit": {
            "abbreviatedOid": "9d94e1b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T00:30:09Z",
          "updatedAt": "2023-05-26T00:30:10Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Oh wait, I'm now realizing htat's wrong; the Leder will be in Finished() while awaiting PingPongFinished().",
              "createdAt": "2023-05-26T00:30:09Z",
              "updatedAt": "2023-05-26T00:30:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WHhij",
          "commit": {
            "abbreviatedOid": "9d94e1b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T00:45:00Z",
          "updatedAt": "2023-05-26T00:45:00Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "On third thought, currently we say that after reaching Finished the Leader won't await any other messages. I think this fine, but we might consider having the Leader go to Continued while waiting for PingPongFinished. WDYT?",
              "createdAt": "2023-05-26T00:45:00Z",
              "updatedAt": "2023-05-26T00:45:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WOR38",
          "commit": {
            "abbreviatedOid": "364ebc4"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T16:33:21Z",
          "updatedAt": "2023-05-26T16:37:27Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "I think we can have the Leader go to Finished; going to Continued is only tricky because it stores a prep state instead of an out share (so we'd really have two states, a \"normal continued\" state and a \"continued awaiting finished\" state, I suppose).\r\n\r\nMaybe we should just say that once the Leader goes to the Finished state, it should expect one more PingPongFinished message? I think that is effectively the semantics we want.",
              "createdAt": "2023-05-26T16:33:21Z",
              "updatedAt": "2023-05-26T16:37:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WOXqA",
          "commit": {
            "abbreviatedOid": "9d94e1b"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T16:48:42Z",
          "updatedAt": "2023-05-26T16:48:43Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Having the leader go to Finished makes sense to me -- otherwise we'd need two separate state machines for the leader and helper. The helper only sends PingPongFinished because we have to send something in a request-response transport. Since the leader should already be in a terminal state machine state, the message can be dropped on the floor -- the VDAF is already done as far as all parties are concerned.",
              "createdAt": "2023-05-26T16:48:42Z",
              "updatedAt": "2023-05-26T16:48:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WOYkr",
          "commit": {
            "abbreviatedOid": "364ebc4"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T16:51:44Z",
          "updatedAt": "2023-05-26T16:51:45Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "We should be explicit about when this state transition rule is applicable.\r\n```suggestion\r\nEach Aggregator handles these messages according to the following transition rule,\r\nso long as they are in the `Continued` state:\r\n```",
              "createdAt": "2023-05-26T16:51:44Z",
              "updatedAt": "2023-05-26T16:51:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WPFnV",
          "commit": {
            "abbreviatedOid": "364ebc4"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "some nitty nits but this looks sound to me!",
          "createdAt": "2023-05-26T18:59:23Z",
          "updatedAt": "2023-05-26T19:24:49Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\nthe Aggregator's recovered output share.\r\n```",
              "createdAt": "2023-05-26T18:59:23Z",
              "updatedAt": "2023-05-26T19:24:49Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nany request/response transport protocol, such as HTTP.\r\n```",
              "createdAt": "2023-05-26T19:00:10Z",
              "updatedAt": "2023-05-26T19:24:49Z"
            },
            {
              "originalPosition": 59,
              "body": "At the risk of being a pedant: if the VDAF being run was 0-round, then `Vdaf.prep_init` would transition right to `Finished`. I suppose you wouldn't bother running the ping-pong mode for a 0-round VDAF at all, but I feel like either this section could state that it's only defined for VDAFs with at least one round, or `{{vdaf}}` might say that `VDAF.ROUNDS > 0`.",
              "createdAt": "2023-05-26T19:03:26Z",
              "updatedAt": "2023-05-26T19:24:49Z"
            },
            {
              "originalPosition": 74,
              "body": "nit: explicit section links would be nice",
              "createdAt": "2023-05-26T19:09:39Z",
              "updatedAt": "2023-05-26T19:24:49Z"
            },
            {
              "originalPosition": 76,
              "body": "nit: it also requires a response, so maybe\r\n```suggestion\r\n  the prep message to the Leader. Preparation requires just one round trip between\r\n  the Leader and the Helper.\r\n```",
              "createdAt": "2023-05-26T19:10:23Z",
              "updatedAt": "2023-05-26T19:24:49Z"
            },
            {
              "originalPosition": 83,
              "body": "```suggestion\r\n  computes its own output share. Preparation requires two round trips.\r\n```",
              "createdAt": "2023-05-26T19:10:49Z",
              "updatedAt": "2023-05-26T19:24:49Z"
            },
            {
              "originalPosition": 126,
              "body": "nit: all the branches should consistently do either\r\n\r\n```\r\nfoo, bar = baz, qux\r\n```\r\n\r\nor\r\n\r\n```\r\nfoo = baz\r\nbar = qux\r\n```",
              "createdAt": "2023-05-26T19:13:21Z",
              "updatedAt": "2023-05-26T19:24:49Z"
            },
            {
              "originalPosition": 197,
              "body": "```suggestion\r\n> originally envisioned for DAP. (As of DAP-05 we are going with the ping pong\r\n```",
              "createdAt": "2023-05-26T19:24:04Z",
              "updatedAt": "2023-05-26T19:24:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WPT8c",
          "commit": {
            "abbreviatedOid": "9d94e1b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T19:50:05Z",
          "updatedAt": "2023-05-26T19:50:06Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "SGTM. Added a note about even-round VDAFs.",
              "createdAt": "2023-05-26T19:50:05Z",
              "updatedAt": "2023-05-26T19:50:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WPU8w",
          "commit": {
            "abbreviatedOid": "3c89fab"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Squashed.",
          "createdAt": "2023-05-26T19:54:34Z",
          "updatedAt": "2023-05-26T20:00:52Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Added \"with at least one round of preparation\" to the first paragraph of this section.\r\n\r\nFWIW 0-round, *verifiable* DAFs probably don't exist unless we bring in public key cryptography.",
              "createdAt": "2023-05-26T19:54:34Z",
              "updatedAt": "2023-05-26T20:00:52Z"
            },
            {
              "originalPosition": 74,
              "body": "Link to which section? There is already a link to {{prio3}}.",
              "createdAt": "2023-05-26T19:55:06Z",
              "updatedAt": "2023-05-26T20:00:52Z"
            },
            {
              "originalPosition": 126,
              "body": "I put it on two lines on 1312-1313 as to avoid breaching the column limit. I'll leave as-is to avoid adding too many lines of code.",
              "createdAt": "2023-05-26T19:57:34Z",
              "updatedAt": "2023-05-26T20:00:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WPl8-",
          "commit": {
            "abbreviatedOid": "e55d9f9"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T20:42:17Z",
          "updatedAt": "2023-05-26T20:42:17Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "^ bumping this",
              "createdAt": "2023-05-26T20:42:17Z",
              "updatedAt": "2023-05-26T20:42:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WPq17",
          "commit": {
            "abbreviatedOid": "e55d9f9"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T20:53:45Z",
          "updatedAt": "2023-05-26T21:15:03Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Looking back at the `prep_init` definition, it just produces initial preparation state, and cannot produce either outbound VDAF messages or output shares. Thus, even if there were a 0-round VDAF, we would still take the Start to Continued edge, in order to get that initial state, then do only one `prep_next` call in the next transition, and land on `Rejected or `Finished`.\r\n\r\nHowever, we may as well keep the \"at least one round of preparation\" caveat, because otherwise we'd need a new message type or special case handling to allow the leader to send some sort of zero-round finish message, with no prep message.",
              "createdAt": "2023-05-26T20:53:45Z",
              "updatedAt": "2023-05-26T21:15:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WP6gF",
          "commit": {
            "abbreviatedOid": "364ebc4"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T22:06:38Z",
          "updatedAt": "2023-05-26T22:06:39Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "Well, whichever the \"following sections\" mentioned on this line are.",
              "createdAt": "2023-05-26T22:06:38Z",
              "updatedAt": "2023-05-26T22:06:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Widxa",
          "commit": {
            "abbreviatedOid": "364ebc4"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:53:06Z",
          "updatedAt": "2023-05-30T21:53:06Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "Ohhh got it. Looking at this once more I think the paranethetical is kind of confusing so I just deleted it.",
              "createdAt": "2023-05-30T21:53:06Z",
              "updatedAt": "2023-05-30T21:53:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WrtHk",
          "commit": {
            "abbreviatedOid": "1b112c3"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-31T23:01:12Z",
          "updatedAt": "2023-05-31T23:03:29Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "nitpick: could this message be called something like `PingPongInitialize`? `PingPongMessage` is a more generic name than necessary IMO -- all of these message types could equally-accurately be called `PingPongMessage`.",
              "createdAt": "2023-05-31T23:01:12Z",
              "updatedAt": "2023-05-31T23:03:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WruT6",
          "commit": {
            "abbreviatedOid": "1b112c3"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-31T23:07:53Z",
          "updatedAt": "2023-05-31T23:07:53Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Done.",
              "createdAt": "2023-05-31T23:07:53Z",
              "updatedAt": "2023-05-31T23:07:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Wz-fx",
          "commit": {
            "abbreviatedOid": "37ae583"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-01T23:52:55Z",
          "updatedAt": "2023-06-01T23:52:56Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "WDYT about introducing a `PingPongRejected` message instead of returning `None`?\r\n\r\nOther than being more explicit about the meaning of this return value, the way things are currently written I suppose someone could misinterpret this text such that the other aggregator would continue to call `ping_pong_next` with `inbound == None`, which is not what we want.",
              "createdAt": "2023-06-01T23:52:55Z",
              "updatedAt": "2023-06-01T23:56:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5W7iXv",
          "commit": {
            "abbreviatedOid": "37ae583"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-02T20:34:02Z",
          "updatedAt": "2023-06-02T20:34:02Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "When would that happen? If I'm in the Rejected state, I'm not going to keep processing messages for that report.",
              "createdAt": "2023-06-02T20:34:02Z",
              "updatedAt": "2023-06-02T20:34:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5W7mAy",
          "commit": {
            "abbreviatedOid": "37ae583"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-02T20:49:49Z",
          "updatedAt": "2023-06-02T20:49:49Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "This aggregator would be in `Rejected` state, but the other aggregator wouldn't be in `Rejected` yet. By returning `None` here, someone misinterpreting this text might think that this means they need to send \"no message\" to the other aggregator, which would then call `ping_pong_next` with `inbound == None`, which would cause the peer aggregator to misbehave.\r\n\r\nBut this is just my guess at how things might go wrong. My bigger concern is being explicit: `PingPongRejected` has a more explicit meaning than `None`, and will make it easier for protocols using these functions to specify handling.",
              "createdAt": "2023-06-02T20:49:49Z",
              "updatedAt": "2023-06-02T20:49:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5W7ogA",
          "commit": {
            "abbreviatedOid": "37ae583"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-02T21:00:45Z",
          "updatedAt": "2023-06-02T21:00:46Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "Hmm, let me think about this. We get to `Rejected()` in three ways:\r\n1. prep_init() raises an error\r\n2. prep_next() or prep_shares_to_prep() raises an error\r\n3. ping_pong_next() is called on `PingPongFinished()`\r\n\r\nWhether there is an explicit message sent in DAP kind of depends: in cases (1) and (2) only the Helper sends an explicit message, at least for now (this might change with https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/issues/438). Case (3) should actually be unreachable if the ping pong API is used correctly.\r\n\r\nI think if we want to be more explicit, we should be consistent. I.e., in case (1) there should be an explicit outbound message. But the fact that whether there is an explicit message depends on protocol details, I think I'd prefer to leave the type as `None` and leave it to the protocol to sort out.",
              "createdAt": "2023-06-02T21:00:46Z",
              "updatedAt": "2023-06-02T21:00:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5W7xc_",
          "commit": {
            "abbreviatedOid": "37ae583"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-02T21:48:02Z",
          "updatedAt": "2023-06-02T21:48:03Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "Good point; one way to resolve this, but perhaps too slowly for this PR, would be to take https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/244 -- then ping-pong initialization could be similarly fused such that `ping_pong_start` would return a state & outbound message, which could then be `PingPongRejected`.\r\n\r\nAnother option would be not to address this at all: I updated https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/pull/393 to use the ping-pong API from this PR, rejection handling isn't too awkward (and not all of the awkwardness would be resolved even if we took this suggestion).",
              "createdAt": "2023-06-02T21:48:02Z",
              "updatedAt": "2023-06-02T21:48:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5W7xrA",
          "commit": {
            "abbreviatedOid": "37ae583"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-02T21:49:27Z",
          "updatedAt": "2023-06-02T21:49:27Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "I'd prefer the second option if it's not too awkward. I just saw your changes to 393 and am reviewing now.",
              "createdAt": "2023-06-02T21:49:27Z",
              "updatedAt": "2023-06-02T21:49:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Xge3z",
          "commit": {
            "abbreviatedOid": "2faf238"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-07T16:30:20Z",
          "updatedAt": "2023-06-07T16:30:21Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": "nit: `encode_method` should be `encode_continue` I think (and similarly below)",
              "createdAt": "2023-06-07T16:30:21Z",
              "updatedAt": "2023-06-07T16:30:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Xgl1B",
          "commit": {
            "abbreviatedOid": "2faf238"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-07T16:44:41Z",
          "updatedAt": "2023-06-07T18:34:53Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "nit: we could save a couple of bytes w/o loss of parseability by dropping `prep_share_len` -- since we only need to decode from a buffer, rather than from a stream, the length of the second field is implied by the length of the first field & the length of the buffer.",
              "createdAt": "2023-06-07T16:44:42Z",
              "updatedAt": "2023-06-07T18:34:53Z"
            },
            {
              "originalPosition": 112,
              "body": "I dislike parsing based on the current round number or any other shared context; this implies that parsing a message received from a peer requires having a matching round number with the peer (or close enough that this logic treats the messages as the same type). This means that if round skew occurs (due to e.g. implementation bugs or transient network failure), message misparsing is likely. I'm not sure how one would determine that this is due to round skew since the round number is not transmitted.\r\n\r\nThis is somewhat more painful in DAP, given that the current round number is transmitted as part of the same message including messages which must be parsed using the current round number as context. For correct parsing, implementations will have to split their parsing logic such that they can parse the round field out of an aggregation-continue request before they try to parse the incoming merged messages.\r\n\r\nInstead, we could include a discriminator byte, or some other method allowing context-free parsing of these messages. Another upside is that this would let us stop tracking the current VDAF round & let it be implicit in the behavior of the underlying VDAF methods (i.e. you know you're done once you receive an out share). This also removes an error case for implementations to handle: a buggy VDAF with a given number of `ROUNDS` which doesn't actually finish until e.g. `ROUNDS+1` rounds.",
              "createdAt": "2023-06-07T16:57:06Z",
              "updatedAt": "2023-06-07T18:34:53Z"
            },
            {
              "originalPosition": 106,
              "body": "This block (L1295-1311), which parses the inbound message, is quite complicated & confusing. Maybe one of the following:\r\n\r\n(a) break it into (pseudocode) match/case blocks.\r\n(b) break it out into a separate parser method.\r\n(c) break it out into separate parser methods -- e.g. `parse_inbound_leader` & `parse_inbound_helper`.",
              "createdAt": "2023-06-07T17:00:17Z",
              "updatedAt": "2023-06-07T18:34:53Z"
            },
            {
              "originalPosition": 99,
              "body": "meta-comment: this function in general is very complicated, handling a bunch of different cases -- that's unfortunate since the goal of this work was simplification. WDYT about splitting it up into `leader_ping_pong_next` & `helper_ping_pong_next` -- each of which assumes the `is_leader` value & simplifies accordingly.",
              "createdAt": "2023-06-07T17:14:55Z",
              "updatedAt": "2023-06-07T18:34:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Xiw67",
          "commit": {
            "abbreviatedOid": "2faf238"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-07T23:29:14Z",
          "updatedAt": "2023-06-08T00:12:37Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "That sounds like it could simplify things in a useful way \ud83d\udc4d ",
              "createdAt": "2023-06-07T23:29:14Z",
              "updatedAt": "2023-06-08T00:12:37Z"
            },
            {
              "originalPosition": 106,
              "body": "(c) sounds good.",
              "createdAt": "2023-06-07T23:29:49Z",
              "updatedAt": "2023-06-08T00:12:37Z"
            },
            {
              "originalPosition": 161,
              "body": "Good catch.",
              "createdAt": "2023-06-07T23:30:23Z",
              "updatedAt": "2023-06-08T00:12:37Z"
            },
            {
              "originalPosition": 165,
              "body": "Sounds good to me.",
              "createdAt": "2023-06-07T23:30:42Z",
              "updatedAt": "2023-06-08T00:12:37Z"
            },
            {
              "originalPosition": 112,
              "body": "I'll think on it more, but I'm not totally convinced we can do away with the round number altogether. In any case I think we can make parsing context-free here.\r\n\r\nA couple of points:\r\n* I'm not sure notwork failures are or should be a consideration for VDAF. Ideally we can think of VDAF as the primitive building block that is used in a protocol that deals with this stuff (DAP). As an anology, we don't typically think about network failures when writing down the spec for Diffie-Hellman key exchange. (And I'd argue we don't need to.)\r\n* Elsewhere in VDAF, parsing is not context-free: For instance in Prio3 the field being used is not encoded in any message. I'm fine doing so here however, since this is connective tissue for a specific protocol.\r\n",
              "createdAt": "2023-06-08T00:12:18Z",
              "updatedAt": "2023-06-08T00:12:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Xoodf",
          "commit": {
            "abbreviatedOid": "2faf238"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I've taken most of your comments, including making serialization context free. I next need to update the DAP PR to match -- there I think we can just refer to the `Message` stsructure explicitly.",
          "createdAt": "2023-06-08T15:53:07Z",
          "updatedAt": "2023-06-08T15:57:11Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": "These methods have been deleted.",
              "createdAt": "2023-06-08T15:53:07Z",
              "updatedAt": "2023-06-08T15:57:11Z"
            },
            {
              "originalPosition": 165,
              "body": "I've decided to specify the ping pong messages in TLS syntax. I think to make it easier to use in DAP we want both length prefixes. (That way parsing DAP messages can be done with the `Decode` trait in libprio.)",
              "createdAt": "2023-06-08T15:54:03Z",
              "updatedAt": "2023-06-08T15:57:11Z"
            },
            {
              "originalPosition": 112,
              "body": "i've added the discriminator byte and removed the round number from the Continue state once more.",
              "createdAt": "2023-06-08T15:54:36Z",
              "updatedAt": "2023-06-08T15:57:11Z"
            },
            {
              "originalPosition": 99,
              "body": "Done.",
              "createdAt": "2023-06-08T15:54:54Z",
              "updatedAt": "2023-06-08T15:57:11Z"
            },
            {
              "originalPosition": 106,
              "body": "Having split the next into Leader and Helper specific functions and simplified the encoding, I no longer think this is necessary, but PTAL and let me know what you think.",
              "createdAt": "2023-06-08T15:56:03Z",
              "updatedAt": "2023-06-08T15:57:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Xp15c",
          "commit": {
            "abbreviatedOid": "0c9dd7a"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I like the usage of TLS syntax -- I was wary of suggesting it as I thought that to be too DAP-specific, but if you are happy with it then so am I.\r\n\r\nI'm still reviewing the DAP PR but I think this one is good to go.",
          "createdAt": "2023-06-08T18:58:58Z",
          "updatedAt": "2023-06-08T20:45:37Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "```suggestion\r\n        peer_prep_share,\r\n```\r\n\r\n(please vet that I'm not confused)",
              "createdAt": "2023-06-08T18:58:59Z",
              "updatedAt": "2023-06-08T20:45:37Z"
            },
            {
              "originalPosition": 174,
              "body": "```suggestion\r\n        peer_prep_share,\r\n```\r\n\r\n(same as above)",
              "createdAt": "2023-06-08T19:01:36Z",
              "updatedAt": "2023-06-08T20:45:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Xq2hV",
          "commit": {
            "abbreviatedOid": "b2e9b3e"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-08T22:24:49Z",
          "updatedAt": "2023-06-08T22:57:27Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "I would prefer adding the `finished` message type back, as otherwise DAP will need an additional discriminator bit outside the `Message` struct to indicate whether or not a helper's response includes a `Message` or not.",
              "createdAt": "2023-06-08T22:24:49Z",
              "updatedAt": "2023-06-08T22:57:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Xq9F7",
          "commit": {
            "abbreviatedOid": "b2e9b3e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-08T23:01:14Z",
          "updatedAt": "2023-06-08T23:01:14Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "True, but I think that discriminator bit is needed in DAP in any case. Having done a few passes of this, I think this is the simplest design we have so far. (I'd encourage you to also review the corresponding DAP PR -- perhaps you'll have an idea to simplify things a bit more.)",
              "createdAt": "2023-06-08T23:01:14Z",
              "updatedAt": "2023-06-08T23:01:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Xq-8A",
          "commit": {
            "abbreviatedOid": "b2e9b3e"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-08T23:10:36Z",
          "updatedAt": "2023-06-08T23:10:36Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "I think this is OK (if slightly confusing due to similar names being used in DAP & VDAF): `finished` exists at the DAP level, as one of the possible states of a `PrepareStep`, and works as you describe; this VDAF `finish` message would be embedded in a DAP `PrepareStep` of type `continue`.",
              "createdAt": "2023-06-08T23:10:36Z",
              "updatedAt": "2023-06-08T23:10:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5Xq_e-",
          "commit": {
            "abbreviatedOid": "b2e9b3e"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-08T23:12:05Z",
          "updatedAt": "2023-06-08T23:12:05Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "(that said, this _is_ somewhat confusing; maybe there's a better way to state this abstraction boundary?)",
              "createdAt": "2023-06-08T23:12:05Z",
              "updatedAt": "2023-06-08T23:12:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5XrEws",
          "commit": {
            "abbreviatedOid": "b2e9b3e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-08T23:34:15Z",
          "updatedAt": "2023-06-08T23:34:16Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "Perhaps. I sort of like what we have though now. It's at least consistent: If there is an actual message to send, then `outbound` will be `None`; otherwise `outbound != None`. This is useful in DAP because the Leader and Helper do different things in this case.",
              "createdAt": "2023-06-08T23:34:16Z",
              "updatedAt": "2023-06-08T23:34:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5YE1X7",
          "commit": {
            "abbreviatedOid": "b2e9b3e"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Here's a first pass with some ticky-tacky spelling and terminology nits. I'm going to do another pass where I read this in conjunction with https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/pull/393 and may come out of that with more substantive structural comments.",
          "createdAt": "2023-06-13T16:53:07Z",
          "updatedAt": "2023-06-13T20:32:34Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "editorial nit: this sentence lacks symmetry and also opening a clause with , but closing it with ; is awkward.\r\n```suggestion\r\nterminal states are `Rejected`, indicating that the report was rejected and\r\ncannot be processed any further, and `Finished(out_share)`, indicating that\r\nthe Aggregator has recovered an output share `out_share`.\r\n```",
              "createdAt": "2023-06-13T16:54:51Z",
              "updatedAt": "2023-06-13T20:32:34Z"
            },
            {
              "originalPosition": 50,
              "body": "The `State` enum type returned by this function doesn't seem to be defined anywhere, except implicitly by `{{vdaf-prep-state-machine}}` and other text. Which I guess is classically Pythonic, but IMO an explicit declaration is necessary.",
              "createdAt": "2023-06-13T17:28:04Z",
              "updatedAt": "2023-06-13T21:10:41Z"
            },
            {
              "originalPosition": 50,
              "body": "I'm not sure that `host` is the best word to use here. I think it's being used here to mean the opposite of the peer aggregator, but I would expect the opposite of a host to be a guest, as in a guest virtual machine running on a host. The other common definition of host is any computer in a network, and so I don't think that helps distinguish from the other aggregator, since both are equally hosts.\r\n\r\nI think `own_input_share` vs. `peer_input_share` (or `_prep_share` or whatever) could be better.",
              "createdAt": "2023-06-13T17:32:58Z",
              "updatedAt": "2023-06-13T20:32:34Z"
            },
            {
              "originalPosition": 100,
              "body": "```suggestion\r\n  initialize(0),\r\n```",
              "createdAt": "2023-06-13T17:34:54Z",
              "updatedAt": "2023-06-13T20:32:34Z"
            },
            {
              "originalPosition": 96,
              "body": "nit: refer to [section 3 on the presentation language](https://datatracker.ietf.org/doc/html/rfc8446#section-3) specifically.",
              "createdAt": "2023-06-13T17:35:45Z",
              "updatedAt": "2023-06-13T20:32:35Z"
            },
            {
              "originalPosition": 149,
              "body": "I think the usage of \"inbound\" here is ambiguous given that the possessive assigns it to the helper, because from the helper's perspective, the message is _out_bound. Maybe:\r\n```suggestion\r\nsection.) The input `inbound` denotes the last message received from the Helper. This\r\n```",
              "createdAt": "2023-06-13T17:40:59Z",
              "updatedAt": "2023-06-13T20:32:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5YGVG0",
          "commit": {
            "abbreviatedOid": "b2e9b3e"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I have a couple more nits or suggestions, but I believe this is fundamentally sound and fits with the corresponding DAP change (https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/pull/393).",
          "createdAt": "2023-06-13T21:06:11Z",
          "updatedAt": "2023-06-13T21:36:44Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "All of this is written in terms of VDAFs. Does that mean this is undefined for DAFs?",
              "createdAt": "2023-06-13T21:06:11Z",
              "updatedAt": "2023-06-13T21:36:44Z"
            },
            {
              "originalPosition": 186,
              "body": "```suggestion\r\nHelper. For the initial request, `inbound == None`. To respond to the Leader,\r\n```",
              "createdAt": "2023-06-13T21:09:51Z",
              "updatedAt": "2023-06-13T21:36:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5YGzmi",
          "commit": {
            "abbreviatedOid": "c09b243"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-13T22:51:28Z",
          "updatedAt": "2023-06-13T22:54:50Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Yes.",
              "createdAt": "2023-06-13T22:51:28Z",
              "updatedAt": "2023-06-13T22:54:50Z"
            },
            {
              "originalPosition": 50,
              "body": "Ack, I think this would be overly verbose. I'd rather keep it implicit. ",
              "createdAt": "2023-06-13T22:52:21Z",
              "updatedAt": "2023-06-13T22:54:50Z"
            },
            {
              "originalPosition": 50,
              "body": "Host and Peer are common terms used in IETF specs (host == \"us\", peer == \"them\")",
              "createdAt": "2023-06-13T22:52:57Z",
              "updatedAt": "2023-06-13T22:54:50Z"
            },
            {
              "originalPosition": 96,
              "body": "Done.",
              "createdAt": "2023-06-13T22:54:45Z",
              "updatedAt": "2023-06-13T22:54:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5YG32J",
          "commit": {
            "abbreviatedOid": "b2e9b3e"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-13T23:14:42Z",
          "updatedAt": "2023-06-13T23:14:43Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I don't agree, but I suppose this isn't ambiguous or impossible to implement as written, so I'll defer to the VDAF editors.",
              "createdAt": "2023-06-13T23:14:42Z",
              "updatedAt": "2023-06-13T23:14:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5YG4KM",
          "commit": {
            "abbreviatedOid": "a18b28d"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "There's nothing left I strictly object to. \ud83d\udea2 ",
          "createdAt": "2023-06-13T23:16:50Z",
          "updatedAt": "2023-06-14T15:04:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 241,
      "id": "PR_kwDOGKuqOc5RShiQ",
      "title": "Convert flp_generic.sage to Python",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/241",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This converts flp_generic.sage to Python, as part of #204.",
      "createdAt": "2023-05-24T21:31:29Z",
      "updatedAt": "2023-05-24T21:39:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "690f59a6c2fe94a3b3647b190c2a5c5d1a8fc28f",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/flp-generic-python",
      "headRefOid": "922eb023787c9d6aa73fdb343ead07279a302178",
      "closedAt": "2023-05-24T21:39:24Z",
      "mergedAt": "2023-05-24T21:39:24Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "5f293a3b9d6520c6b00a92e4a2ee15499bf09713"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5V_yEx",
          "commit": {
            "abbreviatedOid": "922eb02"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-24T21:37:40Z",
          "updatedAt": "2023-05-24T21:37:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 242,
      "id": "PR_kwDOGKuqOc5ReOOt",
      "title": "Finish Python conversion",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/242",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This finishes #204 by converting the last three `.sage` files, and cleaning up the Makefile.",
      "createdAt": "2023-05-26T20:37:01Z",
      "updatedAt": "2023-05-30T22:04:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "5f293a3b9d6520c6b00a92e4a2ee15499bf09713",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/finish-python-conversion",
      "headRefOid": "af4b573e2ea8004eb4fe58a75a78b3934d22b2df",
      "closedAt": "2023-05-30T22:04:05Z",
      "mergedAt": "2023-05-30T22:04:05Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "b2beac14472cf6654a9c029c919f3fbd0f43b3b5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5WibEQ",
          "commit": {
            "abbreviatedOid": "af4b573"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-30T21:44:11Z",
          "updatedAt": "2023-05-30T21:44:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 243,
      "id": "PR_kwDOGKuqOc5RuL1N",
      "title": "Redefine Prio3Histogram measurement and parameters",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/243",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This changes Prio3Histogram so that it is parameterized by a number of buckets, instead of a list of bucket boundaries. The measurement is now an index into the buckets, instead of an integer that's compared with the bucket boundaries. Closes #239. I confirmed that the messages in the Prio3Histogram test vector data are unchanged. (the parameter and measurement naturally changed)",
      "createdAt": "2023-05-30T20:12:44Z",
      "updatedAt": "2024-07-02T21:38:48Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "b2beac14472cf6654a9c029c919f3fbd0f43b3b5",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/histogram-change",
      "headRefOid": "21956c24ce0d3061a10aa377348d8664322724f2",
      "closedAt": "2023-06-07T22:40:33Z",
      "mergedAt": "2023-06-07T22:40:33Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "287e24eb0dfb284988ee44c07de96ca78ac2c596"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5WidRQ",
          "commit": {
            "abbreviatedOid": "f2e9b5b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:51:07Z",
          "updatedAt": "2023-05-30T21:51:11Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I think we need to be a bit more clear about what the measurements are. It may also be helpful to be a bit more concrete with an example.\r\n\r\n```suggestion\r\ncomputing a simple histogram. Each measurement is the index of the histogram bucket,\r\nout of a fixed-length sequence of buckets. For example, the buckets might quantize the real numbers, and each measurement would report the bucket into which a client's value (a real number) would fall. The aggregate result counts the number of\r\n```",
              "createdAt": "2023-05-30T21:51:08Z",
              "updatedAt": "2023-05-30T21:51:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5WrvN2",
          "commit": {
            "abbreviatedOid": "21956c2"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-31T23:12:53Z",
          "updatedAt": "2023-05-31T23:12:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 247,
      "id": "PR_kwDOGKuqOc5SjuCW",
      "title": "Generate Prio3 test vectors with three shares",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/247",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds code to generate Prio3 test vectors with three shares. I also added the number of shares to the test vector itself, because I figure it's easier to do so here than for consumers to count aggregate shares or input shares. Closes #245.",
      "createdAt": "2023-06-08T20:47:34Z",
      "updatedAt": "2023-06-08T21:21:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "287e24eb0dfb284988ee44c07de96ca78ac2c596",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/test-vector-three-shares",
      "headRefOid": "6e1132f03c569e7faf53ac7efdac81be7e280ae5",
      "closedAt": "2023-06-08T21:21:14Z",
      "mergedAt": "2023-06-08T21:21:14Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "2a9eded97d6224c5b303ed8675facce8c32ad343"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5Xqdcn",
          "commit": {
            "abbreviatedOid": "6e1132f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-08T20:54:49Z",
          "updatedAt": "2023-06-08T20:54:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 248,
      "id": "PR_kwDOGKuqOc5Sjvra",
      "title": "Add CODEOWNERS file",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/248",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add a CODEOWNERS file so that GitHub tags each of the Authors with each new PR.",
      "createdAt": "2023-06-08T20:54:00Z",
      "updatedAt": "2024-05-01T20:18:13Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "287e24eb0dfb284988ee44c07de96ca78ac2c596",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/codeowners",
      "headRefOid": "890ff4b101035c8268f056767a8c175ec6c81760",
      "closedAt": "2023-06-08T21:25:33Z",
      "mergedAt": "2023-06-08T21:25:33Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "6b4d624f14d04499b7a6d87421cd68e23156b75e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5XqlNh",
          "commit": {
            "abbreviatedOid": "890ff4b"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-08T21:20:32Z",
          "updatedAt": "2023-06-08T21:20:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 249,
      "id": "PR_kwDOGKuqOc5SjwoG",
      "title": "Add \"rand\" input to test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/249",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds the `rand` input to the machine-readable JSON test vectors, so that consumers don't have to implement its generation. This also opens the door to making randomness used in test vectors even more interesting. Closes #246.",
      "createdAt": "2023-06-08T20:58:13Z",
      "updatedAt": "2023-06-08T21:37:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "287e24eb0dfb284988ee44c07de96ca78ac2c596",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/test-vector-rand",
      "headRefOid": "43b26ef40770db1e45dba8c342b0933d162d455a",
      "closedAt": "2023-06-08T21:37:13Z",
      "mergedAt": "2023-06-08T21:37:13Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "b3e4c28b5a51a5ecb1ce7b6b484fa8f703adf437"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5XqmhZ",
          "commit": {
            "abbreviatedOid": "43b26ef"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-08T21:26:08Z",
          "updatedAt": "2023-06-08T21:26:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 250,
      "id": "PR_kwDOGKuqOc5SpZA5",
      "title": "Format Python code",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/250",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This formats all the code with autopep8 and isort, and then runs those in a new CI job.",
      "createdAt": "2023-06-09T18:27:15Z",
      "updatedAt": "2023-06-14T21:45:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "b3e4c28b5a51a5ecb1ce7b6b484fa8f703adf437",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/format-python",
      "headRefOid": "a7d3866a3d6748dd9c14a8703db81291b0fcb841",
      "closedAt": "2023-06-14T21:45:33Z",
      "mergedAt": "2023-06-14T21:45:33Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "dca32de7527342b8c64d0cae909682facf1174b7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5YPGTC",
          "commit": {
            "abbreviatedOid": "a7d3866"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Great idea :)",
          "createdAt": "2023-06-14T21:44:10Z",
          "updatedAt": "2023-06-14T21:44:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 251,
      "id": "PR_kwDOGKuqOc5TCgCp",
      "title": "Prepare to cut VDAF-06",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/251",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-14T22:29:52Z",
      "updatedAt": "2024-05-01T20:18:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "dca32de7527342b8c64d0cae909682facf1174b7",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-06",
      "headRefOid": "cc6dae3932bd07d7c49c4c4938328b4932e6b073",
      "closedAt": "2023-06-16T01:52:24Z",
      "mergedAt": "2023-06-16T01:52:24Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "87f732949578005d91960ba6497b6f763ed47c70"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5YPTQr",
          "commit": {
            "abbreviatedOid": "cc6dae3"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-14T22:36:22Z",
          "updatedAt": "2023-06-14T22:36:23Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "@divergentdave We previously decided that this change is *not* wire breaking. Thinking about this more: a given measurement will be interpreted differently in 05 versus 06. For example, say the Client's measurement is 2:\r\n* In 05, if the buckets are [0,10,100] then the Client's histogram contribution will be [0, 1, 0, 0]\r\n* In 06, if the number of buckets is 4, then the Client's histogram contribution will be [0, 0, 1, 0]\r\n\r\nSo it's not wire breaking in the sense that the algorithm has changed (though `shard()` would now fail on inputs that it didn't fail before), but the aggregate result would be different. WDYT?",
              "createdAt": "2023-06-14T22:36:22Z",
              "updatedAt": "2023-06-14T22:36:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5YPT2J",
          "commit": {
            "abbreviatedOid": "cc6dae3"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-14T22:38:17Z",
          "updatedAt": "2023-06-14T22:38:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5YPUt3",
          "commit": {
            "abbreviatedOid": "cc6dae3"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-14T22:43:07Z",
          "updatedAt": "2023-06-14T22:43:07Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I think including the asterisk makes sense. It would be incorrect to provide the same measurement to both versions of the VDAF, since its semantics have changed. Whether it's wire-breaking, non-backwards compatible, etc. depends on where you draw the box around it ultimately, but we may as well be a little conservative here.",
              "createdAt": "2023-06-14T22:43:07Z",
              "updatedAt": "2023-06-14T22:43:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 253,
      "id": "PR_kwDOGKuqOc5TXvX4",
      "title": "Return type should be an optional Message",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/253",
      "state": "MERGED",
      "author": "wangshan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "",
      "createdAt": "2023-06-19T19:25:27Z",
      "updatedAt": "2023-08-03T18:01:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "87f732949578005d91960ba6497b6f763ed47c70",
      "headRepository": "wangshan/draft-irtf-cfrg-vdaf",
      "headRefName": "ping-pong-resp-ret-sig",
      "headRefOid": "ddf711e9cc4bba231401e724160deef20296fabb",
      "closedAt": "2023-06-19T19:52:40Z",
      "mergedAt": "2023-06-19T19:52:40Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "2951d2e0f35d06bab3484b1bee958e7e339b328a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5Ynn8L",
          "commit": {
            "abbreviatedOid": "ddf711e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-19T19:26:51Z",
          "updatedAt": "2023-06-19T19:26:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 263,
      "id": "PR_kwDOGKuqOc5VQXtE",
      "title": "Prio3: Refactor shard into shard with(out) joint rand (#215)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/263",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "Partially addresses #215.\r\n\r\nThe description of Prio3 makes it unclear when joint randomness is computed. To clarify the sharding algorithm, we split it into two methods, one that is called when the FLP requires joint randomness and another that is called when joint randomness is not required.",
      "createdAt": "2023-07-12T00:03:47Z",
      "updatedAt": "2024-05-01T20:18:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "2951d2e0f35d06bab3484b1bee958e7e339b328a",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/215/1",
      "headRefOid": "ab7a5c2f6b1b48a04f87e05f5c95be15d38d8560",
      "closedAt": "2023-07-12T15:26:52Z",
      "mergedAt": "2023-07-12T15:26:52Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "ff577aa70e08c171b10b7f69523b58cdb05750cb"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "fyi/ @chris-wood \r\nfyi/ @wangshan ",
          "createdAt": "2023-07-12T00:04:09Z",
          "updatedAt": "2023-07-12T00:05:42Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@divergentdave just a heads up that I forgot to propagate the changes to prep_init before you reviewed. Super minor though.",
          "createdAt": "2023-07-12T15:22:11Z",
          "updatedAt": "2023-07-12T15:22:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5a_guk",
          "commit": {
            "abbreviatedOid": "76dffa9"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-12T15:07:27Z",
          "updatedAt": "2023-07-12T15:11:35Z",
          "comments": [
            {
              "originalPosition": 179,
              "body": "```suggestion\r\n{: #prio3-shard-without-joint-rand title=\"Sharding an encoded measurement without joint randomness.\"}\r\n```",
              "createdAt": "2023-07-12T15:07:27Z",
              "updatedAt": "2023-07-12T15:11:35Z"
            },
            {
              "originalPosition": 198,
              "body": "```suggestion\r\nThe following method is used for FLPs that require joint randomness,\r\n```",
              "createdAt": "2023-07-12T15:08:19Z",
              "updatedAt": "2023-07-12T15:11:35Z"
            },
            {
              "originalPosition": 253,
              "body": "```suggestion\r\n{: #prio3-shard-with-joint-rand title=\"Sharding an encoded measurement with joint\r\n```",
              "createdAt": "2023-07-12T15:08:49Z",
              "updatedAt": "2023-07-12T15:11:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 264,
      "id": "PR_kwDOGKuqOc5VWfHr",
      "title": "Vdaf: Merge first `prep_next()` call into `prep_init()` (#244)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/264",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "Closes #244.\r\n\r\nVdaf: Merge first `prep_next()` call into `prep_init()` (#244)\r\n\r\nModify `prep_init()` so that it output the first round prep share.\r\nAccordingly, make the `prep_msg` input to `prep_next()` mandatory\r\ninstead of optional.\r\n\r\nRework the ping-pong API accordingly, coalescing `ping_pong_start()`\r\n and the first call to `ping_pong_req()` (resp. `ping_pong_resp()`).\r\n\r\nAdditional changes:\r\n\r\n* Propagate some changes from the reference code to the draft that we\r\n  missed in previous commits.\r\n\r\n* poc: Remove the test VDAF rather than update it. With `Prio3` and\r\n  `Poplar1` we are already testing all of the code paths it was\r\n  originally written to test.\r\n",
      "createdAt": "2023-07-12T20:41:36Z",
      "updatedAt": "2023-08-03T18:00:54Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "4bc449d830e5713488977c856e643675017a01fe",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/244",
      "headRefOid": "110102d09b7682893e54a72a109490e62403ef75",
      "closedAt": "2023-07-14T20:41:49Z",
      "mergedAt": "2023-07-14T20:41:49Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "a0ee768faaa6c9b4b186e7d6c82292f31d9e81b1"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "cc/ @branlwyd ",
          "createdAt": "2023-07-12T20:42:04Z",
          "updatedAt": "2023-07-12T20:42:04Z"
        },
        {
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(I looked over the concrete method definitions for the VDAFs, but I'm unlikely to spot any subtle errors there -- additional eyes would be useful. Everything else LGTM.)",
          "createdAt": "2023-07-13T20:09:00Z",
          "updatedAt": "2023-07-13T20:09:00Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased and squashed.",
          "createdAt": "2023-07-14T20:30:11Z",
          "updatedAt": "2023-07-14T20:30:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5bJUWz",
          "commit": {
            "abbreviatedOid": "077e22d"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-13T20:08:10Z",
          "updatedAt": "2023-07-13T20:08:10Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5bOX8-",
          "commit": {
            "abbreviatedOid": "077e22d"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-14T15:15:24Z",
          "updatedAt": "2023-07-14T18:40:30Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "nit: typo\r\n```suggestion\r\nis its output share and its output in each of the preceding rounds is a prep\r\n```",
              "createdAt": "2023-07-14T15:15:25Z",
              "updatedAt": "2023-07-14T18:40:30Z"
            },
            {
              "originalPosition": 68,
              "body": "For clarity, this return type is why this change removes support for zero round VDAFs. Returning `Union[Tuple[Prep, Bytes], OutShare]` just like `prep_next()` would permit zero round VDAFs, in exchange for (unused and unneeded) complexity.",
              "createdAt": "2023-07-14T15:21:23Z",
              "updatedAt": "2023-07-14T18:40:30Z"
            },
            {
              "originalPosition": 185,
              "body": "nit: parallelism\r\n```suggestion\r\nprocessed any further, and `Finished(out_share)`, which indicates that the\r\n```",
              "createdAt": "2023-07-14T15:47:24Z",
              "updatedAt": "2023-07-14T18:40:30Z"
            },
            {
              "originalPosition": 412,
              "body": "Based on the protocol, the inbound message's type is expected to be either \"continue\" or \"finish\". We may want to mention this in a comment, and maybe rename the function to ping_pong_continued, as I think it must be named after the Continued state rather the continue message type. Moreover, the else branch for when `inbound.prep_msg == None` is unreachable during a correctly executed protocol trace. We could replace it with `return (Rejected(), None)` as well.",
              "createdAt": "2023-07-14T16:15:03Z",
              "updatedAt": "2023-07-14T18:40:30Z"
            },
            {
              "originalPosition": 565,
              "body": "The function's argument needs to be updated to match the Python file. (opt_sketch => prep_msg)",
              "createdAt": "2023-07-14T17:02:30Z",
              "updatedAt": "2023-07-14T18:40:30Z"
            },
            {
              "originalPosition": 283,
              "body": "nit: state is misspelled\r\n```suggestion\r\n        return (Continued(prep_state), outbound)\r\n```",
              "createdAt": "2023-07-14T18:21:33Z",
              "updatedAt": "2023-07-14T18:40:30Z"
            },
            {
              "originalPosition": 329,
              "body": "nit: spelling\r\n```suggestion\r\ndef ping_pong_helper_init(\r\n```",
              "createdAt": "2023-07-14T18:22:58Z",
              "updatedAt": "2023-07-14T18:40:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5bPk_A",
          "commit": {
            "abbreviatedOid": "077e22d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-14T18:44:11Z",
          "updatedAt": "2023-07-14T18:44:11Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Ack. Such a protocol would have the same basic shape as DAF, correct? If at some point someone discovers a protocol of that shape that is indeed verifiable, I think we'd have to call DAF something else. Until then, I think I'm comfortable requiring `ROUNDS > 0`. WDYT?",
              "createdAt": "2023-07-14T18:44:11Z",
              "updatedAt": "2023-07-14T18:44:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5bPtZx",
          "commit": {
            "abbreviatedOid": "077e22d"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-14T19:01:08Z",
          "updatedAt": "2023-07-14T19:01:09Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Yes, though DAF doesn't need a `Union` since it's fixed to exactly zero rounds. Requiring `ROUNDS > 0` sounds good to me.",
              "createdAt": "2023-07-14T19:01:09Z",
              "updatedAt": "2023-07-14T19:01:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5bP7Jd",
          "commit": {
            "abbreviatedOid": "077e22d"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-14T19:43:21Z",
          "updatedAt": "2023-07-14T19:43:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5bQRO4",
          "commit": {
            "abbreviatedOid": "077e22d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-14T20:21:46Z",
          "updatedAt": "2023-07-14T20:23:13Z",
          "comments": [
            {
              "originalPosition": 412,
              "body": "* Renamed to ping_pong_continued\r\n* Reworked the control flow\r\n* Removed the dead branch",
              "createdAt": "2023-07-14T20:21:46Z",
              "updatedAt": "2023-07-14T20:23:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 265,
      "id": "PR_kwDOGKuqOc5VcC8r",
      "title": "Use pyflakes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/265",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "This runs pyflakes on the proof of concept code in CI, and cleans up some unused imports and variables.",
      "createdAt": "2023-07-13T16:16:21Z",
      "updatedAt": "2023-08-03T18:00:29Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "ff577aa70e08c171b10b7f69523b58cdb05750cb",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/pyflakes",
      "headRefOid": "cbfbafcfbcf0895ac77e698642ee593dae62ee03",
      "closedAt": "2023-07-13T16:25:56Z",
      "mergedAt": "2023-07-13T16:25:56Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "4bc449d830e5713488977c856e643675017a01fe"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5bH8p3",
          "commit": {
            "abbreviatedOid": "1431685"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-13T16:18:54Z",
          "updatedAt": "2023-07-13T16:19:02Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Can you make sure the draft is updated accordingly?",
              "createdAt": "2023-07-13T16:18:54Z",
              "updatedAt": "2023-07-13T16:19:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5bH-h5",
          "commit": {
            "abbreviatedOid": "cbfbafc"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\u2764\ufe0f ",
          "createdAt": "2023-07-13T16:23:50Z",
          "updatedAt": "2023-07-13T16:23:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 267,
      "id": "PR_kwDOGKuqOc5Vjrwa",
      "title": "Use verbs for API calls (#260)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/267",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "Closes #260.\r\n\r\nRename:\r\n* measurement_to_input_shares -> shard\r\n* out_shares_to_agg_share -> aggregate\r\n* agg_shares_to_result -> unshard",
      "createdAt": "2023-07-14T21:00:07Z",
      "updatedAt": "2023-08-03T17:59:58Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "a0ee768faaa6c9b4b186e7d6c82292f31d9e81b1",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/260",
      "headRefOid": "029878d6c38247b196240967b7b1c99b23775cd4",
      "closedAt": "2023-07-14T21:32:34Z",
      "mergedAt": "2023-07-14T21:32:34Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "e5c45e17269720071b3f7290057c3d15d521cc48"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "cc/ @wangshan ",
          "createdAt": "2023-07-14T21:00:22Z",
          "updatedAt": "2023-07-14T21:00:22Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> Love the new terminology.\r\n\r\nIIRC you came up with the terminology! I just don't remember why we didn't use it in the VDAF syntax ...",
          "createdAt": "2023-07-14T21:26:29Z",
          "updatedAt": "2023-07-14T21:26:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5bQhlJ",
          "commit": {
            "abbreviatedOid": "e9c2ddc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Love the new terminology.",
          "createdAt": "2023-07-14T21:16:12Z",
          "updatedAt": "2023-07-14T21:16:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 268,
      "id": "PR_kwDOGKuqOc5VjwyQ",
      "title": "Clarify the purpose using multiple gadgets (#256)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/268",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "Closes #256.\r\n\r\nSay that this is intended to make circuit design more flexible. While at it, give a slightly more realistic example.\r\n\r\ncc/ @wangshan ",
      "createdAt": "2023-07-14T21:18:35Z",
      "updatedAt": "2024-05-01T20:18:19Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "a0ee768faaa6c9b4b186e7d6c82292f31d9e81b1",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/256",
      "headRefOid": "ed6afcbb62cccc687a5c12903af167486fde344b",
      "closedAt": "2023-07-14T21:24:46Z",
      "mergedAt": "2023-07-14T21:24:46Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "c8cd0ed8fe30df4727e4bdc975f439f00238682a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5bQjuY",
          "commit": {
            "abbreviatedOid": "ed6afcb"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-14T21:24:10Z",
          "updatedAt": "2023-07-14T21:24:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 269,
      "id": "PR_kwDOGKuqOc5Vj77A",
      "title": "Rename `Vdaf.Prep` to `PrepState` (#255)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/269",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "Partially addresses #255.\r\n\r\ncc/ @wangshan ",
      "createdAt": "2023-07-14T22:09:30Z",
      "updatedAt": "2024-05-01T20:18:19Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "e5c45e17269720071b3f7290057c3d15d521cc48",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/255/1/PrepState",
      "headRefOid": "43657d67d6f419625b8cd59be9fd4b42b4edfb79",
      "closedAt": "2023-07-18T15:22:14Z",
      "mergedAt": "2023-07-18T15:22:14Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "0e7ed7e79048175057098007fbc59306dbb8e666"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5bgSbi",
          "commit": {
            "abbreviatedOid": "43657d6"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-18T14:34:01Z",
          "updatedAt": "2023-07-18T14:34:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 270,
      "id": "PR_kwDOGKuqOc5VkHmW",
      "title": "Add nonce to `Daf` API (#259)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/270",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "Partially addresses #259 \r\ncc/ @wangshan \r\n\r\nHarmonize by `Daf` with `Vdaf` by adding a nonce to the API. Now all stages of execution are identical except for preparation.\r\n\r\nThis may also be useful for using IDPF as a standalone `Daf`. In `Poplar`, we pass the nonce to the IDPF.",
      "createdAt": "2023-07-14T23:05:16Z",
      "updatedAt": "2024-05-01T20:18:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "e5c45e17269720071b3f7290057c3d15d521cc48",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/259/1/daf-nonce",
      "headRefOid": "c21810378cee107ba4044a273bdd5f46c00003d5",
      "closedAt": "2023-07-15T00:02:28Z",
      "mergedAt": "2023-07-15T00:02:27Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "a9080ff4b061407a793827bc87eb86a3617a80a6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5bQ3WL",
          "commit": {
            "abbreviatedOid": "254db66"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-14T23:12:08Z",
          "updatedAt": "2023-07-14T23:23:44Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "```suggestion\r\n    for (measurement, nonce) in zip(measurements, nonces):\r\n```",
              "createdAt": "2023-07-14T23:12:08Z",
              "updatedAt": "2023-07-14T23:23:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 271,
      "id": "PR_kwDOGKuqOc5VkRR0",
      "title": "Disambiguate \"input\" and \"measurement\" (#217)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/271",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "Closes #217.\r\n\r\n\"input\" refers to:\r\n* a measurement (we write both \"input\" and \"measurement\")\r\n* input to the validity circuit in `Flp` (we write \"input\" for the plaintext value and \"measurement share\" for the secret-shared value)\r\n* input share as in `Vdaf` (we are consistent here)\r\n* IDPF to `Idpf` (we are also consistent here)\r\n\r\nResolve the ambiguities by:\r\n* always calling a measurement (i.e., the input to the protocol) a measurement\r\n* always call the input to the validity circuit a measurement",
      "createdAt": "2023-07-15T00:04:32Z",
      "updatedAt": "2024-05-01T20:18:26Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "cfe4aee531bd3ec49549839322be6194ecc4ce2c",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/217",
      "headRefOid": "b4e658c353e0533126c5ab4afdea1f692321f5d5",
      "closedAt": "2023-07-19T22:59:45Z",
      "mergedAt": "2023-07-19T22:59:45Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "5ec5721885a35485fdfdeb56141763b7f1e6ab23"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased and squashed.",
          "createdAt": "2023-07-19T22:40:43Z",
          "updatedAt": "2023-07-19T22:40:43Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5bh1bM",
          "commit": {
            "abbreviatedOid": "b04d9c9"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-18T17:38:46Z",
          "updatedAt": "2023-07-18T20:53:29Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "I'd argue that this function and the Mul and PolyEval gadgets below shouldn't be changed like so. The argument could well be an intermediate value from the circuit, and not even a component of the measurement.",
              "createdAt": "2023-07-18T17:38:46Z",
              "updatedAt": "2023-07-18T20:53:29Z"
            },
            {
              "originalPosition": 245,
              "body": "```suggestion\r\n        Instantiate an instace of the `Sum` circuit for measurements in range `[0,\r\n```",
              "createdAt": "2023-07-18T17:52:47Z",
              "updatedAt": "2023-07-18T20:53:29Z"
            },
            {
              "originalPosition": 53,
              "body": "nit: grammar\r\n```suggestion\r\nmeasurements that would otherwise garble the result of the computation can be\r\n```",
              "createdAt": "2023-07-18T17:56:54Z",
              "updatedAt": "2023-07-18T20:53:29Z"
            },
            {
              "originalPosition": 123,
              "body": "I think we're making this change elsewhere in the document\r\n```suggestion\r\nbefore they can begin preparing the measurement shares for aggregation.\r\n```",
              "createdAt": "2023-07-18T18:01:41Z",
              "updatedAt": "2023-07-18T20:53:29Z"
            },
            {
              "originalPosition": 201,
              "body": "We should either say this or \"measurement and proof shares\", but I think the below is clearer.\r\n```suggestion\r\nperforms some a computation on its measurement share and proof share locally and\r\n```",
              "createdAt": "2023-07-18T19:50:47Z",
              "updatedAt": "2023-07-18T20:53:30Z"
            },
            {
              "originalPosition": 270,
              "body": "Unrelated to this PR: this is backwards, and contradictory to the definition of `Flp.decide()`.\r\n```suggestion\r\nthe FLP system ensures that the verifier message reveals nothing about the measurement\r\nother than whether it is valid. Therefore, to decide if a measurement is valid, the\r\n```",
              "createdAt": "2023-07-18T20:04:59Z",
              "updatedAt": "2023-07-18T20:53:30Z"
            },
            {
              "originalPosition": 375,
              "body": "For clarity:\r\n```suggestion\r\nencoded measurement to the length of the aggregated output:\r\n```",
              "createdAt": "2023-07-18T20:35:33Z",
              "updatedAt": "2023-07-18T20:53:30Z"
            },
            {
              "originalPosition": 920,
              "body": "Technically, the  index makes up the entirety of the measurement\r\n```suggestion\r\nThe Client's measurement is an IDPF index, denoted `alpha`. The\r\n```\r\n\r\n```suggestion\r\nThe Client's measurement is interpreted as an IDPF index, denoted `alpha`. The\r\n```",
              "createdAt": "2023-07-18T20:53:17Z",
              "updatedAt": "2023-07-18T20:53:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5bjdni",
          "commit": {
            "abbreviatedOid": "b04d9c9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-18T23:21:38Z",
          "updatedAt": "2023-07-18T23:21:38Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "Fair enough. I was thinking something like \"function of the encoded measurement\", but I think that's confusing. Fixed.",
              "createdAt": "2023-07-18T23:21:38Z",
              "updatedAt": "2023-07-18T23:21:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5bqlhT",
          "commit": {
            "abbreviatedOid": "236a19e"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-19T19:29:58Z",
          "updatedAt": "2023-07-19T21:18:38Z",
          "comments": [
            {
              "originalPosition": 201,
              "body": "nit: extra word (not introduced by this PR)\r\n```suggestion\r\nperforms some computation on its measurement share and proof share locally and\r\n```",
              "createdAt": "2023-07-19T19:29:58Z",
              "updatedAt": "2023-07-19T21:18:38Z"
            },
            {
              "originalPosition": 650,
              "body": "This instance needs to be changed as well\r\n```suggestion\r\nbut if `meas[j]` is not in `[0,2)` for some `j`, the output will be non-zero\r\n```",
              "createdAt": "2023-07-19T21:16:19Z",
              "updatedAt": "2023-07-19T21:18:38Z"
            },
            {
              "originalPosition": 719,
              "body": "This looks like a find-replace mistake\r\n```suggestion\r\nOn input of `meas`, `prove_rand`, and `joint_rand`, the proof is computed as\r\n```",
              "createdAt": "2023-07-19T21:17:17Z",
              "updatedAt": "2023-07-19T21:18:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 272,
      "id": "PR_kwDOGKuqOc5V0C6K",
      "title": "run_vdaf(): Avoid branching on `Vdaf.ROUNDS` (#223)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/272",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "Closes #223.\r\ncc/ @chris-wood ",
      "createdAt": "2023-07-18T18:00:59Z",
      "updatedAt": "2024-05-01T20:18:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "0e7ed7e79048175057098007fbc59306dbb8e666",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/223",
      "headRefOid": "4b9791bf57c42a2026e69ac34996bdb11af7dac9",
      "closedAt": "2023-07-19T21:35:30Z",
      "mergedAt": "2023-07-19T21:35:30Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "cfe4aee531bd3ec49549839322be6194ecc4ce2c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5biCxy",
          "commit": {
            "abbreviatedOid": "597d5e7"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-18T18:17:25Z",
          "updatedAt": "2023-07-18T18:21:35Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I assume that the `# REMOVE ME` bits are purposefully not reflected in the final \"post-loop\" iteration on L227-233, but flagging this just in case.",
              "createdAt": "2023-07-18T18:21:31Z",
              "updatedAt": "2023-07-18T18:21:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5biO1m",
          "commit": {
            "abbreviatedOid": "597d5e7"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-18T18:48:29Z",
          "updatedAt": "2023-07-18T18:48:30Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Great catch! This is a bug actually, we weren't producing the test vectors properly. Fixed and verified that the test vectors haven't changed.",
              "createdAt": "2023-07-18T18:48:29Z",
              "updatedAt": "2023-07-18T18:48:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5bp0q2",
          "commit": {
            "abbreviatedOid": "70c7f29"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-19T18:02:20Z",
          "updatedAt": "2023-07-19T18:09:44Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "nit: grammar (this PR just moves this comment)\r\n```suggestion\r\n        # The final outputs of the prepare phase are the output shares.\r\n```",
              "createdAt": "2023-07-19T18:02:21Z",
              "updatedAt": "2023-07-19T18:09:44Z"
            },
            {
              "originalPosition": 17,
              "body": "See change on poc/vdaf.py\r\n```suggestion\r\n        # The final outputs of the prepare phase are the output shares.\r\n```",
              "createdAt": "2023-07-19T18:03:40Z",
              "updatedAt": "2023-07-19T18:09:44Z"
            },
            {
              "originalPosition": 35,
              "body": "This should have another blank line, only one statement is excluded from the document.\r\n```suggestion\r\n        # REMOVE ME\r\n        prep_test_vec['prep_messages'].append(prep_msg.hex())\r\n\r\n        outbound = []\r\n```",
              "createdAt": "2023-07-19T18:06:23Z",
              "updatedAt": "2023-07-19T18:09:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 275,
      "id": "PR_kwDOGKuqOc5W9gyV",
      "title": "Require type definitions for encoded values",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/275",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "Closes #58.\r\nPartially addresses #255 (see TODOs)\r\nPartially addresses #222\r\n\r\nThe current convention for the `Daf` and `Vdaf` interfaces is to any value that must be written to the network in order to carry out the computation as an opaque byte string (type `bytes`). This includes the public share, input share, prep share, prep message, and aggregate share. These values implicitly have type `bytes` and thus their types don't appear in the interface.\r\n\r\nThis mixture of explicit and implicit types makes the interface confusing. At the same time, the current adhoc approach to specifying encoding of types is hard to understand.\r\n\r\nThis commit requires (V)DAF to specify explicit types for all previously implicitly-`bytes` types. Furthermore, it RECOMMENDS that concrete (V)DAFs specify encodings for these. Finally, this change:\r\n\r\n* Replaces the corresponding types for Prio3 and Poplar1 with more explicit types.\r\n* Moves the previous encodings to their own sections and replaces the adhoc methods with TLS syntax.",
      "createdAt": "2023-08-02T01:26:53Z",
      "updatedAt": "2024-05-01T20:18:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "7fce26b73876a10d0fac5adfca3eb7da6e5deeaa",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/255/2/Prio3",
      "headRefOid": "b1c2dff9afb8658fb21c8f989446bb9cf0cdb932",
      "closedAt": "2023-08-16T01:39:07Z",
      "mergedAt": "2023-08-16T01:39:07Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "120b7676cd8f52b9eda15b605fcef006373c3c38"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch, will fix before merging. ",
          "createdAt": "2023-08-04T18:21:57Z",
          "updatedAt": "2023-08-04T18:21:57Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds like folks still like this change, so we'll go ahead with it. Once it's approved I'll merge.",
          "createdAt": "2023-08-08T16:31:04Z",
          "updatedAt": "2023-08-08T16:31:04Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Squashed.",
          "createdAt": "2023-08-16T01:10:59Z",
          "updatedAt": "2023-08-16T01:10:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5c-nCb",
          "commit": {
            "abbreviatedOid": "2b2dc19"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This is much easier to follow IMO, nice change!",
          "createdAt": "2023-08-02T22:16:42Z",
          "updatedAt": "2023-08-02T22:59:07Z",
          "comments": [
            {
              "originalPosition": 681,
              "body": "```suggestion\r\n  list[FieldLeaf], binder: bytes, rand: bytes[Idpf.RAND_SIZE]) -> tuple[bytes,\r\n```\r\n(typo nit)",
              "createdAt": "2023-08-02T22:16:43Z",
              "updatedAt": "2023-08-02T22:59:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dEdHj",
          "commit": {
            "abbreviatedOid": "2b2dc19"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I like this change because it makes the specification easier to read and also implement, because I'm less likely to mix up two values of type `PrepShare` and `PrepMessage` than two values both of type `bytes`.\r\n\r\nI'm aware that this VDAF change exists in the context of a broader discussion about how CFRG documents should be written: as a protocol designer and implementer who consumes CFRG documents, I am very much in favor of using explicit types like this.\r\n\r\nThe remaining question is whether it's appropriate for a CFRG document to specify a wire encoding. While it's true that RFC 8446 struct syntax implies a wire encoding for messages, I think it does still allow other encodings. For instance a higher level protocol that builds on VDAF could choose to translate the RFC 8446 structs into JSON messages. ",
          "createdAt": "2023-08-03T16:17:36Z",
          "updatedAt": "2023-08-03T16:30:38Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "```suggestion\r\n| `PrepMessage`     | Type of each prep message. |\r\n```",
              "createdAt": "2023-08-03T16:17:36Z",
              "updatedAt": "2023-08-03T16:30:38Z"
            },
            {
              "originalPosition": 293,
              "body": "For readability, but I'm not sure if Markdown or the RFC renderer will like it:\r\n```suggestion\r\n| `InputShare`      | `tuple[`\r\n|                   | `   Union[`\r\n|                   | `       tuple[list[Flp.Field],list[Flp.Field]],`\r\n|                   | `       tuple[bytes, bytes],`\r\n|                   | `   ],`\r\n|                   | `   Optional[bytes],`\r\n|                   | `]`\r\n```",
              "createdAt": "2023-08-03T16:21:09Z",
              "updatedAt": "2023-08-03T16:30:38Z"
            },
            {
              "originalPosition": 760,
              "body": "```suggestion\r\n| `InputShare`      | `tuple[bytes, bytes, list[Idpf.FieldInner], list[Idpf.FieldLeaf]]` |\r\n```",
              "createdAt": "2023-08-03T16:23:15Z",
              "updatedAt": "2023-08-03T16:30:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dFBAX",
          "commit": {
            "abbreviatedOid": "2b2dc19"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-03T17:52:59Z",
          "updatedAt": "2023-08-03T17:52:59Z",
          "comments": [
            {
              "originalPosition": 293,
              "body": "RFC tools seem to hate this unforutnately.",
              "createdAt": "2023-08-03T17:52:59Z",
              "updatedAt": "2023-08-03T17:52:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dLdrn",
          "commit": {
            "abbreviatedOid": "11ac675"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I'm working on implementing the ping-pong topology in libprio-rs, which has caused me to closely inspect those routines and how they treat the values they work with. I think this PR needs to revisit the ping-pong routines so that they decode inputs and encode outputs. For example, consider the current:\r\n\r\n~~~\r\ndef ping_pong_transition(\r\n            Vdaf,\r\n            agg_param: Vdaf.AggParam,\r\n            prep_shares: Vec[bytes],\r\n            prep_state: Vdaf.PrepState,\r\n         ) -> (State, Message):\r\n    prep_msg = Vdaf.prep_shares_to_prep(agg_param,\r\n                                        prep_shares)\r\n    out = Vdaf.prep_next(prep_state, prep_msg)\r\n    if type(out) == Vdaf.OutShare:\r\n        outbound = Message.finish(prep_msg)\r\n        return (Finished(out), outbound)\r\n    (prep_state, prep_share) = out\r\n    outbound = Message.continue(prep_msg, prep_share)\r\n    return (Continued(prep_state), outbound)\r\n~~~\r\n\r\nNote that the input is `prep_shares: Vec[bytes]`, which cannot be passed to `prep_shares_to_prep`. I think the function would have to decode each `prep_shares` into a `Vdaf.PrepShare` before calling `Vdaf.prep_shares_to_prep`. Similarly, `prep_msg` and `prep_share` need to be encoded into opaque bytes before being put into a `Message` structure.\r\n\r\nSince the ping pong functions are generic over `Vdaf`, then I believe you need to specify generic routines for encoding/decoding the various objects to/from bytes, which would correspond to the concrete encoding/decoding routines that are already in the Prio3 and Poplar1 \"Auxiliary Functions\" sections.",
          "createdAt": "2023-08-04T17:19:56Z",
          "updatedAt": "2023-08-04T17:29:12Z",
          "comments": [
            {
              "originalPosition": 234,
              "body": "```suggestion\r\n* `Vdaf.prep_shares_to_prep(agg_param: AggParam, prep_shares: Vec[PrepShare])\r\n```",
              "createdAt": "2023-08-04T17:19:57Z",
              "updatedAt": "2023-08-04T17:25:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dW-L7",
          "commit": {
            "abbreviatedOid": "eb274ad"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-08T00:25:41Z",
          "updatedAt": "2023-08-08T00:25:41Z",
          "comments": [
            {
              "originalPosition": 289,
              "body": "@tgeoghegan, @branlwyd PTAL at this new bit of normative language and the corresponding changes below.",
              "createdAt": "2023-08-08T00:25:41Z",
              "updatedAt": "2023-08-08T00:25:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dW-eI",
          "commit": {
            "abbreviatedOid": "eb274ad"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-08T00:27:46Z",
          "updatedAt": "2023-08-08T00:27:46Z",
          "comments": [
            {
              "originalPosition": 317,
              "body": "This MUST seems, unfortunately, necessary to me. One open question: how will the ping-pong API extend to other VDAFs that aren't in this document?",
              "createdAt": "2023-08-08T00:27:46Z",
              "updatedAt": "2023-08-08T00:27:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dW-6t",
          "commit": {
            "abbreviatedOid": "eb274ad"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I've fixed up the ping-pong API, as @tgeoghegan suggested. I'd appreciate another look from everyone.\r\n\r\nDoes anyone still feel the spec is easier to understand this way? https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/275/files#r1286486411 is a bit unfortunate. I was supportive of this PR before, but I'm starting to think the spec is more complex now.\r\n\r\nI would be in favor of going back to treating the public share, input share, prep share, and prep messages as byte strings, _but_ specifying them in TLS syntax rather than with adhoc methods. ",
          "createdAt": "2023-08-08T00:30:44Z",
          "updatedAt": "2023-08-08T00:30:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5dX_Gi",
          "commit": {
            "abbreviatedOid": "eb274ad"
          },
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I think it makes the spec easier to understand for me. Some comments and suggestions inline.\r\n\r\n> Does anyone still feel the spec is easier to understand this way?\r\n\r\nYes. I think the message definition is clearer in each VDAF after this PR. Before this PR one would have to dig the auxiliary functions to find out the type definition. I see ping-pong APIs as a way to facilitate the network communication, by serializing and deserializing messages in and out of the VDAF. Correct me if I'm wrong.\r\n\r\n> I would be in favor of going back to treating the public share, input share, prep share, and prep messages as byte strings, but specifying them in TLS syntax rather than with adhoc methods.\r\n\r\nWill this require a VDAF to use TLS encoding for all its messages, i.e. one has to embed length prefix in the serialized message? I don't think VDAF messages should be forced to use TLS encoding. The current encoding/decoding interface for each type uses some \"decoding context\" (combination of the initialized VDAF and also `PrepState`), which should be extensible to other VDAFs. I think either way works, using the latter probably saves a couple of bytes in network transmission, but not sure if that's a strong argument yet...",
          "createdAt": "2023-08-08T06:35:47Z",
          "updatedAt": "2023-08-08T10:26:40Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "nit: the rest of the document is using `bytes[...]`.",
              "createdAt": "2023-08-08T06:35:47Z",
              "updatedAt": "2023-08-08T10:26:40Z"
            },
            {
              "originalPosition": 147,
              "body": "nit: There are two `PrepState` here.",
              "createdAt": "2023-08-08T06:36:27Z",
              "updatedAt": "2023-08-08T10:26:40Z"
            },
            {
              "originalPosition": 222,
              "body": "maybe not necessary in this PR, but will defining an explicit return type for this function be more readable?  Something like `Message` and `MessageType`. This can avoid the awkwardness of doing a type comparison in the `ping_pong_*` functions.",
              "createdAt": "2023-08-08T07:24:26Z",
              "updatedAt": "2023-08-08T10:26:40Z"
            },
            {
              "originalPosition": 294,
              "body": "Aggregator ID shouldn't be needed in decoding context, because public share is one per client?",
              "createdAt": "2023-08-08T08:31:08Z",
              "updatedAt": "2023-08-08T10:26:40Z"
            },
            {
              "originalPosition": 368,
              "body": "There doesn't seem to be a definition of `State` in this document yet.",
              "createdAt": "2023-08-08T08:46:31Z",
              "updatedAt": "2023-08-08T10:26:40Z"
            },
            {
              "originalPosition": 395,
              "body": "Why not replace `1` with `MessageType.continue`?",
              "createdAt": "2023-08-08T09:10:11Z",
              "updatedAt": "2023-08-08T10:26:40Z"
            },
            {
              "originalPosition": 691,
              "body": "could we reuse `Prio3LeaderShare` for the first two fields, and similarly `Prio3HelperShare` in `Prio3HelperShareWithJointRand`?",
              "createdAt": "2023-08-08T09:21:47Z",
              "updatedAt": "2023-08-08T10:26:40Z"
            },
            {
              "originalPosition": 655,
              "body": "```suggestion\r\nFinally, when joint randomness is not used, the Helpers' shares are structured\r\n```",
              "createdAt": "2023-08-08T09:24:51Z",
              "updatedAt": "2023-08-08T10:26:40Z"
            },
            {
              "originalPosition": 625,
              "body": "```suggestion\r\nJust as for the public share, the encoding of the input shares depends on\r\n```",
              "createdAt": "2023-08-08T09:32:29Z",
              "updatedAt": "2023-08-08T10:26:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dbj9Y",
          "commit": {
            "abbreviatedOid": "eb274ad"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-08T14:55:06Z",
          "updatedAt": "2023-08-08T14:55:06Z",
          "comments": [
            {
              "originalPosition": 294,
              "body": "You're right, great catch!",
              "createdAt": "2023-08-08T14:55:06Z",
              "updatedAt": "2023-08-08T14:55:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dcPhN",
          "commit": {
            "abbreviatedOid": "eb274ad"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-08T16:18:21Z",
          "updatedAt": "2023-08-08T16:18:21Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "Interesting. Feel free to follow up with a PR sketching the alternative you have in mind.",
              "createdAt": "2023-08-08T16:18:21Z",
              "updatedAt": "2023-08-08T16:18:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dcQiB",
          "commit": {
            "abbreviatedOid": "eb274ad"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-08T16:20:27Z",
          "updatedAt": "2023-08-08T16:20:27Z",
          "comments": [
            {
              "originalPosition": 368,
              "body": "Ack. This was intentionally left implicit, but `State` would be a superclass of `Continued` et al.",
              "createdAt": "2023-08-08T16:20:27Z",
              "updatedAt": "2023-08-08T16:20:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dcRqd",
          "commit": {
            "abbreviatedOid": "eb274ad"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-08T16:22:06Z",
          "updatedAt": "2023-08-08T16:22:07Z",
          "comments": [
            {
              "originalPosition": 395,
              "body": "We discussed this a bit in the initial version (https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/240) and decided this was abusing TLS syntax too much.",
              "createdAt": "2023-08-08T16:22:06Z",
              "updatedAt": "2023-08-08T16:22:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dcSw1",
          "commit": {
            "abbreviatedOid": "eb274ad"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-08T16:24:40Z",
          "updatedAt": "2023-08-08T16:24:41Z",
          "comments": [
            {
              "originalPosition": 368,
              "body": "We talked about the lack of a definition of `State`. when ping pong was first added. I've just been working on implementing ping pong in libprio-rs, and I found the implicit definition of the `State` struct to be confusing. I would strongly recommend adding an explicit definition of this enumeration. You will have to do it anyway if you add a ping pong implementation to `poc`. That's not necessarily relevant to this change, though.",
              "createdAt": "2023-08-08T16:24:40Z",
              "updatedAt": "2023-08-08T16:25:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dcVPt",
          "commit": {
            "abbreviatedOid": "a4f55ca"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-08T16:28:24Z",
          "updatedAt": "2023-08-08T16:28:24Z",
          "comments": [
            {
              "originalPosition": 691,
              "body": "That's a good idea. One annoyance is that we'd have to name the field, so instead of \r\n`leader_share.meas_share` we'd refer to `leader_share.inner.meas_share`:\r\n\r\n```\r\nstruct {\r\n    Prio3LeaderShare inner;\r\n    Prio3Seed k_blind;\r\n} Prio3LeaderShareWithJointRand;\r\n```\r\n\r\nBut I think the dedup is really nice so I took your suggestion.\r\n\r\n",
              "createdAt": "2023-08-08T16:28:24Z",
              "updatedAt": "2023-08-08T16:28:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dcWaM",
          "commit": {
            "abbreviatedOid": "eb274ad"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-08T16:30:24Z",
          "updatedAt": "2023-08-08T16:30:25Z",
          "comments": [
            {
              "originalPosition": 368,
              "body": "@tgeoghegan can you send a PR please?",
              "createdAt": "2023-08-08T16:30:25Z",
              "updatedAt": "2023-08-08T16:30:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ddDRe",
          "commit": {
            "abbreviatedOid": "eb274ad"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-08T18:23:34Z",
          "updatedAt": "2023-08-08T18:23:35Z",
          "comments": [
            {
              "originalPosition": 368,
              "body": "Sure -- I will need to make some DAP changes to catch up with the current ping pong wrapper definitions anyway, and I think I might have a VDAF tweak or two to make.",
              "createdAt": "2023-08-08T18:23:34Z",
              "updatedAt": "2023-08-08T18:23:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ddYdr",
          "commit": {
            "abbreviatedOid": "be3531f"
          },
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Have one more suggestion for you to consider, but otherwise LGTM.",
          "createdAt": "2023-08-08T19:21:37Z",
          "updatedAt": "2023-08-08T19:35:52Z",
          "comments": [
            {
              "originalPosition": 760,
              "body": "nit: here is another opportunity to reuse `Prio3PrepShare`, similar to `Prio3LeaderShare`.",
              "createdAt": "2023-08-08T19:21:37Z",
              "updatedAt": "2023-08-08T19:35:52Z"
            },
            {
              "originalPosition": 553,
              "body": "I think the intent is to map each field in the TLS struct to a variable, but it might be confusing to some people. Is it better to use field name to access each variable. For input share, it's more annoying that you have to condition based on leader or helper here. Will something like this be better?\r\n\r\n```\r\nif agg_id > 0:\r\n    # helper, `input_share` is a `Prio3HelperShareWithJointRand`.\r\n    meas_share, proof_share, k_blind = input_share.meas_share, input_share.proof_share, input_share.k_blind\r\n    meas_share = Prio3.helper_meas_share(agg_id, meas_share)\r\n    proof_share = Prio3.helper_proof_share(agg_id, proof_share)\r\nelse:\r\n    # leader, `input_share` is a `Prio3LeaderShareWithJointRand`.\r\n    meas_share, proof_share, k_blind = input_share.meas_share, input_share.proof_share, input_share.k_blind\r\nreturn (meas_share, proof_share, k_blind)\r\n```",
              "createdAt": "2023-08-08T19:35:07Z",
              "updatedAt": "2023-08-08T19:35:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5degTn",
          "commit": {
            "abbreviatedOid": "be3531f"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "There are some issues with how this uses the TLS presentation language, most notably a classic case of vector lengths needing to count the number of bytes, not the number of nested messages. I think we also need to re-emphasize that field elements are little-endian, because TLS says multi-byte values are serialized in big-endian order. We don't thus far have a TLS-level declaration for a field element -- `opaque[ENCODED_LEN] Field;` may help.\r\n\r\nMore generally, I think that the TLS presentation language syntax is not adding much for our use case, at least beyond the ping-pong messages. We mainly use it to express concatenation, and we do very little nesting of structures. Much of the serialization formats lives in the prose gluing different structures for different cases together, especially when types are represented by the empty string.\r\n\r\nAs an alternative approach to achieve our clarity goals, we could replace the anonymous tuple types we use with named structures/classes in pseudocode/Python, and then give imperative encoding and decoding routines. This would allow us to show how the decoding context arguments are used, and would let us represent the different cases (particularly for Poplar1) more concisely and precisely.",
          "createdAt": "2023-08-08T21:37:17Z",
          "updatedAt": "2023-08-09T17:42:33Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": "nit: copy-paste error\r\n```suggestion\r\nof the `Vdaf` interface specify a method of encoding the `PublicShare`,\r\n```",
              "createdAt": "2023-08-08T21:37:17Z",
              "updatedAt": "2023-08-09T17:42:33Z"
            },
            {
              "originalPosition": 392,
              "body": "nit: this outer call doesn't make sense\r\n```suggestion\r\n        prep_msg = Vdaf.decode_prep_msg(state.prep_state, inbound.prep_msg)\r\n```",
              "createdAt": "2023-08-08T22:32:44Z",
              "updatedAt": "2023-08-09T17:42:33Z"
            },
            {
              "originalPosition": 413,
              "body": "The actual type we use below doesn't nest tuples, and is instead `Union[tuple[list[Flp.Field], list[Flp.Field], Optional[bytes]], tuple[bytes, bytes, Optional[bytes]]]`.",
              "createdAt": "2023-08-08T22:42:45Z",
              "updatedAt": "2023-08-09T17:42:33Z"
            },
            {
              "originalPosition": 478,
              "body": "I think renaming this argument is less clear. We could reassign it inside the method instead, with `k_joint_rand_parts = public_share`, to convey both interpretations.",
              "createdAt": "2023-08-08T22:47:35Z",
              "updatedAt": "2023-08-09T17:42:33Z"
            },
            {
              "originalPosition": 498,
              "body": "Same here, I would suggest `k_joint_rand = prep_msg`.",
              "createdAt": "2023-08-08T22:51:42Z",
              "updatedAt": "2023-08-09T17:42:33Z"
            },
            {
              "originalPosition": 544,
              "body": "The `aggregate()` method above this should be modified to return the aggregate share without encoding it first.",
              "createdAt": "2023-08-09T13:22:18Z",
              "updatedAt": "2023-08-09T17:42:33Z"
            },
            {
              "originalPosition": 574,
              "body": "It might be worth adding another reference to RFC 8446 section 3 at the top of each message serialization section. (We already reference it in the ping pong topology section)",
              "createdAt": "2023-08-09T13:33:49Z",
              "updatedAt": "2023-08-09T17:42:33Z"
            },
            {
              "originalPosition": 650,
              "body": "We should make it extra clear that field elements are encoded in little-endian byte order, because RFC 8446 section 3.1 says multi-byte values are transmitted in big-endian byte order. Moreover, field elements don't appear to have a TLS presentation language definition. (though we do define to_le_bytes/from_le_bytes/encode_vec/decode_vec procedures)",
              "createdAt": "2023-08-09T13:47:51Z",
              "updatedAt": "2023-08-09T17:42:34Z"
            },
            {
              "originalPosition": 655,
              "body": "This is only the second of four cases\r\n```suggestion\r\nWhen joint randomness is not used, the Helpers' shares are structured\r\n```",
              "createdAt": "2023-08-09T14:11:26Z",
              "updatedAt": "2023-08-09T17:42:34Z"
            },
            {
              "originalPosition": 650,
              "body": "RFC 8446 section 3.4 says that the length in square brackets is \"the number of bytes, not the number of elements, in the vector.\" It also says the length can be \"left unspecified until runtime\" -- that may be a better option for us, as currently the lengths we use are misleading. (See `UncompressedPointRepresentation` for an example)",
              "createdAt": "2023-08-09T14:33:47Z",
              "updatedAt": "2023-08-09T17:42:34Z"
            },
            {
              "originalPosition": 882,
              "body": "This tuple is missing a number in the middle for the level.",
              "createdAt": "2023-08-09T15:50:07Z",
              "updatedAt": "2023-08-09T17:42:34Z"
            },
            {
              "originalPosition": 906,
              "body": "nit: simplification\r\n```suggestion\r\n    input_shares = list(zip(keys, corr_seed, corr_inner, corr_leaf))\r\n```",
              "createdAt": "2023-08-09T16:04:47Z",
              "updatedAt": "2023-08-09T17:42:34Z"
            },
            {
              "originalPosition": 950,
              "body": "Same as above, I'd prefer to keep the argument named `prep_msg`.",
              "createdAt": "2023-08-09T16:15:19Z",
              "updatedAt": "2023-08-09T17:42:34Z"
            },
            {
              "originalPosition": 1136,
              "body": "This seems redundant\r\n```suggestion\r\n```",
              "createdAt": "2023-08-09T16:58:26Z",
              "updatedAt": "2023-08-09T17:42:34Z"
            },
            {
              "originalPosition": 1139,
              "body": "nit: grammar\r\n```suggestion\r\nLikewise, the structure of the prep message for Poplar1 depends on the sketching\r\n```",
              "createdAt": "2023-08-09T16:58:56Z",
              "updatedAt": "2023-08-09T17:42:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5eCidV",
          "commit": {
            "abbreviatedOid": "566d51c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-14T22:09:48Z",
          "updatedAt": "2023-08-14T23:04:52Z",
          "comments": [
            {
              "originalPosition": 553,
              "body": "The intent is to make sure the meas_share and proof_share are expanded, hence the name. We could expand it out, as you suggest, but this would happen in two different places. I think it's best to deduplicate code where we can.",
              "createdAt": "2023-08-14T22:09:48Z",
              "updatedAt": "2023-08-14T23:04:52Z"
            },
            {
              "originalPosition": 650,
              "body": "Good catch, done I decided to fully specify lengths, which seems more appropriate here. (In this particular example, TLS has to treat this an opaque blob with an unknown length because it has to deal with the fact that extensions might add new EC fields. In our case, the lengths are determined by the  implementation of `Flp`)",
              "createdAt": "2023-08-14T22:50:00Z",
              "updatedAt": "2023-08-14T23:04:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5eItFl",
          "commit": {
            "abbreviatedOid": "566d51c"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-08-15T20:08:29Z",
          "updatedAt": "2023-08-15T21:23:48Z",
          "comments": [
            {
              "originalPosition": 393,
              "body": "This is fine as pseudocode, but as an FYI, this won't work in actual Python. The left hand side is `<class 'tuple'>`, while the right hand side is an instance of `types.GenericAlias`. The collection types are fully dynamic to begin with, and everything in the `types` module is meant for static analysis, not RTTI.",
              "createdAt": "2023-08-15T20:08:29Z",
              "updatedAt": "2023-08-15T21:23:48Z"
            },
            {
              "originalPosition": 599,
              "body": "This should probably be `opaque`, as it is uninterpreted bytes rather than a series of numbers, semantically.\r\n```suggestion\r\nopaque Prio3Seed[S];\r\n```",
              "createdAt": "2023-08-15T20:29:07Z",
              "updatedAt": "2023-08-15T21:23:48Z"
            },
            {
              "originalPosition": 622,
              "body": "Likewise\r\n```suggestion\r\nopaque Prio3Field[F];\r\n```",
              "createdAt": "2023-08-15T20:29:21Z",
              "updatedAt": "2023-08-15T21:23:48Z"
            },
            {
              "originalPosition": 618,
              "body": "nit: typo\r\n```suggestion\r\nField elements are encoded in little-endian byte order (as defined in\r\n```",
              "createdAt": "2023-08-15T20:59:44Z",
              "updatedAt": "2023-08-15T21:23:48Z"
            },
            {
              "originalPosition": 1064,
              "body": "Likewise\r\n```suggestion\r\nopaque Poplar1Seed[S];\r\n```",
              "createdAt": "2023-08-15T21:12:04Z",
              "updatedAt": "2023-08-15T21:23:48Z"
            },
            {
              "originalPosition": 1110,
              "body": "```suggestion\r\nopaque Poplar1FieldInner[Fi];\r\n~~~\r\n\r\nLikewise, elements of the leaf field are encoded in little-endian byte order\r\n(as defined in {{field}}) and are represented as follows:\r\n\r\n~~~\r\nopaque Poplar1FieldLeaf[Fl];\r\n```",
              "createdAt": "2023-08-15T21:12:35Z",
              "updatedAt": "2023-08-15T21:23:48Z"
            },
            {
              "originalPosition": 1124,
              "body": "```suggestion\r\n    opaque idpf_key[Poplar1.Idpf.KEY_SIZE];\r\n```",
              "createdAt": "2023-08-15T21:13:31Z",
              "updatedAt": "2023-08-15T21:23:48Z"
            },
            {
              "originalPosition": 1192,
              "body": "These paragraphs seem a little confusing, here's a suggested clarification.\r\n```suggestion\r\nNote that these messages have the same structures as the prep shares for the\r\nfirst round.\r\n\r\nThe second-round prep message is the empty string. This is because the sketch\r\nshares are expected to sum to a particular value if the output shares are\r\nvalid; we represent a successful preparation with the empty string and\r\notherwise return an error.\r\n```",
              "createdAt": "2023-08-15T21:20:08Z",
              "updatedAt": "2023-08-15T21:23:48Z"
            },
            {
              "originalPosition": 1198,
              "body": "It's probably worth restating that the choice of field is determined by the aggregation parameter here.\r\n```suggestion\r\nThe encoding of the aggregate share depends on whether the inner or leaf field\r\nis used, and the number of candidate prefixes. Both of these are determined by\r\n the aggregation parameter.\r\n```",
              "createdAt": "2023-08-15T21:22:54Z",
              "updatedAt": "2023-08-15T21:23:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5eJ4xY",
          "commit": {
            "abbreviatedOid": "566d51c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-16T01:00:12Z",
          "updatedAt": "2023-08-16T01:00:12Z",
          "comments": [
            {
              "originalPosition": 393,
              "body": "Ack. @tgeoghegan this may be worth addressing when you try to rework things so that there no invalid states.",
              "createdAt": "2023-08-16T01:00:12Z",
              "updatedAt": "2023-08-16T01:00:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5eJ5Bl",
          "commit": {
            "abbreviatedOid": "566d51c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-16T01:02:04Z",
          "updatedAt": "2023-08-16T01:02:04Z",
          "comments": [
            {
              "originalPosition": 393,
              "body": "Filed https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/283",
              "createdAt": "2023-08-16T01:02:04Z",
              "updatedAt": "2023-08-16T01:02:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5eJ5Hs",
          "commit": {
            "abbreviatedOid": "f4d5c04"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-16T01:02:49Z",
          "updatedAt": "2023-08-16T01:08:56Z",
          "comments": [
            {
              "originalPosition": 599,
              "body": "Done, here and elsewhere.",
              "createdAt": "2023-08-16T01:02:49Z",
              "updatedAt": "2023-08-16T01:08:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 276,
      "id": "PR_kwDOGKuqOc5XDG-D",
      "title": "Add Prio3SumVec",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/276",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "This introduces the ParallelSum gadget and uses it in Prio3SumVec, which computes sums of vectors of integers.\r\n\r\nThis differs from the `Prio3SumVec` implementation that's been in libprio-rs for a while in three respects. First, the chunk length is now an explicit parameter, rather than being floor(sqrt(length * bits)). This both lets us dodge compatibility concerns about how exactly to compute that square root, and provides flexibility to squeeze a few more bytes out by using more optimal chunk length choices. (There are two different kinds of rounding involved in the proof size formula, plus there's a factor of two in front of the rounded number of calls) Second, libprio-rs defined a `BlindPolyEval(x, r) = r * p(x)` gadget for use in this validity circuit, but this PR just uses `Mul(x, y) = x * y` and extra affine gates on the inputs. This lets us keep the gadget's degree at two even when using the parallel sum gadget. We're still calculating the same random linear combination of $\\sum_i {r^{i+1}(x_i^2-x_i)}$. Third, to pad out the inputs to the last ParallelSum invocation, I decided to substitute zero instead of substituting the measurement's last element. I figured that using zeros here is simpler.\r\n\r\nCloses #124.",
      "createdAt": "2023-08-02T21:03:44Z",
      "updatedAt": "2023-08-16T01:52:01Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "7fce26b73876a10d0fac5adfca3eb7da6e5deeaa",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/sum-vec",
      "headRefOid": "9afa6149d59474799002279bc786d7b3490f662f",
      "closedAt": "2023-08-16T01:51:57Z",
      "mergedAt": "2023-08-16T01:51:57Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "e4478dd31a611a40a2ffbcde398b41906f3c1d9f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5c_IzQ",
          "commit": {
            "abbreviatedOid": "f938fcc"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I've only looked at the draft so far, I'll do a pass of the reference code once the draft is a bit more settled. Looking good so far! All comments are non-technical.",
          "createdAt": "2023-08-03T01:20:52Z",
          "updatedAt": "2023-08-03T01:47:24Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nparameters, `length`, `bits`, and `chunk_length`. Each measurement is a vector of positive integers\r\n```",
              "createdAt": "2023-08-03T01:20:53Z",
              "updatedAt": "2023-08-03T01:47:05Z"
            },
            {
              "originalPosition": 23,
              "body": "Orthogonal to this PR, but: WDYTA about using normal exceptions for these kinds of things?\r\n```suggestion\r\n        raise Exception('input: invalid length')\r\n```",
              "createdAt": "2023-08-03T01:26:28Z",
              "updatedAt": "2023-08-03T01:47:05Z"
            },
            {
              "originalPosition": 26,
              "body": "`elem` is reminiscent of \"field element\". \r\n```suggestion\r\n    for val in measurement:\r\n```",
              "createdAt": "2023-08-03T01:27:22Z",
              "updatedAt": "2023-08-03T01:47:05Z"
            },
            {
              "originalPosition": 31,
              "body": "```suggestion\r\n            encoded.append(SumVec.Field((elem >> l) & 1))\r\n```",
              "createdAt": "2023-08-03T01:27:49Z",
              "updatedAt": "2023-08-03T01:47:05Z"
            },
            {
              "originalPosition": 60,
              "body": "* We should assert any necessary preconditions, i.e., `len(inputs)` should be equal to `self.cont * self.subcircuit.ARITY`, correct?\r\n* Would `subgadget` be a more precise term to use? Since it has the an `ARITY` field, we're expecting it to implement the `Gadget` interface.",
              "createdAt": "2023-08-03T01:31:22Z",
              "updatedAt": "2023-08-03T01:47:05Z"
            },
            {
              "originalPosition": 70,
              "body": "\"Rather than use the `Range2` gadget...\" It sounds like you mean to draw a comparison to `Sum`? If so, I'd make this more explicit.",
              "createdAt": "2023-08-03T01:34:22Z",
              "updatedAt": "2023-08-03T01:47:05Z"
            },
            {
              "originalPosition": 76,
              "body": "This parenthetical seems only useful if you're familiar with the (non-standardized) VDAF in libprio-rs with the same name (which we plan to deprecate when we cut the next draft). I'd suggest adding a bit more context here, perhaps describing in greater detail how the \"naive\" approach to parallelizing `Prio3Sum`would work (i.e., what we have in libprio-rs today). Alternatively, we might just cut this.",
              "createdAt": "2023-08-03T01:37:49Z",
              "updatedAt": "2023-08-03T01:47:05Z"
            },
            {
              "originalPosition": 110,
              "body": "* How is `ParallelSum.count` computed from `self.chunk_length`? It looks to me like what we mean to is `len(inputs) / self.chunk_length` (`+1` if there is a partial chunk)\r\n* Hmm, we have a class method called `ParrallelSum` on an undefined class and a constructor for a class called `ParallelSum`. This seems to suggest an odd edge case in how we've been specifying circuits up to this point. This suggests to me that we may want to refactor the API a bit. What do you think about renaming the former to a class method called `call()`?",
              "createdAt": "2023-08-03T01:46:22Z",
              "updatedAt": "2023-08-03T01:47:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dD-0i",
          "commit": {
            "abbreviatedOid": "f938fcc"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-03T15:10:33Z",
          "updatedAt": "2023-08-03T15:10:33Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I think these are fine, our `Error` class subclasses `Exception` from the standard library. It inherits from the right things, and it gets good `repr` formatting for free. We could do `raise Error('input: invalid length')` to provide more granular messages.",
              "createdAt": "2023-08-03T15:10:33Z",
              "updatedAt": "2023-08-03T15:10:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dEIoK",
          "commit": {
            "abbreviatedOid": "f938fcc"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-03T15:31:10Z",
          "updatedAt": "2023-08-03T15:31:10Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/277",
              "createdAt": "2023-08-03T15:31:10Z",
              "updatedAt": "2023-08-03T15:31:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dELwR",
          "commit": {
            "abbreviatedOid": "f938fcc"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-03T15:37:58Z",
          "updatedAt": "2023-08-03T15:37:58Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "The actual implementation includes a call to `check_gadget_eval()`, which compares the input length to the gadget's arity, which is exactly what we need. This is moreso a symptom of us hiding implementation details in our descriptions of gadgets and validity circuits in the document.\r\n\r\nI wanted to avoid calling it a gadget, because it doesn't participate in recording of input wires during evaluation and proof/verification of gadget polynomial consistency. Perhaps we should define a separate `Circuit` interface that both `Valid` and `Gadget` inherit from, that just covers `ARITY`, `DEGREE`, `eval()`, and `eval_poly()`? Edit: validity circuits don't need `eval_poly()`.",
              "createdAt": "2023-08-03T15:37:58Z",
              "updatedAt": "2023-08-03T15:51:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dET-L",
          "commit": {
            "abbreviatedOid": "f938fcc"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-03T15:56:24Z",
          "updatedAt": "2023-08-03T15:56:24Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "The chunk_length VDAF parameter is passed directly through to be `ParallelSum.count`. The gadget's `count` parameter is the number of times it calls the circuit, see the description above. We do that division by chunk_length to decide how many times to call the ParallelSum gadget instead.\r\n\r\nYeah, all the pseudocode for gadgets or validity circuits thus far doesn't match the Python implementation, as they're written as if they are very short functions. The shorthand is breaking down with ParallelSum, since it takes parameters upon its construction, and takes a variable number of input wires. I think making the distinction between the class and the `call()` method under the covers would clear this up.",
              "createdAt": "2023-08-03T15:56:24Z",
              "updatedAt": "2023-08-03T15:56:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dEkdp",
          "commit": {
            "abbreviatedOid": "f938fcc"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-03T16:36:20Z",
          "updatedAt": "2023-08-03T16:36:20Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "My intent was to compare to the `Prio3Sum` circuit, and explain why it isn't in a parallel sum form. I think I'll cut the parenthetical.",
              "createdAt": "2023-08-03T16:36:20Z",
              "updatedAt": "2023-08-03T16:36:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dE5UB",
          "commit": {
            "abbreviatedOid": "f938fcc"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-03T17:32:18Z",
          "updatedAt": "2023-08-03T17:32:18Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Agreed on the first point \ud83d\udc4d \r\n\r\nTo the second point: That's a good point about not overloading the term \"gadget\". Perhaps all that's needed is a comment clarifying that `subcircuit.ARITY` refers to the arity of the gadget that we're parallelizing. I'm wary of making a bigger change this, as it may end up creating more work when we address https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/226.",
              "createdAt": "2023-08-03T17:32:18Z",
              "updatedAt": "2023-08-03T17:32:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dE6Sj",
          "commit": {
            "abbreviatedOid": "f938fcc"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-03T17:34:46Z",
          "updatedAt": "2023-08-03T17:34:46Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Ohhh gotcha, I misunderstood the intent. I think what I would do is have separate paragraph somewhere that is dedicated to contrasting Prio3Sum with Prio3SumVec, perhaps even with its own heading. Totally optional, but I think we're likely to get this question when the CFRG reviews this draft.",
              "createdAt": "2023-08-03T17:34:46Z",
              "updatedAt": "2023-08-03T17:34:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dE7ic",
          "commit": {
            "abbreviatedOid": "f938fcc"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-03T17:37:41Z",
          "updatedAt": "2023-08-03T17:37:42Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "Do you want to take a stab at adding `call()` this PR, or do you think we should do it in a separate PR and rebase? Your call -- I think it's a pretty minor change and impcts the reference code more than the draft,",
              "createdAt": "2023-08-03T17:37:41Z",
              "updatedAt": "2023-08-03T17:37:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dE98d",
          "commit": {
            "abbreviatedOid": "f938fcc"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-03T17:44:27Z",
          "updatedAt": "2023-08-03T17:44:27Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "Yeah, a separate PR sounds like a good idea, I keep finding things I want to clean up. (like fixing shadowing class names with the first parameter to class methods, and moving check_valid_eval etc. to be superclass methods instead of free functions)",
              "createdAt": "2023-08-03T17:44:27Z",
              "updatedAt": "2023-08-03T17:44:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5dnkA2",
          "commit": {
            "abbreviatedOid": "f938fcc"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-09T22:11:54Z",
          "updatedAt": "2023-08-09T22:11:54Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "Rebased over #280",
              "createdAt": "2023-08-09T22:11:54Z",
              "updatedAt": "2023-08-09T22:11:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5eCxeF",
          "commit": {
            "abbreviatedOid": "1d8b37c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-08-14T23:16:36Z",
          "updatedAt": "2023-08-14T23:21:41Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n    def test_vec_set_type_param(Vdaf, test_vec) -> list[str]:\r\n```",
              "createdAt": "2023-08-14T23:16:36Z",
              "updatedAt": "2023-08-14T23:21:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 278,
      "id": "PR_kwDOGKuqOc5XIiPd",
      "title": "Acknowledge Shan",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/278",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "",
      "createdAt": "2023-08-03T18:04:53Z",
      "updatedAt": "2024-05-01T20:18:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "5ec5721885a35485fdfdeb56141763b7f1e6ab23",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/acks",
      "headRefOid": "f62aa3fb7c1ac3a4b89ee10010796f92c0bb3fe1",
      "closedAt": "2023-08-03T18:35:43Z",
      "mergedAt": "2023-08-03T18:35:43Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "45182840303b98eb5c8268e47ddb5dacb925a7ae"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "cc/ @wangshan ",
          "createdAt": "2023-08-03T18:05:06Z",
          "updatedAt": "2023-08-03T18:05:06Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5dFMc6",
          "commit": {
            "abbreviatedOid": "f62aa3f"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-08-03T18:26:15Z",
          "updatedAt": "2023-08-03T18:26:15Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5dFM1b",
          "commit": {
            "abbreviatedOid": "f62aa3f"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-08-03T18:27:18Z",
          "updatedAt": "2023-08-03T18:27:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 279,
      "id": "PR_kwDOGKuqOc5XJTIZ",
      "title": "Add security considerations for fixed-key AES",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/279",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #216.",
      "createdAt": "2023-08-03T21:10:57Z",
      "updatedAt": "2024-07-02T21:50:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "402438c21afceb8352e46e9390345915e14bc430",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "schoppmp/216",
      "headRefOid": "f8b9ce8d1a4115cc1ebab02962dd2b26527c5edf",
      "closedAt": "2023-10-11T18:30:03Z",
      "mergedAt": "2023-10-11T18:30:03Z",
      "mergedBy": "schoppmp",
      "mergeCommit": {
        "oid": "2ed6a6bcf151960a12a114bd1d62ece90a223292"
      },
      "comments": [
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "I didn't add a lot of detail on *why* fixed-key AES implements a correlation-robust hash function, since the proofs in GKWY20 and GKWWY20 are quite technical. @wangxiao1254 do you have a good high-level intuition for this? Also, for DPFs we don't really need circular correlation robustness, right? Does that mean we can avoid the sigma orthomorphism? That would make things simpler, but it probably won't matter for performance, and the only variant that has a formal proof in GKWWY (in the multi-instance setting) is the circular variant. But if there is any other advantage of having CCR here then please let me know.",
          "createdAt": "2023-08-03T21:15:33Z",
          "updatedAt": "2023-08-03T21:15:33Z"
        },
        {
          "author": "wangxiao1254",
          "authorAssociation": "NONE",
          "body": "I will comment on this soon with some intuition on Phillipp's first comment, but note that random-permutation model, where we prove correlation robustness is also an idealized model. orthomorphism can be avoided if circularity is not needed. The main advantage between CCR and RO is that CCR can be constructed using RPM, which is commonly instantiated using fixed-key AES (of course, this final step is not provable, just like how we instantiate SHA for RO).\r\n\r\nI want to quickly note that using fixed-key AES to instantiate random oracle is unconventional. fixed-key AES is invertible while random oracle is not.",
          "createdAt": "2023-08-11T22:09:16Z",
          "updatedAt": "2023-08-11T22:09:16Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I will comment on this soon with some intuition on Phillipp's first comment, but note that random-permutation model, where we prove correlation robustness is also an idealized model. orthomorphism can be avoided if circularity is not needed. The main advantage between CCR and RO is that CCR can be constructed using RPM, which is commonly instantiated using fixed-key AES (of course, this final step is not provable, just like how we instantiate SHA for RO).\r\n\r\nThanks Xiao, we appreciate your feedback. Overall the CFRG is happy to work in idealized models of computation when necessary, but we just need to make clear in the draft what that model is. A bit of intuition about the construction would also be a huge help.\r\n\r\n\r\n> I want to quickly note that using fixed-key AES to instantiate random oracle is unconventional. fixed-key AES is invertible while random oracle is not.\r\n\r\nYup, this is at least clear to the authors of this draft, but we now need to make sure this is clear to anyone who reads this.",
          "createdAt": "2023-08-15T00:14:55Z",
          "updatedAt": "2023-08-15T00:15:12Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Please rebasse and remove the merge commit from the history. It's useful to have a linear commit history when we're getting ready to cut a draft :)",
          "createdAt": "2023-10-05T14:13:35Z",
          "updatedAt": "2023-10-05T14:13:35Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> Please rebasse and remove the merge commit from the history. It's useful to have a linear commit history when we're getting ready to cut a draft :)\r\n\r\nOf course, I always squash the entire PR into a single commit when merging.",
          "createdAt": "2023-10-05T14:26:03Z",
          "updatedAt": "2023-10-05T14:26:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5dLIvA",
          "commit": {
            "abbreviatedOid": "1edeaf5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-04T16:20:59Z",
          "updatedAt": "2023-08-04T16:25:03Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "What about extractability? We used the ROM to prove our IDPF variant extractable in [[DPRS23](https://eprint.iacr.org/2023/130), Lemma 1]. Could we have maybe used correlation robustness instead?",
              "createdAt": "2023-08-04T16:20:59Z",
              "updatedAt": "2023-08-04T16:25:03Z"
            },
            {
              "originalPosition": 40,
              "body": "So this is a computational assumption and not an idealized model of computation, like the ROM?",
              "createdAt": "2023-08-04T16:22:45Z",
              "updatedAt": "2023-08-04T16:25:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5d18qq",
          "commit": {
            "abbreviatedOid": "1edeaf5"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-11T21:58:19Z",
          "updatedAt": "2023-08-11T21:58:20Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Hmm yeah, extractability may in fact be an issue. BBCGGI21 also assume a random oracle for the extractable DPF, although they implement it using fixed-key AES. Now the question is how bad is it if we don't have extractability. One-hotness of the *evaluated* part of the client's vector is ensured through the sketch in BBCGGI21 (or through the technique from [DP22](https://eprint.iacr.org/2021/580.pdf) in the case of Doplar). So the main concern here is the attack described in [[BBCGGI21](https://eprint.iacr.org/2021/017.pdf), Section 4.2]: A client using the fact that fixed-key AES is *not* a random oracle in order to craft a malicious DPF key pair that evaluates to 1 in more than one position, but where the servers only end up evaluating one of these positions. Personally I would feel fine with documenting this, and offering PrgSha3 as an alternative for users who want the additional robustness guarantees that extractability gives them. For privacy both fixed-key AES and SHA-3 should be fine (under the respective assumptions).",
              "createdAt": "2023-08-11T21:58:19Z",
              "updatedAt": "2023-08-11T21:58:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5d1-Ce",
          "commit": {
            "abbreviatedOid": "1edeaf5"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-11T22:03:25Z",
          "updatedAt": "2023-08-11T22:03:25Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Correlation Robustness is just a property of the hash function, that you can prove in a certain model. The fixed-key AES construction is proven to be correlation-robust in the random permutation model [[GKWY20]](https://eprint.iacr.org/2019/074.pdf) for a single fixed key, and the in the ideal cipher model for the multi-instance variant that we use [[GKWWY20]](https://eprint.iacr.org/2019/1168.pdf). So this is more like the ROM, not a computation assumption.",
              "createdAt": "2023-08-11T22:03:25Z",
              "updatedAt": "2023-08-11T22:06:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5eCy2L",
          "commit": {
            "abbreviatedOid": "1edeaf5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-14T23:25:17Z",
          "updatedAt": "2023-08-14T23:25:17Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "In that case I'd add a paranthetical here that says our particular construction is proven secure in the ideal cipher model. ",
              "createdAt": "2023-08-14T23:25:17Z",
              "updatedAt": "2023-08-14T23:25:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5eC5rY",
          "commit": {
            "abbreviatedOid": "1edeaf5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-15T00:11:59Z",
          "updatedAt": "2023-08-15T00:12:00Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "That sounds reasonable, but:\r\n1. We'll need to define a separate codepoint for Poplar1 with SHA-3\r\n2. We'll need to provide concrete guidance (i.e., if attack X is possible, then users MUST choose Poplar1 with SHA-3)\r\n\r\nQuestion: Is there anything about the attack you describe that's not captured by robustness as defined in DPRS23? Do you think that extractability would be needed to prove that Poplar1 is robust?\r\n\r\nFor what it's worth, I'm not sure the analysis of Doplar will be entirely analogous. We use the fact that we can extract from the inputs from the random oracle in order to then do a reduction to DFLP. This initial simplifying step necessary because if we don't know if the IDPF output is onehot, then a DFLP for the sum of the output vector is vacuous. (When we were working on the proof, we couldn't figure out a different assumption about IDPF that would have admitted the same argument.)",
              "createdAt": "2023-08-15T00:12:00Z",
              "updatedAt": "2023-08-15T00:12:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5i16A1",
          "commit": {
            "abbreviatedOid": "1edeaf5"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-04T19:01:31Z",
          "updatedAt": "2023-10-04T19:01:31Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "I added a paragraph talking about extractability and what it means for robustness. Given that the (theoretical) attacks by malicious clients are very limited, I don't think it's necessary to define Poplar1 with SHA-3, and I doubt anyone would actually use it in practice.",
              "createdAt": "2023-10-04T19:01:31Z",
              "updatedAt": "2023-10-04T19:01:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5i17cO",
          "commit": {
            "abbreviatedOid": "1edeaf5"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-04T19:05:07Z",
          "updatedAt": "2023-10-04T19:05:07Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "That part is already there in the next paragraph that talks about our concrete instantiation of the correlation-robust hash function.",
              "createdAt": "2023-10-04T19:05:07Z",
              "updatedAt": "2023-10-04T19:05:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5i8Fzz",
          "commit": {
            "abbreviatedOid": "f919202"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-10-05T13:50:17Z",
          "updatedAt": "2023-10-05T14:12:59Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nusually modeled as random oracles. XofShake128 is designed to be\r\n```",
              "createdAt": "2023-10-05T13:50:17Z",
              "updatedAt": "2023-10-05T14:12:59Z"
            },
            {
              "originalPosition": 48,
              "body": "Do you intend for this to be on its own line? If so, then:\r\n```suggestion\r\n\r\n~~~\r\nPRG(r) = H(xor(r, 1)) || H(xor(r, 2)) || ...`\r\n~~~\r\n\r\n```\r\nIf you want this math to be in-lined, then, make sure lines break at 80 characters.",
              "createdAt": "2023-10-05T14:06:30Z",
              "updatedAt": "2023-10-05T14:12:59Z"
            },
            {
              "originalPosition": 46,
              "body": "```suggestion\r\n`r`, `H(xor(r, x))` is computationally indistinguishable from a random function of `x`.\r\n```",
              "createdAt": "2023-10-05T14:07:10Z",
              "updatedAt": "2023-10-05T14:12:59Z"
            },
            {
              "originalPosition": 59,
              "body": "\r\n```suggestion\r\noracle to make the Idpf extractable. While XofFixedKeyAes128 has been shown\r\n```",
              "createdAt": "2023-10-05T14:08:05Z",
              "updatedAt": "2023-10-05T14:12:59Z"
            },
            {
              "originalPosition": 58,
              "body": "I don't think our analysis applies here, since Doplar requires a stronger IDPF (extractable VIDPF). Our claim is that Poplar1 is robust as-is, due to the arithmetic sketching MPC. Doplar on the other hand would require an extractable VIDPF.\r\n\r\nQuestion: Do {{BBCGGI21}} require a random oracle in order to get their notion of extracability for IdpfPoplar? If so, then it's worth noting that IdpfPoplar is not extractable. ",
              "createdAt": "2023-10-05T14:09:19Z",
              "updatedAt": "2023-10-05T14:12:59Z"
            },
            {
              "originalPosition": 62,
              "body": "```suggestion\r\nWe also stress that been if the Idpf is not extractable, the Poplar1 guarantees\r\n```",
              "createdAt": "2023-10-05T14:09:48Z",
              "updatedAt": "2023-10-05T14:12:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5i8ZrU",
          "commit": {
            "abbreviatedOid": "f919202"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T14:21:43Z",
          "updatedAt": "2023-10-05T14:21:43Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Yes, {{BBCGGI21}} also requires a RO. I'll replace the reference in the text.",
              "createdAt": "2023-10-05T14:21:43Z",
              "updatedAt": "2023-10-05T14:21:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5i8buu",
          "commit": {
            "abbreviatedOid": "f919202"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T14:24:54Z",
          "updatedAt": "2023-10-05T14:24:55Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Fixed.",
              "createdAt": "2023-10-05T14:24:54Z",
              "updatedAt": "2023-10-05T14:24:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jeEE-",
          "commit": {
            "abbreviatedOid": "9a1c5ae"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-10T20:28:28Z",
          "updatedAt": "2023-10-10T20:30:07Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Could we just say this?\r\n```suggestion\r\nAs described in {{xof}}, our constructions rely on eXtendable\r\nOutput Functions (XOFs). In the security analyses of our protocols, these are\r\n```",
              "createdAt": "2023-10-10T20:28:29Z",
              "updatedAt": "2023-10-10T20:30:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 280,
      "id": "PR_kwDOGKuqOc5XJndk",
      "title": "Clean up Gadget, Valid, and Flp APIs, update extracts in document",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/280",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "This makes a variety of changes to the FlpGeneric implementation to simplify things and better follow Python conventions, and then replaces the existing gadget/circuit pseudocode in the document with extracts of the corresponding `eval()` methods. The biggest change is that all the Flp and Valid APIs that were in class methods were moved to plain methods, and the subclass factories were replaced with plain constructors. I renamed several arguments to either avoid upper-case names or shadowing of bindings from outer scopes. (I left `Field` as-is for now, since we also import a module named `field`) I also defined a `Range2` gadget, effectively a specialization of `PolyEval`, so that we can use it in the validity circuits that already claim to use it, and I can extract its `eval()` method into the document.",
      "createdAt": "2023-08-03T23:05:20Z",
      "updatedAt": "2023-08-08T15:44:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "45182840303b98eb5c8268e47ddb5dacb925a7ae",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/valid-gadget-cleanup",
      "headRefOid": "144b41676fc1aaf9f87371734f4b311c9b768405",
      "closedAt": "2023-08-08T15:44:01Z",
      "mergedAt": "2023-08-08T15:44:01Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "7fce26b73876a10d0fac5adfca3eb7da6e5deeaa"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "By the way, I think it will do us a favor later on if we squash this stack into a single commit before merging. ",
          "createdAt": "2023-08-04T20:02:45Z",
          "updatedAt": "2023-08-04T20:02:45Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5dLTgT",
          "commit": {
            "abbreviatedOid": "aa66819"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is much better! Changes to the reference code look correct. One non-blocking comment about `call_poly()`.",
          "createdAt": "2023-08-04T16:48:25Z",
          "updatedAt": "2023-08-04T17:05:44Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "In theory we need not mention `eval_poly()` at all. What is required for `eval()` is that the inputs are all members of the same _ring_, be they field elements or polynomials over the field. For now I'd suggest not mentioning `eval_poly()` and just saying `eval()` either takes in field elements or polynomials over the field. Accordingly, we might remove `Field` from the arguments passed to `eval()` and define the type of `inp`, something like `list[Ring]`.\r\n\r\nOne downside is that this doesn't match the reference code. We _could_ take this one step further, by wrapping sage's ring type with a `Ring` class. But this is probably too much to do right now.... for now I'm fine with the discrepancy because it's a part of the reference implementation that doens't change very much.",
              "createdAt": "2023-08-04T16:50:02Z",
              "updatedAt": "2023-08-04T17:05:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 281,
      "id": "PR_kwDOGKuqOc5XJpA8",
      "title": "Ping-pong topology fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/281",
      "state": "MERGED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "A handful of fixes to the specification of the ping-pong aggregator\r\ncommunication topology encountered during implementation.\r\n\r\n - Explicitly describe Python objects for ping-pong State\r\n - `ping_pong_leader_init` and `_helper_init` return `Message`, not `bytes`\r\n - `ping_pong_transition` always returns a `Message`\r\n - typo in `ping_pong_transition`\r\n - `ping_pong_continued` fails if `state` is not `Continued`\r\n - remove unused `is_leader` parameter from `ping_pong_transition`\r\n",
      "createdAt": "2023-08-03T23:15:57Z",
      "updatedAt": "2023-08-30T22:50:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "86da22906f281e2be69571414774c8c0877469df",
      "headRepository": "tgeoghegan/vdaf",
      "headRefName": "timg/ping-pong-fixes",
      "headRefOid": "b8cfd93d1516e315317a32e30b585ba94959fdf1",
      "closedAt": "2023-08-30T22:50:15Z",
      "mergedAt": "2023-08-30T22:50:15Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "87eb78c6055937de3b664b5d634d44df3d68fb3c"
      },
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Downgrading to draft because I may find other stuff as I implement this and will tack on commits to this PR.",
          "createdAt": "2023-08-03T23:27:17Z",
          "updatedAt": "2023-08-03T23:27:17Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is ready for review now and corresponds to what I have implemented in https://github.com/divviup/libprio-rs/pull/683. There are further changes I'd like to suggest to ping-pong, but more immediately, what I think we should do is review and merge this change, and then make a corresponding change to DAP that adapts to these new definitions. Then we can release DAP-06 and VDAF-07 and have published draft versions we can refer to in implementations. Further refinements to ping-pong can wait for subsequent drafts of the pair of documents.",
          "createdAt": "2023-08-18T17:33:13Z",
          "updatedAt": "2023-08-18T17:33:13Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there's a problem with how aggregation parameters are handled in ping-pong. We have: \r\n\r\n```\r\ndef ping_pong_leader_init(\r\n            Vdaf,\r\n            vdaf_verify_key: bytes[Vdaf.VERIFY_KEY_SIZE],\r\n            agg_param: Vdaf.AggParam,\r\n            nonce: bytes[Vdaf.NONCE_SIZE],\r\n            public_share: bytes,\r\n            input_share: bytes,\r\n        ) -> tuple[State, Message]\r\n```\r\n\r\nBut at the DAP layer, we always represent aggregation parameters as opaque byte buffers. For example:\r\n\r\n```\r\nstruct {\r\n  opaque agg_param<0..2^32-1>;\r\n  PartialBatchSelector part_batch_selector;\r\n  PrepareInit prepare_inits<1..2^32-1>;\r\n} AggregationJobInitReq;\r\n```\r\n\r\nI added a commit here that resolves this by aligning ping-pong's handling of agg param with its handling of things like the public share or input shares: the arguments are now `bytes` and VDAFs are required to define encode/decode routines for their agg param. However we could also rewrite these interfaces to use the expressive types, and then make it DAP's responsibility to call encode/decode. I think VDAF has to require encode/decode routines no matter what, though.",
          "createdAt": "2023-08-18T18:49:10Z",
          "updatedAt": "2023-08-18T18:49:10Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Corresponding DAP changes: https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/pull/494",
          "createdAt": "2023-08-18T20:44:25Z",
          "updatedAt": "2023-08-18T20:44:25Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@tgeoghegan can you squash and summarize the changes in the commit message?",
          "createdAt": "2023-08-30T15:16:10Z",
          "updatedAt": "2023-08-30T15:16:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5ee5mx",
          "commit": {
            "abbreviatedOid": "41c9b39"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Looks good to me! Just some editorial things.",
          "createdAt": "2023-08-18T20:01:11Z",
          "updatedAt": "2023-08-18T20:04:28Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Add `aggregation parameter` to the list above on line 1242.",
              "createdAt": "2023-08-18T20:01:11Z",
              "updatedAt": "2023-08-18T20:04:28Z"
            },
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n{{vdaf-prep-comm}}, which are defined as:\r\n```",
              "createdAt": "2023-08-18T20:01:48Z",
              "updatedAt": "2023-08-18T20:04:28Z"
            },
            {
              "originalPosition": 38,
              "body": "We could just define it as\r\n```python3\r\nclass Start(State)\r\n```",
              "createdAt": "2023-08-18T20:02:31Z",
              "updatedAt": "2023-08-18T20:04:28Z"
            },
            {
              "originalPosition": 20,
              "body": "Can we move these to the supersection, just after defining the state machine?",
              "createdAt": "2023-08-18T20:02:44Z",
              "updatedAt": "2023-08-18T20:04:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5efKsz",
          "commit": {
            "abbreviatedOid": "41c9b39"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-18T21:13:03Z",
          "updatedAt": "2023-08-18T21:13:03Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Whoops, I meant\r\n```python3\r\nclass Start(State):\r\n    pass\r\n```",
              "createdAt": "2023-08-18T21:13:03Z",
              "updatedAt": "2023-08-18T21:13:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5efAxi",
          "commit": {
            "abbreviatedOid": "41c9b39"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-18T20:31:12Z",
          "updatedAt": "2023-08-18T22:58:19Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I don't want to suggest that implementations should ever do anything about the `Start` state, though.",
              "createdAt": "2023-08-18T20:31:12Z",
              "updatedAt": "2023-08-18T22:58:19Z"
            },
            {
              "originalPosition": 38,
              "body": "I don't want to suggest that implementations should ever do anything about the `Start` state, though. At least with ping-pong, there's no reason for any implementation to ever instantiate a `Start` value or deal with one.",
              "createdAt": "2023-08-18T22:58:10Z",
              "updatedAt": "2023-08-18T22:58:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5emwNI",
          "commit": {
            "abbreviatedOid": "d71dd63"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-08-21T15:07:13Z",
          "updatedAt": "2023-08-21T15:07:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5fbMKt",
          "commit": {
            "abbreviatedOid": "2066205"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM. Let's way to merge until we've checked the corresponding changes in the VDAF spec. I also want to look at libprio's implementation.",
          "createdAt": "2023-08-29T17:36:27Z",
          "updatedAt": "2023-08-29T17:36:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5fclFa",
          "commit": {
            "abbreviatedOid": "fba5b5a"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-08-29T21:44:35Z",
          "updatedAt": "2023-08-29T22:10:13Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "This seems confusing, as we just said \"the initial state is `Start`\". It is true that the Start state is ephemeral, and doesn't have to be stored anywhere, but I think it would be clearer to just have `class Start(State): pass` declared and move on. We're just defining which fields are held by which states here, and don't provide advice on their serialization.",
              "createdAt": "2023-08-29T21:44:35Z",
              "updatedAt": "2023-08-29T22:10:13Z"
            },
            {
              "originalPosition": 39,
              "body": "We should adjust the definition of `encode_agg_param` for Poplar1 in 8.2.6.6 to match this, so it takes in the aggregation parameter as a single tuple argument (rather than two separate arguments).",
              "createdAt": "2023-08-29T22:02:40Z",
              "updatedAt": "2023-08-29T22:10:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5fdGE6",
          "commit": {
            "abbreviatedOid": "fba5b5a"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-29T22:53:08Z",
          "updatedAt": "2023-08-29T22:53:09Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "You and Chris both think it makes more sense, and you're the editors, so I'll add it.",
              "createdAt": "2023-08-29T22:53:09Z",
              "updatedAt": "2023-08-29T22:53:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 284,
      "id": "PR_kwDOGKuqOc5YF-Pt",
      "title": "Apply parallel sum optimization to Histogram FLP",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/284",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "This implements #274, hoisting the description of the ParallelSum gadget up a section, and changing the Histogram circuit to use it as well. This reduces report sizes by a bit under two thirds asymptotically. Sharding performance is improved for large histograms as well (I got 27% reduction in runtime for a length of 1000)",
      "createdAt": "2023-08-16T19:17:20Z",
      "updatedAt": "2023-08-23T17:12:54Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "e4478dd31a611a40a2ffbcde398b41906f3c1d9f",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/histogram-parallel-sum",
      "headRefOid": "5078c3acb1a50f224cde8eb6d8e509cafc1f40ae",
      "closedAt": "2023-08-23T17:12:47Z",
      "mergedAt": "2023-08-23T17:12:47Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "a2bde9d56023e87f2d3894296047a985726d121f"
      },
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm wary about swapping the codepoints. If we had the IANA registries mentioned in section 10 set up, we wouldn't be able to do that. Plus, they are already baked into [draft-wang-ppm-dap-taskprov](https://wangshan.github.io/draft-wang-ppm-dap-taskprov/draft-wang-ppm-dap-taskprov.html#section-3-9).",
          "createdAt": "2023-08-18T00:13:47Z",
          "updatedAt": "2023-08-18T00:13:47Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm wary about swapping the codepoints. If we had the IANA registries mentioned in section 10 set up, we wouldn't be able to do that. Plus, they are already baked into [draft-wang-ppm-dap-taskprov](https://wangshan.github.io/draft-wang-ppm-dap-taskprov/draft-wang-ppm-dap-taskprov.html#section-3-9).\r\n\r\nThe IANA considerations are irrelevant until we actually ask IANA for codepoints. Similarly for taskprov: until this is a WG draft, technically we don't really care. Unless you need to support multiple versions of that draft, I'd suggest we change the codepoints here and make sure the latest version is in line.\r\n\r\nOf course, this is ~mostly~(EDITED) strictly a question of aesthetics. If you'd rather not complicate taskprov, then I'm fine leaving the codepoints as they are.",
          "createdAt": "2023-08-18T00:19:07Z",
          "updatedAt": "2023-08-18T02:08:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5eY1RL",
          "commit": {
            "abbreviatedOid": "12da1d7"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Looks good, but I propose, for editorial reasons, we present Prio3SumVec first such that it immediately follows Prio3Sum. This ought to make the transitional text a little cleaner, as well being a little more logical of an order:\r\nPrio3Count\r\nPrio3Sum\r\nPrio3SumVec\r\nPrio3Hisotgram\r\n\r\nI'd also propose that we swap the code points for Prio3SumVec and Prio3Histogram for consistency with the ordering. We're already going to need to bump the `VERSION` so this shouldn't be an interop issue.",
          "createdAt": "2023-08-17T22:16:48Z",
          "updatedAt": "2023-08-17T22:27:35Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "nit: Since `n` is undefined :)\r\n```suggestion\r\n(on the order of O(sqrt(length)) instead of O(length)) by packaging more than one such\r\n```",
              "createdAt": "2023-08-17T22:16:48Z",
              "updatedAt": "2023-08-17T22:27:35Z"
            },
            {
              "originalPosition": 37,
              "body": "Thanks for moving this explanation here. However now that we have Prio3SumVec, I wonder if it should go right after Prio3Sum, which would mean moving this explanation back to Prio3SumVec \ud83d\ude2e\u200d\ud83d\udca8 ",
              "createdAt": "2023-08-17T22:19:45Z",
              "updatedAt": "2023-08-17T22:27:35Z"
            },
            {
              "originalPosition": 57,
              "body": "This comparison would be a tad cleaner if we started with Prio3SumVec",
              "createdAt": "2023-08-17T22:23:16Z",
              "updatedAt": "2023-08-17T22:27:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5eevYt",
          "commit": {
            "abbreviatedOid": "12da1d7"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-18T19:33:58Z",
          "updatedAt": "2023-08-18T19:33:58Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I changed this to `MEAS_LEN` instead, now that this is moving back to Prio3SumVec.",
              "createdAt": "2023-08-18T19:33:58Z",
              "updatedAt": "2023-08-18T19:33:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ee7lu",
          "commit": {
            "abbreviatedOid": "5078c3a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me. If you're concerned about changing the codepoints, feel free to leave them where they are, and I'll file issue to follow up if I decide I care enough :)",
          "createdAt": "2023-08-18T20:09:24Z",
          "updatedAt": "2023-08-18T20:09:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 285,
      "id": "PR_kwDOGKuqOc5YRO7K",
      "title": "prg: unrolled cSHAKE padding",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/285",
      "state": "MERGED",
      "author": "hannahdaviscrypto",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "#209 Switched cSHAKE128 to SHAKE128 in the draft and reference implementation as discussed. The changes here are intended to be minimal, meaning that we pad the domain separation string in the same way that cSHAKE128 pads its customization string, so the only part of the Keccak input that changes is the SHAKE version-identifying postfix. I think a lot of this padding is unnecessary and we can omit it if we like.",
      "createdAt": "2023-08-18T18:04:41Z",
      "updatedAt": "2023-08-25T15:18:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "a2bde9d56023e87f2d3894296047a985726d121f",
      "headRepository": "hannahdaviscrypto/draft-irtf-cfrg-vdaf",
      "headRefName": "cshake-to-shake",
      "headRefOid": "9acec438173c00e941fb37f1a20361d21b3577fd",
      "closedAt": "2023-08-25T15:18:03Z",
      "mergedAt": "2023-08-25T15:18:03Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "092875b82234c98b9c4d38ceda9ae383325d20b7"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@hannahdaviscrypto can you take a look at https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.2 and decide it might work for us here?",
          "createdAt": "2023-08-18T21:55:35Z",
          "updatedAt": "2023-08-18T21:55:35Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> @hannahdaviscrypto can you take a look at https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.2 and decide it might work for us here?\r\n\r\nI took a closer look and quickly realized this doesn't work for us because it expects to know the length of the output in advance. We don't in our application.",
          "createdAt": "2023-08-21T23:59:08Z",
          "updatedAt": "2023-08-21T23:59:08Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you @hannahdaviscrypto !",
          "createdAt": "2023-08-25T15:17:43Z",
          "updatedAt": "2023-08-25T15:17:43Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5eeXTE",
          "commit": {
            "abbreviatedOid": "8b6c19e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "> Switched cSHAKE128 to SHAKE128 in the draft and reference implementation as discussed. The changes here are intended to be minimal, meaning that we pad the domain separation string in the same way that cSHAKE128 pads its customization string, so the only part of the Keccak input that changes is the SHAKE version-identifying postfix.\r\n\r\nJust unrolling the cSHAKE domain separation bits is a reasonable first step, but if this is all we want to do, then I think it would make sense to keep the versioning bits so that we don't change the test vectors.\r\n\r\nNote that one of the tests is failing in `prg` at the moment because this is a wire-breaking change for `PrgSha3`. I think we can comment it out for now and re-generate it once later:\r\n```\r\nsage -python common.py\r\nsage -python field.py\r\nsage -python prg.py\r\nTraceback (most recent call last):\r\n  File \"/Users/christopherpatton/github.com/cfrg/draft-irtf-cfrg-vdaf/poc/prg.py\", line 241, in <module>\r\n    assert expanded_vec[-1] == Field64(13681157193520586550)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\nAssertionError\r\nmake: *** [test] Error 1\r\n```\r\n\r\n>  I think a lot of this padding is unnecessary and we can omit it if we like.\r\n\r\nYes, I think we should take this time to simplify the padding. Indeed, this is why I asked _you_ in particular to bring your crypto eyes to this issue :)\r\n",
          "createdAt": "2023-08-18T18:21:31Z",
          "updatedAt": "2023-08-18T18:36:04Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Since `len(dst) < 256` we can simplify this a bit (`to_le_bytes` is in the `common` module)\r\n```suggestion\r\n        dst_length = to_le_bytes(len(dst), 1)\r\n```",
              "createdAt": "2023-08-18T18:21:31Z",
              "updatedAt": "2023-08-18T18:36:04Z"
            },
            {
              "originalPosition": 26,
              "body": "Similarly here (`byte` is in the `common` module)\r\n\r\n```suggestion\r\n        dst_length_l = byte(1)\r\n```",
              "createdAt": "2023-08-18T18:24:50Z",
              "updatedAt": "2023-08-18T18:36:04Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\n        pre_pad = byte(1) + byte(168)\r\n```",
              "createdAt": "2023-08-18T18:26:21Z",
              "updatedAt": "2023-08-18T18:36:04Z"
            },
            {
              "originalPosition": 56,
              "body": "Can we deduplicate this logic, i.e., create a wrapper function for it and call it here and above?",
              "createdAt": "2023-08-18T18:30:00Z",
              "updatedAt": "2023-08-18T18:36:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5eqNWs",
          "commit": {
            "abbreviatedOid": "2dc9c77"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This approach looks good to me, I have just a few editorial comments.\r\n\r\n",
          "createdAt": "2023-08-22T01:10:20Z",
          "updatedAt": "2023-08-22T01:19:29Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Here and below\r\n```suggestion\r\n        dst_length = to_le_bytes(len(dst), 1)\r\n```",
              "createdAt": "2023-08-22T01:10:20Z",
              "updatedAt": "2023-08-22T01:19:29Z"
            },
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nThe length of the domain separation string `dst` passed to PrgSha3 MUST NOT\r\nexceed 255 bytes.\r\n\r\n```",
              "createdAt": "2023-08-22T01:17:33Z",
              "updatedAt": "2023-08-22T01:19:29Z"
            },
            {
              "originalPosition": 19,
              "body": "This text needs to be normative, so I think we should move it out of a code comment and into its own paragraph. See the suggestion above.\r\n\r\nSimilarly for PrgFixedKeyAes128 below.",
              "createdAt": "2023-08-22T01:18:32Z",
              "updatedAt": "2023-08-22T01:19:29Z"
            },
            {
              "originalPosition": 52,
              "body": "(For consideration in a follow-up PR.) @schoppmp We might go with plain SHA-3 in order instead of SHAKE128 since the output length is fixed. ",
              "createdAt": "2023-08-22T01:18:57Z",
              "updatedAt": "2023-08-22T01:19:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5e5QR5",
          "commit": {
            "abbreviatedOid": "d144310"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Looks good to me. Please add a bit of documentation regarding the broken test (see inline comment).\r\n\r\n@divergentdave could you take a quick look at this change? ",
          "createdAt": "2023-08-23T17:15:27Z",
          "updatedAt": "2023-08-23T17:18:28Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "nit: This is clear enough from context :)\r\n```suggestion\r\n        dst_length = to_le_bytes(len(dst), 1)\r\n```",
              "createdAt": "2023-08-23T17:15:27Z",
              "updatedAt": "2023-08-23T17:18:28Z"
            },
            {
              "originalPosition": 50,
              "body": "When breaking a test, it's important to make clear to the reader why the test is broken (and how it should be fixed).\r\nBonus: We should file an issue to remind us to fix this test, and reference the issue in this comment.\r\n```suggestion\r\n    # TODO: Update the test to account for the change from cSHAKE128 to SHAKE128.\r\n    # assert expanded_vec[-1] == Field64(13681157193520586550)\r\n```",
              "createdAt": "2023-08-23T17:17:30Z",
              "updatedAt": "2023-08-23T17:18:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5e5hr7",
          "commit": {
            "abbreviatedOid": "d144310"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "> Just unrolling the cSHAKE domain separation bits is a reasonable first step, but if this is all we want to do, then I think it would make sense to keep the versioning bits so that we don't change the test vectors.\r\n\r\ncSHAKE128 output can only be matched by SHAKE128 if the customization string is empty. We always provided a customization string, and in that case, we land in the other branch of cSHAKE128's definition, that uses Keccak[256] directly. In that branch, the bits `00` are appended to Keccak's input after the cSHAKE128 input, whereas the definition of SHAKE128 appends the bits `1111` after its input. We are making this change in the pursuit of ease of implementation, so I think we ought to stick with SHAKE128 as-is, and accept the value-breaking change. Bare Keccak[256] implementations are likely to be as rare as cSHAKE128 implementations.\r\n\r\nRegarding removal of the padding bytes after the customization string, section 7.1 of SP 800-185 says they were included to allow precomputation of sponge state for any particular choice of function name and customization string. Our DSTs are 8 bytes, so we're only foreclosing on one precomputation of the Keccak permutation function, and on the other hand doing one fewer absorption iteration about half the time. This sounds fine to me, as it's not a big deal.",
          "createdAt": "2023-08-23T18:01:51Z",
          "updatedAt": "2023-08-23T18:40:17Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "nit: `dst` is passed through `self` here\r\n```suggestion\r\n        dst_length = to_le_bytes(len(self.s), 1)\r\n        stream = SHAKE128(dst_length + self.s + self.x, self.l)\r\n```",
              "createdAt": "2023-08-23T18:01:51Z",
              "updatedAt": "2023-08-23T18:40:17Z"
            },
            {
              "originalPosition": 24,
              "body": "Since there's no separate customization string, we don't have a distinction to draw here anymore.\r\n```suggestion\r\n        # The input is composed of `dst`, the domain separation tag, the\r\n        # `seed`, and the `binder` string.\r\n```",
              "createdAt": "2023-08-23T18:10:50Z",
              "updatedAt": "2023-08-23T18:40:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5fIDFu",
          "commit": {
            "abbreviatedOid": "d144310"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-25T15:17:07Z",
          "updatedAt": "2023-08-25T15:17:07Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/288",
              "createdAt": "2023-08-25T15:17:07Z",
              "updatedAt": "2023-08-25T15:17:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5fIDQV",
          "commit": {
            "abbreviatedOid": "9acec43"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-08-25T15:17:32Z",
          "updatedAt": "2023-08-25T15:17:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 289,
      "id": "PR_kwDOGKuqOc5Y0i72",
      "title": "Rename PRG to XOF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/289",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "Closes #159.\r\n\r\n\"Pseudorandom generator\" is a misnomer because we can't always treat the output as pseudorandom (i.e., computationally indistinguishable from random). We typically require this object to be indifferentiable from a random oracle.\r\n\r\nClarify this in security considerations and rename PRG to XOF (\"eXtendaable Output Function\"). This is a term commonly used for aborb-then-squeeze constructions like SHAKE128.",
      "createdAt": "2023-08-25T18:44:34Z",
      "updatedAt": "2024-07-02T21:50:29Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "6da63ee2f7a1affce87942cfc24650e55fb5bc28",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/159/1/prg-to-xof",
      "headRefOid": "cd0f154c8c17bae9f4ac148c435bb375ffa277c5",
      "closedAt": "2023-08-29T17:33:39Z",
      "mergedAt": "2023-08-29T17:33:39Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "86da22906f281e2be69571414774c8c0877469df"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5fahBS",
          "commit": {
            "abbreviatedOid": "c1d2f09"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-08-29T15:57:42Z",
          "updatedAt": "2023-08-29T17:00:14Z",
          "comments": [
            {
              "originalPosition": 203,
              "body": "nit: inconsistent capitalization\r\n```suggestion\r\nThis section describes XofShake128, a XOF based on the SHAKE128 mode of\r\noperation for the Keccak permutation {{FIPS202}}. This XOF is RECOMMENDED for\r\n```",
              "createdAt": "2023-08-29T15:57:42Z",
              "updatedAt": "2023-08-29T17:00:14Z"
            },
            {
              "originalPosition": 234,
              "body": "nit: inconsistent capitalization\r\n```suggestion\r\nis limited to the XOF used inside the Idpf {{idpf}} implementation in Poplar1\r\n```",
              "createdAt": "2023-08-29T16:55:30Z",
              "updatedAt": "2023-08-29T17:00:14Z"
            },
            {
              "originalPosition": 226,
              "body": "nit: inconsistent capitalization\r\n```suggestion\r\nWhile XofShake128 as described above can be securely used in all cases where a XOF\r\n```",
              "createdAt": "2023-08-29T16:55:37Z",
              "updatedAt": "2023-08-29T17:00:14Z"
            },
            {
              "originalPosition": 713,
              "body": "nit: typo\r\n```suggestion\r\n{{GKWWY20}} and is therefore NOT RECOMMENDED for general use. It is used only by\r\n```",
              "createdAt": "2023-08-29T17:00:00Z",
              "updatedAt": "2023-08-29T17:00:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 290,
      "id": "PR_kwDOGKuqOc5Y_EO_",
      "title": "Close code block",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/290",
      "state": "MERGED",
      "author": "junyechen1996",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "- discovered while reading the draft",
      "createdAt": "2023-08-29T01:13:02Z",
      "updatedAt": "2023-09-27T19:22:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "092875b82234c98b9c4d38ceda9ae383325d20b7",
      "headRepository": "junyechen1996/draft-irtf-cfrg-vdaf",
      "headRefName": "junyec/close-code-block",
      "headRefOid": "e53a1f49805c2cc7631164d3e6a1aa31964f5913",
      "closedAt": "2023-08-29T01:17:09Z",
      "mergedAt": "2023-08-29T01:17:09Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "6da63ee2f7a1affce87942cfc24650e55fb5bc28"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5fU8fT",
          "commit": {
            "abbreviatedOid": "e53a1f4"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2023-08-29T01:17:04Z",
          "updatedAt": "2023-08-29T01:17:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 291,
      "id": "PR_kwDOGKuqOc5ZE2tb",
      "title": "Prepare to cut draft-07",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/291",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "The usual chores, along with some additional minor improvements:\r\n\r\n* Add a pointer to GitHub\r\n* Update change log\r\n* Remove an unused reference\r\n* Remove deprecated XofAes128\r\n* Bump `VERSION`\r\n* Update test vectors\r\n* Remove human-readable test vectors (so that we don't have to keep updating an appendix no one is using!)\r\n* Fix a couple of long line warnings",
      "createdAt": "2023-08-29T21:03:53Z",
      "updatedAt": "2024-07-02T21:50:30Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "87eb78c6055937de3b664b5d634d44df3d68fb3c",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/07/1",
      "headRefOid": "c0cd5735f450eb6bfbd55e663cab12ea5fe68c70",
      "closedAt": "2023-08-31T15:12:35Z",
      "mergedAt": "2023-08-31T15:12:35Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "ede21a4e7d56b3c1cc55f6efd2136cf26f64a724"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebasd.",
          "createdAt": "2023-08-31T14:57:44Z",
          "updatedAt": "2023-08-31T14:57:44Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5fqYP5",
          "commit": {
            "abbreviatedOid": "b055470"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-08-31T14:49:31Z",
          "updatedAt": "2023-08-31T14:53:03Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "nit: typo\r\n```suggestion\r\n  to XofShake128 and PrgFixedKeyAes128 to XofFixedKeyAes128. \"PRG\" is a misnomer\r\n```",
              "createdAt": "2023-08-31T14:49:31Z",
              "updatedAt": "2023-08-31T14:53:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 292,
      "id": "PR_kwDOGKuqOc5ZLFYc",
      "title": "Expand upon chunk length selection",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/292",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-07"
      ],
      "body": "This is a follow-up related to #124, explaining why optimal chunk lengths are not easy to find, and providing some more context about how good the square root rule of thumb/RECOMMENDation is.",
      "createdAt": "2023-08-30T20:07:31Z",
      "updatedAt": "2024-07-02T21:38:45Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "86da22906f281e2be69571414774c8c0877469df",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/chunk-length-selection",
      "headRefOid": "eb1ceaeb9a8a68c73e8329a051ac21bc6719a23e",
      "closedAt": "2023-08-30T22:38:05Z",
      "mergedAt": "2023-08-30T22:38:05Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "31ebac0be227a8dd89bc3e538d991a8203f21498"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5fkkcq",
          "commit": {
            "abbreviatedOid": "e30829e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-30T20:11:35Z",
          "updatedAt": "2023-08-30T20:11:40Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Explain \"two forms of rounding\".",
              "createdAt": "2023-08-30T20:11:35Z",
              "updatedAt": "2023-08-30T20:11:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5flNq5",
          "commit": {
            "abbreviatedOid": "eb1ceae"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-08-30T22:37:59Z",
          "updatedAt": "2023-08-30T22:37:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 293,
      "id": "PR_kwDOGKuqOc5ZQ7sv",
      "title": "Revert PRG name change in the change log",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/293",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We were a bit sloppy in the PRG -> XOF rename in that we changed the names in the change log as well. We want to keep the change log consistent across drafts, so revert these changes.",
      "createdAt": "2023-08-31T17:51:53Z",
      "updatedAt": "2023-08-31T17:54:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "ede21a4e7d56b3c1cc55f6efd2136cf26f64a724",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/revert-prg-rename-in-cl",
      "headRefOid": "095e3f651bbefa78d42052495d2da30b4d66d3f7",
      "closedAt": "2023-08-31T17:54:11Z",
      "mergedAt": "2023-08-31T17:54:11Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "7479613332fbbfce9488165037f65b01d55d73c1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5fr9r-",
          "commit": {
            "abbreviatedOid": "83070e0"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-08-31T17:52:43Z",
          "updatedAt": "2023-08-31T17:52:43Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5fr-IV",
          "commit": {
            "abbreviatedOid": "095e3f6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-31T17:53:26Z",
          "updatedAt": "2023-08-31T17:53:26Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Reviwer tip: Check out the branch and look the Change Log section in `git diff draft-irtf-cfrg-vdaf-06 draft-irtf-cfrg-vdaf.md`",
              "createdAt": "2023-08-31T17:53:26Z",
              "updatedAt": "2023-08-31T17:53:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5fr95M",
          "commit": {
            "abbreviatedOid": "095e3f6"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Edit: I ran into a GitHub bug, I clicked the \"cancel review\" button and it left a comment!",
          "createdAt": "2023-08-31T17:53:03Z",
          "updatedAt": "2023-08-31T17:54:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 294,
      "id": "PR_kwDOGKuqOc5Zs5_F",
      "title": "poc: Update rejection test for XofShake128",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/294",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #288.",
      "createdAt": "2023-09-06T16:26:51Z",
      "updatedAt": "2024-07-02T21:50:31Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "7479613332fbbfce9488165037f65b01d55d73c1",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/288",
      "headRefOid": "b538ca5c457942a53824128d6055f2f1cdfe12d7",
      "closedAt": "2023-09-06T16:36:24Z",
      "mergedAt": "2023-09-06T16:36:24Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "d1440769fac707959d68af3d2e9f80544095b1ca"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5gMDlL",
          "commit": {
            "abbreviatedOid": "b538ca5"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, and I confirmed this falls through in the rejection sampling loop exactly once",
          "createdAt": "2023-09-06T16:35:29Z",
          "updatedAt": "2023-09-06T16:35:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 295,
      "id": "PR_kwDOGKuqOc5aDWa7",
      "title": "Encode integer as bit vector representation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/295",
      "state": "MERGED",
      "author": "junyechen1996",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- Add class methods to encode integer as bit vector representation, as a vector of field elements, and vice versa.\r\n- It's a common functionality used by both Prio3Sum and Prio3SumVec, and increases readability IMO.\r\n- I tried to align it with libprio-rs implementation as much as possible: https://github.com/divviup/libprio-rs/blob/main/src/field.rs#L199-L267\r\n",
      "createdAt": "2023-09-11T18:44:48Z",
      "updatedAt": "2023-09-27T19:22:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d1440769fac707959d68af3d2e9f80544095b1ca",
      "headRepository": "junyechen1996/draft-irtf-cfrg-vdaf",
      "headRefName": "junyec/field-bit-rep",
      "headRefOid": "d53f3a38eb31462cdef68522b3e40e608790d13b",
      "closedAt": "2023-09-13T16:01:14Z",
      "mergedAt": "2023-09-13T16:01:14Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "510c00c59402f4643ec564f873e639ae63be618f"
      },
      "comments": [
        {
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Got it. I squashed and fixed the commit message, and updated PR title and description according to the commit message. Will wait for more reviews in the meantime.",
          "createdAt": "2023-09-11T21:46:03Z",
          "updatedAt": "2023-09-11T21:46:03Z"
        },
        {
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> One more suggestion here: It would be more consistent with our API if the encoder returned the encoded value rather than appended the encoded value to a buffer. Something like this:\r\n> \r\n> * `Field.encode_into_bit_vector(val: Unsigned, bits: Unsinged) -> list[Field]`\r\n> * `Field.decoded_from_bit_vector(encoded: list[Field]) -> Field`\r\n\r\nMakes sense. Initially I made `encode_into_bit_vector` take in the vector so we don't have to allocate it for every coordinate in `Prio3SumVec`, but I guess we could just use python list concatenation.\r\n\r\nI kept the method name `decode_from_bit_vector`, I'm not sure if `decoded_from_bit_vector` is what you intended?",
          "createdAt": "2023-09-12T23:11:37Z",
          "updatedAt": "2023-09-12T23:11:37Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5gmQKO",
          "commit": {
            "abbreviatedOid": "2a89f17"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Nice! A couple minor comments.",
          "createdAt": "2023-09-11T18:56:47Z",
          "updatedAt": "2023-09-11T19:00:42Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "This text needs to be normative, so instead of \"it is useful to ..\" we should say something declaritive, like \"`Field` implements the following methods for representing a value as a sequence of field elements, where each element represents a bit of the input:\"",
              "createdAt": "2023-09-11T18:56:47Z",
              "updatedAt": "2023-09-11T19:00:42Z"
            },
            {
              "originalPosition": 32,
              "body": "I would move the range check to the top of the function. ",
              "createdAt": "2023-09-11T18:57:35Z",
              "updatedAt": "2023-09-11T19:00:42Z"
            },
            {
              "originalPosition": 21,
              "body": "It's a bit odd that the encoding method takes in an `Unsigned` but the decoding method outputs a `Field`. You'd expect the domain of the encoder to be the same as the range of the decoder.\r\n\r\nCould we make this have type `Field` instead?",
              "createdAt": "2023-09-11T18:59:25Z",
              "updatedAt": "2023-09-11T19:00:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5gmY-u",
          "commit": {
            "abbreviatedOid": "2a89f17"
          },
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-11T19:15:52Z",
          "updatedAt": "2023-09-11T19:16:32Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "It is a bit odd. The reason is when we encode integer into bit vector, the measurement is always in `Unsigned` form. When we `truncate`, we need to decode the vector into a `Field`, because the `Field` is actually secret-shared. I could instead make the function name more explicit, e.g. `encode_integer_into_bit_vector` and `decode_field_from_bit_vector`?",
              "createdAt": "2023-09-11T19:15:52Z",
              "updatedAt": "2023-09-11T19:16:32Z"
            },
            {
              "originalPosition": 32,
              "body": "Done.",
              "createdAt": "2023-09-11T19:16:14Z",
              "updatedAt": "2023-09-11T19:16:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5gmd6u",
          "commit": {
            "abbreviatedOid": "2a89f17"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-11T19:30:57Z",
          "updatedAt": "2023-09-11T19:30:57Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Hmm, fair. I think I'd still prefer to take in a `Field`, even if that means we need to  `Field.encode_into_bit_vector(elem=Field(23))` then call `elem.as_unsigned()` in the encoding method internally. But I don't feel strongly about it. Feel free to leave as-is, and we'll see if maybe @divergentdave has a strong opinion here.",
              "createdAt": "2023-09-11T19:30:57Z",
              "updatedAt": "2023-09-11T19:30:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5gm_G6",
          "commit": {
            "abbreviatedOid": "02135a6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks reasonable to me. @junyechen1996 please squash and fix-up the commit message before merging",
          "createdAt": "2023-09-11T21:04:50Z",
          "updatedAt": "2023-09-11T21:44:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5gueaO",
          "commit": {
            "abbreviatedOid": "02135a6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "One more suggestion here: It would be more consistent with our API if the encoder returned the encoded value rather than appended the encoded value to a buffer. Something like this:\r\n* `Field.encode_into_bit_vector(val: Unsigned, bits: Unsinged) -> list[Field]`\r\n* `Field.decoded_from_bit_vector(encoded: list[Field]) -> Field`\r\n",
          "createdAt": "2023-09-12T17:37:52Z",
          "updatedAt": "2023-09-12T17:37:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5g2l4y",
          "commit": {
            "abbreviatedOid": "d53f3a3"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks @junyechen1996 !",
          "createdAt": "2023-09-13T16:01:03Z",
          "updatedAt": "2023-09-13T16:01:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 296,
      "id": "PR_kwDOGKuqOc5bX3nh",
      "title": "Fix __name__ access in poc",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/296",
      "state": "MERGED",
      "author": "junyechen1996",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "__name__ is an attribute of a class instead of that of an instance. flp.Valid is an instance, so accessing __name__ will fail with another exception if the FLP test fails.",
      "createdAt": "2023-09-27T19:26:59Z",
      "updatedAt": "2023-09-27T19:59:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "510c00c59402f4643ec564f873e639ae63be618f",
      "headRepository": "junyechen1996/draft-irtf-cfrg-vdaf",
      "headRefName": "junyec/exception-msg",
      "headRefOid": "cd6aa02c6d4ea51e96250595db8c2675ccaf2d39",
      "closedAt": "2023-09-27T19:59:17Z",
      "mergedAt": "2023-09-27T19:59:17Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "402438c21afceb8352e46e9390345915e14bc430"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5iMjDR",
          "commit": {
            "abbreviatedOid": "cd6aa02"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2023-09-27T19:58:38Z",
          "updatedAt": "2023-09-27T19:58:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 297,
      "id": "PR_kwDOGKuqOc5buyNn",
      "title": "Add poc changes for issue 177",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/297",
      "state": "CLOSED",
      "author": "albertpl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "[#177](https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/177)",
      "createdAt": "2023-10-02T23:34:20Z",
      "updatedAt": "2023-10-02T23:35:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "402438c21afceb8352e46e9390345915e14bc430",
      "headRepository": "albertpl/draft-irtf-cfrg-vdaf",
      "headRefName": "poc-prio3-multiproof",
      "headRefOid": "b049f80f82bef1d40f392bf436663a6c27eb40df",
      "closedAt": "2023-10-02T23:35:15Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 298,
      "id": "PR_kwDOGKuqOc5b1z-X",
      "title": "Add poc changes for [#177]",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/298",
      "state": "MERGED",
      "author": "albertpl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "1. POC implementation for mutliproof proposal in  [#177](https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/177)\r\n    1. Support multiproofs in `Prio3`\r\n    2. Add new `Prio3SumVec` variant, i.e. `Prio3SumVecWithMultiproof`, with configuration (field size, number of proofs)\r\n    3. Add `with_field` class methods to introduce new `SumVec` with configurable field size",
      "createdAt": "2023-10-03T23:02:02Z",
      "updatedAt": "2023-10-24T15:15:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "bb6fa77a90cc519ae95e3ac10488ee16fc1833d4",
      "headRepository": "albertpl/draft-irtf-cfrg-vdaf",
      "headRefName": "poc-prio3-multiproof",
      "headRefOid": "e11c78808d4e92941c1a03729fc8a4138a92b6c6",
      "closedAt": "2023-10-16T14:53:11Z",
      "mergedAt": "2023-10-16T14:53:11Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "3d108f4ff0ff4daec88c5fb537f29d2d440c3c4f"
      },
      "comments": [
        {
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "body": "[Note, I will squash & summarize all changes in the commit, before merging this PR]",
          "createdAt": "2023-10-05T19:07:26Z",
          "updatedAt": "2023-10-05T19:07:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5iuKQQ",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-03T23:02:47Z",
          "updatedAt": "2023-10-03T23:21:35Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I choose to this approach, instead of making `field` a `__init__` parameter  because\r\n1. Follow existing patterns in `vdaf_prio3.py` where we using `Prio3` as a template to create `Prio3SumVec` etc.\r\n2. `SumVec.Field` is closer to template/generic parameters than instance properties, IMHO",
              "createdAt": "2023-10-03T23:02:47Z",
              "updatedAt": "2023-10-03T23:21:35Z"
            },
            {
              "originalPosition": 200,
              "body": "We might need to take other parameters from the underlying FLP circuits/gadgets into considerations? e.g. `Valid.GADGET_CALLS`, `GADGET.DEGREE`? What constrains shall we specify ?\r\n",
              "createdAt": "2023-10-03T23:05:50Z",
              "updatedAt": "2023-10-03T23:21:35Z"
            },
            {
              "originalPosition": 213,
              "body": "What algorithm IDs shall we allocate for this variants? \r\n\r\nLet $N$ be the next available algorithm ID. Maybe we can start with $N$ be Field64 with `PROOFS=2` and $N+1$ be Field64 with `PROOFS=3`? Then allocate more algorithm IDs whenever there is request?\r\n",
              "createdAt": "2023-10-03T23:19:40Z",
              "updatedAt": "2023-10-03T23:21:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5i3P1e",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looking good so far! Very clean for the most part. One high level ask: Please add more context to the commit message. A reference to the issue is somewhat useful, but it's helpful to have a summary of the change in the `git log` as well. (We rely on this heavily when preparing drafts.) ",
          "createdAt": "2023-10-04T23:37:28Z",
          "updatedAt": "2023-10-05T00:12:12Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "We're moving towards not defining exceptions this way: https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/277\r\n\r\nInstead just instantiate the exception you want to raise where you need to.",
              "createdAt": "2023-10-04T23:37:29Z",
              "updatedAt": "2023-10-05T00:12:12Z"
            },
            {
              "originalPosition": 5,
              "body": "Looks good to me. (And thanks for listing alternatives!) One nit: Move this to the last method on the class. The current pattern is to keep the methods that appear in the spec at the top and push operational methods (like this one) towards the bottom.",
              "createdAt": "2023-10-04T23:40:39Z",
              "updatedAt": "2023-10-05T00:12:12Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\n    # Test encoding, truncation, then decoding.\r\n```",
              "createdAt": "2023-10-04T23:42:40Z",
              "updatedAt": "2023-10-05T00:12:12Z"
            },
            {
              "originalPosition": 17,
              "body": "Consider generalizing this function to test any subclass of `Valid`.",
              "createdAt": "2023-10-04T23:43:22Z",
              "updatedAt": "2023-10-05T00:12:12Z"
            },
            {
              "originalPosition": 17,
              "body": "We mainly use type hints aesthetically, in order to make the spec more readable. I would probably not add the type hint here, since we're currently not trying to do any type checking: https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/59\r\n\r\nAlso s/f/Field/ for consistency.\r\n\r\n```suggestion\r\ndef _test_sumvec_with_field(Field):\r\n```",
              "createdAt": "2023-10-04T23:44:21Z",
              "updatedAt": "2023-10-05T00:12:12Z"
            },
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n    PROOFS = 1  # Number of proofs\r\n```\r\n\r\nAlso, we could let this be `None` and expect it to be set by the concrete Prio3 instance.",
              "createdAt": "2023-10-04T23:47:50Z",
              "updatedAt": "2023-10-05T00:12:12Z"
            },
            {
              "originalPosition": 148,
              "body": "^ s/query_rand/query_rands/ for consistency with joint_rands",
              "createdAt": "2023-10-05T00:03:44Z",
              "updatedAt": "2023-10-05T00:12:12Z"
            },
            {
              "originalPosition": 45,
              "body": "Hmm, this is a bit odd; elsewhere we have \"proof shares\" and \"query rands\", but here we have just one \"verifier share\". WDYTA changing this to \"verifier shares\"? One downside is that, during prep_shares_to_prep we combine the \"verifier shares\" into the \"verifier\", so we'd need to change this to \"list of verifier shares\" into the \"verifiers\".\r\n\r\nLet me know if I'm not making sense :) ",
              "createdAt": "2023-10-05T00:05:34Z",
              "updatedAt": "2023-10-05T00:12:12Z"
            },
            {
              "originalPosition": 193,
              "body": "We want to make it clear that this is not (yet) on the standards track. We could prefix the class name with `Test`, or maybe just add a comment clarifying what this is intended for.",
              "createdAt": "2023-10-05T00:09:15Z",
              "updatedAt": "2023-10-05T00:12:12Z"
            },
            {
              "originalPosition": 194,
              "body": "Why not just set it here? If this behavior is needed, then don't set the ID here.",
              "createdAt": "2023-10-05T00:09:38Z",
              "updatedAt": "2023-10-05T00:12:12Z"
            },
            {
              "originalPosition": 213,
              "body": "yeah, for different choices of `PROOFS`, we'd need to distinct code points (i.e., algorithm IDs)",
              "createdAt": "2023-10-05T00:10:54Z",
              "updatedAt": "2023-10-05T00:12:12Z"
            },
            {
              "originalPosition": 161,
              "body": "As @divergentdave suggested, let's incorporate `Prio3.PROOFS` into the transcript for deriving the joint rands.",
              "createdAt": "2023-10-05T00:11:51Z",
              "updatedAt": "2023-10-05T00:12:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5i9lk1",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T16:46:43Z",
          "updatedAt": "2023-10-05T16:46:43Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": "If Prio3\u2019s derivation of domain separation tag already includes algorithm ID, is it sufficient to make algorithm ID specify a distinct combination of `(Field, PROOFS)`, per thread [here](https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/298#discussion_r1344864217)?",
              "createdAt": "2023-10-05T16:46:43Z",
              "updatedAt": "2023-10-05T16:46:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5i9qdx",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T16:58:20Z",
          "updatedAt": "2023-10-05T16:58:20Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Sounds good. I will create a new class `ParamsNotRecommendedError` inherited from `Exception`.",
              "createdAt": "2023-10-05T16:58:20Z",
              "updatedAt": "2023-10-05T16:58:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5i9vOC",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T17:10:54Z",
          "updatedAt": "2023-10-05T17:10:55Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": "That's one possibility, but it somewhat depends on how \"configurable\" we need the value of `PROOFS` to be. Ideally we can fix it for a given choice of circuit and field.",
              "createdAt": "2023-10-05T17:10:55Z",
              "updatedAt": "2023-10-05T17:10:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5i9vWi",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T17:11:15Z",
          "updatedAt": "2023-10-05T17:11:16Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": "I think for now it makes sense to include it in the transcript. ",
              "createdAt": "2023-10-05T17:11:16Z",
              "updatedAt": "2023-10-05T17:11:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5i9vs2",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T17:12:09Z",
          "updatedAt": "2023-10-05T17:12:10Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Actually I would follow what we do else where and just `raise ValueError('something bad happened')` like we do elsewhere.",
              "createdAt": "2023-10-05T17:12:09Z",
              "updatedAt": "2023-10-05T17:12:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5i9wv7",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T17:14:58Z",
          "updatedAt": "2023-10-05T17:14:58Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I want to follow the convention in `prep_shares_to_prep`, i.e. each `prep_share` contains only a share of the verifier message. And then extend this to our multiproofs. So it would be a share of multiple verifier messages? \r\n\r\nMaybe we can use `verifiers_share`, i.e. append **s** to verifier, instead of share, what do you think?",
              "createdAt": "2023-10-05T17:14:58Z",
              "updatedAt": "2023-10-05T17:33:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5i9xZy",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T17:16:45Z",
          "updatedAt": "2023-10-05T17:16:45Z",
          "comments": [
            {
              "originalPosition": 193,
              "body": "OK. I will add a comment.",
              "createdAt": "2023-10-05T17:16:45Z",
              "updatedAt": "2023-10-05T17:16:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5i-KSX",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T18:21:08Z",
          "updatedAt": "2023-10-05T18:21:08Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Along the same line, (notice **s** appended to `proof`)\r\n`leader_proof_share` -> `leader_proofs_share`\r\n`helper_proof_share` -> `helper_proofs_share`",
              "createdAt": "2023-10-05T18:21:08Z",
              "updatedAt": "2023-10-05T18:21:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5i-hCf",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T19:23:35Z",
          "updatedAt": "2023-10-05T19:23:35Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": ">I think for now it makes sense to include it in the transcript.\r\n\r\nJust to clarify. And do we want to use binder string?\r\n",
              "createdAt": "2023-10-05T19:23:35Z",
              "updatedAt": "2023-10-05T19:23:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5i_6FQ",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T23:34:48Z",
          "updatedAt": "2023-10-05T23:34:48Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Yeah I like that idea. It's grammatically a little hairy but it makes the variable names consistent.",
              "createdAt": "2023-10-05T23:34:48Z",
              "updatedAt": "2023-10-05T23:34:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5i_6jx",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T23:38:21Z",
          "updatedAt": "2023-10-05T23:38:21Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": "Yup, at the step where we derive the joint rands from the `k_joint_rand_seed`.",
              "createdAt": "2023-10-05T23:38:21Z",
              "updatedAt": "2023-10-05T23:38:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jGP4P",
          "commit": {
            "abbreviatedOid": "efeab27"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-06T18:23:01Z",
          "updatedAt": "2023-10-06T18:23:39Z",
          "comments": [
            {
              "originalPosition": 244,
              "body": "Choose to be backward compatible, i.e. only embedding `Prio3.PROOFS` when it is > 1.",
              "createdAt": "2023-10-06T18:23:01Z",
              "updatedAt": "2023-10-06T18:23:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jPCyF",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T16:13:57Z",
          "updatedAt": "2023-10-09T16:13:57Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": "If we treat (`PROOFS, Field`) as parameter for the underlying algorithm, i.e. same as `SHARES`, it makes senses to add them into joint randomness derivation. \r\n1. If we do so, maybe we can allocate one algorithm ID/code point for Prio3SumVec variant with multiproofs? \r\n2. Shall we add field choice into joint randomness derivation too (binder) ?",
              "createdAt": "2023-10-09T16:13:57Z",
              "updatedAt": "2023-10-09T16:13:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jdmQD",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T19:14:31Z",
          "updatedAt": "2023-10-10T19:14:32Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": "> If we treat (`PROOFS, Field`) as parameter for the underlying algorithm, i.e. same as `SHARES`, it makes senses to add them into joint randomness derivation.\r\n> \r\n>     1. If we do so, maybe we can allocate one algorithm ID/code point for Prio3SumVec variant with multiproofs?\r\n\r\nI don't think we should actually allocate a codepoint until we know more about robustness. In the meantime, one is free to use any of the unreserved codepoints however they wish.\r\n\r\n\r\n>     2. Shall we add field choice into joint randomness derivation too (binder) ?\r\n\r\nWe maybe don't need to unless we plan to use more than one field. Isn't `Field64` the only one that's needed?\r\n",
              "createdAt": "2023-10-10T19:14:31Z",
              "updatedAt": "2023-10-10T19:14:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jdmao",
          "commit": {
            "abbreviatedOid": "efeab27"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T19:14:48Z",
          "updatedAt": "2023-10-10T19:14:48Z",
          "comments": [
            {
              "originalPosition": 244,
              "body": "Yup, good idea.",
              "createdAt": "2023-10-10T19:14:48Z",
              "updatedAt": "2023-10-10T19:14:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jdoN_",
          "commit": {
            "abbreviatedOid": "025c1c9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Looking very good! High level ask: Make sure that variable naming conventions are consistent across sharding and preparation.",
          "createdAt": "2023-10-10T19:19:07Z",
          "updatedAt": "2023-10-10T19:44:01Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Style question: Why prepend the underscore (`_`)? Is this because `field` is already defined? Is this following a specific Python convention?\r\n\r\nI write a lot of rust these days, so I think of this convention as a way of differentiating multiple variables that I want to be anonymous.",
              "createdAt": "2023-10-10T19:19:07Z",
              "updatedAt": "2023-10-10T19:44:01Z"
            },
            {
              "originalPosition": 45,
              "body": "For consistency with `shard()`\r\n```suggestion\r\n        verifiers_share = []\r\n```",
              "createdAt": "2023-10-10T19:22:56Z",
              "updatedAt": "2023-10-10T19:44:01Z"
            },
            {
              "originalPosition": 70,
              "body": "```suggestion\r\n        for (verifiers_share, k_joint_rand_part) in prep_shares:\r\n```",
              "createdAt": "2023-10-10T19:23:21Z",
              "updatedAt": "2023-10-10T19:44:01Z"
            },
            {
              "originalPosition": 94,
              "body": "```suggestion\r\n        leader_proofs_share = []\r\n```",
              "createdAt": "2023-10-10T19:24:08Z",
              "updatedAt": "2023-10-10T19:44:01Z"
            },
            {
              "originalPosition": 112,
              "body": "```suggestion\r\n        leader_proofs_share = []\r\n```",
              "createdAt": "2023-10-10T19:24:22Z",
              "updatedAt": "2023-10-10T19:44:01Z"
            },
            {
              "originalPosition": 247,
              "body": "This imposes an upper bound on the value of `Prio3.PROOFS`. I think we should note this upper bound where `PROOFS` is first declared.",
              "createdAt": "2023-10-10T19:26:13Z",
              "updatedAt": "2023-10-10T19:44:01Z"
            },
            {
              "originalPosition": 307,
              "body": "```suggestion\r\n            # We encode this as one byte while deriving joing rands\r\n```",
              "createdAt": "2023-10-10T19:27:00Z",
              "updatedAt": "2023-10-10T19:44:01Z"
            },
            {
              "originalPosition": 309,
              "body": "If this comment is referring to a decision that still needs to be made, then I'd make it more clear.\r\n```suggestion\r\n        # TODO(issue#177) Decide how many proofs to use for each field type.\r\n```",
              "createdAt": "2023-10-10T19:30:23Z",
              "updatedAt": "2023-10-10T19:44:01Z"
            },
            {
              "originalPosition": 312,
              "body": "Do you plan to potentially use this field? Before you do, I think we should figure out if we can find a better prime modulus. We'd like to find something that's closer to a power of 2. (cc/ @divergentdave)",
              "createdAt": "2023-10-10T19:35:02Z",
              "updatedAt": "2023-10-10T19:44:01Z"
            },
            {
              "originalPosition": 322,
              "body": "Since this is hard-coded for now, I think we should get rid of this function and declare this the same way we do for the other Prio3 variants: https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/poc/vdaf_prio3.py#L420\r\n",
              "createdAt": "2023-10-10T19:39:15Z",
              "updatedAt": "2023-10-10T19:44:01Z"
            },
            {
              "originalPosition": 351,
              "body": "Same question as above: What convention are you following by prefixing this function with an underscore?",
              "createdAt": "2023-10-10T19:39:47Z",
              "updatedAt": "2023-10-10T19:44:01Z"
            },
            {
              "originalPosition": 354,
              "body": "It seems odd to silently skip the test if the number of proofs is not recommended. Also, should we test that it's greater than 0?",
              "createdAt": "2023-10-10T19:40:27Z",
              "updatedAt": "2023-10-10T19:44:01Z"
            },
            {
              "originalPosition": 244,
              "body": "Reviewer note: I've confirmed the test vectors haven't changed.",
              "createdAt": "2023-10-10T19:43:04Z",
              "updatedAt": "2023-10-10T19:44:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jfPXm",
          "commit": {
            "abbreviatedOid": "025c1c9"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T21:47:25Z",
          "updatedAt": "2023-10-10T21:47:25Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": ">Why prepend the underscore (_)?  Is this because field is already defined?\r\n\r\nYes.  Due to name collision. And we need to access `field.Field64` as well.\r\n```\r\nimport field\r\n```",
              "createdAt": "2023-10-10T21:47:25Z",
              "updatedAt": "2023-10-10T21:47:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jfQUI",
          "commit": {
            "abbreviatedOid": "025c1c9"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T21:51:18Z",
          "updatedAt": "2023-10-10T21:51:18Z",
          "comments": [
            {
              "originalPosition": 354,
              "body": "Do you mean that we should do negative tests? \r\n\r\nLike test with invalid configurations and expect it to throw exception? \r\nIf so, I would like to introduce a dummy exception, like this\r\n```\r\nclass MultiproofParamsNotRecommended(Exception):\r\n    pass\r\n```\r\n\r\nThis way we can throw & check this error. Let other `ValueError` to fail? ",
              "createdAt": "2023-10-10T21:51:18Z",
              "updatedAt": "2023-10-10T21:51:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jfQm9",
          "commit": {
            "abbreviatedOid": "025c1c9"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T21:52:31Z",
          "updatedAt": "2023-10-10T21:52:32Z",
          "comments": [
            {
              "originalPosition": 351,
              "body": "I want to convey that this is an *internal* helper for `test_prio3sumvec`, not to used directly. What naming convention shall we follow?",
              "createdAt": "2023-10-10T21:52:32Z",
              "updatedAt": "2023-10-10T21:52:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jfRjX",
          "commit": {
            "abbreviatedOid": "025c1c9"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T21:55:47Z",
          "updatedAt": "2023-10-10T21:55:48Z",
          "comments": [
            {
              "originalPosition": 312,
              "body": "No. So we will limit to `Field64` only then?",
              "createdAt": "2023-10-10T21:55:47Z",
              "updatedAt": "2023-10-10T21:55:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jfSa5",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T21:57:15Z",
          "updatedAt": "2023-10-10T21:57:15Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "I think this is reflected in the latest version.",
              "createdAt": "2023-10-10T21:57:15Z",
              "updatedAt": "2023-10-10T21:57:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jfSu0",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T21:57:40Z",
          "updatedAt": "2023-10-10T21:57:40Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "I think this is reflected in the latest version.",
              "createdAt": "2023-10-10T21:57:40Z",
              "updatedAt": "2023-10-10T21:57:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jfSyc",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T21:57:46Z",
          "updatedAt": "2023-10-10T21:57:46Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "I think this is reflected in the latest version.",
              "createdAt": "2023-10-10T21:57:46Z",
              "updatedAt": "2023-10-10T21:57:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jfS9-",
          "commit": {
            "abbreviatedOid": "025c1c9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T21:58:31Z",
          "updatedAt": "2023-10-10T21:58:31Z",
          "comments": [
            {
              "originalPosition": 312,
              "body": "Yes. Better to not use `Field96` unless we have to :)",
              "createdAt": "2023-10-10T21:58:31Z",
              "updatedAt": "2023-10-10T21:58:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jfTma",
          "commit": {
            "abbreviatedOid": "025c1c9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T22:00:10Z",
          "updatedAt": "2023-10-10T22:00:11Z",
          "comments": [
            {
              "originalPosition": 351,
              "body": "Sounds reasonable. I ask because I don't use Python a lot and I'm wondering about its conventions. I don't have an alternative in mind, so I'll just defer to you.",
              "createdAt": "2023-10-10T22:00:10Z",
              "updatedAt": "2023-10-10T22:00:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jfUbk",
          "commit": {
            "abbreviatedOid": "025c1c9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T22:01:46Z",
          "updatedAt": "2023-10-10T22:01:46Z",
          "comments": [
            {
              "originalPosition": 354,
              "body": "I'm suggesting that tests to enforce the conditions they expect rather than skip testing if the conditions aren't meant. I would `assert` instead of `return`ing.",
              "createdAt": "2023-10-10T22:01:46Z",
              "updatedAt": "2023-10-10T22:01:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jfU0z",
          "commit": {
            "abbreviatedOid": "025c1c9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T22:02:32Z",
          "updatedAt": "2023-10-10T22:02:32Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Let's maybe go with `f` here.",
              "createdAt": "2023-10-10T22:02:32Z",
              "updatedAt": "2023-10-10T22:02:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jfU44",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T22:02:39Z",
          "updatedAt": "2023-10-10T22:02:39Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Any chance you are not checking the [latest](i.e. 025c1c9) commit? Should be reflected, no?",
              "createdAt": "2023-10-10T22:02:39Z",
              "updatedAt": "2023-10-10T22:02:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jfV_b",
          "commit": {
            "abbreviatedOid": "7342b68"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T22:07:28Z",
          "updatedAt": "2023-10-10T22:13:22Z",
          "comments": [
            {
              "originalPosition": 247,
              "body": "Yes. We check this upper bound in `Prio3SumVecWithMultiproof.is_recommended`.  I will add comments at first declaration as well.\r\nHaving said that, I am not sure what `PROOFS` we will put in the draft? I suppose it depends on robustness analysis. In any cases, due to computation cost, I would imagine > 255 proofs is prohibitive for most use cases.",
              "createdAt": "2023-10-10T22:07:29Z",
              "updatedAt": "2023-10-10T22:17:34Z"
            },
            {
              "originalPosition": 354,
              "body": "Got it. Since we settle on one field size only, this is much easier now. I will update.",
              "createdAt": "2023-10-10T22:13:15Z",
              "updatedAt": "2023-10-10T22:14:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jfZ1G",
          "commit": {
            "abbreviatedOid": "71f242a"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T22:25:26Z",
          "updatedAt": "2023-10-10T22:25:27Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": "OK. Only `Field64` for now. And algorithm ID/code point will assigned in another PR.",
              "createdAt": "2023-10-10T22:25:26Z",
              "updatedAt": "2023-10-10T22:26:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5jfbpC",
          "commit": {
            "abbreviatedOid": "025c1c9"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T22:32:29Z",
          "updatedAt": "2023-10-10T22:32:29Z",
          "comments": [
            {
              "originalPosition": 322,
              "body": "Will do. This does imply we have only one code point for this multiproof variant though?",
              "createdAt": "2023-10-10T22:32:29Z",
              "updatedAt": "2023-10-10T22:37:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5j83v3",
          "commit": {
            "abbreviatedOid": "3b28f0f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good, just nit-picky comments left.",
          "createdAt": "2023-10-13T17:01:23Z",
          "updatedAt": "2023-10-13T17:11:02Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n    \r\n    # Operational parameters\r\n    PROOFS = 1  # Number of proofs, in range `[1, 256)`\r\n```",
              "createdAt": "2023-10-13T17:01:23Z",
              "updatedAt": "2023-10-13T17:11:02Z"
            },
            {
              "originalPosition": 79,
              "body": "```suggestion\r\n        # Verify that each proof is well-formed and accepts the measurement.\r\n```",
              "createdAt": "2023-10-13T17:02:58Z",
              "updatedAt": "2023-10-13T17:11:02Z"
            },
            {
              "originalPosition": 103,
              "body": "```suggestion\r\n        # Generate the proofs and shard it into proof(s) shares.\r\n```",
              "createdAt": "2023-10-13T17:03:40Z",
              "updatedAt": "2023-10-13T17:11:02Z"
            },
            {
              "originalPosition": 267,
              "body": "Not related to this PR, but while we're here: Prefer to capitalize the roles.\r\n```suggestion\r\n        if type(meas_share) == list and type(proofs_share) == list:  # Leader\r\n```",
              "createdAt": "2023-10-13T17:06:03Z",
              "updatedAt": "2023-10-13T17:11:02Z"
            },
            {
              "originalPosition": 273,
              "body": "```suggestion\r\n        elif type(meas_share) == bytes and type(proofs_share) == bytes:  # Helper\r\n```",
              "createdAt": "2023-10-13T17:06:33Z",
              "updatedAt": "2023-10-13T17:11:02Z"
            },
            {
              "originalPosition": 310,
              "body": "```suggestion\r\n            return 2 <= num_proofs < 256\r\n```",
              "createdAt": "2023-10-13T17:07:31Z",
              "updatedAt": "2023-10-13T17:11:02Z"
            },
            {
              "originalPosition": 305,
              "body": "Avoid shadowing the imported `field` module\r\n```suggestion\r\n                       f: FftField) -> bool:\r\n```",
              "createdAt": "2023-10-13T17:08:53Z",
              "updatedAt": "2023-10-13T17:11:02Z"
            },
            {
              "originalPosition": 311,
              "body": "Future proofing\r\n```suggestion\r\n        elif field == Field128:\r\n            return 1 <= num_proofs < 256\r\n        return False\r\n```",
              "createdAt": "2023-10-13T17:09:35Z",
              "updatedAt": "2023-10-13T17:11:02Z"
            },
            {
              "originalPosition": 345,
              "body": "```suggestion\r\n        .with_params(10, 8, 9, num_proofs, field) \\\r\n```",
              "createdAt": "2023-10-13T17:10:32Z",
              "updatedAt": "2023-10-13T17:11:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5j9zUY",
          "commit": {
            "abbreviatedOid": "3b28f0f"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-13T18:41:38Z",
          "updatedAt": "2023-10-13T18:57:58Z",
          "comments": [
            {
              "originalPosition": 309,
              "body": "nit: typo\r\n```suggestion\r\n            # we encode it using one byte in `joint_rands`\r\n```",
              "createdAt": "2023-10-13T18:41:38Z",
              "updatedAt": "2023-10-13T18:57:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 300,
      "id": "PR_kwDOGKuqOc5cnlZp",
      "title": "Implement Prio3MultiHotHistogram that checks bounded number of 1s",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/300",
      "state": "MERGED",
      "author": "junyechen1996",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add a reference implementation of the idea in issue #287, which needs a new FLP 'MultiHotHistogram' and a new Prio3 type 'Prio3MultiHotHistogram' that checks a Client's measurement has a bounded number of 1s.",
      "createdAt": "2023-10-12T10:35:52Z",
      "updatedAt": "2023-10-16T21:06:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "3d108f4ff0ff4daec88c5fb537f29d2d440c3c4f",
      "headRepository": "junyechen1996/draft-irtf-cfrg-vdaf",
      "headRefName": "junyec/multi-hot-histogram",
      "headRefOid": "14ca48c2a74905b37ad0bcf33a388d24d0dbe040",
      "closedAt": "2023-10-16T21:06:09Z",
      "mergedAt": "2023-10-16T21:06:09Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "1d960b21b7f7418e0e3c95e325608fb74cc00914"
      },
      "comments": [
        {
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Squashed. Should be good to merge after CI is completed.",
          "createdAt": "2023-10-16T19:45:35Z",
          "updatedAt": "2023-10-16T19:45:49Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5jzF9I",
          "commit": {
            "abbreviatedOid": "42443c5"
          },
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-12T14:32:42Z",
          "updatedAt": "2023-10-12T14:32:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5j9Agb",
          "commit": {
            "abbreviatedOid": "f96ade5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Great work! One clarifying question about the requirements, see inline comment.",
          "createdAt": "2023-10-13T17:13:30Z",
          "updatedAt": "2023-10-13T17:50:05Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "This codepoint space is intended for Prio3 codepoints that are standardized. Let's leave it out until we've decided to do so. (If it turns out that we do want this for the DP draft, and the DP draft gets adopted, then we will certainly add it to the spec!)\r\n```suggestion\r\n    ID = 0xFFFFFFFF  # private codepoint for Prio3 types\r\n```",
              "createdAt": "2023-10-13T17:13:30Z",
              "updatedAt": "2023-10-13T17:50:05Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\r\n    A validity circuit that checks each Client's measurement is a bit vector\r\n    with at most `max_num_bits` 1s.\r\n```",
              "createdAt": "2023-10-13T17:13:58Z",
              "updatedAt": "2023-10-13T17:50:05Z"
            },
            {
              "originalPosition": 26,
              "body": "To match `valid()`\r\n```suggestion\r\n    In order to check the Client measurement `meas` has at most `max_num_bits` 1s,\r\n```",
              "createdAt": "2023-10-13T17:33:37Z",
              "updatedAt": "2023-10-13T17:50:05Z"
            },
            {
              "originalPosition": 27,
              "body": "Consistency with `SumVec` and `Sum`\r\n```suggestion\r\n    we ask the Client to send an additional `bits_for_count` bits that\r\n```",
              "createdAt": "2023-10-13T17:34:42Z",
              "updatedAt": "2023-10-13T17:50:05Z"
            },
            {
              "originalPosition": 26,
              "body": "Self-consistency: We call this the \"count check\" in the circuit.\r\n```suggestion\r\n    In order to check the Client measurement `x` has at most `max_count` 1s,\r\n```",
              "createdAt": "2023-10-13T17:36:23Z",
              "updatedAt": "2023-10-13T17:50:05Z"
            },
            {
              "originalPosition": 41,
              "body": "Here and below.\r\n```suggestion\r\n    length = None  # Set by the constructor\r\n```",
              "createdAt": "2023-10-13T17:38:13Z",
              "updatedAt": "2023-10-13T17:50:05Z"
            },
            {
              "originalPosition": 46,
              "body": "What is this type? For `Histogram` it's a single bucket index, but for `MultiHotHistogram` we need to be able to represent multiple locations being set.",
              "createdAt": "2023-10-13T17:39:47Z",
              "updatedAt": "2023-10-13T17:50:06Z"
            },
            {
              "originalPosition": 97,
              "body": "Is this sufficient for the DP use case? Suppose our algorithm for adding noise is something like this:\r\n```python3\r\nfor bucket_index in len(meas):\r\n   meas[bucket_index] += sample_independent_noise()\r\n```\r\nDepending on what `sample_independent_noise()` does, `meas[bucket_index]` might be something other than `0` or `1`.",
              "createdAt": "2023-10-13T17:42:31Z",
              "updatedAt": "2023-10-13T17:50:06Z"
            },
            {
              "originalPosition": 118,
              "body": "Prefer simpler language in comments\r\n```suggestion\r\n        # Check that `offset` plus the some of the buckets is equal to the\r\n```",
              "createdAt": "2023-10-13T17:43:24Z",
              "updatedAt": "2023-10-13T17:50:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5j9zTj",
          "commit": {
            "abbreviatedOid": "764776f"
          },
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "@cjpatton Please also feel free to add David to review, since it's his idea. I don't have permission to add him.",
          "createdAt": "2023-10-13T18:41:35Z",
          "updatedAt": "2023-10-13T19:23:04Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "oops, I blindly copied it from Histogram. It should be a vector of bits, so `Vec[Unsigned]`.",
              "createdAt": "2023-10-13T18:41:35Z",
              "updatedAt": "2023-10-13T19:23:04Z"
            },
            {
              "originalPosition": 97,
              "body": "0/1 check at each bucket is sufficient for randomized response Client-DP noise. What we do is: at each coordinate, we flip a coin that is configured with probability `1/(1+e^eps0)` where `eps0` is the pure-epsilon DP. If the coin turns out to be heads, we change the bit `x` to `1-x`, otherwise it stays as `x`, so each coordinate remains a bit.\r\nThe \"count check\" is to check the following statement in [Kunal's paper](https://arxiv.org/abs/2307.15017) after randomized response:\r\n\r\n> Similarly, the output of Rappor is a 0-1 vector where the number of 1s is bounded by O(1+K/(e^eps0 + 1)).\r\n\r\nWe will pass this bound with some delta as `max_count` to `MultiHotHistogram`.",
              "createdAt": "2023-10-13T18:43:19Z",
              "updatedAt": "2023-10-13T19:23:04Z"
            },
            {
              "originalPosition": 26,
              "body": "Fixed at all sites for `x`.",
              "createdAt": "2023-10-13T19:21:47Z",
              "updatedAt": "2023-10-13T19:23:04Z"
            },
            {
              "originalPosition": 27,
              "body": "Changed it at all locations.",
              "createdAt": "2023-10-13T19:22:14Z",
              "updatedAt": "2023-10-13T19:23:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5j-Ix4",
          "commit": {
            "abbreviatedOid": "f96ade5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T19:37:18Z",
          "updatedAt": "2023-10-13T19:37:18Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Perhaps it should be a set of bucket indices, i.e., `set[Unsigned]`? That would line up better with the measurement type for `Histogram`.",
              "createdAt": "2023-10-13T19:37:18Z",
              "updatedAt": "2023-10-13T19:37:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5j-JbU",
          "commit": {
            "abbreviatedOid": "f96ade5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T19:37:47Z",
          "updatedAt": "2023-10-13T19:37:48Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Great, thanks for clarifying.",
              "createdAt": "2023-10-13T19:37:47Z",
              "updatedAt": "2023-10-13T19:37:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5j-KT3",
          "commit": {
            "abbreviatedOid": "764776f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T19:38:34Z",
          "updatedAt": "2023-10-13T19:38:34Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Idea: the measurement is the set of bucket indices.\r\n```suggestion\r\n    Measurement = set[Unsigned]\r\n```",
              "createdAt": "2023-10-13T19:38:34Z",
              "updatedAt": "2023-10-13T19:38:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5j-LiP",
          "commit": {
            "abbreviatedOid": "764776f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "One minor suggestion for the measurement type.",
          "createdAt": "2023-10-13T19:39:55Z",
          "updatedAt": "2023-10-13T19:40:10Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "```suggestion\r\n        return joint_rand[1]    * range_check + \\\r\n               joint_rand[1]**2 * count_check\r\n```",
              "createdAt": "2023-10-13T19:39:55Z",
              "updatedAt": "2023-10-13T19:40:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5j-xHX",
          "commit": {
            "abbreviatedOid": "764776f"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-13T21:22:10Z",
          "updatedAt": "2023-10-13T21:35:38Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "We may as well avoid floating point math when computing this, so we don't have to worry about precision and rounding.\r\n```suggestion\r\n        self.bits_for_count = max_count.bit_length()\r\n```",
              "createdAt": "2023-10-13T21:22:10Z",
              "updatedAt": "2023-10-13T21:35:38Z"
            },
            {
              "originalPosition": 124,
              "body": "We have `autopep8` in our linter CI job, and it won't like the irregular number of spaces around operators. We could add some extra parentheses if readability is of concern.",
              "createdAt": "2023-10-13T21:33:17Z",
              "updatedAt": "2023-10-13T21:35:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5j_A61",
          "commit": {
            "abbreviatedOid": "764776f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T22:14:56Z",
          "updatedAt": "2023-10-13T22:14:56Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": ":(((\r\n\r\nNo no, let's do what the robot tells us to do. The main thing is to be consistent I think.",
              "createdAt": "2023-10-13T22:14:56Z",
              "updatedAt": "2023-10-13T22:14:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5kLoJg",
          "commit": {
            "abbreviatedOid": "5073ea0"
          },
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Rebased on main. Also squashed commits because I have to resolve conflicts.\r\n\r\nThe remaining open question is [this thread](https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/300#discussion_r1358753654).",
          "createdAt": "2023-10-16T18:58:08Z",
          "updatedAt": "2023-10-16T19:01:46Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I'm ok with either way.\r\n\r\nI was thinking more intuitively on how users use this API in the context of DP. They would pass an one-hot vector to the `add_noise` API [here](https://github.com/wangshan/draft-wang-ppm-differential-privacy/blob/main/draft-wang-ppm-differential-privacy.md#dp-mechanisms-mechanisms), and get back a vector of bits, so we can use the same `DataType`.\r\n\r\nIf we use indices, we would use `Unsigned` as input to `add_noise`, and get back `set[Unsigned]`, which also brings an additional dependency of `set`.\r\n\r\nLet me know if you have a strong preference to using `set` here though.",
              "createdAt": "2023-10-16T18:58:08Z",
              "updatedAt": "2023-10-16T19:00:58Z"
            },
            {
              "originalPosition": 70,
              "body": "Good call. Updated.",
              "createdAt": "2023-10-16T18:59:21Z",
              "updatedAt": "2023-10-16T19:00:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5kLzU-",
          "commit": {
            "abbreviatedOid": "764776f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-16T19:28:29Z",
          "updatedAt": "2023-10-16T19:28:29Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I don't have a strong preference.\r\n* Even if you go with `set`, I don't think there's a need to change the API in the DP draft to match: just map one type to the other.\r\n* If you stick with what you have please (1) change `Vec` to `list` and (2) add a comment describing the measurement type.",
              "createdAt": "2023-10-16T19:28:29Z",
              "updatedAt": "2023-10-16T19:28:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5kL29L",
          "commit": {
            "abbreviatedOid": "764776f"
          },
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-16T19:37:06Z",
          "updatedAt": "2023-10-16T19:37:06Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Sounds good. I changed it to `list[Unsigned]` and added comments next to `Measurement` type and `AggResult` type.",
              "createdAt": "2023-10-16T19:37:06Z",
              "updatedAt": "2023-10-16T19:37:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5kL2_h",
          "commit": {
            "abbreviatedOid": "c5332b4"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-16T19:37:13Z",
          "updatedAt": "2023-10-16T19:37:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 301,
      "id": "PR_kwDOGKuqOc5cwx86",
      "title": "Ack Junye",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/301",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "fyi/ @junyechen1996 ",
      "createdAt": "2023-10-13T17:56:35Z",
      "updatedAt": "2024-07-02T21:50:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "2ed6a6bcf151960a12a114bd1d62ece90a223292",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/ack-junye",
      "headRefOid": "037873bf525d9911a0cb318ff4d32b019384b154",
      "closedAt": "2023-10-13T18:32:47Z",
      "mergedAt": "2023-10-13T18:32:47Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "bb6fa77a90cc519ae95e3ac10488ee16fc1833d4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5j9gdX",
          "commit": {
            "abbreviatedOid": "037873b"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-13T18:03:01Z",
          "updatedAt": "2023-10-13T18:03:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5j9rV5",
          "commit": {
            "abbreviatedOid": "037873b"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-13T18:27:53Z",
          "updatedAt": "2023-10-13T18:27:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 302,
      "id": "PR_kwDOGKuqOc5dSylx",
      "title": "Add language about how the binder string / nonce is used in Poplar1",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/302",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wire change"
      ],
      "body": "Also use the nonce for the sharding XOF in poplar1, and make the poplar1 pseudocode in the spec consistent with the reference implementation.",
      "createdAt": "2023-10-19T16:11:56Z",
      "updatedAt": "2024-07-02T21:50:36Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "1d960b21b7f7418e0e3c95e325608fb74cc00914",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "schoppmp/poplar1_nonce",
      "headRefOid": "d112bd662ead74d655a4616d5c0ffc4113b97692",
      "closedAt": "2023-10-25T14:59:17Z",
      "mergedAt": "2023-10-25T14:59:17Z",
      "mergedBy": "schoppmp",
      "mergeCommit": {
        "oid": "d879846ee8e44c020660591206d868ab59c7693f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5k51In",
          "commit": {
            "abbreviatedOid": "5307605"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T15:29:30Z",
          "updatedAt": "2023-10-23T15:29:30Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5lDXrX",
          "commit": {
            "abbreviatedOid": "5307605"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Just a nit. Thanks for fixing this.",
          "createdAt": "2023-10-24T16:33:25Z",
          "updatedAt": "2023-10-24T16:33:59Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n  the Client (see {{nonce-requirements}}).\r\n```",
              "createdAt": "2023-10-24T16:33:25Z",
              "updatedAt": "2023-10-24T16:33:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 303,
      "id": "PR_kwDOGKuqOc5dTeMJ",
      "title": "Reduce number of AES calls needed by using the LSB of s for t in IdpfPoplar.extend",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/303",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wire change"
      ],
      "body": "",
      "createdAt": "2023-10-19T18:18:03Z",
      "updatedAt": "2024-07-02T21:50:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "1d960b21b7f7418e0e3c95e325608fb74cc00914",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "schoppmp/aes_expansion",
      "headRefOid": "36cba7611d21fc3666a80250dd273a75abe14ec2",
      "closedAt": "2023-10-25T14:57:56Z",
      "mergedAt": "2023-10-25T14:57:56Z",
      "mergedBy": "schoppmp",
      "mergeCommit": {
        "oid": "9426729655e1096d56d6d945201e599523d2faa8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5k7_O6",
          "commit": {
            "abbreviatedOid": "36cba76"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks reasonable to me. FWIW, note that the seed correction word will always have its low bit cleared.",
          "createdAt": "2023-10-23T20:12:44Z",
          "updatedAt": "2023-10-23T20:12:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5lDei8",
          "commit": {
            "abbreviatedOid": "36cba76"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Great idea \ud83d\udc4d ",
          "createdAt": "2023-10-24T16:44:37Z",
          "updatedAt": "2023-10-24T16:44:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 305,
      "id": "PR_kwDOGKuqOc5dq8Jh",
      "title": "Align draft with POC for multiproof changes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/305",
      "state": "MERGED",
      "author": "albertpl",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Update draft per multiproof POC\r\n* Add new Prio3 specific parameter, i.e. `Prio3.PROOFS`\r\n* Update Prio3 methods for sharing, preparation, aggregation to align with POC codes.",
      "createdAt": "2023-10-24T18:21:27Z",
      "updatedAt": "2023-11-04T15:48:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d879846ee8e44c020660591206d868ab59c7693f",
      "headRepository": "albertpl/draft-irtf-cfrg-vdaf",
      "headRefName": "draft-prio3-multiproof",
      "headRefOid": "974e24c4b2793bf7414e856913b9276f55f39b22",
      "closedAt": "2023-11-04T15:48:27Z",
      "mergedAt": "2023-11-04T15:48:27Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "ccbb6a0080255b0dbd28630bfa8b8d522b99fd84"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5lEPsw",
          "commit": {
            "abbreviatedOid": "f413443"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-24T18:22:56Z",
          "updatedAt": "2023-10-24T18:23:18Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "In POC, `PROOFS` lives in `class Prio3`. So I didn't add this parameter in VDAF or FLP. What do you think?",
              "createdAt": "2023-10-24T18:22:56Z",
              "updatedAt": "2023-10-24T18:23:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5lXMw3",
          "commit": {
            "abbreviatedOid": "865ec0a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Great start! I still need to double check that the reference code was copied properly (will do so in my next pass). In the meantime, the text needs a little work:\r\n\r\n\r\n1. I think we need a gentler introduction to the idea of multiple proofs. In the overview section, I think we should start by describing things in terms of a single proof, then have a paragraph where we describe the multi-proof feature and, just as importantly, why we need it\r\n2. Terms like \"proofs share\" and \"verifiers share\" make sense as variable names in code, but they don't read very well in English. My advice would be to read through the Prio3.\r\n3. We're going to need a section in Security Considerations about how changing `PROOFS` impacts security, in particular when we go for a smaller field for a given circuit. Feel free to leave as a TODO for now, but we should at least stub it out so we remember to get to it later.",
          "createdAt": "2023-10-26T20:20:05Z",
          "updatedAt": "2023-10-26T20:41:32Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\"proofs shares\" is grammatically odd. Even though we agreed this is the right term to use in the code, in English we should say this differently. I'd also suggesting hinting here that usually there will be one proof, but there could be more. (See suggestion.)\r\n```suggestion\r\n  used to verify the recovered output shares (e.g., the \"shares of the of the proof(s)\" in Prio3\r\n```",
              "createdAt": "2023-10-26T20:20:06Z",
              "updatedAt": "2023-10-26T20:40:50Z"
            },
            {
              "originalPosition": 13,
              "body": "I agree I don't think it belongs in either table.\r\n\r\nI would probably not create a table just for this. The first paragraph of {{prio3-construction}} (i.e., this section) lists `Xof` and `Flp` as \"associated parameters\"; I'd define `PROOFS` there. Perhaps call it an \"associated constant\". ",
              "createdAt": "2023-10-26T20:24:56Z",
              "updatedAt": "2023-10-26T20:40:50Z"
            },
            {
              "originalPosition": 28,
              "body": "I think we need a more gentle introduction to the idea of multi-proofs. Here I think we should speak just in terms of a single proof. Then in a short paragraph below, recall the `PROOFS` parameter and say what it does.",
              "createdAt": "2023-10-26T20:26:18Z",
              "updatedAt": "2023-10-26T20:40:50Z"
            },
            {
              "originalPosition": 144,
              "body": "```suggestion\r\n1. Generate and shard each proof into shares\r\n```",
              "createdAt": "2023-10-26T20:27:02Z",
              "updatedAt": "2023-10-26T20:40:50Z"
            },
            {
              "originalPosition": 155,
              "body": "\"randomnesses\" might be the right term if \"randomness\" would be ambiguous in context. Here I don't think it is. (Similar comment below.)\r\n\r\n```suggestion\r\nThe methods on `Prio3` for deriving the prover randomness, measurement shares,\r\n```",
              "createdAt": "2023-10-26T20:27:57Z",
              "updatedAt": "2023-10-26T20:40:50Z"
            },
            {
              "originalPosition": 290,
              "body": "```suggestion\r\njoint randomnesses `joint_rands`, split it into multiple `joint_rand`,\r\n```",
              "createdAt": "2023-10-26T20:28:38Z",
              "updatedAt": "2023-10-26T20:40:50Z"
            },
            {
              "originalPosition": 302,
              "body": "```suggestion\r\n1. Compute the joint randomness for each proof evaluation from the joint randomness seed\r\n```",
              "createdAt": "2023-10-26T20:30:22Z",
              "updatedAt": "2023-10-26T20:40:50Z"
            },
            {
              "originalPosition": 315,
              "body": "\"proofs share\" and \"verifiers share\" are confusing terms in this context. Don't just search and replace; we need to make sure this paragraph is still understandable.\r\n\r\nHere and below.",
              "createdAt": "2023-10-26T20:32:33Z",
              "updatedAt": "2023-10-26T20:40:50Z"
            },
            {
              "originalPosition": 623,
              "body": "As I mentioned above, I don't think we should create a table for just one parameter. Idea: Perhaps add the operational parameters (I believe just `Xof` and the `Flp`) to this table as well? Here and below.",
              "createdAt": "2023-10-26T20:34:25Z",
              "updatedAt": "2023-10-26T20:40:50Z"
            },
            {
              "originalPosition": 677,
              "body": "Paragraphs should wrap at 80 characters (this line is 88 characters long).",
              "createdAt": "2023-10-26T20:35:00Z",
              "updatedAt": "2023-10-26T20:40:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5leDVN",
          "commit": {
            "abbreviatedOid": "7d8f677"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-27T18:56:24Z",
          "updatedAt": "2023-10-27T18:57:49Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I add this paragraph after we introduce `FLP` in details since we need these details (proof, Flp.prove, field, soundness, etc) to describe the concept of multiproofs better.  What do you think?",
              "createdAt": "2023-10-27T18:56:24Z",
              "updatedAt": "2023-10-27T18:57:49Z"
            },
            {
              "originalPosition": 45,
              "body": "I hightlight the default value `1` here. Maybe we don't have to repeat it in each instance?",
              "createdAt": "2023-10-27T18:57:27Z",
              "updatedAt": "2023-10-27T18:57:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5lnznl",
          "commit": {
            "abbreviatedOid": "6572a2b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Looking good, almost there.",
          "createdAt": "2023-10-30T19:35:21Z",
          "updatedAt": "2023-10-30T20:04:27Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nall proofs have been thoroughly verified. Notably, several proofs using a smaller\r\n```",
              "createdAt": "2023-10-30T19:35:21Z",
              "updatedAt": "2023-10-30T20:04:27Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nfield can offer the same level of soundness as a single proof using a large field.\r\n```",
              "createdAt": "2023-10-30T19:35:33Z",
              "updatedAt": "2023-10-30T20:04:27Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n({{xof}}). It also has an associated constant, `PROOFS` with a value within\r\n the range of `[1, 256)`, denotes the number of FLPs generated by the Client ({{multiproofs}}). The value of `PROOFS` is `1` unless explicitly specified.\r\n```",
              "createdAt": "2023-10-30T19:37:40Z",
              "updatedAt": "2023-10-30T20:04:27Z"
            },
            {
              "originalPosition": 19,
              "body": "Let's simplify this a bit, since we're going to have to spell it out again in {{prio3}}. Best to keep things high level here.\r\n```suggestion\r\nTo generate these proofs for a specific measurement, the prover calls\r\n`Flp.prove` multiple times, each time using an independently generated prover and joint randomness string.\r\nThe verifier checks each proof independently, each time with an independently generated query randomness string. It accepts the measurement only if all the decision algorithm accepts on each proof.\r\n```",
              "createdAt": "2023-10-30T19:42:41Z",
              "updatedAt": "2023-10-30T20:04:27Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\n defined in {{prio3-param}}. The methods required for sharding,\r\n```",
              "createdAt": "2023-10-30T19:43:03Z",
              "updatedAt": "2023-10-30T20:04:27Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\n```",
              "createdAt": "2023-10-30T19:43:23Z",
              "updatedAt": "2023-10-30T20:04:27Z"
            },
            {
              "originalPosition": 53,
              "body": "* Add more prompting (remind the reader why this feature exists)\r\n* Make grammar consistent with above\r\n* Fix various typos\r\n\r\n```suggestion\r\nAs described in {{multiproofs}}, the soundness of the FLP can be amplified by generating and verifying multiple FLPs. (This in turn improves the robustness of Prio3.) To support this, in Prio3:\r\n\r\n* In step 3, derive as much joint randomness as required by `PROOFS` proofs\r\n* repeat step 4 `PROOFS` times, each time with a unique joint randomness\r\n```",
              "createdAt": "2023-10-30T19:52:12Z",
              "updatedAt": "2023-10-30T20:04:27Z"
            },
            {
              "originalPosition": 277,
              "body": "```suggestion\r\n                                             prove_rand, joint_rand)\r\n```",
              "createdAt": "2023-10-30T19:54:56Z",
              "updatedAt": "2023-10-30T20:04:27Z"
            },
            {
              "originalPosition": 162,
              "body": "```suggestion\r\n1. Encode each measurement and shares of each proof into an input share\r\n```",
              "createdAt": "2023-10-30T19:55:49Z",
              "updatedAt": "2023-10-30T20:04:27Z"
            },
            {
              "originalPosition": 168,
              "body": "```suggestion\r\nNotice that only one pair of measurement and proof(s) share (called the\r\n```",
              "createdAt": "2023-10-30T19:56:28Z",
              "updatedAt": "2023-10-30T20:04:27Z"
            },
            {
              "originalPosition": 328,
              "body": "```suggestion\r\ncombined into the verifier message(s) used to decide whether to accept.\r\n```",
              "createdAt": "2023-10-30T19:57:52Z",
              "updatedAt": "2023-10-30T20:04:27Z"
            },
            {
              "originalPosition": 4,
              "body": "This section should have a forwards reference to {{security-multiproof}}",
              "createdAt": "2023-10-30T20:01:34Z",
              "updatedAt": "2023-10-30T20:04:27Z"
            },
            {
              "originalPosition": 625,
              "body": "\r\n```suggestion\r\n## Choosing the Number of Proofs to Use for Prio3 {#security-multiproof}\r\n```",
              "createdAt": "2023-10-30T20:02:25Z",
              "updatedAt": "2023-10-30T20:04:27Z"
            },
            {
              "originalPosition": 625,
              "body": "Add a newline between the title and the first paragraph\r\n```suggestion\r\n## Considerations for multiple proofs (`PROOFS`) {#security-multiproof}\r\n\r\n```",
              "createdAt": "2023-10-30T20:02:47Z",
              "updatedAt": "2023-10-30T20:04:27Z"
            },
            {
              "originalPosition": 626,
              "body": "* \"TODO\"s should be imperative, similarly to how we write commit messages. (E.g., TODO Add guidance for ...\"\r\n* Add a reference to the open issue.\r\n* Break lines at 80 characters.\r\n",
              "createdAt": "2023-10-30T20:04:02Z",
              "updatedAt": "2023-10-30T20:04:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ln9-r",
          "commit": {
            "abbreviatedOid": "7d8f677"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-30T20:04:46Z",
          "updatedAt": "2023-10-30T20:04:46Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Works for me.",
              "createdAt": "2023-10-30T20:04:46Z",
              "updatedAt": "2023-10-30T20:04:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5l7ncP",
          "commit": {
            "abbreviatedOid": "f1e0533"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-02T12:30:54Z",
          "updatedAt": "2023-11-02T12:33:02Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n```",
              "createdAt": "2023-11-02T12:30:54Z",
              "updatedAt": "2023-11-02T12:33:02Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nall proofs have been verified. Notably, several proofs using a smaller\r\nfield can offer the same level of soundness as a single proof using a large field.\r\n```",
              "createdAt": "2023-11-02T12:31:48Z",
              "updatedAt": "2023-11-02T12:33:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5l9H70",
          "commit": {
            "abbreviatedOid": "974e24c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you! Please squash and I'll merge.",
          "createdAt": "2023-11-02T15:00:05Z",
          "updatedAt": "2023-11-03T01:59:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 308,
      "id": "PR_kwDOGKuqOc5fAtZw",
      "title": "Replace SHAKE128 with TurboSHAKE128",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/308",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wire change"
      ],
      "body": "Closes #299.\r\n\r\nThe reference code uses the reference implementation of TurboSHAKE128. This code is unoptimized, so care is needed to ensure our tests run in a reasonable amount of time.\r\n\r\nEach time `XofTurboShake128` is constructed we call `TurboSHAKE128()` once and fill a buffer with the output stream. The size of the buffer is a constant, `MAX_XOF_OUT_STREAM_BYTES`, chosen to be sufficiently long for every test that we have. So that we don't have to make this value too large, some of tests in `vdaf_poplar1.py` have been modified.",
      "createdAt": "2023-11-09T09:14:48Z",
      "updatedAt": "2024-07-02T21:50:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "ccbb6a0080255b0dbd28630bfa8b8d522b99fd84",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/299",
      "headRefOid": "c0131a26073c6da2acb159165824c43f013835b0",
      "closedAt": "2023-11-15T14:43:05Z",
      "mergedAt": "2023-11-15T14:43:05Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "fd7a2dc4993babbf3acffc7d498cd7925890064b"
      },
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "FWIW, Datatracker is returning a quoted-printable encoding of \"Beno\u00eet Viguier\", so xml2rfc's reference cache sees `<author initials=\"\" surname=\"=?utf-8?q?Beno=C3=AEt_Viguier?=\" fullname=\"=?utf-8?q?Beno=C3=AEt_Viguier?=\">`. (Both the bibtex and bibxml files have the quoted-printable version) The encoded strings unfortunately show up in the [rendered document](https://cfrg.github.io/draft-irtf-cfrg-vdaf/cjpatton/299/draft-irtf-cfrg-vdaf.html#TurboSHAKE). This is showing up on the [KangarooTwelve Datatracker page](https://datatracker.ietf.org/doc/draft-irtf-cfrg-kangarootwelve/) as well. The [upstream source](https://github.com/cfrg/draft-irtf-cfrg-kangarootwelve/blame/master/draft-irtf-cfrg-kangarootwelve.xml) looks reasonable, as it's using an XML character entry reference. There's an issue filed about this particular issue already, see ietf-tools/datatracker#6455.",
          "createdAt": "2023-11-13T19:14:00Z",
          "updatedAt": "2023-11-13T19:14:00Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5mpm-T",
          "commit": {
            "abbreviatedOid": "92060f8"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-09T10:10:58Z",
          "updatedAt": "2023-11-09T10:10:58Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "CI is failing here, apparently because it's not fetching the `draft-irtf-cfrg-kangarootwelve` submodule. How do we tell CI to fetch this?\r\n\r\nNote that I've included this implementation because there appears to be no implementation of TurboSHAKE available in pip. As a last resort, we could just copy-paste the reference code for TurboSHAKE here.",
              "createdAt": "2023-11-09T10:10:58Z",
              "updatedAt": "2023-11-09T10:10:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ms2EX",
          "commit": {
            "abbreviatedOid": "92060f8"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-09T16:41:53Z",
          "updatedAt": "2023-11-09T16:41:54Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "This is controlled by the default settings of the `actions/checkout@v3` reusable action. We just need the following in the test job:\r\n\r\n```yaml\r\n- name: Checkout\r\n  uses: actions/checkout@v3\r\n  with:\r\n    submodules: true\r\n```\r\n\r\nThere is [`Crypto.Hash.KangarooTwelve.K12_XOF`](https://pycryptodome.readthedocs.io/en/latest/src/hash/k12.html#Crypto.Hash.KangarooTwelve.K12_XOF) in PyCryptodome, but if it's using a different name, I wonder if the algorithm might be from an old enough draft version that the algorithm is different.",
              "createdAt": "2023-11-09T16:41:53Z",
              "updatedAt": "2023-11-09T16:41:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5mtFc0",
          "commit": {
            "abbreviatedOid": "92060f8"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-09T17:04:59Z",
          "updatedAt": "2023-11-09T17:05:00Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I played around with this a bit and I don't think it complies with the draft. (See https://github.com/Legrandin/pycryptodome/issues/780.) Hint: This takes in an arbitrary-length customization string, whereas the draft wants just a byte for customization.",
              "createdAt": "2023-11-09T17:04:59Z",
              "updatedAt": "2023-11-09T17:05:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5mtKA6",
          "commit": {
            "abbreviatedOid": "92060f8"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-09T17:14:57Z",
          "updatedAt": "2023-11-09T17:14:57Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "That fixed CI! Thanks @divergentdave. I'll leave the TurboSHAKE128 implementation where it is ... it would be great to use PyCryptodome if/when it is compatible with the draft.",
              "createdAt": "2023-11-09T17:14:57Z",
              "updatedAt": "2023-11-09T17:14:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5nBPt-",
          "commit": {
            "abbreviatedOid": "c0131a2"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-13T22:19:40Z",
          "updatedAt": "2023-11-13T22:19:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 309,
      "id": "PR_kwDOGKuqOc5fImXg",
      "title": "Prio3: Improve domain separation for multi-proof mode",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/309",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wire change"
      ],
      "body": "Partially addresses #177.\r\n\r\nThe query randomness is correlated for different values of `Prio3.PROOFS`. To provide defense in depth in case the same verification key is used for different versions, prepend the binder with `bytes(Prio3.PROOFS)`.\r\n\r\nFor consistency, do the same for the prove randomness and each Helper's share of the proofs. Also, do the same for joint randomness in case `Prio3.PROOFS == 1`.",
      "createdAt": "2023-11-10T12:06:21Z",
      "updatedAt": "2024-06-08T19:54:54Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "ccbb6a0080255b0dbd28630bfa8b8d522b99fd84",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/177-breaking",
      "headRefOid": "bdf1354f2c501bd9c10ff7737bc07ee4a4992937",
      "closedAt": "2023-11-16T14:28:14Z",
      "mergedAt": "2023-11-16T14:28:14Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "bfcfeb77a7f5866dbf728a247e537248ab303655"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@divergentdave please let me know if you'd be happy implementing multi-proof mode in libprio-rs. (Previously it was optional, but this PR would make this feature wire breaking.)\r\n\r\n@albertpl please review as well and make sure you're happy.",
          "createdAt": "2023-11-10T12:07:57Z",
          "updatedAt": "2023-11-10T12:07:57Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> Good catch!\r\n> \r\n> So this change would break some of the Prio3 related test vectors , right? If we generate test vectors with `PROOFS=1`, it wouldn't be the same again. Is that a problem? Shall we document this?\r\n\r\nYes, we'll break the test vectors, but we will break the test vectors anyway in the next version (when we bump `VERSION`). All we need to do is re-generate them, so this is not a problem. The break will be documented in the Change Log section of the draft.\r\n\r\n> Wait. So `wire change` is for this purpose?\r\n\r\nYes.\r\n",
          "createdAt": "2023-11-14T17:36:11Z",
          "updatedAt": "2023-11-14T17:36:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5m3cHM",
          "commit": {
            "abbreviatedOid": "bdf1354"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Good catch!\r\n\r\nSo this change would break some of the Prio3 related test vectors , right? If we generate test vectors with `PROOFS=1`, it wouldn't be the same again. Is that a problem? Shall we document this? \r\n\r\nWait. So `wire change` is for this purpose? ",
          "createdAt": "2023-11-10T23:43:21Z",
          "updatedAt": "2023-11-10T23:48:02Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Note to myself. `byte` actually returns `bytes`, which is a sequence. So `+` is concatenation operation.",
              "createdAt": "2023-11-10T23:43:21Z",
              "updatedAt": "2023-11-10T23:45:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5nLKc0",
          "commit": {
            "abbreviatedOid": "bdf1354"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for catching this.",
          "createdAt": "2023-11-14T23:12:26Z",
          "updatedAt": "2023-11-14T23:12:26Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5nTl7n",
          "commit": {
            "abbreviatedOid": "bdf1354"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM. We can implement it in libprio-rs too. I figure the main thing we'll have to watch out for is performance regressions if bound checks stop being elided, but we can address that with appropriate use of iterators.",
          "createdAt": "2023-11-15T23:01:06Z",
          "updatedAt": "2023-11-15T23:01:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 310,
      "id": "PR_kwDOGKuqOc5fW3S-",
      "title": "Fix metadata of informative references",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/310",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #307. I noticed the following error messages when running `make`:\r\n\r\n```\r\n*** attributes left {\"authors\"=>[{\"ins\"=>\"C. Guo\"}, {\"ins\"=>\"J. Katz\"}, {\"ins\"=>\"X. Wang\"}, {\"ins\"=>\"C. Weng\"}, {\"ins\"=>\"Y. Yu\"}]}!\r\n*** attributes left {\"authors\"=>[{\"ins\"=>\"C. Guo\"}, {\"ins\"=>\"J. Katz\"}, {\"ins\"=>\"X. Wang\"}, {\"ins\"=>\"Y. Yu\"}]}!\r\n```",
      "createdAt": "2023-11-14T00:41:57Z",
      "updatedAt": "2023-11-14T16:30:45Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "ccbb6a0080255b0dbd28630bfa8b8d522b99fd84",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/fix-reference-author",
      "headRefOid": "1da7ee5b7a0c8bf97caf2f2a56e01c7123173b0b",
      "closedAt": "2023-11-14T16:30:42Z",
      "mergedAt": "2023-11-14T16:30:42Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "016cf0194c5f827ed36f56a8cd02ac68b2915603"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5nIIqL",
          "commit": {
            "abbreviatedOid": "1da7ee5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-14T16:29:56Z",
          "updatedAt": "2023-11-14T16:29:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 313,
      "id": "PR_kwDOGKuqOc5fpNfO",
      "title": "Prepare VDAF-08",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/313",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* Update change log\r\n* Bump `VERSION`\r\n* Generate test vectors",
      "createdAt": "2023-11-16T15:23:52Z",
      "updatedAt": "2024-06-08T19:54:54Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "bfcfeb77a7f5866dbf728a247e537248ab303655",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/draft08",
      "headRefOid": "76d7a862ef1838871353348d34e2f056fe739c30",
      "closedAt": "2023-11-20T12:48:11Z",
      "mergedAt": "2023-11-20T12:48:11Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "b74e9c37d838b9a1182f0e4b7b4f6e737bd565ed"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5nbSfD",
          "commit": {
            "abbreviatedOid": "76d7a86"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-16T18:51:30Z",
          "updatedAt": "2023-11-16T18:51:30Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5nbgrd",
          "commit": {
            "abbreviatedOid": "76d7a86"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-16T19:16:18Z",
          "updatedAt": "2023-11-16T19:16:24Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "This is for my own edification, not a request to change the wording: since k_shard is randomly generated, and not used anywhere else, this binding isn't checked/enforced by any other protocol participant. While this isn't preventing any replay attack, I can see that it could simplify security proofs, and maybe improve bounds, by eliminating the impact of k_shard colliding. Is it typical to still refer to incorporating identifiers as \"binding\" in situations like this?",
              "createdAt": "2023-11-16T19:16:18Z",
              "updatedAt": "2023-11-16T19:16:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ndB2C",
          "commit": {
            "abbreviatedOid": "76d7a86"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-16T22:36:29Z",
          "updatedAt": "2023-11-16T22:36:29Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "\"Binding\" is a very abused term. I'm using the phrase \"bind to nonce\" here to mean that the value is derived from the nonce: if the changes, then so does the value. I don't mean to imply any particular security property. In certain situations, this sort of thing may indeed be necessary for security.",
              "createdAt": "2023-11-16T22:36:29Z",
              "updatedAt": "2023-11-16T22:36:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 315,
      "id": "PR_kwDOGKuqOc5gmaSM",
      "title": "Remove test vectors for non-standard Prio3 variants",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/315",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The reference code has implementations of Prio3 variants that have not been standardized. The test code generates test vectors for these, which we checked in to the repo when we cut the last draft.\r\n\r\nTo avoid confusion, remove the test vectors for these non-standardized variants.",
      "createdAt": "2023-11-28T20:53:00Z",
      "updatedAt": "2024-06-08T19:54:55Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "b74e9c37d838b9a1182f0e4b7b4f6e737bd565ed",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/remove-unnused-test-vec",
      "headRefOid": "9b7fff25579423291ac4217f0f1f19fecb9b6980",
      "closedAt": "2023-11-28T22:19:29Z",
      "mergedAt": "2023-11-28T22:19:29Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "e03411b116a185de6c42dfe43a0e8f3b5f62ca90"
      },
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "One related note: when `test_prio3sumvec_with_multiproof()` calls `_test_prio3sumvec()` three times, this results in clobbering the test vector file twice. Before we eventually standardize this, we'll want to pass different numbers for `test_vec_instance` to fix this.",
          "createdAt": "2023-11-28T20:59:09Z",
          "updatedAt": "2023-11-28T20:59:09Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> Looks good. Should we take out the `print_test_vec=TEST_VECTOR` arguments that generated these as well?\r\n\r\nDone.",
          "createdAt": "2023-11-28T21:13:59Z",
          "updatedAt": "2023-11-28T21:13:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5oiwKm",
          "commit": {
            "abbreviatedOid": "dcf940e"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good. Should we take out the `print_test_vec=TEST_VECTOR` arguments that generated these as well?",
          "createdAt": "2023-11-28T21:05:24Z",
          "updatedAt": "2023-11-28T21:05:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 317,
      "id": "PR_kwDOGKuqOc5hB1Y9",
      "title": "Clarify powers of malicious collectors in Poplar",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/317",
      "state": "CLOSED",
      "author": "simon-friedberger",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This resolves https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/316",
      "createdAt": "2023-12-04T09:19:26Z",
      "updatedAt": "2024-03-07T17:24:56Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "e03411b116a185de6c42dfe43a0e8f3b5f62ca90",
      "headRepository": "simon-friedberger/draft-irtf-cfrg-vdaf",
      "headRefName": "main",
      "headRefOid": "cba222fa5946ff286e3bdb6b1b5377e7906b79b4",
      "closedAt": "2024-03-07T17:24:55Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Hey @simon-friedberger, just a heads up that we've been disucssing this issue and may end up resolving it slightly differently. We'll review this PR soon. Thanks again!",
          "createdAt": "2023-12-08T17:22:14Z",
          "updatedAt": "2023-12-08T17:22:14Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #332.",
          "createdAt": "2024-03-07T17:24:55Z",
          "updatedAt": "2024-03-07T17:24:55Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 318,
      "id": "PR_kwDOGKuqOc5hOszr",
      "title": "Add a tool for plotting Prio3 robustness bounds",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/318",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #311.",
      "createdAt": "2023-12-05T21:26:02Z",
      "updatedAt": "2024-06-08T19:54:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "e03411b116a185de6c42dfe43a0e8f3b5f62ca90",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/311",
      "headRefOid": "f6f689b4962d88217b1d27f1c2152099800b6639",
      "closedAt": "2023-12-15T22:57:54Z",
      "mergedAt": "2023-12-15T22:57:54Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "cb5433b91163a2bc36b0f6ac6d1a84405e6634c2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5pTGwY",
          "commit": {
            "abbreviatedOid": "b38ac91"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-06T04:33:38Z",
          "updatedAt": "2023-12-06T05:07:44Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Maybe comment or rename it to souness error?",
              "createdAt": "2023-12-06T04:33:39Z",
              "updatedAt": "2023-12-06T05:07:44Z"
            },
            {
              "originalPosition": 6,
              "body": "Any chance to reuse the definitions in field.py?",
              "createdAt": "2023-12-06T04:36:19Z",
              "updatedAt": "2023-12-06T05:07:44Z"
            },
            {
              "originalPosition": 50,
              "body": "Same question as above. Is this meant to be used as standalone tool? or it is OK to reuse  the class `SumVec`?",
              "createdAt": "2023-12-06T04:53:18Z",
              "updatedAt": "2023-12-06T05:07:44Z"
            },
            {
              "originalPosition": 27,
              "body": "btw, I believe when `num_proofs` increase,  these negligible may become more significant since the first term is exponentially shrinking. Any harm to include it anyway?",
              "createdAt": "2023-12-06T05:05:07Z",
              "updatedAt": "2023-12-06T05:07:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5pXYJB",
          "commit": {
            "abbreviatedOid": "b38ac91"
          },
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-06T14:35:15Z",
          "updatedAt": "2023-12-06T14:36:46Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Don't you also need to account for the soundness error of taking random linear combination, when one of the coefficients multiplied with x^2-x circuits is 0? proved by Theorem 5.3 in the same paper.",
              "createdAt": "2023-12-06T14:35:15Z",
              "updatedAt": "2023-12-06T14:36:46Z"
            },
            {
              "originalPosition": 55,
              "body": "nit: `math.sqrt` will produce a float, better to use round down or up? since `chunk_length` should be an integer.",
              "createdAt": "2023-12-06T14:35:50Z",
              "updatedAt": "2023-12-06T14:36:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5pYkdW",
          "commit": {
            "abbreviatedOid": "b38ac91"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-06T16:23:56Z",
          "updatedAt": "2023-12-06T16:32:04Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Could do, but I didn't want to over-complicate this script.",
              "createdAt": "2023-12-06T16:23:57Z",
              "updatedAt": "2023-12-06T16:32:04Z"
            },
            {
              "originalPosition": 22,
              "body": "Yes, good catch.",
              "createdAt": "2023-12-06T16:24:33Z",
              "updatedAt": "2023-12-06T16:32:04Z"
            },
            {
              "originalPosition": 27,
              "body": "Sure, I can add it.",
              "createdAt": "2023-12-06T16:28:55Z",
              "updatedAt": "2023-12-06T16:32:04Z"
            },
            {
              "originalPosition": 50,
              "body": "I think I'd rather keep it independent, but I don't feel strongly about it. If you feel strongly about this I can move this script into the poc folder.",
              "createdAt": "2023-12-06T16:30:17Z",
              "updatedAt": "2023-12-06T16:32:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5pZew0",
          "commit": {
            "abbreviatedOid": "b38ac91"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-06T18:01:22Z",
          "updatedAt": "2023-12-06T18:01:22Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "That is excellent point! And this new term is probably the dominant one.",
              "createdAt": "2023-12-06T18:01:22Z",
              "updatedAt": "2023-12-06T18:01:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5pZrOj",
          "commit": {
            "abbreviatedOid": "954b19d"
          },
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-06T18:21:29Z",
          "updatedAt": "2023-12-06T18:21:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5pZrmz",
          "commit": {
            "abbreviatedOid": "954b19d"
          },
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-06T18:22:24Z",
          "updatedAt": "2023-12-06T18:22:29Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I know we are assuming `bit_length = 1` in this function, but in case you want to extend this function in the future, it might help to make this explicit (e.g. defining this variable, or set that as one of the function arguments), since you also need `bit_length` when computing `circuit_soundness = length * bit_length / field_size`, so we don't forget about this assumption.",
              "createdAt": "2023-12-06T18:22:24Z",
              "updatedAt": "2023-12-06T18:22:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5pY_J4",
          "commit": {
            "abbreviatedOid": "954b19d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-06T17:11:08Z",
          "updatedAt": "2023-12-06T18:36:05Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Done.",
              "createdAt": "2023-12-06T17:11:08Z",
              "updatedAt": "2023-12-06T18:36:05Z"
            },
            {
              "originalPosition": 12,
              "body": "\"bound\" would be a better term. I think I'd prefer to keep it as is.",
              "createdAt": "2023-12-06T17:11:33Z",
              "updatedAt": "2023-12-06T18:36:05Z"
            },
            {
              "originalPosition": 55,
              "body": "Done.",
              "createdAt": "2023-12-06T17:14:38Z",
              "updatedAt": "2023-12-06T18:36:05Z"
            },
            {
              "originalPosition": 50,
              "body": "Done.",
              "createdAt": "2023-12-06T17:14:51Z",
              "updatedAt": "2023-12-06T18:36:05Z"
            },
            {
              "originalPosition": 22,
              "body": "Done.",
              "createdAt": "2023-12-06T17:25:47Z",
              "updatedAt": "2023-12-06T18:36:05Z"
            },
            {
              "originalPosition": 27,
              "body": "Great catch here. This term really does indeed have an impact on the plot.",
              "createdAt": "2023-12-06T17:46:47Z",
              "updatedAt": "2023-12-06T18:36:05Z"
            },
            {
              "originalPosition": 52,
              "body": "Good idea, done.",
              "createdAt": "2023-12-06T18:36:00Z",
              "updatedAt": "2023-12-06T18:36:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5pcYSY",
          "commit": {
            "abbreviatedOid": "46a9ae2"
          },
          "author": "albertpl",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-07T03:18:19Z",
          "updatedAt": "2023-12-07T03:18:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5pgsAQ",
          "commit": {
            "abbreviatedOid": "46a9ae2"
          },
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-07T13:33:06Z",
          "updatedAt": "2023-12-07T13:33:48Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Why does the power have negative sign..?\r\n```suggestion\r\n    chunk_length = max(1, int(length**(1/2)))\r\n```",
              "createdAt": "2023-12-07T13:33:06Z",
              "updatedAt": "2023-12-07T13:33:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5piOMQ",
          "commit": {
            "abbreviatedOid": "46a9ae2"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-07T16:29:33Z",
          "updatedAt": "2023-12-07T16:29:34Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Whoops, the negative sign isn't supposed to be there.\r\nThe `int()` isn't necessary because sage represents numbers exactly:\r\n```\r\n[cjpatton/311][~/github.com/cfrg/draft-irtf-cfrg-vdaf/poc]$ sage\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 SageMath version 9.8, Release Date: 2023-02-11                     \u2502\r\n\u2502 Using Python 3.11.1. Type \"help()\" for help.                       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nsage: 100^(1/2)\r\n10\r\nsage: 102^(1/2)\r\nsqrt(102)\r\nsage:\r\n```",
              "createdAt": "2023-12-07T16:29:33Z",
              "updatedAt": "2023-12-07T16:29:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 320,
      "id": "PR_kwDOGKuqOc5iMdYe",
      "title": "Infer relative path of kangerootwelve",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/320",
      "state": "MERGED",
      "author": "junyechen1996",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This will resolve two problems:\r\n- When another repo tries to submodule this repo, we won't hit problems when trying to import kangerootwelve\r\n- We don't always have to run unit tests from the \"poc\" folder, e.g., I can still run unit tests from the root directory of this repo, sage -python poc/vdaf_prio3.py",
      "createdAt": "2023-12-17T20:00:42Z",
      "updatedAt": "2023-12-18T15:18:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "cb5433b91163a2bc36b0f6ac6d1a84405e6634c2",
      "headRepository": "junyechen1996/draft-irtf-cfrg-vdaf",
      "headRefName": "junyec/use-relative-path",
      "headRefOid": "d8c9709c93ec4ab61657e4540b4a3160e35d0b86",
      "closedAt": "2023-12-18T15:18:50Z",
      "mergedAt": "2023-12-18T15:18:50Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "3d2dd77befcf149c818b4bae1744e60c00d0a4f3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5qhaiz",
          "commit": {
            "abbreviatedOid": "d8c9709"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\ud83d\udc4d ",
          "createdAt": "2023-12-18T15:18:44Z",
          "updatedAt": "2023-12-18T15:18:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 322,
      "id": "PR_kwDOGKuqOc5igJja",
      "title": "poc: Reduce test runtime by making TurboSHAKE128 stateful",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/322",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #321.\r\n\r\nThe reference implementation of TurboSHAKE128 provides a one-shot API. To use this efficiently, we restrict the number of bytes required for tests so that we can pre-compute the entire output buffer. This is controlled by MAX_XOF_OUT_STREAM_BYTES.\r\n\r\nThis restriction is confusing and has side-effects for specs that use XofTurboShake128. However using the one-shot API without this optimization makes the unit tests prohibitively slow, about a minute on my machine.\r\n\r\nImplement a stateful API for TurboSHAKE128 and use it in XofTurboShake128. This reduces the runtime to 20 seconds on my machine.\r\n\r\nAccordingly, restore the unit tests for Poplar1 to what they were before we made this optimization.\r\n\r\ncc/ @junyechen1996 ",
      "createdAt": "2023-12-20T19:13:56Z",
      "updatedAt": "2024-06-08T19:54:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "3d2dd77befcf149c818b4bae1744e60c00d0a4f3",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/321-implement-stateful-turboshake",
      "headRefOid": "dda6990b53c2b7270071b2757a2bfe921cb87b57",
      "closedAt": "2024-01-10T02:58:19Z",
      "mergedAt": "2024-01-10T02:58:19Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "97fcdd4e159767ced633d373397b7048901f7d29"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Reviewer note: Eventually we'll be able to use PyCryptodome instead: https://github.com/Legrandin/pycryptodome/issues/780\r\n",
          "createdAt": "2024-01-09T00:19:33Z",
          "updatedAt": "2024-01-09T00:19:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5sAJh4",
          "commit": {
            "abbreviatedOid": "dda6990"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-09T20:44:45Z",
          "updatedAt": "2024-01-09T20:44:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 324,
      "id": "PR_kwDOGKuqOc5j2ZWt",
      "title": "Use PyCryptodomex's implementation of TurboSHAKE128",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/324",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #323.\r\n\r\nSupport for TurboSHAKE was recently (as of version 3.20.0) added to PyCryptodomex. Use it instead of our own implementation and remove our implementation.\r\n\r\nAccordingly, remove the draft-irtf-cfrg-kangarootwelve submodule, as we no longer need it for interop testing with our code.\r\n\r\nNote that PyCryptodomex can be upgraded with:\r\n\r\n$ sage -pip install --upgrade pycryptodomex",
      "createdAt": "2024-01-11T19:26:13Z",
      "updatedAt": "2024-05-01T20:18:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "97fcdd4e159767ced633d373397b7048901f7d29",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/323",
      "headRefOid": "1cd5941e6dbc6ced4149518ccc73a36e2bdc843f",
      "closedAt": "2024-01-11T19:58:22Z",
      "mergedAt": "2024-01-11T19:58:22Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "2c7a6817c21f618c72c16609aea03d05be0c638c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5sRI04",
          "commit": {
            "abbreviatedOid": "b95ebf7"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-11T19:32:35Z",
          "updatedAt": "2024-01-11T19:32:36Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This should install `pycryptodomex` instead, per `poc/README.md`. The two PyPI packages get imported differently.",
              "createdAt": "2024-01-11T19:32:36Z",
              "updatedAt": "2024-01-11T19:32:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5sRPrL",
          "commit": {
            "abbreviatedOid": "b95ebf7"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-11T19:43:06Z",
          "updatedAt": "2024-01-11T19:43:06Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "What about just importing AES from Crypto instead of Cryptodome. I've updated the README to install pycryptodome instead of pycryptodomex.\r\n\r\nDoes that work for you, or might there be an enviernment where this doesn't work? CI seems happy, as well as my Mac.",
              "createdAt": "2024-01-11T19:43:06Z",
              "updatedAt": "2024-01-11T19:43:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5sRSjj",
          "commit": {
            "abbreviatedOid": "b95ebf7"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-11T19:47:19Z",
          "updatedAt": "2024-01-11T19:47:19Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Yeah, this should be fine, so long as we're consistent. This would preclude someone from installing PyCrypto in the same Sage install, but hopefully that's not a common occurrence.",
              "createdAt": "2024-01-11T19:47:19Z",
              "updatedAt": "2024-01-11T19:47:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5sRWbZ",
          "commit": {
            "abbreviatedOid": "362d1f4"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-11T19:52:56Z",
          "updatedAt": "2024-01-11T19:52:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5sRXLY",
          "commit": {
            "abbreviatedOid": "b95ebf7"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-11T19:54:01Z",
          "updatedAt": "2024-01-11T19:54:01Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Hmm actually that's a good call. In fact I think that's what we intended when we decided to use PyCryptodomex in the first place.",
              "createdAt": "2024-01-11T19:54:01Z",
              "updatedAt": "2024-01-11T19:54:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5sRX9K",
          "commit": {
            "abbreviatedOid": "b95ebf7"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-11T19:55:13Z",
          "updatedAt": "2024-01-11T19:55:14Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Replaced Crypto with Cryptodome.",
              "createdAt": "2024-01-11T19:55:13Z",
              "updatedAt": "2024-01-11T19:55:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5sRYTy",
          "commit": {
            "abbreviatedOid": "1cd5941"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, test vectors are unchanged to boot.",
          "createdAt": "2024-01-11T19:55:48Z",
          "updatedAt": "2024-01-11T19:55:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 325,
      "id": "PR_kwDOGKuqOc5j3SXR",
      "title": "Add guidance for choosing the field size",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/325",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #311.\r\n\r\nFor Prio3, when joint randomness is used:\r\n\r\n* RECOMMEND Field128\r\n* Field64 MAY be used, but `PROOFS` MUST be `3`\r\n\r\nThe latter is motivated by issue #177. The recommendation is based on the upper bound given by {{DPRS23}}, Theorem 1 and a matching attack described by @bwesterb (see issue #311).",
      "createdAt": "2024-01-11T22:13:34Z",
      "updatedAt": "2024-05-01T20:18:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "b87c2d6e2169ba2801f14f63abc24723d03c8da6",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/311-f128-to-f64",
      "headRefOid": "fffbafe6ecbea1c92cf965fbd9136273f31a1c36",
      "closedAt": "2024-01-23T21:58:40Z",
      "mergedAt": "2024-01-23T21:58:40Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "041fce5c59c1d1467376f7630a082cc53f13820f"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> Approved assuming \"Connecting soundness and robustness\" is addressed either in this PR or a future one.\r\n\r\nRight, thanks for the reminder! I'll ping you for a quick review if you don't mind.",
          "createdAt": "2024-01-23T20:32:22Z",
          "updatedAt": "2024-01-23T20:32:22Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> @divergentdave  Looks good. I think we should also add `| PROOFS | 1 |` to tables 9, 10, 11, and 12, right after `Field`, to be clear about the parameter values for the four concrete Prio3 VDAFs (and algorithm IDs) we define.\r\n\r\nThese tables specify parameters of the circuit; the number of proofs is not a parameter of the circuit. In fact, the gudance here is about modifying one of the circuits, say `SumVec` by changing the field from `Field64` to `Field128`.\r\n\r\nWhat do you think about decoupling `Field` from the circuit and moving it to the `Prio3` variant. There, `PROOFS` is (or should, at least) be specified.",
          "createdAt": "2024-01-23T21:31:14Z",
          "updatedAt": "2024-01-23T21:31:14Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Good point, I think that sounds better",
          "createdAt": "2024-01-23T21:34:14Z",
          "updatedAt": "2024-01-23T21:34:14Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll lift to an issue and handle it after this PR.",
          "createdAt": "2024-01-23T21:56:21Z",
          "updatedAt": "2024-01-23T21:56:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5sVhrO",
          "commit": {
            "abbreviatedOid": "fa04ac5"
          },
          "author": "bwesterb",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-12T07:47:49Z",
          "updatedAt": "2024-01-12T07:47:49Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "Perhaps \u22653 instead of =3?",
              "createdAt": "2024-01-12T07:47:49Z",
              "updatedAt": "2024-01-12T07:47:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5sVh44",
          "commit": {
            "abbreviatedOid": "fa04ac5"
          },
          "author": "bwesterb",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-12T07:48:23Z",
          "updatedAt": "2024-01-12T07:48:23Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "For the rest, lgtm.",
              "createdAt": "2024-01-12T07:48:23Z",
              "updatedAt": "2024-01-12T07:48:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5sm8pz",
          "commit": {
            "abbreviatedOid": "43d7b22"
          },
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-15T18:50:14Z",
          "updatedAt": "2024-01-15T18:50:14Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nof the FLP depends on a variety of parameters, like the length of the\r\n```",
              "createdAt": "2024-01-15T18:50:14Z",
              "updatedAt": "2024-01-15T18:50:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5snCBv",
          "commit": {
            "abbreviatedOid": "43d7b22"
          },
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-15T19:17:28Z",
          "updatedAt": "2024-01-15T19:17:29Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "should we add a section to quantify the risk of using 2 PROOFS vs 3?",
              "createdAt": "2024-01-15T19:17:29Z",
              "updatedAt": "2024-01-15T19:17:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5snClu",
          "commit": {
            "abbreviatedOid": "43d7b22"
          },
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-15T19:20:34Z",
          "updatedAt": "2024-01-15T19:20:34Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "here soundness is not mentioned, while it was in #multiproofs. Should we mention the relationship between soundness and robustness (which is the overall goal) here?",
              "createdAt": "2024-01-15T19:20:34Z",
              "updatedAt": "2024-01-15T19:20:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5su3K3",
          "commit": {
            "abbreviatedOid": "fcc9f91"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-16T17:04:38Z",
          "updatedAt": "2024-01-16T17:04:38Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Can you clarify: 2 proofs for Field128 or Field64?\r\n\r\nConnecting soundness and robustness is a good idea, will do.",
              "createdAt": "2024-01-16T17:04:38Z",
              "updatedAt": "2024-01-16T17:04:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5tGqSD",
          "commit": {
            "abbreviatedOid": "609fcae"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good. I think we should also add `| PROOFS | 1 |` to tables 9, 10, 11, and 12, right after `Field`, to be clear about the parameter values for the four concrete Prio3 VDAFs (and algorithm IDs) we define.",
          "createdAt": "2024-01-18T19:58:43Z",
          "updatedAt": "2024-01-23T21:19:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5tmooC",
          "commit": {
            "abbreviatedOid": "609fcae"
          },
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-23T13:51:03Z",
          "updatedAt": "2024-01-23T21:19:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5toRlm",
          "commit": {
            "abbreviatedOid": "fcc9f91"
          },
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-23T16:30:39Z",
          "updatedAt": "2024-01-23T16:30:40Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "2 proofs for Field64.\r\nThere were many discussions in issues for robustness analysis, especially 2 proofs vs 3. Would be good to tell reader what are the risks involved using PROOFS == 2. So we can justify why \"`PROOFS` MUST be set to at least `3`\", instead of \"SHOULD be\"",
              "createdAt": "2024-01-23T16:30:40Z",
              "updatedAt": "2024-01-23T16:30:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5tqD_K",
          "commit": {
            "abbreviatedOid": "fcc9f91"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-23T19:20:06Z",
          "updatedAt": "2024-01-23T19:20:06Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Below we say \"breaking robustness for `PROOFS == 2` is feasible, if impractical\".\r\n\r\nI mean to use the terms \"feasible\" and \"impractical\" the way they are generally meant in the crypto literature:  An attack is \"feasilbe' if it can be pulled off, given enough resources. However the amount of resources it takes to pull off means we may not see the attack happen in practice (costs too much money, too much memory, or too much time). ",
              "createdAt": "2024-01-23T19:20:06Z",
              "updatedAt": "2024-01-23T19:20:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5tqfXz",
          "commit": {
            "abbreviatedOid": "609fcae"
          },
          "author": "wangshan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Approved assuming \"Connecting soundness and robustness\" is addressed either in this PR or a future one.",
          "createdAt": "2024-01-23T20:24:02Z",
          "updatedAt": "2024-01-23T21:19:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5tq5m5",
          "commit": {
            "abbreviatedOid": "609fcae"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-23T21:26:48Z",
          "updatedAt": "2024-01-23T21:26:48Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Added note about robustness versus soundness.",
              "createdAt": "2024-01-23T21:26:48Z",
              "updatedAt": "2024-01-23T21:26:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 326,
      "id": "PR_kwDOGKuqOc5kuV9R",
      "title": "Improvements to test vector generation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/326",
      "state": "MERGED",
      "author": "junyechen1996",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add an environmental variable TEST_VECTOR to control test vector generation, and an optional environmental variable TEST_VECTOR_PATH to specify a custom path where test vectors are generated. Add a new target in Makefile to generate all test vectors in VDAF spec.",
      "createdAt": "2024-01-22T13:48:14Z",
      "updatedAt": "2024-01-22T20:16:57Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "2c7a6817c21f618c72c16609aea03d05be0c638c",
      "headRepository": "junyechen1996/draft-irtf-cfrg-vdaf",
      "headRefName": "junyec/test-vector-improvement",
      "headRefOid": "8510618ce9d42d8721756a009f0ff2db5ce9b495",
      "closedAt": "2024-01-22T20:16:56Z",
      "mergedAt": "2024-01-22T20:16:56Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "b87c2d6e2169ba2801f14f63abc24723d03c8da6"
      },
      "comments": [
        {
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Squashed. Should be good to merge after CI.",
          "createdAt": "2024-01-22T18:45:45Z",
          "updatedAt": "2024-01-22T18:45:45Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5teKcP",
          "commit": {
            "abbreviatedOid": "08cbe13"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Great idea! One minor suggestion.",
          "createdAt": "2024-01-22T14:37:38Z",
          "updatedAt": "2024-01-22T14:39:38Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This list of commands needs to be kept in sync with the files for which we generate test vectors.\r\n\r\nLuckily, I don't think this is necessary. To set the `TEST_VECTOR` variable to `true`, just do:\r\n```\r\nmake TEST_VECTOR=true\r\n```\r\n\r\n```suggestion\r\n```",
              "createdAt": "2024-01-22T14:37:38Z",
              "updatedAt": "2024-01-22T14:39:38Z"
            },
            {
              "originalPosition": 3,
              "body": "Remove `generate_test_vectors` from the Makefile (see above) and update these instructions.",
              "createdAt": "2024-01-22T14:38:49Z",
              "updatedAt": "2024-01-22T14:39:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5tfsC4",
          "commit": {
            "abbreviatedOid": "4b20c62"
          },
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-22T17:43:29Z",
          "updatedAt": "2024-01-22T17:43:49Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Done.",
              "createdAt": "2024-01-22T17:43:29Z",
              "updatedAt": "2024-01-22T17:43:49Z"
            },
            {
              "originalPosition": 9,
              "body": "Good point. Done.",
              "createdAt": "2024-01-22T17:43:41Z",
              "updatedAt": "2024-01-22T17:43:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5tfwjv",
          "commit": {
            "abbreviatedOid": "8510618"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Please squash and then I'll merge.",
          "createdAt": "2024-01-22T17:54:38Z",
          "updatedAt": "2024-01-22T18:45:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc5tgjIk",
          "commit": {
            "abbreviatedOid": "8510618"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-22T19:53:04Z",
          "updatedAt": "2024-01-22T19:53:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 329,
      "id": "PR_kwDOGKuqOc5n8P6n",
      "title": "Fix filename in multiproof plot script",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/329",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This corrects the name of this file in the comments.",
      "createdAt": "2024-02-26T16:59:44Z",
      "updatedAt": "2024-02-26T17:06:19Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "041fce5c59c1d1467376f7630a082cc53f13820f",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/fix-filename",
      "headRefOid": "967483457b97fc2786511f220d81cff932aacc8b",
      "closedAt": "2024-02-26T17:06:15Z",
      "mergedAt": "2024-02-26T17:06:15Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "da84b8ad9ad38bf998a423da4fd6cdfffd70813b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5xVqqT",
          "commit": {
            "abbreviatedOid": "9674834"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-26T17:00:40Z",
          "updatedAt": "2024-02-26T17:00:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 330,
      "id": "PR_kwDOGKuqOc5oTrnk",
      "title": "Use unittest for tests",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/330",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This moves tests from `if __name__ == \"__main__\":` blocks in each file to a separate directory, using the standard library's `unittest` framework. Aside from better code organization, this also speeds up test execution, because we only need to load Sage's libraries once. This is part of #327.",
      "createdAt": "2024-02-29T15:18:27Z",
      "updatedAt": "2024-02-29T16:09:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "da84b8ad9ad38bf998a423da4fd6cdfffd70813b",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/move-tests",
      "headRefOid": "10ca481230ace17cb9e9f04602eb266c00d6e489",
      "closedAt": "2024-02-29T16:09:33Z",
      "mergedAt": "2024-02-29T16:09:33Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "9bb282b1efd3278c2f02b2800ad71adbd1164f90"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5xzB8L",
          "commit": {
            "abbreviatedOid": "10ca481"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Beautiful, thanks so much for putting the time in on this.",
          "createdAt": "2024-02-29T15:32:10Z",
          "updatedAt": "2024-02-29T15:35:27Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Why make this change?",
              "createdAt": "2024-02-29T15:32:10Z",
              "updatedAt": "2024-02-29T15:35:27Z"
            },
            {
              "originalPosition": 1,
              "body": "Why is this file needed?",
              "createdAt": "2024-02-29T15:34:16Z",
              "updatedAt": "2024-02-29T15:35:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5xzKEX",
          "commit": {
            "abbreviatedOid": "10ca481"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-29T15:45:40Z",
          "updatedAt": "2024-02-29T15:48:32Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I saw a message after I added an import for this file, I think it was a deprecation warning. The issue is that `\\s` is not a supported escape character sequence. Since backslashes are only used in LaTeX syntax here, I just turned the docstring into a raw string literal to fix it.",
              "createdAt": "2024-02-29T15:45:40Z",
              "updatedAt": "2024-02-29T15:48:32Z"
            },
            {
              "originalPosition": 1,
              "body": "This indicates that Python should treat the folder hierarchy as a package. The unittest auto-discovery code needs to see this, and it's also required to enable intra-package imports.",
              "createdAt": "2024-02-29T15:48:21Z",
              "updatedAt": "2024-02-29T15:48:32Z"
            }
          ]
        }
      ]
    },
    {
      "number": 331,
      "id": "PR_kwDOGKuqOc5oUF_m",
      "title": "Use Sage container image in CI",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/331",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This uses a Sage Docker image in lieu of installing Sage with apt-get. This should hopefully speed up CI significantly. #330 enables this because our Makefile is now only two lines long, so we can duplicate the command in it, and use this container image that lacks GNU Make.",
      "createdAt": "2024-02-29T16:17:26Z",
      "updatedAt": "2024-02-29T16:37:00Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "9bb282b1efd3278c2f02b2800ad71adbd1164f90",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/gha-docker",
      "headRefOid": "39db3a31daaf0bbe3ca3155ebd9529696e78202c",
      "closedAt": "2024-02-29T16:36:58Z",
      "mergedAt": "2024-02-29T16:36:58Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "82389a81e1c871b39cd24d267768873555580529"
      },
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Now twice as fast!",
          "createdAt": "2024-02-29T16:36:49Z",
          "updatedAt": "2024-02-29T16:36:49Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5xznyD",
          "commit": {
            "abbreviatedOid": "39db3a3"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-29T16:35:54Z",
          "updatedAt": "2024-02-29T16:35:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 332,
      "id": "PR_kwDOGKuqOc5o-NMp",
      "title": "Add checks that prefix counts are consistent across multiple VDAF executions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/332",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security consideration",
        "draft-09"
      ],
      "body": "Fixes #316 ",
      "createdAt": "2024-03-07T14:17:58Z",
      "updatedAt": "2024-07-02T21:50:55Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "e8c0cbeab9588613801feb3579536bc1221571dc",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "schoppmp/issue-316",
      "headRefOid": "e8ed23fa8c4fcca2dd2074ff46d2647d5de4f762",
      "closedAt": "2024-05-13T21:20:34Z",
      "mergedAt": "2024-05-13T21:20:34Z",
      "mergedBy": "schoppmp",
      "mergeCommit": {
        "oid": "a593fd485d9793cb5047c4d8c9a0351a8da2b436"
      },
      "comments": [
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "Following the discussion in [this doc](https://docs.google.com/document/d/1ZjXz-1kGsTDf2Vn2u-fwYqR8BSc3tOYlELVHAYvAfjk), it seems clear that differential privacy is required to implement heavy hitters privately. For now, this PR only ensures that the tree is traversed correctly (i.e., not on arbitrary leaves; see mitigation 1 [here](https://docs.google.com/document/d/1ZjXz-1kGsTDf2Vn2u-fwYqR8BSc3tOYlELVHAYvAfjk/edit#bookmark=id.yyi83665dnuy)).\r\n\r\nThe details of how to add differential privacy to a heavy hitters protocol based on Poplar should be specified in the higher-level protocol, as VDAF doesn't have any syntax for DP (like privacy parameters). There are also different ways to implement DP here, so this is not something we want to restrict in VDAF.",
          "createdAt": "2024-04-19T16:13:32Z",
          "updatedAt": "2024-04-19T16:13:32Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5yoQoh",
          "commit": {
            "abbreviatedOid": "bb7ef65"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-07T17:53:17Z",
          "updatedAt": "2024-03-07T18:45:34Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "We'll need to update the type of `previous_agg_params` to be a `list[AggParam]` instead of a `set[AggParam]`: https://cfrg.github.io/draft-irtf-cfrg-vdaf/draft-irtf-cfrg-vdaf.html#section-5.3",
              "createdAt": "2024-03-07T17:53:17Z",
              "updatedAt": "2024-03-07T18:45:34Z"
            },
            {
              "originalPosition": 45,
              "body": "Could we relax this to allow the level to increase by _at least_ 1? ",
              "createdAt": "2024-03-07T17:54:49Z",
              "updatedAt": "2024-03-07T18:45:34Z"
            },
            {
              "originalPosition": 27,
              "body": "This is a class method.\r\n```suggestion\r\ndef is_valid(Poplar1, agg_param, previous_agg_params):\r\n```",
              "createdAt": "2024-03-07T17:56:00Z",
              "updatedAt": "2024-03-07T18:45:34Z"
            },
            {
              "originalPosition": 48,
              "body": "Is there any reason to allow the threshold to vary at each level? It's not necessary for the plain heavy hitters use case. On the other hand, it seems a little dangerous to give the attacker (i.e., the party that picks the threshold) this much control.\r\n\r\nI suggest making we make the threshold a parameter of `Poplar1` class. In fact, I would even go a step further: `Poplar1` should enforce agreement on the threshold among honest parties. That is, preparation should fail unless the Client and honest Aggregator agree on the threshold.",
              "createdAt": "2024-03-07T17:59:12Z",
              "updatedAt": "2024-03-07T18:45:34Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\n    for i in range(len(prefixes)):\r\n```",
              "createdAt": "2024-03-07T18:30:08Z",
              "updatedAt": "2024-03-07T18:45:34Z"
            },
            {
              "originalPosition": 54,
              "body": "`parent_index` is not defined.",
              "createdAt": "2024-03-07T18:37:03Z",
              "updatedAt": "2024-03-07T18:45:34Z"
            },
            {
              "originalPosition": 52,
              "body": "This code is hard to follow. Let's try to encapsulate some of the bit fiddling details with high level funtions, like `is_parent_of(parent, child)`.",
              "createdAt": "2024-03-07T18:41:44Z",
              "updatedAt": "2024-03-07T18:45:34Z"
            },
            {
              "originalPosition": 95,
              "body": "```suggestion\r\nIDPF output at any position. While our construction ensures that the sum of all\r\n```",
              "createdAt": "2024-03-07T18:42:29Z",
              "updatedAt": "2024-03-07T18:45:34Z"
            },
            {
              "originalPosition": 24,
              "body": "Here we should list the invariants we should expect to hold for each aggregation.\r\n\r\nWDYTA enforcing that the sum of the prefix counts is equal to the number of valid reports in the batch?",
              "createdAt": "2024-03-07T18:45:31Z",
              "updatedAt": "2024-03-07T18:45:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc51t9q2",
          "commit": {
            "abbreviatedOid": "0aa572f"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T20:42:25Z",
          "updatedAt": "2024-04-02T21:29:12Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Done.",
              "createdAt": "2024-04-02T20:42:26Z",
              "updatedAt": "2024-04-02T21:29:12Z"
            },
            {
              "originalPosition": 24,
              "body": "Added some text.\r\n\r\n> WDYTA enforcing that the sum of the prefix counts is equal to the number of valid reports in the batch?\r\n\r\nThis is enforced in `aggregate`.",
              "createdAt": "2024-04-02T21:15:52Z",
              "updatedAt": "2024-04-02T21:29:12Z"
            },
            {
              "originalPosition": 45,
              "body": "We could, is this needed somewhere? This would require changing the checks below.",
              "createdAt": "2024-04-02T21:22:17Z",
              "updatedAt": "2024-04-02T21:29:12Z"
            },
            {
              "originalPosition": 54,
              "body": "Fixed.",
              "createdAt": "2024-04-02T21:26:11Z",
              "updatedAt": "2024-04-02T21:29:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc51uxA5",
          "commit": {
            "abbreviatedOid": "bb7ef65"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T22:40:54Z",
          "updatedAt": "2024-04-02T22:40:55Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Done.",
              "createdAt": "2024-04-02T22:40:54Z",
              "updatedAt": "2024-04-02T22:40:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc51ux00",
          "commit": {
            "abbreviatedOid": "bb7ef65"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T22:44:54Z",
          "updatedAt": "2024-04-02T22:44:54Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Done.",
              "createdAt": "2024-04-02T22:44:54Z",
              "updatedAt": "2024-04-02T22:44:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc51ux8Y",
          "commit": {
            "abbreviatedOid": "bb7ef65"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-02T22:45:32Z",
          "updatedAt": "2024-04-02T22:45:32Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Added a helper `get_prefix` that contains the bit shift.",
              "createdAt": "2024-04-02T22:45:32Z",
              "updatedAt": "2024-04-02T22:45:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc516HAm",
          "commit": {
            "abbreviatedOid": "d837f12"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This looks to be on the right track, modulo our conversation today about compatibility with DP. I think the only thing that would change is enforcing count consistency, in which case we would take some version of this PR no matter what the outcome is.\r\n\r\nI'd suggest implementing in the reference code so that we can unit test is_valid() and make sure the changes to the rest of the construction still pass our current tests. If you like you can leave out the count checks.",
          "createdAt": "2024-04-03T22:12:58Z",
          "updatedAt": "2024-04-03T22:24:25Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Note that we'll need to make the same change to `shard()`.",
              "createdAt": "2024-04-03T22:12:58Z",
              "updatedAt": "2024-04-03T22:24:25Z"
            },
            {
              "originalPosition": 51,
              "body": "I believe our Python linters like two spaces for in-line comments\r\n```suggestion\r\n        raise ERR_INPUT  # unexpected number of prep shares\r\n```",
              "createdAt": "2024-04-03T22:13:31Z",
              "updatedAt": "2024-04-03T22:24:25Z"
            },
            {
              "originalPosition": 72,
              "body": "```suggestion\r\n    # Helper function to determine the prefix of `input` at `last_level`.\r\n```",
              "createdAt": "2024-04-03T22:14:19Z",
              "updatedAt": "2024-04-03T22:24:25Z"
            },
            {
              "originalPosition": 32,
              "body": "`prep_init()` is a classmethod; the class is called `Poplar1` in this scope.\r\n\r\n(Sorry, in retrospect, class factories was probably the wrong paradigm for this project. cc/ @divergentdave.)",
              "createdAt": "2024-04-03T22:17:12Z",
              "updatedAt": "2024-04-03T22:24:25Z"
            },
            {
              "originalPosition": 71,
              "body": "WDYT?\r\n```suggestion\r\ndef get_ancestor(input, this_level, last_level):\r\n```",
              "createdAt": "2024-04-03T22:19:03Z",
              "updatedAt": "2024-04-03T22:24:25Z"
            },
            {
              "originalPosition": 105,
              "body": "I think we also need to check that value in this dict is 0?",
              "createdAt": "2024-04-03T22:21:19Z",
              "updatedAt": "2024-04-03T22:24:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc53yFwr",
          "commit": {
            "abbreviatedOid": "7dcb804"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-18T18:39:52Z",
          "updatedAt": "2024-04-18T19:25:01Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Reverted to avoid depending on heavy hitters parameters.",
              "createdAt": "2024-04-18T18:39:52Z",
              "updatedAt": "2024-04-18T19:25:01Z"
            },
            {
              "originalPosition": 105,
              "body": "Removed the dict.",
              "createdAt": "2024-04-18T19:24:55Z",
              "updatedAt": "2024-04-18T19:25:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc536mNi",
          "commit": {
            "abbreviatedOid": "5280b62"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-19T16:09:28Z",
          "updatedAt": "2024-04-19T16:09:29Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Should this become a MUST?",
              "createdAt": "2024-04-19T16:09:29Z",
              "updatedAt": "2024-04-19T16:09:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc54b-dW",
          "commit": {
            "abbreviatedOid": "a637131"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-24T18:09:32Z",
          "updatedAt": "2024-04-24T18:13:25Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "`0` is not the empty prefix here, but the leftmost prefix. The length of all these prefixes is implicitly `last_level`, so there's no way to represent the empty prefix. Rather, bootstrapping prefixes is handled by `if len(previous_agg_params) < 1:` above.\r\n```suggestion\r\n    last_prefixes_set = set(last_prefixes)\r\n```",
              "createdAt": "2024-04-24T18:09:32Z",
              "updatedAt": "2024-04-24T18:13:25Z"
            },
            {
              "originalPosition": 32,
              "body": "See the related suggestion on the specification.\r\n```suggestion\r\n        last_prefixes_set = set(last_prefixes)\r\n```",
              "createdAt": "2024-04-24T18:10:24Z",
              "updatedAt": "2024-04-24T18:13:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc54dFyU",
          "commit": {
            "abbreviatedOid": "a637131"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-04-24T20:33:42Z",
          "updatedAt": "2024-04-24T20:40:54Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This doesn't need to be a class method. How about defining this below the class somewhere, just as a helper function?",
              "createdAt": "2024-04-24T20:37:10Z",
              "updatedAt": "2024-04-24T20:40:55Z"
            },
            {
              "originalPosition": 79,
              "body": "```suggestion\r\nIDPF output at any position. While our construction ensures that the sum of all\r\n```",
              "createdAt": "2024-04-24T20:39:56Z",
              "updatedAt": "2024-04-24T20:40:55Z"
            },
            {
              "originalPosition": 84,
              "body": "I don't think we can make it a MUST without specifying a mechanism for achieving it.",
              "createdAt": "2024-04-24T20:40:31Z",
              "updatedAt": "2024-04-24T20:40:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc54-CmL",
          "commit": {
            "abbreviatedOid": "12bbf0e"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-29T20:19:42Z",
          "updatedAt": "2024-04-29T20:23:25Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I don't think I understand what this check does. Where is `prefix_counts` defined?",
              "createdAt": "2024-04-29T20:19:43Z",
              "updatedAt": "2024-04-29T20:23:25Z"
            },
            {
              "originalPosition": 84,
              "body": "I don't think that's true. For instance, OHTTP doesn't specify how clients obtain the configuration of gateways, but still has a MUST about it ([source](https://datatracker.ietf.org/doc/html/rfc9458#section-7)):\r\n\r\n> A specific method for a Client to acquire configurations is not included in this specification. Applications using this design MUST provide accommodations to mitigate tracking using Client configurations.\r\n\r\nSo I think we could include a MUST about using DP, since the VDAF's privacy guarantees don't hold unless you do.",
              "createdAt": "2024-04-29T20:21:52Z",
              "updatedAt": "2024-04-29T20:23:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc54-NAv",
          "commit": {
            "abbreviatedOid": "5280b62"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-29T20:29:56Z",
          "updatedAt": "2024-04-29T20:29:56Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "I'm fine with it being a MUST.",
              "createdAt": "2024-04-29T20:29:56Z",
              "updatedAt": "2024-04-29T20:29:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc54-NG-",
          "commit": {
            "abbreviatedOid": "a637131"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-29T20:30:03Z",
          "updatedAt": "2024-04-29T20:30:03Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Bump",
              "createdAt": "2024-04-29T20:30:03Z",
              "updatedAt": "2024-04-29T20:30:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc54-NLS",
          "commit": {
            "abbreviatedOid": "a637131"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-29T20:30:08Z",
          "updatedAt": "2024-04-29T20:30:08Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Bump",
              "createdAt": "2024-04-29T20:30:08Z",
              "updatedAt": "2024-04-29T20:30:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55aKvg",
          "commit": {
            "abbreviatedOid": "5280b62"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-02T21:02:56Z",
          "updatedAt": "2024-05-02T21:02:56Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "I'm leaving it at RECOMMENDED for now, since I'm not sure prescribing DP but not any particular DP parameters would be meaningful. In particular, implementers could satisfy the requirement by implementing DP with $\\delta=1$ or similar insecure settings.",
              "createdAt": "2024-05-02T21:02:56Z",
              "updatedAt": "2024-05-02T21:02:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55flsx",
          "commit": {
            "abbreviatedOid": "15299a7"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-03T14:48:39Z",
          "updatedAt": "2024-05-03T14:48:39Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "This was from an earlier version, removed it.",
              "createdAt": "2024-05-03T14:48:39Z",
              "updatedAt": "2024-05-03T14:48:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55fmfU",
          "commit": {
            "abbreviatedOid": "15299a7"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-03T14:50:03Z",
          "updatedAt": "2024-05-03T14:50:03Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Done.",
              "createdAt": "2024-05-03T14:50:03Z",
              "updatedAt": "2024-05-03T14:50:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc551MQN",
          "commit": {
            "abbreviatedOid": "f8e91c2"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-07T19:24:23Z",
          "updatedAt": "2024-05-07T19:42:50Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "This comment is outdated.\r\n```suggestion\r\n```",
              "createdAt": "2024-05-07T19:24:23Z",
              "updatedAt": "2024-05-07T19:42:50Z"
            },
            {
              "originalPosition": 75,
              "body": "nit: I think the intermediate list is unnecessary, as `set()` can take any iterable\r\n```suggestion\r\n    last_prefixes_set = set(last_prefixes)\r\n```",
              "createdAt": "2024-05-07T19:27:27Z",
              "updatedAt": "2024-05-07T19:42:50Z"
            },
            {
              "originalPosition": 24,
              "body": "See above\r\n```suggestion\r\n```",
              "createdAt": "2024-05-07T19:28:32Z",
              "updatedAt": "2024-05-07T19:42:51Z"
            },
            {
              "originalPosition": 25,
              "body": "See above\r\n```suggestion\r\n        last_prefixes_set = set(last_prefixes)\r\n```",
              "createdAt": "2024-05-07T19:28:46Z",
              "updatedAt": "2024-05-07T19:42:51Z"
            },
            {
              "originalPosition": 83,
              "body": "I think this conditional is unnecessary, or at least the explanation in the comment is incorrect, since we already handle the first aggregation separately at the top of the function. If the last level was 0, then we would expect the last prefixes to be '0' and '1' (unless the collector had some reason to skip either). Thus, the checks below should still work, though we are high up enough in the tree that the attacker has nothing to gain in its choice of prefixes.",
              "createdAt": "2024-05-07T19:38:17Z",
              "updatedAt": "2024-05-07T19:42:51Z"
            },
            {
              "originalPosition": 34,
              "body": "nit: `i` is unused\r\n```suggestion\r\n            for prefix in prefixes:\r\n```",
              "createdAt": "2024-05-07T19:39:55Z",
              "updatedAt": "2024-05-07T19:42:51Z"
            },
            {
              "originalPosition": 103,
              "body": "This is incorrect since we backed out passing the previous aggregate result to `is_valid()`.",
              "createdAt": "2024-05-07T19:40:27Z",
              "updatedAt": "2024-05-07T19:42:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc551cnw",
          "commit": {
            "abbreviatedOid": "f8e91c2"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-07T19:59:27Z",
          "updatedAt": "2024-05-07T19:59:27Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "The issue is the following. In the first run, there are no prefixes being passed (i.e., last_prefixes_set is empty). In the second run, either 0 or 1 or both are passed in. `get_ancestor` below will turn both of these to 0 (shifting right by 1 bit), but the membership check fails because the set is empty. The previous version incorrectly always added 0 to the set, here we just skip the check since it's supposed to always pass even on the second run (any string has the empty string as prefix).",
              "createdAt": "2024-05-07T19:59:27Z",
              "updatedAt": "2024-05-07T19:59:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc551eRX",
          "commit": {
            "abbreviatedOid": "f8e91c2"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-07T20:03:44Z",
          "updatedAt": "2024-05-07T20:03:44Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "Fixed.",
              "createdAt": "2024-05-07T20:03:44Z",
              "updatedAt": "2024-05-07T20:03:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc552WLt",
          "commit": {
            "abbreviatedOid": "f8e91c2"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-07T22:18:12Z",
          "updatedAt": "2024-05-07T22:18:12Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "In the second run, \"0, 1, or both\" would be the prefixes from the past aggregation parameter, while the current aggregation parameter would have a level of 1 and a list of prefixes that are two bits long. The current level's prefixes get passed to `get_ancestor()` so those would be mapped to 0 or 1, which is correct.\r\n\r\nI think the existing unit tests of `is_valid()` are misleading. For starters, they show an aggregation parameter with an empty list of candidate prefixes. This doesn't make sense, as it would produce an empty output share if the VDAF were actually run. The candidate prefixes in later aggregation parameters are shorter than they need to be, see the tests `test_poplar1` and test_generate_test_vectors` for comparison.",
              "createdAt": "2024-05-07T22:18:12Z",
              "updatedAt": "2024-05-07T22:18:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc552YkI",
          "commit": {
            "abbreviatedOid": "f8e91c2"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-07T22:29:21Z",
          "updatedAt": "2024-05-07T22:29:21Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Oh, I see. I guess `prefixes` confused me, I thought it refers to the nodes being expanded (the parent), but it's the nodes after the expansion. I'll fix that tomorrow, and the tests as well.",
              "createdAt": "2024-05-07T22:29:21Z",
              "updatedAt": "2024-05-07T22:29:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc56AjP-",
          "commit": {
            "abbreviatedOid": "9af3d2f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, though I think we could increase test coverage a bit.",
          "createdAt": "2024-05-09T00:33:58Z",
          "updatedAt": "2024-05-09T00:35:12Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "```suggestion\r\n    # Check that the level increased.\r\n```",
              "createdAt": "2024-05-09T00:33:58Z",
              "updatedAt": "2024-05-09T00:35:12Z"
            },
            {
              "originalPosition": 1,
              "body": "Could we also add some unit tests for `get_ancestor()`?",
              "createdAt": "2024-05-09T00:34:49Z",
              "updatedAt": "2024-05-09T00:35:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc56avnf",
          "commit": {
            "abbreviatedOid": "9af3d2f"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-13T21:08:17Z",
          "updatedAt": "2024-05-13T21:08:17Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "Done.",
              "createdAt": "2024-05-13T21:08:17Z",
              "updatedAt": "2024-05-13T21:08:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc56awIB",
          "commit": {
            "abbreviatedOid": "1b07e49"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-13T21:09:41Z",
          "updatedAt": "2024-05-13T21:14:08Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "nit: sync with Sage\r\n```suggestion\r\ndef get_ancestor(input, this_level, last_level):\r\n```",
              "createdAt": "2024-05-13T21:09:41Z",
              "updatedAt": "2024-05-13T21:14:08Z"
            },
            {
              "originalPosition": 84,
              "body": "This is closer to the Sage, and doesn't need as many columns in the text rendering.\r\n```suggestion\r\n        # Current prefix not a suffix of last level's prefixes.\r\n        return False\r\n```",
              "createdAt": "2024-05-13T21:12:33Z",
              "updatedAt": "2024-05-13T21:14:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 336,
      "id": "PR_kwDOGKuqOc5uMw7-",
      "title": "Add IDPF extractability to security considerations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/336",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security consideration",
        "draft-09"
      ],
      "body": "Closes #12.\r\nCloses #273.\r\n\r\nFirst, clarify that the Aggregators need to check that they have the same public share.\r\n\r\nSecond, clarify which IDPF tree traversals are safe. Since we only guarantee extractability at the last level, it is not safe to use intermediate nodes for any purpose except the heavy hitters tree traversal.",
      "createdAt": "2024-04-30T22:00:10Z",
      "updatedAt": "2024-06-08T19:54:48Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "9ff20bfdafd7aa192d06f91f7d362a9835d31ed2",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/poplar1-extractability",
      "headRefOid": "fa8775745117f802c60a30a6931b39bf87a04812",
      "closedAt": "2024-05-07T14:05:52Z",
      "mergedAt": "2024-05-07T14:05:52Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "d5d3e1f0175f86daf25c215289262deb9e9d340b"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased and squashed.",
          "createdAt": "2024-05-06T13:47:19Z",
          "updatedAt": "2024-05-06T13:47:19Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc55J1-C",
          "commit": {
            "abbreviatedOid": "85dd125"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-30T22:01:30Z",
          "updatedAt": "2024-04-30T22:01:31Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "@schoppmp a question: I wonder if we should be worried about using `XofFixedKeyAes128` for generating leaf nodes, since the Poplar paper wants this to be a random oracle?",
              "createdAt": "2024-04-30T22:01:31Z",
              "updatedAt": "2024-04-30T22:01:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55KZ7k",
          "commit": {
            "abbreviatedOid": "85dd125"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-30T23:11:17Z",
          "updatedAt": "2024-04-30T23:26:30Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nthe Client. It is sufficient, for example, to exchange a hash of the public\r\n```\r\n\r\n(typo nit)",
              "createdAt": "2024-04-30T23:11:17Z",
              "updatedAt": "2024-04-30T23:26:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55PD5z",
          "commit": {
            "abbreviatedOid": "85dd125"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-01T17:09:02Z",
          "updatedAt": "2024-05-01T17:10:20Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Do we satisfy this requirement in DAP?",
              "createdAt": "2024-05-01T17:09:02Z",
              "updatedAt": "2024-05-01T17:10:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55PFpY",
          "commit": {
            "abbreviatedOid": "85dd125"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-01T17:14:03Z",
          "updatedAt": "2024-05-01T17:14:03Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Yes, since public share is bound to HPKE decryption.",
              "createdAt": "2024-05-01T17:14:03Z",
              "updatedAt": "2024-05-01T17:14:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55PIpT",
          "commit": {
            "abbreviatedOid": "d95f2d7"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-01T17:21:36Z",
          "updatedAt": "2024-05-02T00:02:11Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "copyedit\r\n```suggestion\r\nThe Aggregators MUST verify that they have both received the same public share from\r\n```",
              "createdAt": "2024-05-01T17:21:36Z",
              "updatedAt": "2024-05-02T00:02:11Z"
            },
            {
              "originalPosition": 29,
              "body": "This might need to be rephrased a bit, because it's trivial to pick keys and a public share that evaluate to (uncontrolled) nonzero values everywhere. Rather what's hard is multiple nonzero evaluations while keeping the other evaluations equal to zero.",
              "createdAt": "2024-05-01T23:24:42Z",
              "updatedAt": "2024-05-02T00:02:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55WuWn",
          "commit": {
            "abbreviatedOid": "897bcfd"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-02T14:54:58Z",
          "updatedAt": "2024-05-02T14:54:58Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Good catch. This needs a bit of thinking. The way I understand it is that a malicious client shouldn't be able to _undetectably_ produce a Poplar1 report that evaluates to 1 at two leaves.",
              "createdAt": "2024-05-02T14:54:58Z",
              "updatedAt": "2024-05-02T14:54:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55ZlSZ",
          "commit": {
            "abbreviatedOid": "897bcfd"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-02T19:43:37Z",
          "updatedAt": "2024-05-02T20:46:22Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Yeah, for the RO model fixed-key AES may be a bit sketchy (as we discussed in [#279](https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/279#issuecomment-1675457126)). I guess the safe choice would be XofTurboShake128 on the last level. We're already using a different field with larger bit size there.",
              "createdAt": "2024-05-02T19:43:37Z",
              "updatedAt": "2024-05-02T20:46:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55plDJ",
          "commit": {
            "abbreviatedOid": "85dd125"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-06T14:36:41Z",
          "updatedAt": "2024-05-06T14:36:41Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Filed #341.",
              "createdAt": "2024-05-06T14:36:41Z",
              "updatedAt": "2024-05-06T14:36:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55q60A",
          "commit": {
            "abbreviatedOid": "d95f2d7"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-06T17:21:07Z",
          "updatedAt": "2024-05-06T17:21:07Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I've reworked this text, pleaase take another look.",
              "createdAt": "2024-05-06T17:21:07Z",
              "updatedAt": "2024-05-06T17:21:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55sEM2",
          "commit": {
            "abbreviatedOid": "801dd82"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-06T20:11:58Z",
          "updatedAt": "2024-05-06T20:11:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc55tGV-",
          "commit": {
            "abbreviatedOid": "85dd125"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-07T00:26:56Z",
          "updatedAt": "2024-05-07T00:26:56Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Maybe I'm missing something: in DAP , the client separately HPKE encrypts input shares to either aggregator's respective key. A malicious could therefore use distinct public shares and construct distinct AADs, no?",
              "createdAt": "2024-05-07T00:26:56Z",
              "updatedAt": "2024-05-07T00:26:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55sWli",
          "commit": {
            "abbreviatedOid": "801dd82"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-06T20:59:39Z",
          "updatedAt": "2024-05-07T01:55:42Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "nit: typo\r\n```suggestion\r\nnon-zero value is `1`. Depending on how the values are used, the secure sketch\r\n```",
              "createdAt": "2024-05-06T20:59:39Z",
              "updatedAt": "2024-05-07T01:55:42Z"
            },
            {
              "originalPosition": 9,
              "body": "The risk that the Poplar paper talks about when the aggregators don't have a consistent view of the public parameters is that the malicious client could control the output of the DPF at two inputs, instead of one, like we want. This happens because choosing different group element correction words for one level, and giving each aggregator a different one, gives the client an extra degree of freedom it shouldn't have.\r\n\r\nSince we're considering a malicious client when we consider attempts to break extractability in this manner, we don't need to protect this report's privacy, and thus the only goal that matters is robustness. For robustness, we get to assume that both aggregators are honest, and thus we can assume that the leader will distribute the public share to the helper correctly, without considering the HPKE AAD.\r\n\r\nIncluding the public share in the HPKE AAD is probably more relevant for protecting against privacy attacks, as we wouldn't want to let a rogue leader pass an honest client's input share with a tampered public share.",
              "createdAt": "2024-05-07T01:42:35Z",
              "updatedAt": "2024-05-07T01:55:42Z"
            },
            {
              "originalPosition": 36,
              "body": "After reading the extractability section over, I think we should clarify this by talking about the attacker's control over the output, rather than introducing this concept of a trivial IDPF. Note that the game starts with the adversary choosing a subset P (that does not include zero), and it wins if it produces inputs that evaluate to an element of P, such that the extractor can't extract a matching bit string.\r\n\r\n```suggestion\r\nlevel of the tree, it is infeasible for an attacker to control values of the\r\nIDPF such that it takes on chosen non-zero values at more than one node. (It\r\ncan practically only achieve the zero function, a point function, or a\r\npseudorandom function)\r\n```",
              "createdAt": "2024-05-07T01:46:26Z",
              "updatedAt": "2024-05-07T01:55:42Z"
            },
            {
              "originalPosition": 41,
              "body": "(same idea as above)\r\n```suggestion\r\nproduce IDPF shares with two controlled non-zero nodes.\r\n```",
              "createdAt": "2024-05-07T01:53:03Z",
              "updatedAt": "2024-05-07T01:55:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 337,
      "id": "PR_kwDOGKuqOc5uM80m",
      "title": "Rule out some ideas for streamlining preparation syntax",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/337",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "draft-09"
      ],
      "body": "Closes #42.\r\n\r\nWe had considered whether we could bake the idea of a \"linear state machine\" into the VDAF syntax. We could probably do something here, but our best idea involves mucking with type hints, something that has created some code rot in this repository already. Since no one has complained about this, let's just rule it out. Also, note that if we end up simplifying the syntax to only supporting 1-round VDAFs, then this point will be moot.\r\n\r\nAlso, we had a paragraph about 0-round VDAFs, which our syntax currently rules out. Delete the paragraph and the associated OPEN ISSUE.",
      "createdAt": "2024-04-30T22:31:13Z",
      "updatedAt": "2024-06-08T19:54:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "82389a81e1c871b39cd24d267768873555580529",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/42",
      "headRefOid": "5f7ff1bdf5d728356164dd1567b29ab1adfef286",
      "closedAt": "2024-05-02T14:56:43Z",
      "mergedAt": "2024-05-02T14:56:43Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "e8c0cbeab9588613801feb3579536bc1221571dc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc55VI_s",
          "commit": {
            "abbreviatedOid": "5f7ff1b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-02T12:17:39Z",
          "updatedAt": "2024-05-02T12:17:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 339,
      "id": "PR_kwDOGKuqOc5uSge6",
      "title": "Clarify that VDAFs aren't sufficient for DP",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/339",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "draft-09"
      ],
      "body": "Closes #94.\r\n\r\nAs written, the intro seems to frame MPC as an alternative to DP, which is not true. Rather, we want to frame MPC as a necessary component of a data aggregation system that provides DP.\r\n\r\n~Indeed, this change goes a step forward: VDAFs SHOULD be composed with a mechanism for DP.~",
      "createdAt": "2024-05-01T21:17:21Z",
      "updatedAt": "2024-06-08T19:54:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "e8c0cbeab9588613801feb3579536bc1221571dc",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/94",
      "headRefOid": "ce349107134a6cb44c5c101dfb5484c0f6466662",
      "closedAt": "2024-05-06T13:36:25Z",
      "mergedAt": "2024-05-06T13:36:25Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "9ff20bfdafd7aa192d06f91f7d362a9835d31ed2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc55RNc6",
          "commit": {
            "abbreviatedOid": "c58d147"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-01T22:21:01Z",
          "updatedAt": "2024-05-01T22:21:06Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "How does an implementer know what makes a mechanism compatible?\n\nWhen is this a MUST?",
              "createdAt": "2024-05-01T22:21:01Z",
              "updatedAt": "2024-05-01T22:21:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55ROmv",
          "commit": {
            "abbreviatedOid": "c58d147"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-01T22:26:29Z",
          "updatedAt": "2024-05-01T22:26:29Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "> How does an implementer know what makes a mechanism compatible?\r\n\r\nI don't think we can answer this question without being concrete about what DP mechanisms are available. There is an I-D for this, but its in early stages and doesn't have a home at IETF yet: https://github.com/wangshan/draft-wang-ppm-differential-privacy/\r\n\r\n> When is this a MUST?\r\n\r\nIt really depends on the application: for Poplar1, we think it's always going to be necessary to stop attacks (https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/336); for Prio3, it doesn't seem strictly necessary in all cases.",
              "createdAt": "2024-05-01T22:26:29Z",
              "updatedAt": "2024-05-01T22:26:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55RUNI",
          "commit": {
            "abbreviatedOid": "c58d147"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-01T22:56:28Z",
          "updatedAt": "2024-05-01T22:56:28Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "For the record, @ekr suggests on list that a SHOULD is inappropriate and the sentence should just be deleted.",
              "createdAt": "2024-05-01T22:56:28Z",
              "updatedAt": "2024-05-01T22:56:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55RYIS",
          "commit": {
            "abbreviatedOid": "a426594"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-01T23:17:43Z",
          "updatedAt": "2024-05-01T23:24:14Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "\"from whence\" seems fancy, when \"from which\" would do.",
              "createdAt": "2024-05-01T23:17:43Z",
              "updatedAt": "2024-05-01T23:24:14Z"
            },
            {
              "originalPosition": 49,
              "body": "```suggestion\r\nHowever, even when the measurements are noised, collecting them in the clear\r\n```",
              "createdAt": "2024-05-01T23:18:08Z",
              "updatedAt": "2024-05-01T23:24:14Z"
            },
            {
              "originalPosition": 53,
              "body": "Instead of \"Specifically, ... Indeed...\", I might use \"On the one hand... On the other hand...\"",
              "createdAt": "2024-05-01T23:20:39Z",
              "updatedAt": "2024-05-01T23:24:14Z"
            },
            {
              "originalPosition": 116,
              "body": "Might I suggest one of the additional options in RFC 6919, e.g., [SHOULD CONSIDER](https://rfcs.online/rfcs/rfc6919.html#section-2)?\r\n\r\nMore seriously, the idea of composition seems worth mentioning, but I agree that RFC 2119 language probably isn't appropriate.",
              "createdAt": "2024-05-01T23:24:05Z",
              "updatedAt": "2024-05-01T23:24:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55RYnC",
          "commit": {
            "abbreviatedOid": "a426594"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-01T23:20:31Z",
          "updatedAt": "2024-05-01T23:24:17Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "```suggestion\r\nVDAFs do not inherently provide differential privacy {{Dwo06}}. Depending on\r\n```",
              "createdAt": "2024-05-01T23:20:31Z",
              "updatedAt": "2024-05-01T23:24:17Z"
            },
            {
              "originalPosition": 115,
              "body": "```suggestion\r\nleak a significant amount of information about individual measurements or measurements\r\nthat relate to a single person or group. Thus\r\n```",
              "createdAt": "2024-05-01T23:21:24Z",
              "updatedAt": "2024-05-01T23:24:17Z"
            },
            {
              "originalPosition": 116,
              "body": "```suggestion\r\napplications might compose a VDAF with a compatible mechanism for differential\r\n```",
              "createdAt": "2024-05-01T23:22:03Z",
              "updatedAt": "2024-05-01T23:24:17Z"
            },
            {
              "originalPosition": 63,
              "body": "```suggestion\r\ndifferentially private aggregate {{MPRV09}}. In this document, we describe\r\n```",
              "createdAt": "2024-05-01T23:22:19Z",
              "updatedAt": "2024-05-01T23:24:17Z"
            },
            {
              "originalPosition": 39,
              "body": "```suggestion\r\nThis problem is often formulated in terms of differential privacy (DP)\r\n```",
              "createdAt": "2024-05-01T23:22:59Z",
              "updatedAt": "2024-05-01T23:24:17Z"
            },
            {
              "originalPosition": 49,
              "body": "```suggestion\r\nHowever even when noise is added to measurements, collecting them in the clear\r\n```",
              "createdAt": "2024-05-01T23:23:39Z",
              "updatedAt": "2024-05-01T23:24:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55WGNr",
          "commit": {
            "abbreviatedOid": "c58d147"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-02T14:00:56Z",
          "updatedAt": "2024-05-02T14:00:56Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "@martinthomson also concurs on list, I'll remove it!",
              "createdAt": "2024-05-02T14:00:56Z",
              "updatedAt": "2024-05-02T14:00:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55WO-r",
          "commit": {
            "abbreviatedOid": "a426594"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-02T14:12:43Z",
          "updatedAt": "2024-05-02T14:12:43Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Changed to \"an individual measurement or the person that generated it\", PTAL.",
              "createdAt": "2024-05-02T14:12:43Z",
              "updatedAt": "2024-05-02T14:12:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55WPdz",
          "commit": {
            "abbreviatedOid": "a426594"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-02T14:13:30Z",
          "updatedAt": "2024-05-02T14:13:30Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "I deleted the sentence per @ekr's suggestion ... I can add it back with \"might\" if you like.",
              "createdAt": "2024-05-02T14:13:30Z",
              "updatedAt": "2024-05-02T14:13:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55WPs2",
          "commit": {
            "abbreviatedOid": "a426594"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-02T14:13:54Z",
          "updatedAt": "2024-05-02T14:13:55Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Thanks for crushing my dreams, Richard.",
              "createdAt": "2024-05-02T14:13:55Z",
              "updatedAt": "2024-05-02T14:13:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55WiDd",
          "commit": {
            "abbreviatedOid": "f2a7ff8"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-02T14:42:11Z",
          "updatedAt": "2024-05-02T14:45:54Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "We can also delete the commented-out \"Vad16\" reference below. That was just used [here](https://github.com/cjpatton/ppm/blob/1d38aacd713ec7f23a3de3a41c5166e29ef43be2/draft-patton-multi-ppm.md?plain=1#L377) early in the history of the document, and the other references we have are sufficient.",
              "createdAt": "2024-05-02T14:42:12Z",
              "updatedAt": "2024-05-02T14:45:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55XfI2",
          "commit": {
            "abbreviatedOid": "4738490"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "~I agree with Richard that a SHOULD CONSIDER is appropriate.~ Oh I get the joke",
          "createdAt": "2024-05-02T16:07:53Z",
          "updatedAt": "2024-05-02T16:09:51Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "What does \"delegated\" MPC mean? Is the distinction useful in this document?",
              "createdAt": "2024-05-02T16:07:53Z",
              "updatedAt": "2024-05-02T16:08:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55X1Qa",
          "commit": {
            "abbreviatedOid": "4738490"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-02T16:43:22Z",
          "updatedAt": "2024-05-02T16:43:22Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "\"Delegated\" means a small set of servers carry out the computation on behalf of a large number of clients providing the inputs.",
              "createdAt": "2024-05-02T16:43:22Z",
              "updatedAt": "2024-05-02T16:43:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55X63-",
          "commit": {
            "abbreviatedOid": "ce34910"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-02T16:55:02Z",
          "updatedAt": "2024-05-06T13:32:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc55aQas",
          "commit": {
            "abbreviatedOid": "4738490"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-02T21:11:15Z",
          "updatedAt": "2024-05-02T21:11:15Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Is that a term of art?  It's the first I've heard it.",
              "createdAt": "2024-05-02T21:11:15Z",
              "updatedAt": "2024-05-02T21:11:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55e2ox",
          "commit": {
            "abbreviatedOid": "ce34910"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-03T13:19:57Z",
          "updatedAt": "2024-05-06T13:32:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 340,
      "id": "PR_kwDOGKuqOc5uTA78",
      "title": "Tweak nonce requirements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/340",
      "state": "MERGED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "security consideration",
        "draft-09"
      ],
      "body": "- Clarify that aggregators must verify that nonces are never re-used. Since VDAF aims to provide privacy in the face of malicious clients, it doesn't suffice to say clients MUST generate nonces using a CSPRNG; we have to account for malicious clients by adding a MUST for the aggregator. This lines up with the behavior DAP has specified for a long time now.\r\n\r\n- In the second paragraph, clarify that over exposing a *report* is the risk, not a *measurement*. It's always possible for the same measurement to occur many times (for instance, in `Prio3Count`, most measurements are 1), but we want the enclosing *report* to be unique.\r\n\r\nSee https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/issues/558 for discussion",
      "createdAt": "2024-05-01T23:58:03Z",
      "updatedAt": "2024-05-08T16:14:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "82389a81e1c871b39cd24d267768873555580529",
      "headRepository": "tgeoghegan/vdaf",
      "headRefName": "timg/clarify-nonce-uniqueness",
      "headRefOid": "45fc0bcc060bf059a7b81d0a596200bb2087ba53",
      "closedAt": "2024-05-08T16:14:09Z",
      "mergedAt": "2024-05-08T16:14:09Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "3a7fc7f094a6f835fa62fbbfb542f2f0cf8c40c0"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "~For the record: it's not clear this is strictly necessary, but it does correspond to the threat model described in DPRS23. And since we already have the requirement in DAP, we might as well adopt it here.~",
          "createdAt": "2024-05-02T15:15:21Z",
          "updatedAt": "2024-05-02T15:38:55Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, I forgot that the draft already reacommended using the nonce for replay protection, and that this just adds clarity to this. Looks like we're good to go! I'm gonna merge, and I don't think there's a need for a second PR.",
          "createdAt": "2024-05-08T16:14:06Z",
          "updatedAt": "2024-05-08T16:14:06Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc55WzFt",
          "commit": {
            "abbreviatedOid": "0818979"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-02T15:02:55Z",
          "updatedAt": "2024-05-02T15:02:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc55W7wF",
          "commit": {
            "abbreviatedOid": "0818979"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-02T15:17:52Z",
          "updatedAt": "2024-05-02T15:17:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc55XCvU",
          "commit": {
            "abbreviatedOid": "0818979"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-05-02T15:29:17Z",
          "updatedAt": "2024-05-02T15:29:42Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Actually, I'm a little hesitant to create this requirement for non-DAP applications. And I'm not sure it's strictly necessary.\r\n\r\n```suggestion\r\nmeasurement, the Client MUST generate this nonce using a CSPRNG. This is\r\nrequired in order to leverage security analysis for the privacy definition of\r\n{{DPRS23}}, which assumes the nonce is chosen at random prior to generating the\r\nreport.\r\n```\r\n\r\nFirst, let me to clarify my claim on the thread in https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/issues/558.  First, the security game in {{DPRS23}} models honest clients that always generate nonces at random. It does not say anything about privacy once a collision occurs, but if the nonce space is sufficiently large, then the probability of a collision is negligible.\r\n\r\nNow, let's consider an attacker that sends the honest aggregator a report with the nonce generated by an honest client. For Prio3, what it learns is a verifier share computed with the same query randomness, but over an input and proof it already knows. The question then is what does the honest client's input as a result? Observe that the attacker can compute this verifier share on its own; there is nothing more it can learn by interacting with the honest aggregator.\r\n\r\nThis makes me think that replay protection is not necessary for the _base_ privacy goal of VDAF. (It would be necessary for DP.)\r\n\r\n@hannahdaviscrypto I would appreciate your view here.",
              "createdAt": "2024-05-02T15:29:17Z",
              "updatedAt": "2024-05-02T15:29:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55XoTn",
          "commit": {
            "abbreviatedOid": "0818979"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-02T16:23:16Z",
          "updatedAt": "2024-05-02T16:23:16Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I agree with this change. It's true that for Prio3, the attacker can't learn anything by submitting an input share with a repeated nonce and known input/proof to the honest aggregator, and in the {{DPRS23}} model, this is the only way it can repeat a nonce.\r\n\r\nBut implicitly, the {{DPRS23}} model is relying on non-malleability of the channel between the prover and the honest aggregator, which some VDAFs might not want to assume. If the attacker can submit a report with the same nonce and input share as an honest client but a tampered proof, I think we've lost security in a way that isn't covered by the {{DPRS23}} model (but would be by the {{MPDST24}} model).\r\n\r\nIn DAP, of course, we should have non-malleability and don't need to worry about it. But if we're specifically talking about non-DAP applications, it seems wise to keep the requirements on them as light as possible. \r\n\r\nMore to the point, is there a downside to asking this of aggregators? Is there a target application where it would substantially help to allow repeated nonces?",
              "createdAt": "2024-05-02T16:23:16Z",
              "updatedAt": "2024-05-02T16:23:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55X5py",
          "commit": {
            "abbreviatedOid": "0818979"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-02T16:52:20Z",
          "updatedAt": "2024-05-02T16:52:20Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "The downside of this requirement is that checking for nonce uniqueness is expensive and so relaxing the requirement can make protocols easier to implement or at least to operate (fewer expensive database lookups).",
              "createdAt": "2024-05-02T16:52:20Z",
              "updatedAt": "2024-05-02T16:52:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55YABq",
          "commit": {
            "abbreviatedOid": "0818979"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-02T17:03:27Z",
          "updatedAt": "2024-05-02T17:03:27Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "By {{MPDST24}} you mean https://eprint.iacr.org/2024/221, correct?\r\n\r\nThis non-malleability property is important and needs to be called out. I believe this is provided by HPKE, as long as it is IND-CCA. Do you agree? \r\n\r\n> In DAP, of course, we should have non-malleability and don't need to worry about it. But if we're specifically talking about non-DAP applications, it seems wise to keep the requirements on them as light as possible.\r\n>\r\n> More to the point, is there a downside to asking this of aggregators? Is there a target application where it would substantially help to allow repeated nonces?\r\n\r\nYou bring up a very interesting point. On the one hand, we would like security requirements to be as minimal as possible, i.e., not requiring non-malleability of the channel would be good. On the other hand, detecting replayed nonces is a rather stringent _operational_ requirement. In fact, this is what spurred @tgeoghegan's PR in the first place: https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/issues/556\r\n\r\nTo answer your question: anti-replay has a high operational cost, and while it already exists for DAP, I wouldn't want to impose it on every application.",
              "createdAt": "2024-05-02T17:03:27Z",
              "updatedAt": "2024-05-02T17:03:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55YCis",
          "commit": {
            "abbreviatedOid": "0818979"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-02T17:06:46Z",
          "updatedAt": "2024-05-02T17:06:46Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "On balance, I think I would prefer to spell out that security consideration than impose the operational consideration. What do you two think?",
              "createdAt": "2024-05-02T17:06:46Z",
              "updatedAt": "2024-05-02T17:06:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55YFAr",
          "commit": {
            "abbreviatedOid": "0818979"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-02T17:11:45Z",
          "updatedAt": "2024-05-02T17:11:45Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Yep, that's the paper I meant. I think we did later decide that it was important to model malicious clients in privacy.\r\n\r\nYes, IND-CCA HPKE is definitely sufficient, and a callout would be good.\r\n\r\nThanks for highlighting the operational cost. In that case I think the question is this: are there any VDAFs we're interested in where, unlike Prio3, privacy could be compromised by submitting a known report with a repeated nonce to an honest aggregator? If so, I think that the security concern would probably outweigh the cost concern and we should make this change. If not, letting applications pick between using HPKE and unique nonces makes sense.\r\n\r\nThe stupid toy example I'm thinking of is a VDAF where privacy relies on queries being truly random. Perhaps instead of the leader selecting a verification key, the aggregators have to interact to jointly sample it. Then nonce replays would be more dangerous. ",
              "createdAt": "2024-05-02T17:11:45Z",
              "updatedAt": "2024-05-02T17:11:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55ZkPh",
          "commit": {
            "abbreviatedOid": "0818979"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-02T19:40:57Z",
          "updatedAt": "2024-05-02T19:40:58Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "> Thanks for highlighting the operational cost. In that case I think the question is this: are there any VDAFs we're interested in where, unlike Prio3, privacy could be compromised by submitting a known report with a repeated nonce to an honest aggregator? If so, I think that the security concern would probably outweigh the cost concern and we should make this change. If not, letting applications pick between using HPKE and unique nonces makes sense.\r\n\r\nLet me see if I understand the attack:\r\n1. Honest client uploads a report; the attacker interacts with the honest aggregator to process it\r\n2. Attacker uploads a report with the same nonce; the attacker interacts with the honest aggregator to process it\r\n3. Attacker guesses a bit of the honest measurement based on its share of the honest report and the messages exchanged\r\n",
              "createdAt": "2024-05-02T19:40:58Z",
              "updatedAt": "2024-05-02T19:40:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55Z13k",
          "commit": {
            "abbreviatedOid": "0818979"
          },
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-02T20:22:00Z",
          "updatedAt": "2024-05-02T20:22:00Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "In step 3, possibly also the final result (i.e., whether the honest aggregator accepted the fake report). Otherwise, yes.",
              "createdAt": "2024-05-02T20:22:00Z",
              "updatedAt": "2024-05-02T20:22:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc55Z5ZP",
          "commit": {
            "abbreviatedOid": "0818979"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-02T20:30:54Z",
          "updatedAt": "2024-05-02T20:30:54Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Thanks. At the moment I can't imagine a VDAF for which this attack is possible. It would require preparation of the honest report to leak something it's not supposed to, correct? In which case the repeated nonce doesn't matter.\r\n\r\nPerhaps we should try to flesh out your counter example? ",
              "createdAt": "2024-05-02T20:30:54Z",
              "updatedAt": "2024-05-02T20:30:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc559IYA",
          "commit": {
            "abbreviatedOid": "45fc0bc"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-08T15:59:39Z",
          "updatedAt": "2024-05-08T15:59:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc559NDb",
          "commit": {
            "abbreviatedOid": "45fc0bc"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-08T16:09:20Z",
          "updatedAt": "2024-05-08T16:09:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 343,
      "id": "PR_kwDOGKuqOc5u5GOR",
      "title": "Clarify that public share consistency needn't be explicit",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/343",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "draft-09"
      ],
      "body": "Closes #342.",
      "createdAt": "2024-05-08T14:55:11Z",
      "updatedAt": "2024-06-08T19:54:47Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d5d3e1f0175f86daf25c215289262deb9e9d340b",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/342",
      "headRefOid": "415c89c0424febf84b48f065d52cd64fe6c82be5",
      "closedAt": "2024-05-08T15:31:55Z",
      "mergedAt": "2024-05-08T15:31:55Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "d9fede04149c48c8f75dc0ca1a2bc4a4fb210ffc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc558j_Y",
          "commit": {
            "abbreviatedOid": "415c89c"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-08T14:56:16Z",
          "updatedAt": "2024-05-08T14:56:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 344,
      "id": "PR_kwDOGKuqOc5vSbHE",
      "title": "Prepare to cut VDAF-09",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/344",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-09"
      ],
      "body": "* Update change log for VDAF-09 (assumes #332 has landed)\r\n* Does not bump `VERSION`, as there are no breaking changes in either Prio3 or Poplar1",
      "createdAt": "2024-05-13T17:01:36Z",
      "updatedAt": "2024-06-08T19:54:46Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "a593fd485d9793cb5047c4d8c9a0351a8da2b436",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-09",
      "headRefOid": "ffac8b062fa72426003f500f90c328185543e5c1",
      "closedAt": "2024-05-14T02:59:13Z",
      "mergedAt": "2024-05-14T02:59:12Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "b5f062a8e583297684409866b77b6dfb547d15ff"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc56awcC",
          "commit": {
            "abbreviatedOid": "63b75f2"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-13T21:10:41Z",
          "updatedAt": "2024-05-13T21:10:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc56ayPM",
          "commit": {
            "abbreviatedOid": "63b75f2"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-13T21:15:57Z",
          "updatedAt": "2024-05-13T21:16:12Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "This seems like it's missing a word\r\n```suggestion\r\n  counts. Accordingly, add text ensuring public share consistency to security\r\n  considerations.\r\n```",
              "createdAt": "2024-05-13T21:15:57Z",
              "updatedAt": "2024-05-13T21:16:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 345,
      "id": "PR_kwDOGKuqOc5xmpSL",
      "title": "Add guidance for encoding byte strings as IDPF indices",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/345",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "Closes #101.\r\n\r\nBig-endian encoding is the most natural choice as it aligns most naturally with our definition of index. We also should note that a reversible padding scheme is needed when the inputs might be variable length.\r\n\r\nWhile at it, pick up a few minor editorial improvements:\r\n\r\n- \"set of candidate preixes\" -> \"sequence of candidate prefixes\"\r\n- Use one free variable in defining index prefixes\r\n- \"Vec\" -> \"list\"\r\n- \"Client\" -> \"Sharding\" for consistency with the Prio3 section",
      "createdAt": "2024-06-05T20:48:23Z",
      "updatedAt": "2024-06-06T21:23:47Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "b5f062a8e583297684409866b77b6dfb547d15ff",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/101",
      "headRefOid": "b47b6623a54f7224640f4c33264b316e7c66b7eb",
      "closedAt": "2024-06-06T21:22:37Z",
      "mergedAt": "2024-06-06T21:22:37Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "ffd69aa33e1365f6b5f65d1dd0eaf462588d01e4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc59U1HM",
          "commit": {
            "abbreviatedOid": "d5b68bf"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-06T17:17:03Z",
          "updatedAt": "2024-06-06T17:18:55Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "nit: extra word\r\n```suggestion\r\nThe Client's measurement is an IDPF index, denoted `alpha`. (See\r\n```",
              "createdAt": "2024-06-06T17:17:03Z",
              "updatedAt": "2024-06-06T17:18:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc59XMHs",
          "commit": {
            "abbreviatedOid": "d5b68bf"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-06T21:17:09Z",
          "updatedAt": "2024-06-06T21:17:09Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "Done.",
              "createdAt": "2024-06-06T21:17:09Z",
              "updatedAt": "2024-06-06T21:17:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 347,
      "id": "PR_kwDOGKuqOc5xnVWm",
      "title": "Remove type aliases, simplify hints, and express bounds in prose",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/347",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "Based on #345 (merge that first).\r\n\r\nCloses #222.\r\nPartially addresses #233.\r\nPartially addresses #59.\r\n\r\nWe use Python's type hints to make APIs more self-documenting. However\r\nwe abuse hints in a couple of ways:\r\n\r\n1. We give aliases to primitive types, e.g., `Vec` for `list`.\r\n2. We try to express fixed-length arrays with hints, e.g.,\r\n   `bytes[Vdaf.NONCE_SIZE]`, but don't (and probably can't) enforce it.\r\n3. We use `Unsigned` for non-negative integers, but don't enforce it.\r\n\r\nThese abuses have lead to code rot. To address this, we remove the type\r\naliases altogether, simplify the type hints, and express bounds on\r\ntypes in prose. In some cases, the bounds are stricter than they were\r\nbefore.\r\n\r\nA few minor changes picked up along the way:\r\n\r\n- idpf_poplar.py: `packed_bits` -> `packed` for consistency with\r\n  `encoded` elsewhere.\r\n\r\n- vdaf_prio3.py: Remove `PRio3SumVecWithMultiproof.is_recommended()` as\r\n  it is not really used.\r\n\r\n- Declare `gen_rand()` to be a CSPRNG.",
      "createdAt": "2024-06-06T00:01:59Z",
      "updatedAt": "2024-06-10T16:08:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "ffd69aa33e1365f6b5f65d1dd0eaf462588d01e4",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/222",
      "headRefOid": "b402812916cd4169c931fd058c2f896fea55100f",
      "closedAt": "2024-06-06T21:32:01Z",
      "mergedAt": "2024-06-06T21:32:01Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "9e7c7cfdebd512a9930337f0fdd5231bd15b765f"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased and addressed your comments.",
          "createdAt": "2024-06-06T21:27:09Z",
          "updatedAt": "2024-06-06T21:27:09Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc59WKg8",
          "commit": {
            "abbreviatedOid": "ba804ba"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-06T18:51:17Z",
          "updatedAt": "2024-06-06T20:39:29Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "nit: missing word\r\n```suggestion\r\n    a CSPRNG. (See {{security}} for details.)\r\n```",
              "createdAt": "2024-06-06T18:51:17Z",
              "updatedAt": "2024-06-06T20:39:29Z"
            },
            {
              "originalPosition": 689,
              "body": "nit: typo\r\n```suggestion\r\n  * `num_measurements` MUST equal the number of measurements that contributed to\r\n```",
              "createdAt": "2024-06-06T19:20:46Z",
              "updatedAt": "2024-06-06T20:39:29Z"
            },
            {
              "originalPosition": 858,
              "body": "nit: repetition\r\n```suggestion\r\n    * `binder` MUST be chosen uniformly at random by the Client\r\n```",
              "createdAt": "2024-06-06T19:27:08Z",
              "updatedAt": "2024-06-06T20:39:29Z"
            },
            {
              "originalPosition": 855,
              "body": "This should be one shorter to reflect the length of the list.\r\n```suggestion\r\n       `range(Idpf.BITS - 1)`.\r\n```",
              "createdAt": "2024-06-06T19:28:00Z",
              "updatedAt": "2024-06-06T20:39:29Z"
            },
            {
              "originalPosition": 889,
              "body": "```suggestion\r\n  * Each `prefix` in `prefixes` MUST be distinct and in `range(2**level)`.\r\n```",
              "createdAt": "2024-06-06T19:29:17Z",
              "updatedAt": "2024-06-06T20:39:29Z"
            },
            {
              "originalPosition": 887,
              "body": "This should probably be deleted, unless we want to say something about the public share here.\r\n```suggestion\r\n```",
              "createdAt": "2024-06-06T19:30:52Z",
              "updatedAt": "2024-06-06T20:39:29Z"
            },
            {
              "originalPosition": 63,
              "body": "Same as in the text\r\n```suggestion\r\n              `range(Idpf.BITS - 1)`\r\n```",
              "createdAt": "2024-06-06T19:33:51Z",
              "updatedAt": "2024-06-06T20:39:29Z"
            },
            {
              "originalPosition": 89,
              "body": "```suggestion\r\n        Evaluate an IDPF key and public share at a given level of the tree\r\n```",
              "createdAt": "2024-06-06T20:15:29Z",
              "updatedAt": "2024-06-06T20:39:29Z"
            },
            {
              "originalPosition": 134,
              "body": "There's no such argument here\r\n```suggestion\r\n```",
              "createdAt": "2024-06-06T20:34:13Z",
              "updatedAt": "2024-06-06T20:39:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc59XPZN",
          "commit": {
            "abbreviatedOid": "ba804ba"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-06T21:25:59Z",
          "updatedAt": "2024-06-06T21:25:59Z",
          "comments": [
            {
              "originalPosition": 887,
              "body": "Ugh, this is a bit of copy-pasta. My apologies, I should have done more self-review before putting this in front of you.",
              "createdAt": "2024-06-06T21:25:59Z",
              "updatedAt": "2024-06-06T21:25:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 348,
      "id": "PR_kwDOGKuqOc5xs0wd",
      "title": "Replace generic `ERR_*` exceptions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/348",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "Based on #350 (merge that first).\r\n\r\nCloses #277.\r\n\r\nUse a generic Python exception with a helpful error message. `ValueError` is the natural choice for all of our cases.",
      "createdAt": "2024-06-06T15:55:51Z",
      "updatedAt": "2024-06-10T16:08:57Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "9ba9c346d6f339e2643bc93da749ec0a40d68eef",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/277",
      "headRefOid": "21f014259596094cdf2f9f96f0ede1e9c876fc3c",
      "closedAt": "2024-06-07T14:02:20Z",
      "mergedAt": "2024-06-07T14:02:20Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "9ea01b9c1144b8644527450f03fb35c2a0ff479b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc59W9Ew",
          "commit": {
            "abbreviatedOid": "0ae9dcd"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-06T20:41:47Z",
          "updatedAt": "2024-06-06T22:14:11Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "It looks like we can get rid of this class too.",
              "createdAt": "2024-06-06T20:41:47Z",
              "updatedAt": "2024-06-06T22:14:11Z"
            },
            {
              "originalPosition": 5,
              "body": "I think \"field size\" is ambiguous here, as it sounds like it's referring to the modulus. Maybe \"a multiple of the size of an encoded field element\"?",
              "createdAt": "2024-06-06T21:02:42Z",
              "updatedAt": "2024-06-06T22:14:11Z"
            },
            {
              "originalPosition": 209,
              "body": "The prepare state is not an input here\r\n```suggestion\r\n        raise ValueError('invalid prep message')\r\n```",
              "createdAt": "2024-06-06T21:36:59Z",
              "updatedAt": "2024-06-06T22:14:11Z"
            },
            {
              "originalPosition": 178,
              "body": "nit: off-by-one errors (the first invalid input should be a power of two in both cases)\r\n```suggestion\r\n    if level not in range(2**16):\r\n        raise ValueError('level out of range')\r\n    if len(prefixes) not in range(2**32):\r\n        raise ValueError('number of prefixes out of range')\r\n```",
              "createdAt": "2024-06-06T21:46:27Z",
              "updatedAt": "2024-06-06T22:14:11Z"
            },
            {
              "originalPosition": 89,
              "body": "nit: typo\r\n```suggestion\r\n            raise ValueError('measurement out of range')\r\n```",
              "createdAt": "2024-06-06T22:07:13Z",
              "updatedAt": "2024-06-06T22:14:11Z"
            },
            {
              "originalPosition": 78,
              "body": "Same as in the document:\r\n```suggestion\r\n        if level not in range(2**16):\r\n            raise ValueError('level out of range')\r\n        if len(prefixes) not in range(2**32):\r\n            raise ValueError('number of prefixes out of range')\r\n```",
              "createdAt": "2024-06-06T22:13:35Z",
              "updatedAt": "2024-06-06T22:14:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc59Xe49",
          "commit": {
            "abbreviatedOid": "0ae9dcd"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-06T22:23:16Z",
          "updatedAt": "2024-06-06T22:27:11Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "Fixed by aligning with the poc.",
              "createdAt": "2024-06-06T22:23:16Z",
              "updatedAt": "2024-06-06T22:27:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc59Xgaq",
          "commit": {
            "abbreviatedOid": "72d04bc"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-06T22:30:11Z",
          "updatedAt": "2024-06-07T13:54:31Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "nit: this needs another space\r\n```suggestion\r\n            'input length must be a multiple of the size of an '\r\n```",
              "createdAt": "2024-06-06T22:30:11Z",
              "updatedAt": "2024-06-07T13:54:31Z"
            },
            {
              "originalPosition": 15,
              "body": "Same as above\r\n```suggestion\r\n                'input length must be a multiple of the size of an '\r\n```",
              "createdAt": "2024-06-07T13:54:08Z",
              "updatedAt": "2024-06-07T13:54:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 349,
      "id": "PR_kwDOGKuqOc5xut9H",
      "title": "Add Prio3MultihotCountVec to the draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/349",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "Closes #287.\r\n\r\nAssign Prio3MultiHotHistogram a codepoint (0x00000004) and add it to the draft under the name Prio3MultihotCountVec. Also, rename \"count\" to \"weight\", as in the \"weight of the vector\" (i.e., the number of non-zero entries).",
      "createdAt": "2024-06-06T21:06:38Z",
      "updatedAt": "2024-07-02T21:39:07Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "6684fcca6995e080e10bf852d68f3671bc568dca",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/287",
      "headRefOid": "8dad22a540ea4f9649cdf5cf93583480baa83302",
      "closedAt": "2024-06-11T22:20:17Z",
      "mergedAt": "2024-06-11T22:20:17Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "e57208850eb83afee11993df689afbb3809c534d"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Changed base to main.",
          "createdAt": "2024-06-06T22:28:41Z",
          "updatedAt": "2024-06-06T22:28:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed Junye's comments and rebased.",
          "createdAt": "2024-06-07T19:17:30Z",
          "updatedAt": "2024-06-07T19:17:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc59coaq",
          "commit": {
            "abbreviatedOid": "2933487"
          },
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Have one comment about the definition of `offset`, otherwise LGTM.",
          "createdAt": "2024-06-07T14:00:14Z",
          "updatedAt": "2024-06-07T14:22:09Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nPrio3MultihotCountVec to be composed with a randomized response mechanism,\r\n```",
              "createdAt": "2024-06-07T14:00:14Z",
              "updatedAt": "2024-06-07T14:22:09Z"
            },
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n(i.e., the number of non-zero entries); and `chunk_length`, which is used by\r\n```",
              "createdAt": "2024-06-07T14:00:55Z",
              "updatedAt": "2024-06-07T14:22:09Z"
            },
            {
              "originalPosition": 33,
              "body": "Should we quickly explain what `offset` is in the draft itself?",
              "createdAt": "2024-06-07T14:07:11Z",
              "updatedAt": "2024-06-07T14:22:09Z"
            },
            {
              "originalPosition": 47,
              "body": "Related comment about `offset`: I don't think the circuit is offsetting by `max_weight`? The `offset` is the difference between `max_weight` and `next_power_of_2(max_weight) - 1`.",
              "createdAt": "2024-06-07T14:21:46Z",
              "updatedAt": "2024-06-07T14:22:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc59ez5g",
          "commit": {
            "abbreviatedOid": "2fa9804"
          },
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-07T19:21:40Z",
          "updatedAt": "2024-06-07T19:21:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc59sVbn",
          "commit": {
            "abbreviatedOid": "2fa9804"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-10T21:21:25Z",
          "updatedAt": "2024-06-10T21:47:46Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "We shouldn't use `range(max_weight)` Python-style notation here (and elsewhere), as `max_weight` should be an inclusive upper bound, but `range()` has an exclusive upper bound.",
              "createdAt": "2024-06-10T21:21:25Z",
              "updatedAt": "2024-06-10T21:47:46Z"
            },
            {
              "originalPosition": 25,
              "body": "We should define `bits_for_weight` first, before this definition.",
              "createdAt": "2024-06-10T21:23:36Z",
              "updatedAt": "2024-06-10T21:47:46Z"
            },
            {
              "originalPosition": 108,
              "body": "This is incorrect, as we remove some of these elements during `truncate()`.\r\n```suggestion\r\n| `OUTPUT_LEN`     | `length`                                        |\r\n```",
              "createdAt": "2024-06-10T21:35:15Z",
              "updatedAt": "2024-06-10T21:47:46Z"
            },
            {
              "originalPosition": 72,
              "body": "nit: typo\r\n```suggestion\r\n            - `chunk_length > 0`\r\n```",
              "createdAt": "2024-06-10T21:42:05Z",
              "updatedAt": "2024-06-10T21:47:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc59tJjx",
          "commit": {
            "abbreviatedOid": "ad1f2b1"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-11T00:23:45Z",
          "updatedAt": "2024-06-11T01:07:55Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Good catch, David. I'm gonna rename this to `weight_bound` to match https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/355/files#diff-ae2b81b107a8e1333a5859497c41aad419ff1d6033893b60e15edd89d2e167d6, which I think is a bit more natural.",
              "createdAt": "2024-06-11T00:23:45Z",
              "updatedAt": "2024-06-11T01:07:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc59z2ol",
          "commit": {
            "abbreviatedOid": "2fa9804"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-11T15:06:17Z",
          "updatedAt": "2024-06-11T15:06:17Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Hmm, I think that making the VDAF's parameter an exclusive bound on the measurement's weight, rather than an inclusive bound, is confusing to the end user. I'd rather say \"I want between zero and five ones, so I'll construct `Prio3MultihotCountVec` with `max_weight = 5`\", than \"I want between zero and five ones, so I'll construct `Prio3MultihotCountVec` with `weight_bound = 6`\". Plus, the reader would have to be familiar with Python to catch the nuance.",
              "createdAt": "2024-06-11T15:06:17Z",
              "updatedAt": "2024-06-11T15:06:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc59z4Zd",
          "commit": {
            "abbreviatedOid": "2fa9804"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-11T15:09:04Z",
          "updatedAt": "2024-06-11T15:09:04Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Hmm, I figured aligning with Python would make things clearer. I don't feel strongly about this though, and since it's what we we already doing, I'm happy to revert.",
              "createdAt": "2024-06-11T15:09:04Z",
              "updatedAt": "2024-06-11T15:09:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc591JqK",
          "commit": {
            "abbreviatedOid": "2fa9804"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-11T17:40:18Z",
          "updatedAt": "2024-06-11T17:40:18Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Done - PTAL",
              "createdAt": "2024-06-11T17:40:18Z",
              "updatedAt": "2024-06-11T17:40:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc592lJP",
          "commit": {
            "abbreviatedOid": "9e13341"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-11T21:09:14Z",
          "updatedAt": "2024-06-11T22:04:34Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "nit: typo\r\n```suggestion\r\n* `bits_for_weight = max_weight.bit_length()`\r\n```",
              "createdAt": "2024-06-11T21:09:14Z",
              "updatedAt": "2024-06-11T22:04:34Z"
            },
            {
              "originalPosition": 35,
              "body": "Same as above\r\n```suggestion\r\n    * `bits_for_weight = max_weight.bit_length()`\r\n```",
              "createdAt": "2024-06-11T21:09:56Z",
              "updatedAt": "2024-06-11T22:04:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 350,
      "id": "PR_kwDOGKuqOc5xu1lv",
      "title": "Apply feedback from @divergentdave's review of #347",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/350",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "I forgot to include this before I merged the previous commit. See #347.",
      "createdAt": "2024-06-06T21:34:36Z",
      "updatedAt": "2024-06-10T16:09:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "9e7c7cfdebd512a9930337f0fdd5231bd15b765f",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/222-fix",
      "headRefOid": "95d62df5f14a1feb52211a3ac663ffe8901387be",
      "closedAt": "2024-06-06T21:36:50Z",
      "mergedAt": "2024-06-06T21:36:50Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "9ba9c346d6f339e2643bc93da749ec0a40d68eef"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc59XSd4",
          "commit": {
            "abbreviatedOid": "95d62df"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-06T21:36:23Z",
          "updatedAt": "2024-06-06T21:36:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 351,
      "id": "PR_kwDOGKuqOc5xu-9o",
      "title": "Enforce type hints in field.py, xof.py",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/351",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "Partially addresses #59.\r\n\r\nAdd type hint enforcement with mypy to CI, starting with field.py and xof.py. This checks that the variables passed into a function match the function's type hints.",
      "createdAt": "2024-06-06T22:14:18Z",
      "updatedAt": "2024-06-10T16:09:19Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "9ba9c346d6f339e2643bc93da749ec0a40d68eef",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/59/mypy-1",
      "headRefOid": "4e35c5b1fd88f0cd4d548a980329989b8bde05a8",
      "closedAt": "2024-06-07T17:10:11Z",
      "mergedAt": "2024-06-07T17:10:11Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "3ac03623c4680b28d1517af0a16dd513e1d0c310"
      },
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "BTW, it would be good to run mypy on unit tests as well, to help catch mistakes.",
          "createdAt": "2024-06-07T14:51:04Z",
          "updatedAt": "2024-06-07T14:51:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc59Xdcr",
          "commit": {
            "abbreviatedOid": "4e35c5b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-06T22:16:49Z",
          "updatedAt": "2024-06-06T22:17:45Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "@divergentdave I added this to the test workflow simply becuase we already have sage as a dependency.  Do you think it would be better to add this as a different workflow?\r\n\r\nAlso, I'm starting with xof.py and field.py because these were straightforward to fix. We'll add more as we go.",
              "createdAt": "2024-06-06T22:16:49Z",
              "updatedAt": "2024-06-06T22:17:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc59dBwF",
          "commit": {
            "abbreviatedOid": "4e35c5b"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-07T14:39:53Z",
          "updatedAt": "2024-06-07T14:47:58Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Sounds good, this is fast enough to install and run that splitting it wouldn't be worth the parallelism.",
              "createdAt": "2024-06-07T14:39:53Z",
              "updatedAt": "2024-06-07T14:47:58Z"
            },
            {
              "originalPosition": 5,
              "body": "It looks like we could improve upon this situation by generating some `.pyi` files with `stubgen`, or writing them by hand, but I think that should wait until after this first pass.\r\n\r\n`sage.all` is kind of terrifying, because it is responsible for importing modules in the right order (and this is load bearing!), it imports all of Sage's libraries, which is wasteful from our perspective, and it does some runtime reflection tricks that probably make things harder for static analysis tools.",
              "createdAt": "2024-06-07T14:47:00Z",
              "updatedAt": "2024-06-07T14:47:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc59dNHo",
          "commit": {
            "abbreviatedOid": "4e35c5b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-07T15:01:19Z",
          "updatedAt": "2024-06-07T15:01:19Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I wonder if we should even bother. We have already encapsulated most of the sage stuff behind abstractions like `Field`.",
              "createdAt": "2024-06-07T15:01:19Z",
              "updatedAt": "2024-06-07T15:01:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 353,
      "id": "PR_kwDOGKuqOc5x1MmF",
      "title": "Have `is_prefix()` take in a level rather than a length",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/353",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "",
      "createdAt": "2024-06-07T19:42:16Z",
      "updatedAt": "2024-07-02T21:50:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "3ac03623c4680b28d1517af0a16dd513e1d0c310",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/is-prefix",
      "headRefOid": "81c3bfd95bc2302f5bab43a9ad4d3f2c40ebd55a",
      "closedAt": "2024-06-10T19:38:53Z",
      "mergedAt": "2024-06-10T19:38:53Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "c73fb68c8b93e2375223ce45d00ce84dcd779b41"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc59rsLU",
          "commit": {
            "abbreviatedOid": "81c3bfd"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-10T19:31:52Z",
          "updatedAt": "2024-06-10T19:31:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 354,
      "id": "PR_kwDOGKuqOc5x2INa",
      "title": "Enforce type hints for flp.py, flp_generic.py, and tests",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/354",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "Partially addresses #59.\r\n\r\nThe \"associated type\" pattern we're trying to follow is not enforceable.\r\nFor example, we'll do something like this:\r\n\r\n```\r\nclass Foo:\r\n    Measurement = None\r\n    def bar(self, m: Measurement): pass\r\n```\r\n\r\n`mypy` complains because `None` is not a valid type. We instead could do\r\nthe following:\r\n\r\n```\r\nclass Foo:\r\n    Measurement: Any = None\r\n    def bar(self, m: Measurement): pass\r\n```\r\n\r\nA concrete sub-class would override this in the natural way:\r\n\r\n```\r\nclass FooForInt(Foo):\r\n    Measurement = int\r\n    def bar(self, m: int): pass\r\n\r\nFoo().bar(23)\r\nFoo().bar(\"23\")\r\nFooForInt().bar(23)\r\nFooForInt().bar(\"23\") # fails\r\n```",
      "createdAt": "2024-06-08T01:14:50Z",
      "updatedAt": "2024-07-02T21:49:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "3ac03623c4680b28d1517af0a16dd513e1d0c310",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/59/2-flp",
      "headRefOid": "82638453ee23a6ec2ac09929eeb4373b75bd2f9c",
      "closedAt": "2024-06-11T01:11:25Z",
      "mergedAt": "2024-06-11T01:11:25Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "b56f3b11aecf10bfe50e68b37d4b03adaee20da3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc59gCPm",
          "commit": {
            "abbreviatedOid": "1ab6113"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-08T01:28:52Z",
          "updatedAt": "2024-06-08T01:28:52Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "Reviewer note: this is an error because `ARITY` and `DEGREE` are declared to have type `int`. Similarly below.",
              "createdAt": "2024-06-08T01:28:52Z",
              "updatedAt": "2024-06-08T01:28:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc59gCx8",
          "commit": {
            "abbreviatedOid": "8263845"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-08T01:39:03Z",
          "updatedAt": "2024-06-08T01:39:03Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Reviewer note: I tried this because I thought it would be more natural:\r\n\r\n```suggestion\r\n    Field: type[field.Field]\r\n```\r\n\r\nThis doesn't work: ttps://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases\r\n\r\nAnother alternative is to make this generic. For instance we could do:\r\n```python\r\nF = TypeVar('F', bound=field.Field)\r\nclass Flp(Generic[F]):\r\n   field: F\r\n\r\nclass FlpField64(Flp[Field64]):\r\n   field = Field64\r\n```\r\n\r\nGeneric may in fact be the way to go in the long run, but it requires more refactoring.\r\n\r\nNote that we still we don't get to use `F` as a type: it exists only to support type hints. Thus it is still necessary to define `field` as an attribute.\r\n\r\nAlso, note that as of python 3.12, there is some syntactic sugar that makes this look nicer:\r\n```python\r\nclass Flp[F: Field]:\r\n   field: F\r\n```",
              "createdAt": "2024-06-08T01:39:03Z",
              "updatedAt": "2024-06-08T01:39:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc59rFF9",
          "commit": {
            "abbreviatedOid": "8263845"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-10T18:01:07Z",
          "updatedAt": "2024-06-10T18:20:31Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I think the problem here is fundamentally one of partial initialization, due to how we use class factories. Instead of `Any`, we could hypothetically use something like `Union[type[field.Field], NoneType]`. Note that `None` would still be a problem even if we had generic type variables, as the type hint would then be `Union[type[F], NoneType]`.\r\n\r\nMoreover, the final class we construct from a class factory only really exists at runtime, so static analysis-based type checking will run into some fundamental limitations with this pattern.",
              "createdAt": "2024-06-10T18:01:07Z",
              "updatedAt": "2024-06-10T18:20:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc59tS_6",
          "commit": {
            "abbreviatedOid": "8263845"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-11T01:11:20Z",
          "updatedAt": "2024-06-11T01:11:20Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "This is indeed messy. I find I often end up in trying to over-engineer things like this in Python. I think to address this issue I want to more or less follow what we've already done. Using `Any` for the \"abstract base class\" solves things without too many changes.",
              "createdAt": "2024-06-11T01:11:20Z",
              "updatedAt": "2024-06-11T01:11:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 355,
      "id": "PR_kwDOGKuqOc5x3ylr",
      "title": "flp: Make the output of `Valid` a vector",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/355",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "Closes #262.\r\nPartially addresses #306.\r\n\r\nIf the input is valid, then each output should be zero. To save bandwidth, we generate an extra element of query randomness and use it to reduce the result.\r\n\r\nTo exercise this feature, implement a new circuit, `Sum2`, that generalizes `Sum` to support any bound, including non-powers-of-two.",
      "createdAt": "2024-06-08T21:44:30Z",
      "updatedAt": "2024-06-20T17:00:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "12054cd332d75f127b3484119024e70f47b89c34",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/262/1",
      "headRefOid": "f53e1a27be45d02f2b0ae0a518aadc7447c2f2a2",
      "closedAt": "2024-06-20T16:30:57Z",
      "mergedAt": "2024-06-20T16:30:57Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "39fb4753a55bbc33a8da8c662dba8ed99f50e6ff"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to update this to speak in terms of \"max_measurement\" rather than \"measurement_bound\" per @divergentdave's comment here: https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/349#discussion_r1635055085",
          "createdAt": "2024-06-11T15:53:56Z",
          "updatedAt": "2024-06-11T15:53:56Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased and squashed.",
          "createdAt": "2024-06-20T16:22:21Z",
          "updatedAt": "2024-06-20T16:22:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5-F2VE",
          "commit": {
            "abbreviatedOid": "dea8cb6"
          },
          "author": "junyechen1996",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM overall, left some nitpicky comments.",
          "createdAt": "2024-06-13T10:58:50Z",
          "updatedAt": "2024-06-13T14:49:26Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "```suggestion\r\n        - `bits = max_measurement.bit_length()`\r\n```\r\n?",
              "createdAt": "2024-06-13T10:58:50Z",
              "updatedAt": "2024-06-13T14:49:26Z"
            },
            {
              "originalPosition": 167,
              "body": "Can this be more descriptive?",
              "createdAt": "2024-06-13T14:35:27Z",
              "updatedAt": "2024-06-13T14:49:26Z"
            },
            {
              "originalPosition": 228,
              "body": "```suggestion\r\n| `AggResult`       | `list[int]`, each element in `range(2)`                                     |\r\n```",
              "createdAt": "2024-06-13T14:47:42Z",
              "updatedAt": "2024-06-13T14:49:26Z"
            },
            {
              "originalPosition": 143,
              "body": "Will there be a spec for `Sum2` now that we've added a reference implementation?",
              "createdAt": "2024-06-13T14:48:30Z",
              "updatedAt": "2024-06-13T14:49:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5-I9-A",
          "commit": {
            "abbreviatedOid": "dea8cb6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-13T16:26:41Z",
          "updatedAt": "2024-06-13T16:26:41Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "Uggghh yes :)",
              "createdAt": "2024-06-13T16:26:41Z",
              "updatedAt": "2024-06-13T16:26:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5-JAhH",
          "commit": {
            "abbreviatedOid": "dea8cb6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-13T16:32:01Z",
          "updatedAt": "2024-06-13T16:32:01Z",
          "comments": [
            {
              "originalPosition": 228,
              "body": "That's not true for the aggregate result (it's true for each encoded measurement though)",
              "createdAt": "2024-06-13T16:32:01Z",
              "updatedAt": "2024-06-13T16:32:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5-JBC1",
          "commit": {
            "abbreviatedOid": "dea8cb6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-13T16:33:07Z",
          "updatedAt": "2024-06-13T16:33:07Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "for now `Sum2` is meant to exercise the new feature in tests. It may eventually replace the circuit in `Prio3Sum`, but that's a question for #306. ",
              "createdAt": "2024-06-13T16:33:07Z",
              "updatedAt": "2024-06-13T16:33:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5-JD-x",
          "commit": {
            "abbreviatedOid": "dea8cb6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-13T16:39:05Z",
          "updatedAt": "2024-06-13T16:39:05Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "Renamed to `SumOfRangeCheckedInputs`. This is probably overly verbose; we may consider renaming it to `Sum` as part of #306.",
              "createdAt": "2024-06-13T16:39:05Z",
              "updatedAt": "2024-06-13T16:39:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5-IgGY",
          "commit": {
            "abbreviatedOid": "a89c542"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-13T15:37:43Z",
          "updatedAt": "2024-06-13T17:21:03Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "nit: grammar\r\n```suggestion\r\nevaluate the polynomial at a random point. If each of the outputs is zero, then\r\n```",
              "createdAt": "2024-06-13T15:37:43Z",
              "updatedAt": "2024-06-13T17:21:03Z"
            },
            {
              "originalPosition": 23,
              "body": "I think this language is fine as-is, but we could simplify it by just saying that we take a random linear combination of the outputs.",
              "createdAt": "2024-06-13T15:38:57Z",
              "updatedAt": "2024-06-13T17:21:03Z"
            },
            {
              "originalPosition": 162,
              "body": "We don't need to change this one since it's a gadget, not a circuit.",
              "createdAt": "2024-06-13T16:39:53Z",
              "updatedAt": "2024-06-13T17:21:03Z"
            },
            {
              "originalPosition": 67,
              "body": "FWIW, this is inconsistent with how we reduce vectors inside various sectors, where we multiply by r, r^2, r^3, ..., instead of 1, r, r^2, ...\r\n\r\nIn this case it's fine as far as security is concerned, since there's no addition after this linear combination happens, so we don't need to worry about the term with coefficient 1 cancelling with anything. If we unified on starting with r, that could help implementers avoid mistakes by being consistent.",
              "createdAt": "2024-06-13T17:08:52Z",
              "updatedAt": "2024-06-13T17:21:03Z"
            },
            {
              "originalPosition": 234,
              "body": "I don't think this encoding and validity circuit achieve their goal. If the parameters are max_measurement=5, bits=3, offset=2, then the malicious encoding [p-1, 0, 0, 1] would produce a circuit output of [0, 0, 0, shares * 2 * shares_inv + p - 1 - 1] = [0, 0, 0, 0].\r\n\r\nWe could fix this if the encoded measurement length were self.bits * 2, and the encoding routine concatenated encode_into_bit_vector(x) and encode_into_vector(x + offset). I'm not sure whether we can do better.",
              "createdAt": "2024-06-13T17:19:41Z",
              "updatedAt": "2024-06-13T17:21:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5-J4tQ",
          "commit": {
            "abbreviatedOid": "a89c542"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-13T17:32:39Z",
          "updatedAt": "2024-06-13T17:53:10Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "You're right, that was sloppy.",
              "createdAt": "2024-06-13T17:32:39Z",
              "updatedAt": "2024-06-13T17:53:10Z"
            },
            {
              "originalPosition": 67,
              "body": "Good point. So the draft language in this PR is \"interpret the outputs as coefficients of a polynomial and evaluate that polynomial at a random point\", which is what's implemented here. I think this is a bit more intuitive than starting at $r^1=r$.\r\n\r\nHowever I agree we should be consistent. We could either:\r\n1. Start at $r^0=1$ everywhere (like this change does). This has the advantage of not being a breaking change.\r\n2. Start at $r^1=r$ everywhere (like the current circuits do). This would require a breaking change.\r\n\r\nI'm on the fence because I think 2 is more intuitive. On the other hand, breaking changes are expensive at this stage. On the the other _other_ hand, we're already considering a breaking change for Prio3Sum (#306).\r\n\r\nI don't want to make this change in draft-10, but I think we should consider doing it before RGLC. What do you think?\r\n\r\n",
              "createdAt": "2024-06-13T17:41:15Z",
              "updatedAt": "2024-06-13T17:53:10Z"
            },
            {
              "originalPosition": 234,
              "body": "Hmmm, perhaps you can try express this attack as a test? The circuit seems to detect this particular malformed input:\r\n```python\r\n    def test_sum_of_range_checked_inputs_malformed(self):\r\n        flp = FlpGeneric(SumOfRangeCheckedInputs(5))\r\n        self.assertEqual(flp.Valid.bits, 3)\r\n        self.assertEqual(flp.Valid.offset.as_unsigned(), 2)\r\n        test_flp_generic(flp, [\r\n            (\r\n                [\r\n                    flp.Field(flp.Field.MODULUS - 1),\r\n                    flp.Field(0),\r\n                    flp.Field(0),\r\n                    flp.Field(1),\r\n                ],\r\n                False,\r\n            ),\r\n        ])\r\n```\r\nThe output of the circuit is `[0, 0, 0, 18446744069414584318]`.\r\n\r\nAlternatively, is there a fundamental flaw I'm not seeing?",
              "createdAt": "2024-06-13T17:51:27Z",
              "updatedAt": "2024-06-13T17:53:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5-KCxy",
          "commit": {
            "abbreviatedOid": "dea8cb6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-13T17:56:01Z",
          "updatedAt": "2024-06-13T17:56:01Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "\"Linear combination\" is a bit more general than this I think? For instance, we could have done $r_1 x_1, + \\cdots r_n x_n$ where the $x_i$s are the outputs and the $r_i$s are independent, uniform random field elements.",
              "createdAt": "2024-06-13T17:56:01Z",
              "updatedAt": "2024-06-13T17:56:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5-KFor",
          "commit": {
            "abbreviatedOid": "a89c542"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-13T18:02:12Z",
          "updatedAt": "2024-06-13T18:02:13Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Do you prefer 1 or 2?",
              "createdAt": "2024-06-13T18:02:13Z",
              "updatedAt": "2024-06-13T18:02:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5-KRgi",
          "commit": {
            "abbreviatedOid": "a89c542"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-13T18:25:50Z",
          "updatedAt": "2024-06-13T18:25:50Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Changing the circuits using joint randomness to start with 1 makes me a little nervous. We'd have to carefully analyze circuit soundness if we did so, to make sure we don't end up with two monomials with the same powers of joint randomness values, and different input elements. This is doable, but having an extra r factor makes it easier to justify.\r\n\r\nI'm torn between the two options. On the one hand, starting with r has the benefit of inertia, and it's easier to convince oneself of circuit soundness, as discussed above. On the other hand, starting with 1 could be more intuitive to people reading the spec for the first time; in fact this was one of the compatibility bugs we worked through when initially implementing Prio3 in divviup-ts. Maybe if we start with r we should rephrase the prose description.",
              "createdAt": "2024-06-13T18:25:50Z",
              "updatedAt": "2024-06-13T18:25:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5-KVxO",
          "commit": {
            "abbreviatedOid": "a89c542"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-13T18:34:50Z",
          "updatedAt": "2024-06-13T18:34:50Z",
          "comments": [
            {
              "originalPosition": 234,
              "body": "Ah, I encoded the bitvector the wrong way in my head. This fails:\r\n\r\n```python\r\n    def test_sum_of_range_checked_inputs_malformed(self):\r\n        flp = FlpGeneric(SumOfRangeCheckedInputs(5))\r\n        self.assertEqual(flp.Valid.bits, 3)\r\n        self.assertEqual(flp.Valid.offset.as_unsigned(), 2)\r\n        test_flp_generic(flp, [\r\n            (\r\n                [\r\n                    flp.Field(flp.Field.MODULUS - 1),\r\n                    flp.Field(1),\r\n                    flp.Field(0),\r\n                    flp.Field(0),\r\n                ],\r\n                False,\r\n            ),\r\n        ])\r\n```",
              "createdAt": "2024-06-13T18:34:50Z",
              "updatedAt": "2024-06-13T18:34:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5-KbJH",
          "commit": {
            "abbreviatedOid": "a89c542"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-13T18:44:58Z",
          "updatedAt": "2024-06-13T18:44:58Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "> Maybe if we start with r we should rephrase the prose description.\r\n\r\nDefinitely.",
              "createdAt": "2024-06-13T18:44:58Z",
              "updatedAt": "2024-06-13T18:44:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5-Kdp0",
          "commit": {
            "abbreviatedOid": "a89c542"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-13T18:50:32Z",
          "updatedAt": "2024-06-13T18:50:32Z",
          "comments": [
            {
              "originalPosition": 234,
              "body": "Ah, I think I see what's going on here: we need to prevent the offset measurement from wrapping around the field modulus. Bit encoding it is sufficient. Really great catch :)",
              "createdAt": "2024-06-13T18:50:32Z",
              "updatedAt": "2024-06-13T18:50:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5-KhEJ",
          "commit": {
            "abbreviatedOid": "a89c542"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-13T18:55:49Z",
          "updatedAt": "2024-06-13T18:55:49Z",
          "comments": [
            {
              "originalPosition": 234,
              "body": "Fixed.",
              "createdAt": "2024-06-13T18:55:49Z",
              "updatedAt": "2024-06-13T18:55:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5-KkIU",
          "commit": {
            "abbreviatedOid": "a89c542"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-13T19:03:21Z",
          "updatedAt": "2024-06-13T19:03:22Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "> Changing the circuits using joint randomness to start with 1 makes me a little nervous. We'd have to carefully analyze circuit soundness if we did so, to make sure we don't end up with two monomials with the same powers of joint randomness values, and different input elements. This is doable, but having an extra r factor makes it easier to justify.\r\n\r\nCan you elaborate here? I don't know what you mean by \"monomial\".\r\n\r\nStarting with $1$: My intuition here is that if you have a polynomial $f$ of degree $n > 0$, then there are at most $n$ roots, i.e., points $x$ for which $f(x) = 0$. Hence  $Pr[ f(x) = 0 ] \\leq n / p$, where $p$ is the field modulus and where $x$ is uniform random.\r\n\r\nWhen we start with $r$ rather $1$, we're doing basically the same thing except that the polynomial we're evaluating is $f(x) \\cdot x$ which has degree $n+1$.",
              "createdAt": "2024-06-13T19:03:22Z",
              "updatedAt": "2024-06-13T19:03:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5-KxnX",
          "commit": {
            "abbreviatedOid": "a89c542"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-13T19:37:55Z",
          "updatedAt": "2024-06-13T19:37:55Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "\"Monomial\" here refers to the terms that get added together in the circuit output, after distributing multiplication and expanding everything.\r\n\r\nOff the top of my head, I think Histogram would be fine to switch to starting with 1. The output would look like bit_check_0 + bit_check_1 * joint_rand[0] + bit_check_2 * joint_rand[0] ** 2 + sum_check * joint_rand[1].\r\n\r\nStarting with r would be robust to things like forgetting joint_rand[1] in the second combination step, because there's already a power of joint_rand[0] on every term from one side, and none on the other side. Thus, we're safe from cancellation even before we multiply by joint_rand[1] and joint_rand[1] ** 2 respectively.",
              "createdAt": "2024-06-13T19:37:55Z",
              "updatedAt": "2024-06-13T19:37:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5-K1KD",
          "commit": {
            "abbreviatedOid": "a89c542"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-13T19:42:09Z",
          "updatedAt": "2024-06-13T19:42:09Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "So to your thinking, this is more about defense in depth? Always a good idea, I think. We want to establish patterns that are more likely to be secure when copy-pasted without thinking.",
              "createdAt": "2024-06-13T19:42:09Z",
              "updatedAt": "2024-06-13T19:42:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5-K4tX",
          "commit": {
            "abbreviatedOid": "c9d30b9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-13T19:51:36Z",
          "updatedAt": "2024-06-13T19:51:51Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Done! Please take a look.",
              "createdAt": "2024-06-13T19:51:37Z",
              "updatedAt": "2024-06-13T19:51:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5-MIAW",
          "commit": {
            "abbreviatedOid": "9ccfbed"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-13T22:06:41Z",
          "updatedAt": "2024-06-13T22:23:02Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "This could be simplified a little now\r\n```suggestion\r\n        encoded = []\r\n        encoded += self.Field.encode_into_bit_vector(\r\n            measurement,\r\n            self.bits\r\n        )\r\n        encoded += self.Field.encode_into_bit_vector(\r\n            measurement + self.offset.as_unsigned(),\r\n            self.bits\r\n        )\r\n        return encoded\r\n```",
              "createdAt": "2024-06-13T22:06:41Z",
              "updatedAt": "2024-06-13T22:23:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 356,
      "id": "PR_kwDOGKuqOc5x_1jI",
      "title": "Clarify network assumptions and limits on robustness",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/356",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "Closes #304.\r\n\r\nAdd the following clarifications to our thread model:\r\n\r\n- Privacy assumes the attacker does not control transmission of messages between the honest Clients and Aggregators.\r\n\r\n- Robustness assumes the attacker eavesdrops on the network but does not control transmission.\r\n\r\nThis implies that guaranteed output delivery and malicious robustness are not guaranteed.",
      "createdAt": "2024-06-10T15:56:08Z",
      "updatedAt": "2024-07-02T21:49:48Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "3ac03623c4680b28d1517af0a16dd513e1d0c310",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/304",
      "headRefOid": "dabc4daa3c5c6b6ad74678f37ebae32ef7b7fd11",
      "closedAt": "2024-06-10T23:56:20Z",
      "mergedAt": "2024-06-10T23:56:20Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "b59b382f1c4f220d36e0dfc0ab87b11477817798"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc59qIES",
          "commit": {
            "abbreviatedOid": "dabc4da"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-10T15:57:26Z",
          "updatedAt": "2024-06-10T15:57:26Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "@jimouris, @pratiksarkar93 let me know if you have a preferred reference for guaranteed output delivery.",
              "createdAt": "2024-06-10T15:57:26Z",
              "updatedAt": "2024-06-10T15:57:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc59qIi1",
          "commit": {
            "abbreviatedOid": "dabc4da"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-10T15:58:19Z",
          "updatedAt": "2024-06-10T15:58:19Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I decided against https://eprint.iacr.org/2020/300 because it's not published anywhere. However RFCs do have references to unpublished work, so we could include it if you think it's better.\r\n",
              "createdAt": "2024-06-10T15:58:19Z",
              "updatedAt": "2024-06-10T15:58:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc59qKYm",
          "commit": {
            "abbreviatedOid": "dabc4da"
          },
          "author": "jimouris",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Looks good to me, thanks for updating! Agreed that it's better to cite published papers.",
          "createdAt": "2024-06-10T16:01:54Z",
          "updatedAt": "2024-06-10T16:01:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc59sAQ-",
          "commit": {
            "abbreviatedOid": "dabc4da"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-10T20:25:28Z",
          "updatedAt": "2024-06-10T20:25:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 357,
      "id": "PR_kwDOGKuqOc5yJwcB",
      "title": "Enforce more type hints",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/357",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "Partially addresses #59.\r\n\r\nThis covers everything but Prio3 and Poplar1, which may turn out to be more complicated.",
      "createdAt": "2024-06-11T19:53:07Z",
      "updatedAt": "2024-07-02T21:49:47Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "b56f3b11aecf10bfe50e68b37d4b03adaee20da3",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/59/3",
      "headRefOid": "8e10a1b0636d16fc6f0a3c360bf9fd492744ae01",
      "closedAt": "2024-06-11T21:51:08Z",
      "mergedAt": "2024-06-11T21:51:08Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "6684fcca6995e080e10bf852d68f3671bc568dca"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc592jXp",
          "commit": {
            "abbreviatedOid": "8e10a1b"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-11T21:03:51Z",
          "updatedAt": "2024-06-11T21:03:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 358,
      "id": "PR_kwDOGKuqOc5yKmxw",
      "title": "Rename \"secure sketch\" to \"arithmetic sketch\" per {{BBCGGI23}}",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/358",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "Closes #335.\r\n\r\n{{BCCGI23}} generalizes the idea from {{BBCGGI21}} for checking one hotness of the output shares for Poplar. The generalization, called \"arithmetic sketching\", allows for checking richer properties of the output shares.",
      "createdAt": "2024-06-11T22:39:41Z",
      "updatedAt": "2024-07-02T21:39:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "e57208850eb83afee11993df689afbb3809c534d",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/335",
      "headRefOid": "39f04da407fa92da97fb6a8118e2fccdbdd5975c",
      "closedAt": "2024-06-18T14:13:18Z",
      "mergedAt": "2024-06-18T14:13:18Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "d4f5db6c60ef115291ee45aee45b03aeba489452"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5-MQKm",
          "commit": {
            "abbreviatedOid": "39f04da"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-13T22:43:27Z",
          "updatedAt": "2024-06-13T22:43:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 360,
      "id": "PR_kwDOGKuqOc5yRJdk",
      "title": "Poplar1: Rename preparation steps",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/360",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "draft-10"
      ],
      "body": "Henry Corrigan-Gibbs suggests the following names:\r\n- \"round one\" -> \"evaluate sketch\"\r\n- \"round two\" -> \"reveal sketch\"",
      "createdAt": "2024-06-12T17:31:47Z",
      "updatedAt": "2024-07-02T21:39:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d4f5db6c60ef115291ee45aee45b03aeba489452",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/poplar1-rename-prep-steps",
      "headRefOid": "6bb7d3629fb1f3d1dbda70b299f9d8e2ac9ecdea",
      "closedAt": "2024-06-20T16:21:21Z",
      "mergedAt": "2024-06-20T16:21:21Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "12054cd332d75f127b3484119024e70f47b89c34"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased.",
          "createdAt": "2024-06-20T16:19:33Z",
          "updatedAt": "2024-06-20T16:19:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5-MPGO",
          "commit": {
            "abbreviatedOid": "1521ff3"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-13T22:37:59Z",
          "updatedAt": "2024-06-13T22:37:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 362,
      "id": "PR_kwDOGKuqOc5yRVBs",
      "title": "Enforce type hints for vdaf_*.py and all remaining tests",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/362",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "Closes #59.",
      "createdAt": "2024-06-12T17:56:24Z",
      "updatedAt": "2024-06-26T15:22:24Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "e57208850eb83afee11993df689afbb3809c534d",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/59/4",
      "headRefOid": "d25739d0865b554e68bf1fabfb93ff256cd3f128",
      "closedAt": "2024-06-12T21:21:55Z",
      "mergedAt": "2024-06-12T21:21:55Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "f028280737b6167962dce46a30bf831705400ef9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5-BJ_w",
          "commit": {
            "abbreviatedOid": "d25739d"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-12T21:14:27Z",
          "updatedAt": "2024-06-12T21:18:18Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "FYI `issubclass()` is the class-level counterpart of `isinstance()`.",
              "createdAt": "2024-06-12T21:14:27Z",
              "updatedAt": "2024-06-12T21:18:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 363,
      "id": "PR_kwDOGKuqOc5zGHTW",
      "title": "Replace class factories with OOP inheritance",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/363",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "This PR is going to replace class factories throughout the codebase with conventional OOP inheritance and classes defined at the top level. This will make type checking and other static analysis work better, and help avoid bugs around mutating class attributes on the wrong class in factory methods. So far I've rewritten `daf.py`, and improved the type hints in `field.py`, so that __add__ returns `Self` instead of `Field`. `Self` is a special generic type variable, so this more precise signature tells us we get a field element of the same type back, not a field element from possibly any field. I needed this improvement after adding hints to more signatures in `TestDaf`, particularly `aggregate()`.\r\n\r\nRelated to #361.",
      "createdAt": "2024-06-20T16:38:26Z",
      "updatedAt": "2024-07-02T19:24:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "39fb4753a55bbc33a8da8c662dba8ed99f50e6ff",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/poc-oop",
      "headRefOid": "f56c30ddedba7c839c72598ae5cc19ae271cfbd9",
      "closedAt": "2024-07-02T19:17:21Z",
      "mergedAt": "2024-07-02T19:17:21Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "d762500131e8906ccaea4fb3969b94a4e17aee2b"
      },
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "The type hint system does not support associated types, but I am able to get just as strong type checking by defining a lot of generic type parameters on abstract classes that define interfaces, and then filling in those type parameters on concrete subclasses. I get errors from mypy if an overridden method has a signature incompatible with that defined by the superclass.",
          "createdAt": "2024-06-21T21:20:46Z",
          "updatedAt": "2024-06-21T21:24:03Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Alright, I've done everything but update the excerpts in the markdown file at this point. I'll hold off on that until the changes in the proof of concept are settled.",
          "createdAt": "2024-06-27T14:43:01Z",
          "updatedAt": "2024-06-27T14:43:01Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "This closes #233 as well, since it replaces various class arguments named after classes with `self` arguments instead. I checked this with `sage -python -m pylint --disable=all --enable redefined-outer-name *.py tests/*.py`.",
          "createdAt": "2024-06-27T22:17:15Z",
          "updatedAt": "2024-06-27T22:17:15Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> This closes #233 as well, since it replaces various class arguments named after classes with `self` arguments instead. I checked this with `sage -python -m pylint --disable=all --enable redefined-outer-name *.py tests/*.py`.\r\n\r\nWorth adding this check to CI I think.",
          "createdAt": "2024-06-27T23:11:03Z",
          "updatedAt": "2024-06-27T23:11:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5_jf02",
          "commit": {
            "abbreviatedOid": "b0d0d79"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-25T22:48:57Z",
          "updatedAt": "2024-06-25T23:04:32Z",
          "comments": [
            {
              "originalPosition": 203,
              "body": "FYI I removed this TODO because the idea referenced is only applicable if the output field is very small, which doesn't align with our use case. This is essentially the dual of the 'stealing' we do for control bits in `extend()` already, but applied to `convert()` instead. We just don't have enough space between the PRG output size and the desired security parameter to fit a 64-bit field element, let alone a 255-bit field element.",
              "createdAt": "2024-06-25T22:48:57Z",
              "updatedAt": "2024-06-25T23:04:32Z"
            },
            {
              "originalPosition": 43,
              "body": "FYI, I moved this to a separate file because I needed to reference `Valid` in a type hint inside `Flp`, but importing it from `flp_generic.py` would have set up an import cycle. I figured a separate module for arithmetic circuit basics would make sense.",
              "createdAt": "2024-06-25T22:54:27Z",
              "updatedAt": "2024-06-25T23:04:32Z"
            },
            {
              "originalPosition": 83,
              "body": "This `cast()` function shows up a lot in this file. It's a type hint escape hatch that acts like the identity function at runtime, but tells static analysis tools to ignore the type of the input and use the provided type on the output value. This is necessary primarily because we have many unions of Field64 and Field255, or instances of those classes, or lists thereof. Without the casts, we would get warnings on arithmetic between objects of such union types, because `mypy`'s analysis conservatively assumes that we could have objects of different field classes on either side (though that doesn't happen in practice). I plan to cut out the cast calls in code excerpts in the specification, and add comments here regarding that.",
              "createdAt": "2024-06-25T22:59:25Z",
              "updatedAt": "2024-06-25T23:04:32Z"
            },
            {
              "originalPosition": 283,
              "body": "Type checking trophy case entry!",
              "createdAt": "2024-06-25T23:00:14Z",
              "updatedAt": "2024-06-25T23:04:32Z"
            },
            {
              "originalPosition": 110,
              "body": "Type checking caught that this was out of date after other changes",
              "createdAt": "2024-06-25T23:01:09Z",
              "updatedAt": "2024-06-25T23:04:32Z"
            },
            {
              "originalPosition": 90,
              "body": "This was incorrect, as we actually use a 3-tuple, not nested 2-tuples",
              "createdAt": "2024-06-25T23:01:49Z",
              "updatedAt": "2024-06-25T23:04:32Z"
            },
            {
              "originalPosition": 2,
              "body": "This setting was important, I learned that `mypy` will by default not do any type checking in the bodies of functions/methods with no type hints in their signature. Setting this flushed a lot of little things out.",
              "createdAt": "2024-06-25T23:03:11Z",
              "updatedAt": "2024-06-25T23:04:32Z"
            },
            {
              "originalPosition": 348,
              "body": "`mypy` does not like it when we reuse one variable name in a method in two disjoint regions with different types, so I've split uses of `outbound` as appropriate here, and done similar elsewhere.",
              "createdAt": "2024-06-25T23:04:22Z",
              "updatedAt": "2024-06-25T23:04:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5_rW3J",
          "commit": {
            "abbreviatedOid": "b0d0d79"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-26T14:32:48Z",
          "updatedAt": "2024-06-26T14:32:48Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Thinking about this some more, `Flp` doesn't need a `valid: Valid` attribute, `FlpGeneric` does, so I can unwind this particular change.",
              "createdAt": "2024-06-26T14:32:48Z",
              "updatedAt": "2024-06-26T14:32:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5_7Yxb",
          "commit": {
            "abbreviatedOid": "a538b43"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Wow. I started working on the generic parameter route while working on #59 and gave up. I can appreciate how much work this was. _Thank you_: I think we're way better off. This could also provide a template for future CFRG docs, e.g., the PINE or Mastic drafts.\r\n\r\nJust a few comments/questions inline.",
          "createdAt": "2024-06-27T18:55:01Z",
          "updatedAt": "2024-06-27T21:13:24Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "where do we use this on `bytes`?",
              "createdAt": "2024-06-27T18:59:53Z",
              "updatedAt": "2024-06-27T21:13:24Z"
            },
            {
              "originalPosition": 28,
              "body": "\r\n```suggestion\r\n    A Distributed Aggregation Function (DAF).\r\n```",
              "createdAt": "2024-06-27T19:01:12Z",
              "updatedAt": "2024-06-27T21:13:24Z"
            },
            {
              "originalPosition": 45,
              "body": "Whooaaa I didn't know you could refer to the class as `Self`!",
              "createdAt": "2024-06-27T19:09:05Z",
              "updatedAt": "2024-06-27T21:13:24Z"
            },
            {
              "originalPosition": 266,
              "body": "Why go with `enumerate()` here? This is a little harder to read IMO.\r\nHere and elsewhere.",
              "createdAt": "2024-06-27T19:12:19Z",
              "updatedAt": "2024-06-27T21:13:24Z"
            },
            {
              "originalPosition": 17,
              "body": "Does mypy enforce this?",
              "createdAt": "2024-06-27T19:16:36Z",
              "updatedAt": "2024-06-27T21:13:24Z"
            },
            {
              "originalPosition": 271,
              "body": "```suggestion\r\n        raise NotImplementedError(\"QueryGadget does not need to implement eval_poly()\")\r\n```",
              "createdAt": "2024-06-27T19:21:25Z",
              "updatedAt": "2024-06-27T21:13:24Z"
            },
            {
              "originalPosition": 341,
              "body": "Why is this `cast()` needed? Maybe add a comment.",
              "createdAt": "2024-06-27T19:23:07Z",
              "updatedAt": "2024-06-27T21:13:24Z"
            },
            {
              "originalPosition": 433,
              "body": "`x` and `y` correspond to variables named in the draft: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf#section-7.3.3.2-2.5.1\r\n\r\nI'd like to keep them.\r\n",
              "createdAt": "2024-06-27T19:25:54Z",
              "updatedAt": "2024-06-27T21:13:24Z"
            },
            {
              "originalPosition": 805,
              "body": "```suggestion\r\n            int,        # Measurement, `range(length)`\r\n            list[int],  # AggResult\r\n            Field128,\r\n```",
              "createdAt": "2024-06-27T19:31:27Z",
              "updatedAt": "2024-06-27T21:13:24Z"
            },
            {
              "originalPosition": 114,
              "body": "I don't think you need the generic parameters here.\r\n```suggestion\r\n             binder: bytes) -> Output:\r\n```",
              "createdAt": "2024-06-27T19:39:32Z",
              "updatedAt": "2024-06-27T21:13:24Z"
            },
            {
              "originalPosition": 150,
              "body": "Writing Go for years makes me think this is more readable. Feel free to disregard if you don't agree.\r\n```suggestion\r\n        return self.field_leaf\r\n```",
              "createdAt": "2024-06-27T19:41:06Z",
              "updatedAt": "2024-06-27T21:13:24Z"
            },
            {
              "originalPosition": 11,
              "body": "`f` -> `field` for consistency with above.\r\n```suggestion\r\ndef test_xof(cls: type[Xof], field: type[Field], expanded_len: int) -> None:\r\n```",
              "createdAt": "2024-06-27T20:00:08Z",
              "updatedAt": "2024-06-27T21:13:24Z"
            },
            {
              "originalPosition": 15,
              "body": "WDYTA about declaring these type parameters in one file so that we don't have to keep re-declaring them in different files?",
              "createdAt": "2024-06-27T20:01:31Z",
              "updatedAt": "2024-06-27T21:13:24Z"
            },
            {
              "originalPosition": 26,
              "body": "What is `list[Any]` refer to?",
              "createdAt": "2024-06-27T20:02:14Z",
              "updatedAt": "2024-06-27T21:13:24Z"
            },
            {
              "originalPosition": 442,
              "body": "Consistency with `out_share` below\r\n```suggestion\r\n        outbound_out_shares = []\r\n```",
              "createdAt": "2024-06-27T20:05:50Z",
              "updatedAt": "2024-06-27T21:13:24Z"
            },
            {
              "originalPosition": 413,
              "body": "This seems to be a breaking change. It actually seems reasonable to me, and in any case I don't\r\n\r\nDigging through git history, this goes back to the initial version of Popolar1 (a88e2cef):\r\n```python\r\n        elif step == b'sketch round 1' and opt_sketch != None:\r\n            prev_sketch = Field.decode_vec(opt_sketch)\r\n            if len(prev_sketch) == 0:\r\n                prev_sketch = Field.zeros(3)\r\n            elif len(prev_sketch) != 3:\r\n                raise ERR_INPUT # prep message malformed\r\n```\r\n\r\nI suppose this behavior made sense because we treated `b''` as a synonym for the all-zero string:\r\n```python\r\n        if sketch == Field.zeros(len(sketch)):\r\n            # In order to reduce communication overhead, let the\r\n            # empty string denote the zero vector of the required\r\n            # length.\r\n            return b''\r\n```\r\n\r\nHowever, we have sense moved away from operating on byte strings and operating on typed data instead. The type is now `Optional[FieldVec]`, and we only consume `None` on the \"reveal sketch\" step.\r\n\r\nI think we should take this change, but we may need to treat this as breaking and bump the DST for Poplar1.",
              "createdAt": "2024-06-27T20:49:50Z",
              "updatedAt": "2024-06-27T21:13:24Z"
            },
            {
              "originalPosition": 526,
              "body": "FWIW, I think we can probably live with keeping the `cast()`s in the draft. We'd just need to explain somewhere in pros what it means.",
              "createdAt": "2024-06-27T20:53:03Z",
              "updatedAt": "2024-06-27T21:13:24Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n        bytes,  # measurement share seed\r\n        bytes,  # proof share seed\r\n```",
              "createdAt": "2024-06-27T20:59:11Z",
              "updatedAt": "2024-06-27T21:13:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6ACwEc",
          "commit": {
            "abbreviatedOid": "10f311d"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-28T14:34:24Z",
          "updatedAt": "2024-06-28T16:40:39Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "There's one case in the Poplar1 shard method, splitting off the IDPF randomness.",
              "createdAt": "2024-06-28T14:34:24Z",
              "updatedAt": "2024-06-28T16:40:39Z"
            },
            {
              "originalPosition": 433,
              "body": "I ran into problems because x was used with a different type further up in the method. I can rename that variable instead.",
              "createdAt": "2024-06-28T15:08:49Z",
              "updatedAt": "2024-06-28T16:40:39Z"
            },
            {
              "originalPosition": 17,
              "body": "Yes, insofar as it requires that types subclass the bound when it is used, and it allows you to use methods and attributes the bound provides.",
              "createdAt": "2024-06-28T15:24:29Z",
              "updatedAt": "2024-06-28T16:40:39Z"
            },
            {
              "originalPosition": 15,
              "body": "It seems like this would be non-idiomatic, from what I've seen. Some sources prefix their TypeVar variables with one underscore, to make them effectively module-private (through mangling). I also worry whether various static analysis tools could handle chasing imports to locate type variable definitions. Plus, different files have three different bounds for type variables named `F`.\r\n\r\nType variables have unintuitive behavior, because whenever they get bound in a class or function definition, each binding is entirely separate from the others. Thus, there's nothing to be saved but line count by sharing them, though I think having type variable declarations close to uses outweighs this.",
              "createdAt": "2024-06-28T15:59:05Z",
              "updatedAt": "2024-06-28T16:40:39Z"
            },
            {
              "originalPosition": 413,
              "body": "Hmm, I'll back this out and put a current_field() call back for now, (I don't like the error message I used anymore) but we should probably follow up on this in #366. I don't think we would expect the first prepare message to be three zeros. Now, `prep_shares_to_prep()` only compresses the second round message, when it is one zero.",
              "createdAt": "2024-06-28T16:25:19Z",
              "updatedAt": "2024-06-28T16:40:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6AEXQm",
          "commit": {
            "abbreviatedOid": "a538b43"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-28T17:42:59Z",
          "updatedAt": "2024-06-28T17:43:00Z",
          "comments": [
            {
              "originalPosition": 433,
              "body": "In that case, feel free to keep your code. Perhaps add a comment clarifying how this connects to the text in the doc.",
              "createdAt": "2024-06-28T17:43:00Z",
              "updatedAt": "2024-06-28T17:43:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6AEX-w",
          "commit": {
            "abbreviatedOid": "a538b43"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-28T17:44:49Z",
          "updatedAt": "2024-06-28T17:44:49Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "FWIW as of python 3.12 we get to do stuff like this:\r\n```python\r\nclass Foo[Measurement]:\r\n    ...\r\n```\r\nHowever the lateste version of sage uses an older version of python.",
              "createdAt": "2024-06-28T17:44:49Z",
              "updatedAt": "2024-06-28T17:44:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6AEYjp",
          "commit": {
            "abbreviatedOid": "a538b43"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-28T17:46:04Z",
          "updatedAt": "2024-06-28T17:46:04Z",
          "comments": [
            {
              "originalPosition": 413,
              "body": "Agreed this is low probability and probably negligible, but my intuition is that it could weaken the security bound somewhat. I could be wrong.",
              "createdAt": "2024-06-28T17:46:04Z",
              "updatedAt": "2024-06-28T17:46:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6AEZTq",
          "commit": {
            "abbreviatedOid": "b0d0d79"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-28T17:48:20Z",
          "updatedAt": "2024-06-28T17:48:20Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I appreciate the thorough analysis here. It may be useful to summarize this somewhere in a comment.",
              "createdAt": "2024-06-28T17:48:20Z",
              "updatedAt": "2024-06-28T17:48:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6AEcr3",
          "commit": {
            "abbreviatedOid": "7c04c58"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-28T17:57:03Z",
          "updatedAt": "2024-06-28T17:57:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc6AEvCx",
          "commit": {
            "abbreviatedOid": "a538b43"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-28T18:42:17Z",
          "updatedAt": "2024-06-28T18:42:17Z",
          "comments": [
            {
              "originalPosition": 433,
              "body": "Fixed in 7c04c58193cb09e29dd27302deb9c7d4c7e1cf11, this leaves a smaller and nicer diff, keeping x and y during the gadget polynomial query.",
              "createdAt": "2024-06-28T18:42:17Z",
              "updatedAt": "2024-06-28T18:42:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6AGPZB",
          "commit": {
            "abbreviatedOid": "d470f0b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-28T23:57:02Z",
          "updatedAt": "2024-06-29T00:00:33Z",
          "comments": [
            {
              "originalPosition": 1740,
              "body": "?\r\n\r\nLikewise elsewhere (grep for `\\.Field')\r\n```suggestion\r\n| `Field`          | `valid.field`       |\r\n```",
              "createdAt": "2024-06-28T23:57:02Z",
              "updatedAt": "2024-06-29T00:00:33Z"
            },
            {
              "originalPosition": 1760,
              "body": "Perhaps clarify in the conventions section that `F` is sometimes used as a generic parameter for a `Field`.",
              "createdAt": "2024-06-28T23:57:44Z",
              "updatedAt": "2024-06-29T00:00:33Z"
            },
            {
              "originalPosition": 2053,
              "body": "Do we need to define this in prose?\r\n\r\nPreviously we were leaving this out, though I don't think we've been consistent.\r\n\r\nIf you decide to remove it, then annotate it with `# REMOVE ME` like we do for other things.",
              "createdAt": "2024-06-28T23:58:18Z",
              "updatedAt": "2024-06-29T00:00:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6ASqus",
          "commit": {
            "abbreviatedOid": "d470f0b"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-01T23:08:54Z",
          "updatedAt": "2024-07-01T23:08:54Z",
          "comments": [
            {
              "originalPosition": 2053,
              "body": "I also added the definition of the method to the figure \"Derived methods for validity circuits\"",
              "createdAt": "2024-07-01T23:08:54Z",
              "updatedAt": "2024-07-01T23:08:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6AbXB3",
          "commit": {
            "abbreviatedOid": "f56c30d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-02T19:14:04Z",
          "updatedAt": "2024-07-02T19:14:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 367,
      "id": "PR_kwDOGKuqOc50PLHH",
      "title": "Tidy up artwork and sourcecode types",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/367",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "This closes #364. Stacked on #363.",
      "createdAt": "2024-07-02T19:10:12Z",
      "updatedAt": "2024-07-02T19:24:26Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d762500131e8906ccaea4fb3969b94a4e17aee2b",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/code-fences",
      "headRefOid": "766dfde5be14f2d150e1b4fade5fbe499aa7ea4f",
      "closedAt": "2024-07-02T19:19:45Z",
      "mergedAt": "2024-07-02T19:19:45Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "cf92a2a8a8636a93ccfb19c3cdca057a3d5729f6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6AbWlu",
          "commit": {
            "abbreviatedOid": "1616d4d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-02T19:12:49Z",
          "updatedAt": "2024-07-02T19:12:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 368,
      "id": "PR_kwDOGKuqOc50Pc2c",
      "title": "Check vector lengths when adding/subtracting",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/368",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "draft-10"
      ],
      "body": "This adds some missing checks that vectors are of the same length in `vec_add()` and `vec_sub()`. The prose introducing these claims that \"an exception is raised by each function if the operands are not the same length\", but that wasn't true yet. `zip()` stops yielding when any input iterator does, so we need to explicitly check for this case.\r\n\r\n```python\r\n>>> list(zip([1], ['a', 'b']))\r\n[(1, 'a')]\r\n```",
      "createdAt": "2024-07-02T19:50:47Z",
      "updatedAt": "2024-07-02T21:31:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "cf92a2a8a8636a93ccfb19c3cdca057a3d5729f6",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/vec-ops-length-check",
      "headRefOid": "964a1a2cf6e4c70854871ac55a631fe0008c348c",
      "closedAt": "2024-07-02T21:31:49Z",
      "mergedAt": "2024-07-02T21:31:49Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "a08239cb5f5a155e2f532e7483b5869e0e273fb8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6AcJQ3",
          "commit": {
            "abbreviatedOid": "964a1a2"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-02T20:57:47Z",
          "updatedAt": "2024-07-02T20:57:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 369,
      "id": "PR_kwDOGKuqOc50PedS",
      "title": "Remove HTML comment about Prio+",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/369",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "This text is superseded by the last paragraph of {{sec-vdaf-prepare}}, which says,\r\n\r\n> The preparation-state update accomplishes two tasks: recovery of output shares\r\n> from the input shares and ensuring that the recovered output shares are valid.\r\n> The abstraction boundary is drawn so that an Aggregator only recovers an output\r\n> share if it is deemed valid (at least, based on the Aggregator's view of the\r\n> protocol). Another way to draw this boundary would be to have the Aggregators\r\n> recover output shares first, then verify that they are valid. However, this\r\n> would allow the possibility of misusing the API by, say, aggregating an invalid\r\n> output share. Moreover, in protocols like Prio+ {{AGJOP21}} based on oblivious\r\n> transfer, it is necessary for the Aggregators to interact in order to recover\r\n> aggregatable output shares at all.",
      "createdAt": "2024-07-02T19:54:40Z",
      "updatedAt": "2024-07-02T21:34:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "cf92a2a8a8636a93ccfb19c3cdca057a3d5729f6",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/remove-comment",
      "headRefOid": "b2bda4dd3a056b697cf985fa2c4012aa4240257e",
      "closedAt": "2024-07-02T21:34:41Z",
      "mergedAt": "2024-07-02T21:34:41Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "737a40d46c7af8892d4e8db64a7ac82515b922c5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6AcPKK",
          "commit": {
            "abbreviatedOid": "b2bda4d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-02T21:11:32Z",
          "updatedAt": "2024-07-02T21:11:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 370,
      "id": "PR_kwDOGKuqOc50Pgf7",
      "title": "Rename non-test files in tests directory",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/370",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "poc",
        "draft-10"
      ],
      "body": "This renames two files under the tests subdirectory that provided common utilities to multiple unit test files. This is partly for clarity, and partly to work around issues my IDE was having resolving module imports correctly.",
      "createdAt": "2024-07-02T19:59:43Z",
      "updatedAt": "2024-07-02T21:32:36Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "cf92a2a8a8636a93ccfb19c3cdca057a3d5729f6",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/rename-test-helper-files",
      "headRefOid": "a51d4300e962b0c5050cdba611908072ba6bd6c2",
      "closedAt": "2024-07-02T21:32:33Z",
      "mergedAt": "2024-07-02T21:32:33Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "92ee09b1409405b279c6e5f05ad8715e0f29d79a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6AcPfM",
          "commit": {
            "abbreviatedOid": "a51d430"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-02T21:12:19Z",
          "updatedAt": "2024-07-02T21:12:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 371,
      "id": "PR_kwDOGKuqOc50P1f9",
      "title": "Fix remaining line length warnings",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/371",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "draft-10"
      ],
      "body": "This wraps the remaining long lines in the document that were causing warnings.",
      "createdAt": "2024-07-02T20:52:30Z",
      "updatedAt": "2024-07-02T21:38:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "cf92a2a8a8636a93ccfb19c3cdca057a3d5729f6",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/other-line-length-warnings",
      "headRefOid": "333bff055d3c8528c335ac0de67909de4cd00857",
      "closedAt": "2024-07-02T21:38:27Z",
      "mergedAt": "2024-07-02T21:38:27Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "ecaf743825c0f8b6d2e171731284ff489ffc7808"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6AcP55",
          "commit": {
            "abbreviatedOid": "333bff0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-02T21:13:20Z",
          "updatedAt": "2024-07-02T21:13:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 372,
      "id": "PR_kwDOGKuqOc50P45I",
      "title": "Set submission type to IRTF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/372",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "This sets the submission type to IRTF. See https://datatracker.ietf.org/doc/html/rfc7991#appendix-A.2 for its definition. Note that `kramdown-rfc2629` supports this as one of three [aliases](https://github.com/cabo/kramdown-rfc/blob/6aef289cc6f39e1c851f92efbc69c4ac917c0537/data/kramdown-rfc2629.erb#L32) to set the `submissionType` attribute on the `<rfc>` tag. This clears up the following warning:\r\n\r\n> Warning: Expected a valid submissionType (stream) setting, one of IETF, IAB, IRTF, independent, editorial, but found None.  Will use 'IETF'",
      "createdAt": "2024-07-02T21:02:57Z",
      "updatedAt": "2024-07-02T21:33:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "cf92a2a8a8636a93ccfb19c3cdca057a3d5729f6",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/set-submission-type",
      "headRefOid": "d65abbc10d65f30b3b12f0f21e6af20cb3976857",
      "closedAt": "2024-07-02T21:33:48Z",
      "mergedAt": "2024-07-02T21:33:48Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "a5914a80ae0d3355eec3b1aeba645c7b78ecbeea"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6AcQSW",
          "commit": {
            "abbreviatedOid": "d65abbc"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-02T21:14:14Z",
          "updatedAt": "2024-07-02T21:14:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 373,
      "id": "PR_kwDOGKuqOc50P5hH",
      "title": "Use parentheses around notes to RFC editor",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/373",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "Using square brackets around these notes causes Markdown issues. Rather than try to escape the brackets, I decided to use parentheses instead, because a quick Google search suggests parentheses are more common for these sorts of remarks.",
      "createdAt": "2024-07-02T21:04:33Z",
      "updatedAt": "2024-07-03T18:38:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "cf92a2a8a8636a93ccfb19c3cdca057a3d5729f6",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/note-to-editor-parens",
      "headRefOid": "498eb36cb95856c575cbb4692cbaa9b328588ce0",
      "closedAt": "2024-07-03T18:38:34Z",
      "mergedAt": "2024-07-03T18:38:34Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "024de7c6a74a08b3f22316a7725f0faf924a4b88"
      },
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "All the existing `TODO`s and `NOTE`s just use blockquotes, so I think they're good as-is.",
          "createdAt": "2024-07-03T13:53:31Z",
          "updatedAt": "2024-07-03T13:53:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6AcQyK",
          "commit": {
            "abbreviatedOid": "498eb36"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Completness: There are may also be inlined TODOs or NOTEs for which we'd want to apply the same change.",
          "createdAt": "2024-07-02T21:15:18Z",
          "updatedAt": "2024-07-02T21:15:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 374,
      "id": "PR_kwDOGKuqOc50QFQT",
      "title": "Poplar1: On first prep round, handle none as error",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/374",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "Closes #366.\r\n\r\nThe prep message type for Poplar1 is `Optional[FieldVec]`.\u00a0The `None` variant is intended to be used in place of `[field(0)]`. This is the message we expect on the second round when the input is valid, so this saves a little bit of bandwidth.\r\n\r\nWe also use it in place of the length-3 vector of zeros. That is, if an Aggregator gets `None` in the first round, it will replace the message with `[field(0)] * 3` and proceed as if this is the message it received. However, in an honest execution of the protocol, the Aggregator will never receive `None` in the first round.\r\n\r\nThis commit modifies the behavior of `prep_next()` by treating this explicitly as an error. This change doesn't seem strictly necessary, as the all-zero vector is likely to be rejected, and in any case an attacker can always send the all-zero vector and trigger the same behavior. Nevertheless, it is security conservative as it eliminates a case we didn't intend.",
      "createdAt": "2024-07-02T21:42:41Z",
      "updatedAt": "2024-07-03T16:36:58Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "ecaf743825c0f8b6d2e171731284ff489ffc7808",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/366",
      "headRefOid": "fd11c5b1473f79f8aff22f357592824b47ea5a1f",
      "closedAt": "2024-07-03T16:36:58Z",
      "mergedAt": "2024-07-03T16:36:58Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "e0c06221fbee594b02334a30d1b23b24f7fe5115"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6AcaZ1",
          "commit": {
            "abbreviatedOid": "fd11c5b"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-02T21:45:47Z",
          "updatedAt": "2024-07-02T21:45:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 375,
      "id": "PR_kwDOGKuqOc50QRKH",
      "title": "Rename FlpGeneric to FlpBBCGGI19 and IdpfPoplar to IdpfBBCGGI21",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/375",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "draft-10"
      ],
      "body": "The rationale has two parts.\r\n\r\nFirst, the names follow different conventions: \"Generic\" in the sense that it applies to any language that can be expressed as an arithmetic circuit, and \"Poplar\" simply because it was the IDPF from the Poplar paper. This is a bit awkward.\r\n\r\nSecond, neither scheme is named, so the names that apply best are the papers in which the schemes were described (BBCGGI19 and BBCGGI21 respectively).\r\n\r\nThe new names only appear in the reference code. IN the document we just refer to them as the \"FLP of {{BBCGGI19}}\" and IDPF of {{BBCGGI21}} respectively.",
      "createdAt": "2024-07-02T22:34:55Z",
      "updatedAt": "2024-07-03T14:55:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "ecaf743825c0f8b6d2e171731284ff489ffc7808",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/rename-flp-idpf",
      "headRefOid": "3754c21a974d984293e1b8cc6571aea90c8d720e",
      "closedAt": "2024-07-03T14:55:27Z",
      "mergedAt": "2024-07-03T14:55:27Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "532583d71e733fb463d29428f9dc8bad3d282365"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6AirYW",
          "commit": {
            "abbreviatedOid": "fc1bb52"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-03T14:12:31Z",
          "updatedAt": "2024-07-03T14:28:46Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "nit: rename this too",
              "createdAt": "2024-07-03T14:12:32Z",
              "updatedAt": "2024-07-03T14:28:46Z"
            },
            {
              "originalPosition": 11,
              "body": "We should change `test_vec_name` too, below",
              "createdAt": "2024-07-03T14:13:13Z",
              "updatedAt": "2024-07-03T14:28:47Z"
            },
            {
              "originalPosition": 37,
              "body": "nit: This got rewrapped wrong\r\n```suggestion\r\n        # with an IDPF, we require the binder to be a random nonce.\r\n```",
              "createdAt": "2024-07-03T14:23:42Z",
              "updatedAt": "2024-07-03T14:28:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 376,
      "id": "PR_kwDOGKuqOc50QmCI",
      "title": "Prio3: Move field spec from FLP to VDAF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/376",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "Closes #328.\r\n\r\nIf one wants to use a different field for a circuit other than the default, they must define a subclass with the `field` parameter overwritten. This is a bit clunky, and the need to configure the field is common enough that it's worth reducing the friction.\r\n\r\nThis commit moves the specification of the field from the validity circuit up to the VDAF. Accordingly, add a table to each subsection of {{prio3-instantiations}} that defines the circuit, field, number of proofs, and XOF.\r\n\r\nOther changes:\r\n\r\n- Align the FLP syntax with the poc: use `F` as the generic field parameter rather than `Field`.\r\n\r\n- In the specification of `FlpBBCGGI19`, use `field` instead of `Field` as a reference to the field object.",
      "createdAt": "2024-07-03T00:02:50Z",
      "updatedAt": "2024-07-03T18:16:56Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "e0c06221fbee594b02334a30d1b23b24f7fe5115",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/328",
      "headRefOid": "218a4c6b252e5cbf2596bf7839f0a65d2f28f2ad",
      "closedAt": "2024-07-03T18:16:56Z",
      "mergedAt": "2024-07-03T18:16:56Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "8f31e832525426071780f18ebc2c0fb649bb2061"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6AkM5t",
          "commit": {
            "abbreviatedOid": "d1ca9d1"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-03T17:10:58Z",
          "updatedAt": "2024-07-03T17:15:58Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "I think we should mention the requirement that the field be FFT-friendly, and link to the relevant section, since the link was removed from the validity circuit's table of parameters.",
              "createdAt": "2024-07-03T17:10:58Z",
              "updatedAt": "2024-07-03T17:15:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 377,
      "id": "PR_kwDOGKuqOc50uSOM",
      "title": "Update change log",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/377",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-10"
      ],
      "body": "",
      "createdAt": "2024-07-08T17:15:23Z",
      "updatedAt": "2024-07-08T18:04:31Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "024de7c6a74a08b3f22316a7725f0faf924a4b88",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/vdaf-10",
      "headRefOid": "6913d14e4f93c215f8ed0fdb6bea397bbd61eda7",
      "closedAt": "2024-07-08T18:04:30Z",
      "mergedAt": "2024-07-08T18:04:30Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "610eab2a4657d49dbc6e0b6a69236be1a3160060"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6A-vqT",
          "commit": {
            "abbreviatedOid": "6913d14"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-08T17:16:05Z",
          "updatedAt": "2024-07-08T17:16:05Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "The new names names don't actually appear in the draft, ",
              "createdAt": "2024-07-08T17:16:05Z",
              "updatedAt": "2024-07-08T17:16:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6A_Edc",
          "commit": {
            "abbreviatedOid": "6913d14"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-08T18:01:56Z",
          "updatedAt": "2024-07-08T18:01:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 378,
      "id": "PR_kwDOGKuqOc50wtZx",
      "title": "Fix copy-pasta in Prio3 variant tables",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/378",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "draft-11"
      ],
      "body": "`Sum` was copied into the `SumVec`, `Histogram`, and `MulithotCountVec` sections.",
      "createdAt": "2024-07-09T00:53:32Z",
      "updatedAt": "2024-07-09T01:20:24Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "610eab2a4657d49dbc6e0b6a69236be1a3160060",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/edit",
      "headRefOid": "e558882b43c74e679cfbd63d3ef98061fd67c0ee",
      "closedAt": "2024-07-09T01:20:24Z",
      "mergedAt": "2024-07-09T01:20:24Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "80dfdd328df5a629f7095e038300a77fe15d9e91"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6BBqma",
          "commit": {
            "abbreviatedOid": "b028127"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-09T00:57:40Z",
          "updatedAt": "2024-07-09T00:58:10Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "One more typo\n```suggestion\n| `Valid`           | `MultihotCountVec(Field128, length, max_weight, chunk_lengh)` (this section) |\n```",
              "createdAt": "2024-07-09T00:57:40Z",
              "updatedAt": "2024-07-09T00:58:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 379,
      "id": "PR_kwDOGKuqOc51BUD1",
      "title": "Sync up descriptions of DAFs and VDAFs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/379",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-11"
      ],
      "body": "This PR updates `is_valid()` for DAFs to take a list of previous aggregation parameters, following a similar change to VDAFs. It also updates the description of VDAF sharding to reflect that DAF sharding has the same sets of inputs and outputs.",
      "createdAt": "2024-07-10T21:15:16Z",
      "updatedAt": "2024-07-11T14:16:07Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "80dfdd328df5a629f7095e038300a77fe15d9e91",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "david/update-daf",
      "headRefOid": "490b002863b5af837ea6a41afed30e0a868bbfe9",
      "closedAt": "2024-07-11T14:16:06Z",
      "mergedAt": "2024-07-11T14:16:06Z",
      "mergedBy": "divergentdave",
      "mergeCommit": {
        "oid": "5aa7f1c2764bc600970335bc468266453329ba22"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6BXPxo",
          "commit": {
            "abbreviatedOid": "490b002"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-10T21:17:57Z",
          "updatedAt": "2024-07-10T21:17:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 381,
      "id": "PR_kwDOGKuqOc52P-X6",
      "title": "Rename binder string to nonce, and add a length requirement",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/381",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-11"
      ],
      "body": "Fixes #352.",
      "createdAt": "2024-07-23T18:22:48Z",
      "updatedAt": "2024-07-23T22:10:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "5aa7f1c2764bc600970335bc468266453329ba22",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "schoppmp/issue-352",
      "headRefOid": "be713553d1e4080544f508039c49c62d0d145f78",
      "closedAt": "2024-07-23T19:25:08Z",
      "mergedAt": "2024-07-23T19:25:08Z",
      "mergedBy": "schoppmp",
      "mergeCommit": {
        "oid": "01291c2c7c7568f8d31d01aa4d3e9df653d6b447"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6C00fZ",
          "commit": {
            "abbreviatedOid": "be71355"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Works for me, thanks Phillipp!",
          "createdAt": "2024-07-23T19:24:06Z",
          "updatedAt": "2024-07-23T19:24:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 382,
      "id": "PR_kwDOGKuqOc527O7x",
      "title": "Make the reference code installable via pip",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/382",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-11"
      ],
      "body": "Closes #359.\r\n\r\nProjects can now install the reference implementation via\r\n\r\n```\r\nsage -pip install git+https://github.com/cfrg/draft-irtf-cfrg-vdaf@draft-irtf-cfrg-vdaf-11#subdirectory=poc\r\n```\r\n\r\nThis avoids the need to hack a submodule into the project's import path.\r\n\r\nThis change also moves `test_vec` to the root project directory so that `pip install` can disambiguate this folder from the actual package, which is called `vdaf_poc` and exists in the same directory. We could alternatively put the package in a distinguished `src` directory, but this would require the user to install the package in order to run tests.",
      "createdAt": "2024-07-30T21:54:44Z",
      "updatedAt": "2024-07-31T00:22:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "01291c2c7c7568f8d31d01aa4d3e9df653d6b447",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/359",
      "headRefOid": "a708034f615271668bbeba60f3142623afa4ed69",
      "closedAt": "2024-07-31T00:14:21Z",
      "mergedAt": "2024-07-31T00:14:21Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "489048c7d22ccb2feb08575832b8640d6ef35bfd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6Dp1JX",
          "commit": {
            "abbreviatedOid": "a24bc50"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-30T21:56:03Z",
          "updatedAt": "2024-07-30T21:56:03Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "nit: @divergentdave is this too long / should it have periods in it? [The example I'm following](https://packaging.python.org/en/latest/tutorials/packaging-projects/#configuring-metadata) does not have periods.",
              "createdAt": "2024-07-30T21:56:03Z",
              "updatedAt": "2024-07-30T21:56:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6Dp2cQ",
          "commit": {
            "abbreviatedOid": "cf1c27a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-30T22:00:35Z",
          "updatedAt": "2024-07-30T22:05:47Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "@divergentdave please confirm we don't want to check this in.",
              "createdAt": "2024-07-30T22:00:36Z",
              "updatedAt": "2024-07-30T22:05:47Z"
            },
            {
              "originalPosition": 10,
              "body": "Reviewer note: I've confirmed this works at cf1c27aaae0d33007e0211b6fc5b5816b98e5ed8.",
              "createdAt": "2024-07-30T22:03:55Z",
              "updatedAt": "2024-07-30T22:05:47Z"
            },
            {
              "originalPosition": 5,
              "body": "@divergentdave do you think this will cause anyone any trouble? I  did this to help `pip` disambiguate `vdaf_poc` from `test_vec` as the package to install. Perhaps there's a better way to do this?",
              "createdAt": "2024-07-30T22:05:43Z",
              "updatedAt": "2024-07-30T22:05:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6Dp473",
          "commit": {
            "abbreviatedOid": "a24bc50"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-30T22:09:07Z",
          "updatedAt": "2024-07-30T22:09:07Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "It looks like this is the tagline that appears on PyPI project pages, and in search results. Thus, I think this might be on the line of \"too long\". If we want to include something longer, we could use `readme` to point at a file. I wonder if the setup.py `long_description` argument would work here as well, if we wanted to put the bigger blurb inline.",
              "createdAt": "2024-07-30T22:09:07Z",
              "updatedAt": "2024-07-30T22:09:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6Dp7ii",
          "commit": {
            "abbreviatedOid": "a24bc50"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-30T22:18:28Z",
          "updatedAt": "2024-07-30T22:18:28Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Shortened to \"Reference implementation of draft-irtf-cfrg-vdaf\" and added a pointer to the README.",
              "createdAt": "2024-07-30T22:18:28Z",
              "updatedAt": "2024-07-30T22:18:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6Dp5KT",
          "commit": {
            "abbreviatedOid": "31c786a"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-30T22:09:58Z",
          "updatedAt": "2024-07-30T22:54:31Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Yes, LGTM.",
              "createdAt": "2024-07-30T22:09:58Z",
              "updatedAt": "2024-07-30T22:54:31Z"
            },
            {
              "originalPosition": 9,
              "body": "From the `poc` directory, I tried running `sage -python tools/plot_prio3_multiproof_robustness.py`, and it didn't work. Running `sage -pip install -e .` first fixed it, though. I tried uninstalling the editable package, then copying the script up a directory, into `poc`, and running that worked as well. I suppose getting rid of the tools directory would be the simplest solution.",
              "createdAt": "2024-07-30T22:30:12Z",
              "updatedAt": "2024-07-30T22:54:31Z"
            },
            {
              "originalPosition": 5,
              "body": "I think this should be fine.",
              "createdAt": "2024-07-30T22:33:58Z",
              "updatedAt": "2024-07-30T22:54:31Z"
            },
            {
              "originalPosition": 13,
              "body": "This paragraph is largely duplicative now",
              "createdAt": "2024-07-30T22:38:00Z",
              "updatedAt": "2024-07-30T22:54:31Z"
            },
            {
              "originalPosition": 66,
              "body": "This doesn't align with the sentence above.\r\n```suggestion\r\nTEST_VECTOR=TRUE TEST_VECTOR_PATH=test_vec/00 sage -python -m unittest --quiet tests/test_vdaf_prio3.py\r\n```",
              "createdAt": "2024-07-30T22:51:32Z",
              "updatedAt": "2024-07-30T22:54:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6DqWUR",
          "commit": {
            "abbreviatedOid": "31c786a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-31T00:10:38Z",
          "updatedAt": "2024-07-31T00:11:15Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Moved the plotter to the poc directory. There you can run it without installing the package.",
              "createdAt": "2024-07-31T00:10:38Z",
              "updatedAt": "2024-07-31T00:11:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 383,
      "id": "PR_kwDOGKuqOc527qDZ",
      "title": "Move some test utilities into the `vdaf_poc` package",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/383",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "poc",
        "draft-11"
      ],
      "body": "Pull `test_flp_bbcggi19` and `test_vdaf` into into the installable package so they can be used elsewhere.",
      "createdAt": "2024-07-31T00:16:36Z",
      "updatedAt": "2024-07-31T20:00:45Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "489048c7d22ccb2feb08575832b8640d6ef35bfd",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/poc-test-utils",
      "headRefOid": "72227878a6fc1c9dae4d9b9e8bb1bfa1cc286bfc",
      "closedAt": "2024-07-31T20:00:45Z",
      "mergedAt": "2024-07-31T20:00:45Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "fefc5a2f563e70e73a74d3c57b7145e0dd1c2e3f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6DyYIA",
          "commit": {
            "abbreviatedOid": "7222787"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-31T19:59:35Z",
          "updatedAt": "2024-07-31T19:59:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 384,
      "id": "PR_kwDOGKuqOc53KtO8",
      "title": "Prio3: Add an implementation note about the output share",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/384",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-11"
      ],
      "body": "Closes #380.\r\n\r\nIt may be desirable to store the measurement share seed rather than the output share.",
      "createdAt": "2024-08-01T20:04:51Z",
      "updatedAt": "2024-08-02T17:29:38Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "fefc5a2f563e70e73a74d3c57b7145e0dd1c2e3f",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/380",
      "headRefOid": "95c95fb75f0e1f6ecd6c720047a815bc2122a469",
      "closedAt": "2024-08-02T17:29:37Z",
      "mergedAt": "2024-08-02T17:29:37Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "8355b5c54a7c0af3719c15b2a7df269b5ff42b37"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6D-QwB",
          "commit": {
            "abbreviatedOid": "2b16952"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-01T22:29:52Z",
          "updatedAt": "2024-08-01T22:30:33Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nthat will be released once preparation is complete. In some situations, it may be\r\n```",
              "createdAt": "2024-08-01T22:29:52Z",
              "updatedAt": "2024-08-01T22:30:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 385,
      "id": "PR_kwDOGKuqOc53LfhY",
      "title": "poc: Move test vector generation out of unit tests",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/385",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-11"
      ],
      "body": "Partially addresses #327.\r\n\r\nRemove the TEST_VECTOR and TEST_VECTOR_PATH environment variables and move test vector generation logic into a new tool, `gen_test_vec.py`.\r\n\r\nThe test vectors are complete with the following exceptions:\r\n\r\n1. We currently don't have test vectors for Prio3MultihotCountVec. This VDAF is new as of draft 10, but we neglected to add test vectors for it. This change checks in the test vectors.\r\n\r\n2. The test vector for IdpfBBCGGI21 was regenerated after this IDPF was renamed. Also, as of 01291c2c7c7568f8d31d01aa4d3e9df653d6b447, we are generating this with a proper nonce rather than an adhoc binder. To confirm that nothing has changed, you can modify `gen_test_vec_for_idpf()` by replacing Lines\r\n\r\n    ```\r\n    nonce = gen_rand(idpf.NONCE_SIZE)\r\n    ```\r\n\r\n    with\r\n\r\n    ```\r\n    nonce = bytes([0x73,0x6f,0x6d,0x65,0x20,0x6e,0x6f,0x6e,0x63,0x65])\r\n    ```\r\n\r\nAlso, this change opts in `gen_test_vec.py` and\r\n`plot_prio3_multiproof_robustness.py` into linting and type checking.",
      "createdAt": "2024-08-01T21:45:10Z",
      "updatedAt": "2024-08-02T20:53:14Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "8355b5c54a7c0af3719c15b2a7df269b5ff42b37",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/327",
      "headRefOid": "7381f8441be9eb3687b8647d10648c2da6540442",
      "closedAt": "2024-08-02T20:53:14Z",
      "mergedAt": "2024-08-02T20:53:14Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "4d7694e20c797817dba389a90c6fba6b0fa1182e"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> We should update the command in the README. (and cut out the second command about how to filter which test vectors you generated, since that's no longer possible)\r\n\r\nThat's odd, I thought I had checked in this change! I guess I didn't. Anyway, done now.",
          "createdAt": "2024-08-02T20:46:43Z",
          "updatedAt": "2024-08-02T20:46:43Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6D-F_p",
          "commit": {
            "abbreviatedOid": "ec6b349"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-01T21:57:40Z",
          "updatedAt": "2024-08-01T22:01:37Z",
          "comments": [
            {
              "originalPosition": 389,
              "body": "@divergentdave I can't figure out what mypy is complaining about here. Could you take a look?",
              "createdAt": "2024-08-01T21:57:40Z",
              "updatedAt": "2024-08-01T22:01:37Z"
            },
            {
              "originalPosition": 60,
              "body": "Reviewer note: I copied `run_vdaf()` from `test_vec/vdaf.py` and removed the `# REMOVE ME` comments.",
              "createdAt": "2024-08-01T21:59:17Z",
              "updatedAt": "2024-08-01T22:01:37Z"
            },
            {
              "originalPosition": 266,
              "body": "Reviewer note: copied verbatim from the tests directory.",
              "createdAt": "2024-08-01T21:59:48Z",
              "updatedAt": "2024-08-01T22:01:37Z"
            },
            {
              "originalPosition": 303,
              "body": "Reviewer note: copied verbatim from the tests directory.",
              "createdAt": "2024-08-01T22:00:01Z",
              "updatedAt": "2024-08-01T22:01:37Z"
            },
            {
              "originalPosition": 19,
              "body": "Reviewer note: Moved this from below to here. I like the idea of having all type variables for a file in one place.",
              "createdAt": "2024-08-01T22:01:15Z",
              "updatedAt": "2024-08-01T22:01:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6EF-Yi",
          "commit": {
            "abbreviatedOid": "6835255"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "We should update the command in the README. (and cut out the second command about how to filter which test vectors you generated, since that's no longer possible)",
          "createdAt": "2024-08-02T18:21:14Z",
          "updatedAt": "2024-08-02T19:40:42Z",
          "comments": [
            {
              "originalPosition": 389,
              "body": "This is another papercut because of Poplar1's union types of `list[Field64] | list[Field255]`. Changing the `list[F]` to `list[Any]` in the signature of `gen_test_vec_for_vdaf()` will work around this; I previously did the same in `test_vdaf()`.",
              "createdAt": "2024-08-02T18:21:14Z",
              "updatedAt": "2024-08-02T19:40:42Z"
            },
            {
              "originalPosition": 377,
              "body": "nit: the others use tuples, while this uses a list",
              "createdAt": "2024-08-02T19:36:24Z",
              "updatedAt": "2024-08-02T19:40:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6EGycK",
          "commit": {
            "abbreviatedOid": "751207a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-02T20:41:21Z",
          "updatedAt": "2024-08-02T20:46:17Z",
          "comments": [
            {
              "originalPosition": 377,
              "body": "Done.",
              "createdAt": "2024-08-02T20:41:21Z",
              "updatedAt": "2024-08-02T20:46:17Z"
            },
            {
              "originalPosition": 389,
              "body": "Done! Thanks :)",
              "createdAt": "2024-08-02T20:43:02Z",
              "updatedAt": "2024-08-02T20:46:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 386,
      "id": "PR_kwDOGKuqOc53Th6K",
      "title": "poc: Ensure all test failures are enforced by CI",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/386",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-11"
      ],
      "body": "Closes #327.\r\n\r\nFor some of our tests, when the test fails, it outputs something to stdout:\r\n\r\n```python\r\nif not test_succeeded:\r\n    print('test failed!')\r\n```\r\n\r\nThis does not cause `sage python -m unittest` to fail, and so will be missed by CI. To address this, replace these with an assertion:\r\n\r\n```python\r\nassert test_succeeded\r\n```\r\n\r\nIn fact, this change goes one step further: encapsulate the test in a `unittest.TestCase` so that the test runner can provide more useful feedback:\r\n\r\n```python\r\nclass MyTest(unittest.TestCase):\r\n    def test(self):\r\n       ...\r\n       self.assertTrue(test_succeeded)\r\n```\r\n\r\nThis required a bit of refactoring:\r\n\r\n1. Create a new module, `vdaf_poc/test_utils.py`, that defines a test harness for instances of `Vdaf` and `FlpBBCGGI19`.\r\n\r\n2. Likewise, move `vdaf_poc/idpf_util.py` to a test harness in `tests/test_idpf_bbcggi21.py`.\r\n\r\nFinally, replace assertions in unit tests with `unittest`-style assertions.",
      "createdAt": "2024-08-02T22:54:35Z",
      "updatedAt": "2024-08-05T23:14:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "4d7694e20c797817dba389a90c6fba6b0fa1182e",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/327-1-hard-fail",
      "headRefOid": "03e7fb2dcc3be7040881a4e6d214636c719ead90",
      "closedAt": "2024-08-05T23:14:39Z",
      "mergedAt": "2024-08-05T23:14:39Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "452ae27e7295d78eff9aefb28d9472b07f80195c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6EHTLf",
          "commit": {
            "abbreviatedOid": "03e7fb2"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-02T23:01:18Z",
          "updatedAt": "2024-08-02T23:03:05Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "Reviewer note: this is definitely easier to review with whitespace hidden.",
              "createdAt": "2024-08-02T23:01:18Z",
              "updatedAt": "2024-08-02T23:03:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6EUidK",
          "commit": {
            "abbreviatedOid": "03e7fb2"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I checked the code coverage as well, and it looks good. (to make sure all the test code is properly discovered and run, after being rearranged)",
          "createdAt": "2024-08-05T22:59:56Z",
          "updatedAt": "2024-08-05T22:59:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 387,
      "id": "PR_kwDOGKuqOc53TlDf",
      "title": "Move mention of {{OriginTelemetry}} and {{ENPA}} to acks",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/387",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-11"
      ],
      "body": "Closes #338.",
      "createdAt": "2024-08-02T23:17:31Z",
      "updatedAt": "2024-08-05T16:10:47Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "4d7694e20c797817dba389a90c6fba6b0fa1182e",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/338",
      "headRefOid": "ecd7b7d2cf2e3dfe80404f6ac20ad7941ba563b8",
      "closedAt": "2024-08-05T16:10:47Z",
      "mergedAt": "2024-08-05T16:10:47Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "82997647a9b34115ba16847ae07664f17e9c7f95"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6ERMc3",
          "commit": {
            "abbreviatedOid": "231a9a8"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The origin telemetry link is broken now, by the way. It's archived at https://web.archive.org/web/20221025174046/https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/collection/origin.html.",
          "createdAt": "2024-08-05T14:04:20Z",
          "updatedAt": "2024-08-05T14:04:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 388,
      "id": "PR_kwDOGKuqOc53fulA",
      "title": "Replace pseudocode for ping-pong topology with Python",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/388",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-11"
      ],
      "body": "Closes #283.\r\nBased on #386 (merge that first).\r\n\r\nAdd an implementation of the ping-pong API to the reference code. The\r\npseudocode currently in the draft doesn't compile, so replace it with\r\nthe tested, type-checked, and linted Python.\r\n\r\nAlso, in the draft, we don't need to list the encoding methods used by\r\nthe ping-pong API; these should be clear in context.",
      "createdAt": "2024-08-05T20:51:14Z",
      "updatedAt": "2024-08-13T18:43:26Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "bb104e39792d7dd7400a492b3217d13784a0625b",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/283",
      "headRefOid": "956ee965ecb92979ee5f8ee9b0960e7e613c8532",
      "closedAt": "2024-08-13T18:43:26Z",
      "mergedAt": "2024-08-13T18:43:26Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "a0dfe1dcfb6daf038540a3b299a758b9b5978bc7"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased and squashed.",
          "createdAt": "2024-08-08T20:25:29Z",
          "updatedAt": "2024-08-08T20:25:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6EUMLr",
          "commit": {
            "abbreviatedOid": "30c30b2"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-05T21:22:11Z",
          "updatedAt": "2024-08-05T21:22:12Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "@divergentdave I can use your help here figuring out how to wrangle type hints. In the ping-pong API, we need to be able to condition the code on the type of `out` (a prep state and share or an output share). We can't do `type(out) == OutShare` here because `OutShare` is a type variable. `type != tuple` is a heuristic, and it fails if the output share is a tuple.\r\n\r\nAny ideas? ",
              "createdAt": "2024-08-05T21:22:11Z",
              "updatedAt": "2024-08-05T21:22:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6EUPfz",
          "commit": {
            "abbreviatedOid": "30c30b2"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-05T21:34:04Z",
          "updatedAt": "2024-08-05T21:34:04Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "We could avoid the problem by tracking rounds in the ping pong state, and interpreting `out` based on that. Alternately, we could change `prep_next()` to be explicit by adding a boolean or enum to its output, though that would be more disruptive to the whole document.",
              "createdAt": "2024-08-05T21:34:04Z",
              "updatedAt": "2024-08-05T21:34:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6EUQTj",
          "commit": {
            "abbreviatedOid": "30c30b2"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-05T21:37:12Z",
          "updatedAt": "2024-08-05T21:37:12Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "I like the idea of tracking the round.",
              "createdAt": "2024-08-05T21:37:12Z",
              "updatedAt": "2024-08-05T21:37:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6EUZIH",
          "commit": {
            "abbreviatedOid": "30c30b2"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-05T22:13:48Z",
          "updatedAt": "2024-08-05T22:13:48Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "Done.",
              "createdAt": "2024-08-05T22:13:48Z",
              "updatedAt": "2024-08-05T22:13:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6Es-EE",
          "commit": {
            "abbreviatedOid": "49421a9"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-07T23:53:56Z",
          "updatedAt": "2024-08-08T00:24:38Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "IMO, it would read easier if we kept a helper function for encoding/decoding ping-pong messages -- maybe the interface would be to take the type (e.g. 0 for initialize, 1 for continue, 2 for finsih) & a sequence of byte strings which would be length-prefix-encoded? Otherwise, this somewhat-hairy byte-wrangling code is repeated a few times throughout these functions.\r\n\r\nAnother approach would be a series of helper functions, one for each type of ping-pong message (initialize/continue/finish), but that might be too wordy.",
              "createdAt": "2024-08-07T23:53:56Z",
              "updatedAt": "2024-08-08T00:24:38Z"
            },
            {
              "originalPosition": 263,
              "body": "nit: the `prep_msg` is encoded here, and in the `if` block above. we could save a bit of code if we encoded it once, before the `if`.",
              "createdAt": "2024-08-08T00:04:23Z",
              "updatedAt": "2024-08-08T00:24:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6EzpA4",
          "commit": {
            "abbreviatedOid": "49421a9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-08T14:52:55Z",
          "updatedAt": "2024-08-08T14:52:55Z",
          "comments": [
            {
              "originalPosition": 263,
              "body": "Nice, done.",
              "createdAt": "2024-08-08T14:52:55Z",
              "updatedAt": "2024-08-08T14:52:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6E0tAL",
          "commit": {
            "abbreviatedOid": "49421a9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-08T16:53:21Z",
          "updatedAt": "2024-08-08T16:53:21Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "Hmm, I'm exploring two options here, neither of which I think is very good.\r\n\r\nOption 1: define encoder/decoders for each message type:\r\n* encode_init_msg(prep_share)\r\n* encode_cont_msg(prep_msg, prep_share)\r\n* encode_finish_msg(prep_msg)\r\n\r\nOption 2: a single function for encoding each message type:\r\n```python3\r\ndef encode_msg(encoded_prep_msg: Optional[bytes],\r\n               encoded_prep_share: Optional[bytes]) -> bytes:\r\n    encoded = bytes()\r\n    if encoded_prep_msg == None and encoded_prep_share != None:\r\n        encoded += byte(0)  # initialize\r\n    elif encoded_prep_msg != None and encoded_prep_share != None:\r\n        encoded += byte(1)  # continue\r\n    elif encoded_prep_msg != None and encoded_prep_share == None:\r\n        encoded += byte(2)  # finish\r\n    else:\r\n        raise ValueError(\"cannot send empty message\")\r\n    if encoded_prep_msg != None:\r\n        encoded_prep_msg = cast(bytes, encoded_prep_msg)\r\n        encoded += to_be_bytes(len(encoded_prep_msg), 4)\r\n        encoded += encoded_prep_msg\r\n    if encoded_prep_share != None:\r\n        encoded_prep_share = cast(bytes, encoded_prep_share)\r\n        encoded += to_be_bytes(len(encoded_prep_share), 4)\r\n        encoded += encoded_prep_share\r\n    return encoded\r\n```\r\n\r\nThe decoder would return `tuple[Optional[bytes], Optional[bytes]]` and the caller has to check if it has it was it needs to proceed.\r\n\r\n",
              "createdAt": "2024-08-08T16:53:21Z",
              "updatedAt": "2024-08-08T16:54:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6E0tzx",
          "commit": {
            "abbreviatedOid": "49421a9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-08T16:55:06Z",
          "updatedAt": "2024-08-08T16:55:06Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "What I like about what we have currently is that it's explicit, relatively concise, and don't have a bunch of `if` statements.",
              "createdAt": "2024-08-08T16:55:06Z",
              "updatedAt": "2024-08-08T16:55:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6E1r7i",
          "commit": {
            "abbreviatedOid": "49421a9"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-08T19:14:11Z",
          "updatedAt": "2024-08-08T19:14:11Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "I like Option 1, but I think an even simpler approach for encoding would be a function that takes the \"type\" byte (initialize/continue/finish) & a sequence of byte strings, and encodes the type byte followed by each of the byte strings with prefixed length. This would be a very simple function (one loop, I suppose).\r\n\r\nDecoding would look similar: it could be a function that returns the type byte & a sequence of byte strings (decoded as you would expect). Then the program logic could handle parsing the byte strings, and the byte wrangling would be deduplicated & hid behind a function.\r\n\r\nWhat I don't like about the existing approach is that it duplicates the encoding/decoding logic in each location, and the encoding/decoding logic is inline with the \"processing\" logic, which makes it harder to follow. If this argument isn't compelling to you, I won't hold the PR up over it. WDYT?",
              "createdAt": "2024-08-08T19:14:11Z",
              "updatedAt": "2024-08-08T19:14:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6E2Ggc",
          "commit": {
            "abbreviatedOid": "2b5aa5c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-08T20:14:02Z",
          "updatedAt": "2024-08-08T20:14:02Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "You're right, that's much nicer. Done.",
              "createdAt": "2024-08-08T20:14:02Z",
              "updatedAt": "2024-08-08T20:14:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6E2Kp0",
          "commit": {
            "abbreviatedOid": "37177d1"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-08T20:23:16Z",
          "updatedAt": "2024-08-08T20:25:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc6Esrhg",
          "commit": {
            "abbreviatedOid": "37177d1"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-07T22:33:59Z",
          "updatedAt": "2024-08-13T17:30:39Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "I think we should keep this, as it's referenced below",
              "createdAt": "2024-08-07T22:33:59Z",
              "updatedAt": "2024-08-13T17:30:39Z"
            },
            {
              "originalPosition": 31,
              "body": "This is missing the new field\r\n```suggestion\r\n    def __init__(self, prep_state: PrepState, prep_round: int):\r\n        self.prep_state = prep_state\r\n        self.prep_round = prep_round\r\n```",
              "createdAt": "2024-08-13T13:19:44Z",
              "updatedAt": "2024-08-13T17:30:39Z"
            },
            {
              "originalPosition": 219,
              "body": "A pointer back to the enum would be nice for clarity.\r\n```suggestion\r\nProcedure `decode` decodes the inbound message and returns the MessageType variant\r\n```",
              "createdAt": "2024-08-13T13:22:05Z",
              "updatedAt": "2024-08-13T17:30:39Z"
            },
            {
              "originalPosition": 280,
              "body": "This comment is incorrect\r\n```suggestion\r\n        num_counts = 1   # prep_msg\r\n```",
              "createdAt": "2024-08-13T16:49:39Z",
              "updatedAt": "2024-08-13T17:30:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6FShxq",
          "commit": {
            "abbreviatedOid": "37177d1"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-13T18:00:32Z",
          "updatedAt": "2024-08-13T18:03:20Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Done. I also added a NOTE in the code to remind us that these are excerpted.",
              "createdAt": "2024-08-13T18:00:32Z",
              "updatedAt": "2024-08-13T18:03:20Z"
            },
            {
              "originalPosition": 39,
              "body": "Yup, this was a goof. Fixed.",
              "createdAt": "2024-08-13T18:01:12Z",
              "updatedAt": "2024-08-13T18:03:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 390,
      "id": "PR_kwDOGKuqOc53gIoT",
      "title": "Sketch the star topology for VDAF preparation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/390",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-11"
      ],
      "body": "Closes #261.",
      "createdAt": "2024-08-05T22:30:01Z",
      "updatedAt": "2024-08-07T15:35:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "452ae27e7295d78eff9aefb28d9472b07f80195c",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/261-sketch",
      "headRefOid": "71cc65b1b54704431d868f6488b99c44a2335c68",
      "closedAt": "2024-08-07T15:35:39Z",
      "mergedAt": "2024-08-07T15:35:39Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "45b75e584d402496988130130b8755a742e5c096"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6EbW6y",
          "commit": {
            "abbreviatedOid": "6609180"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Some copyedits:",
          "createdAt": "2024-08-06T16:26:00Z",
          "updatedAt": "2024-08-06T16:28:46Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nAggregators, then the star topology described in this section can\r\n```",
              "createdAt": "2024-08-06T16:26:00Z",
              "updatedAt": "2024-08-06T16:28:47Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\noutput share or, if more rounds of preparation are required, compute its updated state\r\n```",
              "createdAt": "2024-08-06T16:28:18Z",
              "updatedAt": "2024-08-06T16:28:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 391,
      "id": "PR_kwDOGKuqOc53gUOM",
      "title": "Replace `Union[TypeA, TypeB]` with `TypeA | TypeB`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/391",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-11"
      ],
      "body": "Closes #389.",
      "createdAt": "2024-08-05T23:27:14Z",
      "updatedAt": "2024-08-06T17:33:48Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "452ae27e7295d78eff9aefb28d9472b07f80195c",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/389",
      "headRefOid": "e4c9aaaf495ad3088d06f9d10d33401c711d2094",
      "closedAt": "2024-08-06T17:33:47Z",
      "mergedAt": "2024-08-06T17:33:47Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "5591b148094299688c4eb7f50e063408dcd8ff1b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6EaTQ4",
          "commit": {
            "abbreviatedOid": "a262883"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-06T14:30:46Z",
          "updatedAt": "2024-08-06T15:48:35Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "This change is at the wrong bracket depth\r\n```suggestion\r\n| `InputShare`      | `tuple[list[F], list[F], Optional[bytes]] | tuple[bytes, bytes, Optional[bytes]]` |\r\n```",
              "createdAt": "2024-08-06T14:30:46Z",
              "updatedAt": "2024-08-06T15:48:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 392,
      "id": "PR_kwDOGKuqOc53gfvn",
      "title": "Resolve open issues for #255",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/392",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-11"
      ],
      "body": "Closes #255.\r\n\r\nTwo questions remain.\r\n\r\nFirst, for consistency with other sections, allow the IDPF to define its own type for the public share and express the encoding correction words for {{BBCGG21}} in TLS-syntax.\r\n\r\nSecond, for consistency with other sections, we express the encoding of `Poplar1`'s aggregation parameter in TLS-syntax. This is slightly hairy because of the prefix packing procedure, but this can be factored out pretty nicely.",
      "createdAt": "2024-08-06T00:23:50Z",
      "updatedAt": "2024-08-20T01:43:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "34e248229d68188bc3bf286a7d4857c414a83316",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/255-finish-it",
      "headRefOid": "109ec2ec58cb4cae276a4fa5aeda820f8110d6f7",
      "closedAt": "2024-08-20T01:43:05Z",
      "mergedAt": "2024-08-20T01:43:05Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "14edbfb22b356a1daf73a4efb987f594b7f12eb6"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@divergentdave let me know if you'd like me to change the public share type for `Idpf` from `bytes` to generic `PublicShare`.",
          "createdAt": "2024-08-07T16:06:19Z",
          "updatedAt": "2024-08-07T16:06:19Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased and squashed.",
          "createdAt": "2024-08-07T23:47:03Z",
          "updatedAt": "2024-08-07T23:47:03Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed all of the lints. To compare to what you last reviewed:\r\n```\r\ngit range-diff 452ae27e..7ba120c cjpatton/255-finish-it^..cjpatton/255-finish-it\r\n```",
          "createdAt": "2024-08-08T00:03:31Z",
          "updatedAt": "2024-08-08T00:03:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased.",
          "createdAt": "2024-08-16T18:12:59Z",
          "updatedAt": "2024-08-16T18:12:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6EseVk",
          "commit": {
            "abbreviatedOid": "4ecef01"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-07T21:43:31Z",
          "updatedAt": "2024-08-07T21:59:55Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "This is still excerpted, so we should keep this note.",
              "createdAt": "2024-08-07T21:43:32Z",
              "updatedAt": "2024-08-07T21:59:55Z"
            },
            {
              "originalPosition": 5,
              "body": "I think it would be worthwhile to separate public share encoding/decoding from the sharding and preparation routines, and using a type other than `bytes` for the public share internally. This is now the last composite data structure we represent as a byte string in the API, so it would be good to clean this up for consistency.",
              "createdAt": "2024-08-07T21:57:04Z",
              "updatedAt": "2024-08-07T21:59:55Z"
            },
            {
              "originalPosition": 27,
              "body": "typo fix and rephrasing:\r\n```suggestion\r\n`packed_prefixes`, the sequence of prefixes packed into a byte string of\r\nlength `packed_len`. The prefixes are encoded with the following procedure:\r\n```",
              "createdAt": "2024-08-07T21:59:11Z",
              "updatedAt": "2024-08-07T21:59:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6Es26B",
          "commit": {
            "abbreviatedOid": "4ecef01"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-07T23:31:06Z",
          "updatedAt": "2024-08-07T23:31:06Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done.",
              "createdAt": "2024-08-07T23:31:06Z",
              "updatedAt": "2024-08-07T23:31:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6Es7kM",
          "commit": {
            "abbreviatedOid": "6751d9e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-07T23:48:46Z",
          "updatedAt": "2024-08-07T23:48:46Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "@divergentdave I can revert this if you like. CorrectionWord seems just as accurate to me and is a bit pithier.",
              "createdAt": "2024-08-07T23:48:46Z",
              "updatedAt": "2024-08-07T23:48:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6Ftlt9",
          "commit": {
            "abbreviatedOid": "7171378"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-16T18:21:29Z",
          "updatedAt": "2024-08-16T18:21:30Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "```suggestion\r\nHere `Ci` denotes the length of `Poplar1CWSeedAndPayloadInner` and\r\n```",
              "createdAt": "2024-08-16T18:21:30Z",
              "updatedAt": "2024-08-16T18:21:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6F4h5c",
          "commit": {
            "abbreviatedOid": "7171378"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-19T18:21:56Z",
          "updatedAt": "2024-08-19T19:52:36Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": "nit: grammar\r\n```suggestion\r\nIt encodes each group of eight bits into a byte, in LSB to MSB order, padding the most\r\nsignificant bits of the last byte with zeros as necessary, and returns the byte\r\narray. Decoding performs the reverse operation: it takes in a byte array\r\n```",
              "createdAt": "2024-08-19T18:21:56Z",
              "updatedAt": "2024-08-19T19:52:36Z"
            },
            {
              "originalPosition": 178,
              "body": "nit: inconsistent indentation\r\n```suggestion\r\ncontrol_bits = []\r\nfor i in range(length):\r\n    control_bits.append(Field2(\r\n        (packed_control_bits[i // 8] >> (i % 8)) & 1\r\n    ))\r\nleftover_bits = packed_control_bits[-1] >> (\r\n    (length + 7) % 8 + 1\r\n)\r\nif (length + 7) // 8 != len(packed_control_bits) or \\\r\n        leftover_bits != 0:\r\n    raise ValueError('trailing bits')\r\n```",
              "createdAt": "2024-08-19T18:24:15Z",
              "updatedAt": "2024-08-19T19:52:36Z"
            },
            {
              "originalPosition": 252,
              "body": "The preamble before this shouldn't mention `encode_public_share()` anymore",
              "createdAt": "2024-08-19T19:36:41Z",
              "updatedAt": "2024-08-19T19:52:36Z"
            },
            {
              "originalPosition": 289,
              "body": "Similarly, the preamble before this shouldn't mention `decode_public_share()` anymore",
              "createdAt": "2024-08-19T19:37:27Z",
              "updatedAt": "2024-08-19T19:52:36Z"
            },
            {
              "originalPosition": 156,
              "body": "nit: typo\r\n```suggestion\r\npacked_control_bits = bytes(packed_control_buf)\r\n```",
              "createdAt": "2024-08-19T19:41:43Z",
              "updatedAt": "2024-08-19T19:52:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6F65ln",
          "commit": {
            "abbreviatedOid": "109ec2e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-20T01:33:47Z",
          "updatedAt": "2024-08-20T01:42:57Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "I'd hardly call that a nit \ud83d\ude2c ",
              "createdAt": "2024-08-20T01:33:47Z",
              "updatedAt": "2024-08-20T01:42:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 393,
      "id": "PR_kwDOGKuqOc53mQVO",
      "title": "Address feedback on the intro",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/393",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-11"
      ],
      "body": "Closes #219.\r\nCloses #346 (the new intro rework leans into DAF being a core part of the draft).\r\n\r\n* Introduce DAFs first, in order to mirror the document structure.\r\n\r\n* Explain (function) secret sharing and give examples of aggregation functions that can be computed with (V)DAFs\r\n\r\n* Give less detail about Prio3 and Poplar1\r\n\r\n* Point to discussion about non-collusion in {{overview}}\r\n\r\nAlso, in security considerations, discuss dealing with non-static corruptions and how to pick the number of aggregators. This addresses an idea for the intro, but resolving it seems to require a proper security consideration.",
      "createdAt": "2024-08-06T17:27:03Z",
      "updatedAt": "2024-08-07T23:35:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "45b75e584d402496988130130b8755a742e5c096",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/219",
      "headRefOid": "62807b5a9f24e7a689431f70f96cb80a4a15f7fe",
      "closedAt": "2024-08-07T23:35:03Z",
      "mergedAt": "2024-08-07T23:35:03Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "9ccd7545b7c2697fac983c72ac896cd87630cbef"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased and squashed.",
          "createdAt": "2024-08-07T23:32:01Z",
          "updatedAt": "2024-08-07T23:32:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6EdeMA",
          "commit": {
            "abbreviatedOid": "35b00a0"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-06T22:08:59Z",
          "updatedAt": "2024-08-06T23:02:26Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "This seems misleading, as sharding always produces multiple shares.\n```suggestion\nmeasurement into multiple secret shares, one for each aggregation\n```",
              "createdAt": "2024-08-06T22:08:59Z",
              "updatedAt": "2024-08-06T23:02:26Z"
            },
            {
              "originalPosition": 147,
              "body": "I think starting a new paragraph here may help. The \"in fact\" coming right after a \"however\" seems like it's going to be contradicting the statement about linear functions of the encoding, but that's not the case, and instead it introduces the aggregation parameter, which is orthogonal to the aggregation part.\n```suggestion\nmeasurements.\n\nIn fact, our framework admits DAFs with slightly more\n```\n",
              "createdAt": "2024-08-06T22:19:15Z",
              "updatedAt": "2024-08-06T23:02:26Z"
            },
            {
              "originalPosition": 174,
              "body": "```suggestion\ninteract with one another over a number of rounds of communication. DAFs on the\n```\n",
              "createdAt": "2024-08-06T22:21:32Z",
              "updatedAt": "2024-08-06T23:02:26Z"
            },
            {
              "originalPosition": 213,
              "body": "Pre-existing typo\n```suggestion\n  variety of aggregate statistics, combining additive secret sharing as described\n```\n",
              "createdAt": "2024-08-06T22:23:54Z",
              "updatedAt": "2024-08-06T23:02:26Z"
            },
            {
              "originalPosition": 256,
              "body": "Actually the point function is the partial application of g on the measurement, $g(\\cdot, meas)$, but I don't know if we need to split that hair here.",
              "createdAt": "2024-08-06T22:26:29Z",
              "updatedAt": "2024-08-06T23:02:26Z"
            },
            {
              "originalPosition": 255,
              "body": "nit: typo\n```suggestion\n  least `t` times for some threshold `t`. The core primitive in their protocol\n```\n",
              "createdAt": "2024-08-06T22:48:43Z",
              "updatedAt": "2024-08-06T23:02:26Z"
            },
            {
              "originalPosition": 320,
              "body": "Typo, lol",
              "createdAt": "2024-08-06T22:59:21Z",
              "updatedAt": "2024-08-06T23:02:26Z"
            },
            {
              "originalPosition": 336,
              "body": "I found \"including\" to be confusing here, so I rephrased it.\n```suggestion\n{{star-topo}}. Note however that some schemes are not compatible with this mode of operation,\nsuch as Poplar1.\n```",
              "createdAt": "2024-08-06T23:02:19Z",
              "updatedAt": "2024-08-06T23:02:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6EdvAh",
          "commit": {
            "abbreviatedOid": "d995a17"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-06T23:28:04Z",
          "updatedAt": "2024-08-06T23:30:16Z",
          "comments": [
            {
              "originalPosition": 256,
              "body": "The operative word is \"allows\", as in \"they evaluate point function shares on each of their input shares and add up the output shares to get share of the count\". Is this is clear enough or do we need to fix it?",
              "createdAt": "2024-08-06T23:28:04Z",
              "updatedAt": "2024-08-06T23:30:16Z"
            },
            {
              "originalPosition": 320,
              "body": "\ud83d\ude2c ",
              "createdAt": "2024-08-06T23:29:10Z",
              "updatedAt": "2024-08-06T23:30:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6Esk3A",
          "commit": {
            "abbreviatedOid": "62807b5"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-07T22:07:24Z",
          "updatedAt": "2024-08-07T23:31:51Z",
          "comments": [
            {
              "originalPosition": 256,
              "body": "I think it's fine as-is",
              "createdAt": "2024-08-07T22:07:24Z",
              "updatedAt": "2024-08-07T22:17:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 394,
      "id": "PR_kwDOGKuqOc5340op",
      "title": "Add prep state to prep diagram",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/394",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "draft-11"
      ],
      "body": "These arrows are important for the diagram because they have implications for how you architect a protocol around a VDAF.\r\n\r\nfyi/ @bhalleycf",
      "createdAt": "2024-08-08T22:32:07Z",
      "updatedAt": "2024-08-09T15:09:00Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "9ccd7545b7c2697fac983c72ac896cd87630cbef",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/prep-fig",
      "headRefOid": "821c090ca2fc13ff3452a2801cc182ffad2da4fe",
      "closedAt": "2024-08-09T15:09:00Z",
      "mergedAt": "2024-08-09T15:09:00Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "bb104e39792d7dd7400a492b3217d13784a0625b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6E3Me5",
          "commit": {
            "abbreviatedOid": "821c090"
          },
          "author": "branlwyd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-08T23:55:38Z",
          "updatedAt": "2024-08-08T23:55:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc6E8bFz",
          "commit": {
            "abbreviatedOid": "821c090"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-09T15:00:45Z",
          "updatedAt": "2024-08-09T15:00:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 395,
      "id": "PR_kwDOGKuqOc54KEcc",
      "title": "Move test vector generator to test utils",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/395",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "poc",
        "draft-11"
      ],
      "body": "This makes it easier for other projects to generate VDAF test vectors with the same format.",
      "createdAt": "2024-08-12T21:27:41Z",
      "updatedAt": "2024-08-13T18:51:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "a0dfe1dcfb6daf038540a3b299a758b9b5978bc7",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/test-util-vdaf-test-vec",
      "headRefOid": "5245c612d2b131a0ca2a220ba8aa3475ab8ba8d1",
      "closedAt": "2024-08-13T18:51:49Z",
      "mergedAt": "2024-08-13T18:51:49Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "beaaffec1d066157deac9fe6b6367a4eaec2f2f3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6FSmkl",
          "commit": {
            "abbreviatedOid": "9d6e51a"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-13T18:10:41Z",
          "updatedAt": "2024-08-13T18:13:00Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "nit: extra line",
              "createdAt": "2024-08-13T18:10:41Z",
              "updatedAt": "2024-08-13T18:13:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 399,
      "id": "PR_kwDOGKuqOc54SbIm",
      "title": "Add diagrams for FLP and rework overview/extensions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/399",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-11"
      ],
      "body": "Closes #257.\r\nPartially addresses #226.\r\n\r\nThis commit includes editorial improvements for `FlpBBCGGI19`:\r\n\r\n1. Add diagrams to show concepts relate to one another: validity circuit, gadgets, encoded measurement, joint, prove, and query randomness, and so on.\r\n\r\n2. Improve the overview section, building up each of the concepts one by one.\r\n\r\n3. Do an editorial pass of the extensions section, some of which is a little out of date. Also, add a reference for NTT.",
      "createdAt": "2024-08-13T22:41:24Z",
      "updatedAt": "2024-08-22T16:18:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "e37da53af7092a9c6c91b4dba6b9c0dc64466dcf",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/257",
      "headRefOid": "9a73ae2ed4c3198d80f0f17a86ee432a2a863e03",
      "closedAt": "2024-08-22T16:18:52Z",
      "mergedAt": "2024-08-22T16:18:52Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "b3bbb5c793cf101f5b7e8d0ceb55f935431e646e"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the careful review here! Note that I've rebased to resolve conflicts, while at it I decided to squash as well.",
          "createdAt": "2024-08-20T02:04:30Z",
          "updatedAt": "2024-08-20T02:04:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6F5hdv",
          "commit": {
            "abbreviatedOid": "d7f27dd"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-19T20:59:14Z",
          "updatedAt": "2024-08-19T21:45:36Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "After #355, we should either say the circuit output is a vector of field elements here, or introduce it as one of our extensions below.",
              "createdAt": "2024-08-19T20:59:14Z",
              "updatedAt": "2024-08-19T21:45:36Z"
            },
            {
              "originalPosition": 80,
              "body": "This formulation of a circuit seems unusual, I think either 'multiplication and addition' or 'multiplication, addition, and subtraction' would be more conventional.",
              "createdAt": "2024-08-19T21:17:31Z",
              "updatedAt": "2024-08-19T21:45:36Z"
            },
            {
              "originalPosition": 121,
              "body": "Constants used in constant multiplications are fine as-is, but constants that get added need to be scaled, since this is one way of replacing them with additive shares of themselves.\r\n```suggestion\r\n(Note that, for this equality to hold, it is necessary to scale any addition of a constant\r\n```",
              "createdAt": "2024-08-19T21:26:43Z",
              "updatedAt": "2024-08-19T21:45:36Z"
            },
            {
              "originalPosition": 122,
              "body": "nit: typo\r\n```suggestion\r\nin the circuit by `1/SHARES`.) However, this is not the case if `C` has\r\n```",
              "createdAt": "2024-08-19T21:29:42Z",
              "updatedAt": "2024-08-19T21:45:36Z"
            },
            {
              "originalPosition": 123,
              "body": "nit: typo\r\n```suggestion\r\nmultiplication gates with non-constant inputs. Thus our goal is to transform\r\n```",
              "createdAt": "2024-08-19T21:29:54Z",
              "updatedAt": "2024-08-19T21:45:36Z"
            },
            {
              "originalPosition": 138,
              "body": "This isn't quite right, because the wire polynomials evaluated at the first point produce blinding values. (and the gadget polynomial evaluated at the first point outputs some function of the blinding values) I think we should probably mention or allude to the blinding here, since it's necessary for zero knowledge, and it's not mentioned below.",
              "createdAt": "2024-08-19T21:34:38Z",
              "updatedAt": "2024-08-19T21:45:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6F6-MI",
          "commit": {
            "abbreviatedOid": "d7f27dd"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-20T01:55:05Z",
          "updatedAt": "2024-08-20T01:55:05Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "This is introduced in the extensions section, in the very first paragraph. Do you think we should either introduce it here or say more about it there? I figured we should keep the overview as conceptually close to the paper as possible.",
              "createdAt": "2024-08-20T01:55:05Z",
              "updatedAt": "2024-08-20T01:55:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6F6-pv",
          "commit": {
            "abbreviatedOid": "d7f27dd"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-20T01:56:57Z",
          "updatedAt": "2024-08-20T01:56:57Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "Hmm, I think of addition, multiplication, and negation as analogues of OR, AND, and NOT respectively for boolean circuits, which to me is more intuitive. What about stating this analogy here, and maybe me mentioning that subtraction is negation followed by addition?",
              "createdAt": "2024-08-20T01:56:57Z",
              "updatedAt": "2024-08-20T01:56:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6F6-5F",
          "commit": {
            "abbreviatedOid": "d7f27dd"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-20T01:58:11Z",
          "updatedAt": "2024-08-20T01:58:11Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "Good catch.",
              "createdAt": "2024-08-20T01:58:11Z",
              "updatedAt": "2024-08-20T01:58:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6F6_7h",
          "commit": {
            "abbreviatedOid": "d7f27dd"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-20T02:03:53Z",
          "updatedAt": "2024-08-20T02:03:53Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Nice catch :) Please take another look: I used `s` to denote the blinding factor, which is short for `seed`, the word we use in the actual specification.",
              "createdAt": "2024-08-20T02:03:53Z",
              "updatedAt": "2024-08-20T02:03:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6GK6GW",
          "commit": {
            "abbreviatedOid": "d7f27dd"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-21T14:38:44Z",
          "updatedAt": "2024-08-21T14:38:44Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "I missed it on my first read (probably because it wasn't part of the diff), but this is addressed as the fourth extension in 7.3.1.1. LGTM.",
              "createdAt": "2024-08-21T14:38:44Z",
              "updatedAt": "2024-08-21T14:38:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6GLBw_",
          "commit": {
            "abbreviatedOid": "d7f27dd"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-21T14:49:03Z",
          "updatedAt": "2024-08-21T14:49:03Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "I don't think we need to draw direct parallels to boolean circuits. Besides, if we were to project a boolean circuit into an arithmetic circuit, logical negation would probably be implemented with (1 - x), so I think the analogy doesn't hold up.\r\n\r\nLooking at the 2019 Prio paper, it says in section 7.1 that arithmetic circuits over a ring R \"may contain addition, subtraction and multiplication gates, as well as constants from R.\" The Wikipedia page for [Arithmetic circuit complexity](https://en.wikipedia.org/wiki/Arithmetic_circuit_complexity) says that circuits are made up of input gates, sum gates, and product gates.",
              "createdAt": "2024-08-21T14:49:03Z",
              "updatedAt": "2024-08-21T14:49:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6GLe2Q",
          "commit": {
            "abbreviatedOid": "f873881"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-21T15:14:54Z",
          "updatedAt": "2024-08-21T15:16:08Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "This needs to be updated to match the above changes.\r\n```suggestion\r\n1. Each Aggregator locally computes and broadcasts its share of `p(1)`, which\r\n```",
              "createdAt": "2024-08-21T15:14:54Z",
              "updatedAt": "2024-08-21T15:16:08Z"
            },
            {
              "originalPosition": 136,
              "body": "nit: formatting\r\n```suggestion\r\nRange2(x) = x * (x - 1) = x^2 - x\r\n```",
              "createdAt": "2024-08-21T15:15:06Z",
              "updatedAt": "2024-08-21T15:16:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6GMHlL",
          "commit": {
            "abbreviatedOid": "032e14c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-21T16:20:27Z",
          "updatedAt": "2024-08-21T16:20:32Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "I'm not sure I aqgree, but I don't feel strongly either way. I replaced \"negation\" with \"subtraction\".",
              "createdAt": "2024-08-21T16:20:27Z",
              "updatedAt": "2024-08-21T16:20:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6GYdcd",
          "commit": {
            "abbreviatedOid": "c8a0089"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-22T13:39:54Z",
          "updatedAt": "2024-08-22T13:59:06Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "nit: formatting\r\n```suggestion\r\nThis circuit contains one subtraction gate (`x - 1`) and one multiplication\r\ngate (`x * (x - 1)`). Observe that `C(x) = 0` if and only if `x in range(2)`.\r\n```",
              "createdAt": "2024-08-22T13:39:54Z",
              "updatedAt": "2024-08-22T13:59:06Z"
            },
            {
              "originalPosition": 95,
              "body": "Note that one constant input and one non-constant input is affine\r\n```suggestion\r\ntwo non-constant inputs.) Then each Aggregator can compute its share locally, since\r\n```",
              "createdAt": "2024-08-22T13:40:40Z",
              "updatedAt": "2024-08-22T13:59:06Z"
            },
            {
              "originalPosition": 106,
              "body": "Same as above\r\n```suggestion\r\ncontains multiplication gates with two non-constant inputs. Thus our goal is to\r\n```",
              "createdAt": "2024-08-22T13:42:06Z",
              "updatedAt": "2024-08-22T13:59:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 400,
      "id": "PR_kwDOGKuqOc54Sg06",
      "title": "Use lower case after colon",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/400",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-11"
      ],
      "body": "Closes #396.",
      "createdAt": "2024-08-13T22:55:08Z",
      "updatedAt": "2024-08-14T15:55:02Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "beaaffec1d066157deac9fe6b6367a4eaec2f2f3",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/396",
      "headRefOid": "503958e7f828fc766f9eb76e4f896a177d11afff",
      "closedAt": "2024-08-14T15:55:02Z",
      "mergedAt": "2024-08-14T15:55:02Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "34e248229d68188bc3bf286a7d4857c414a83316"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6FbLqx",
          "commit": {
            "abbreviatedOid": "8cc2d03"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-14T15:16:22Z",
          "updatedAt": "2024-08-14T15:17:59Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I lean towards leaving these occurrences in the changelog as-is, because I view the sentence as starting with \"Allow\", for example, and the \"FLP:\" that comes before it as a label, outside of the sentence structure.",
              "createdAt": "2024-08-14T15:16:22Z",
              "updatedAt": "2024-08-14T15:17:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6FbWdy",
          "commit": {
            "abbreviatedOid": "8cc2d03"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-14T15:28:53Z",
          "updatedAt": "2024-08-14T15:28:53Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Done.",
              "createdAt": "2024-08-14T15:28:53Z",
              "updatedAt": "2024-08-14T15:28:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 401,
      "id": "PR_kwDOGKuqOc54Sj4D",
      "title": "Refer to an instance, not the class in msssage encoding sections",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/401",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "draft-11"
      ],
      "body": "To define message encoding, we need to be able to refer to attributes of the VDAF, e.g., the value of `SHARES`. Previously we referred to the class in this section, e.g., `Prio3`, but since getting rid of the class-factor pattern, it is now necessary to refer to an instance of the class.\r\n\r\nTo make this clear, replace upper case `Prio3` with lowercase `prio3`, to imply that we an instance of a sub-class of `Vdaf` rather than the sub-class itself.",
      "createdAt": "2024-08-13T23:01:38Z",
      "updatedAt": "2024-08-20T01:46:45Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "34e248229d68188bc3bf286a7d4857c414a83316",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/message-encoding-nits",
      "headRefOid": "be7009d526daf6dbb908ee0a1e8e06f467c35496",
      "closedAt": "2024-08-20T01:46:45Z",
      "mergedAt": "2024-08-20T01:46:45Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "8736056c0f655cd66711c932681c76645877191a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6F5RaC",
          "commit": {
            "abbreviatedOid": "1063f7b"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Other candidates:\r\n\r\n- `Prio3.xof.SEED_SIZE` on line 3027\r\n- `Prio3.field.ENCODED_SIZE` on line 3028\r\n- `Prio3.flp.JOINT_RAND_LEN > 0` on line 3044\r\n- `Poplar1.xof.SEED_SIZE` on line 4699\r\n- `Poplar1.idpf.field_inner` on line 4700\r\n- `Poplar1.idpf.field_leaf` on line 4701\r\n\r\nActually, these last two `Fi`/`Fl` aliases should be for `poplar1.idpf.field_inner.ENCODED_SIZE` and `poplar1.idpf.field_leaf.ENCODED_SIZE`, now that I'm looking at it.",
          "createdAt": "2024-08-19T20:17:20Z",
          "updatedAt": "2024-08-19T20:17:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 402,
      "id": "PR_kwDOGKuqOc54SoJZ",
      "title": "Rename FFT to NTT",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/402",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-11"
      ],
      "body": "Closes #398 \r\n\r\n\"Number theoretic transform\" is the term preferred by most cryptographers.\r\n\r\nAlso, remove an out of date comment related to NTT and padding.",
      "createdAt": "2024-08-13T23:18:06Z",
      "updatedAt": "2024-08-20T01:47:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "14edbfb22b356a1daf73a4efb987f594b7f12eb6",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/398",
      "headRefOid": "150dfcfe1fea59095325dd066e40efa4a37c1ff8",
      "closedAt": "2024-08-20T01:47:28Z",
      "mergedAt": "2024-08-20T01:47:28Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "e37da53af7092a9c6c91b4dba6b9c0dc64466dcf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6F5VtA",
          "commit": {
            "abbreviatedOid": "1ddb55b"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-19T20:28:00Z",
          "updatedAt": "2024-08-19T20:42:53Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Should we leave this as-is since it's part of the changelog, or is this fine?",
              "createdAt": "2024-08-19T20:28:00Z",
              "updatedAt": "2024-08-19T20:42:53Z"
            },
            {
              "originalPosition": 36,
              "body": "I think we can delete this note here too",
              "createdAt": "2024-08-19T20:42:20Z",
              "updatedAt": "2024-08-19T20:42:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc6F67yr",
          "commit": {
            "abbreviatedOid": "1ddb55b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-20T01:45:09Z",
          "updatedAt": "2024-08-20T01:45:09Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Good catch. it depends on whether we mention renaming FFT to NTT in the change log: I decided to, so I think we should here. Fixed.",
              "createdAt": "2024-08-20T01:45:09Z",
              "updatedAt": "2024-08-20T01:45:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 403,
      "id": "PR_kwDOGKuqOc54e5jr",
      "title": "Update change log for draft 11",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/403",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-11"
      ],
      "body": "",
      "createdAt": "2024-08-15T16:00:42Z",
      "updatedAt": "2024-08-22T16:19:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "34e248229d68188bc3bf286a7d4857c414a83316",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/draft-11/cl",
      "headRefOid": "836795d844c20fd3c3fc7df864ea7af3c1c6512c",
      "closedAt": "2024-08-22T16:19:15Z",
      "mergedAt": "2024-08-22T16:19:14Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "e5b156fb211934fea9e63f40a1c87b4210bd6611"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6GLiN1",
          "commit": {
            "abbreviatedOid": "836795d"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-21T15:18:54Z",
          "updatedAt": "2024-08-21T15:18:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 404,
      "id": "PR_kwDOGKuqOc546LEm",
      "title": "Bump VERSION to 12 (*)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/404",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-12"
      ],
      "body": "",
      "createdAt": "2024-08-20T21:54:22Z",
      "updatedAt": "2024-08-23T22:05:25Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "e37da53af7092a9c6c91b4dba6b9c0dc64466dcf",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/draft-12/1-ver",
      "headRefOid": "4b89b0ac1d65998eee404815f2d7ef01cb0fcd0f",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc6GmOit",
          "commit": {
            "abbreviatedOid": "4b89b0a"
          },
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-23T22:05:25Z",
          "updatedAt": "2024-08-23T22:05:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 405,
      "id": "PR_kwDOGKuqOc546LRo",
      "title": "idpf: Use XofTurboShake128 for the leaf nodes (*)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/405",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-12"
      ],
      "body": "Based on #404.\r\nCloses #341.\r\n\r\nThis is a safer choice for ensuring the IDPF is extracatible.",
      "createdAt": "2024-08-20T21:55:16Z",
      "updatedAt": "2024-08-22T16:25:50Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "cjpatton/draft-12/1-ver",
      "baseRefOid": "4b89b0ac1d65998eee404815f2d7ef01cb0fcd0f",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/draft-12/2-idpf-leaf-xof",
      "headRefOid": "a27581ddd023b0b1fb1d3b0ef700d1a7070bfd70",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 406,
      "id": "PR_kwDOGKuqOc546LvD",
      "title": "Improve circuit for `Prio3Sum` (*)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/406",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-12"
      ],
      "body": "Based on #405.\r\nCloses #306.\r\n\r\nReplace `Sum` with `SumOfRangeCheckedInputs`. The new circuit has two improvements:\r\n\r\n1. No joint randomness is used, so it's safe to use a smaller field.\r\n\r\n2. The largest measurement can be any positive integer, not just a power of two.\r\n\r\nUpdate `Prio3Sum` accordingly by switching from `Field128` to `Field64`.",
      "createdAt": "2024-08-20T21:57:17Z",
      "updatedAt": "2024-08-22T16:26:04Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "cjpatton/draft-12/2-idpf-leaf-xof",
      "baseRefOid": "a27581ddd023b0b1fb1d3b0ef700d1a7070bfd70",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/draft-12/3-issue-306",
      "headRefOid": "bad646dd7a478c65f472fcb0a34bb69c160b7ab4",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 407,
      "id": "PR_kwDOGKuqOc546Mn7",
      "title": "Prio3: Double the length of the joint randomness seed (*)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/407",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-12"
      ],
      "body": "Based on #406.\r\nCloses #319.\r\n\r\nA robustness attacker can try to find two distinct reports that derive the joint randomness seed by an offline birthday attack. By increasing the seed size from 16 to 32 bytes, we ensure this probability is negligible (in the random oracle model) even when the attacker can do a lot of computation (make many random oracle queries).",
      "createdAt": "2024-08-20T22:00:49Z",
      "updatedAt": "2024-08-21T17:46:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "cjpatton/draft-12/3-issue-306",
      "baseRefOid": "bad646dd7a478c65f472fcb0a34bb69c160b7ab4",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/draft-12/4-larger-joint-rand-seed",
      "headRefOid": "0e241f9c14452d9cb63dc0e74522a79b280e62cf",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Wouldn't we need to make joint randomness hints 32 bytes as well? I think a similar offline birthday attack could be mounted against either seed derivation, whether it be the input share => joint randomness hint RO call, or the joint randomness hints => joint randomness seed RO call.",
          "createdAt": "2024-08-21T15:47:30Z",
          "updatedAt": "2024-08-21T15:47:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> Wouldn't we need to make joint randomness hints 32 bytes as well? I think a similar offline birthday attack could be mounted against either seed derivation, whether it be the input share => joint randomness hint RO call, or the joint randomness hints => joint randomness seed RO call.\r\n\r\n@hannahdaviscrypto can correct me if I'm wrong, but I believe the reasoning here is that you have to find a collision on the entire vector of hints, of which there are at least 2 (`SHARES >= 2`). Since the seed sizes is `16`, that's at least `2*16` bytes. Does this make sense or am I missing something?",
          "createdAt": "2024-08-21T16:23:44Z",
          "updatedAt": "2024-08-21T16:23:44Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "You could still hold one input share constant, and then search for a collision in the other hint. That will randomize your measurement, though. I'm not sure whether it's feasible to mount an attack starting from such a joint randomness collision, with two different measurements. Intuitively, I think it would make sense to account for random oracle collision on both queries to be safe. ",
          "createdAt": "2024-08-21T16:48:15Z",
          "updatedAt": "2024-08-21T16:48:15Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> You could still hold one input share constant, and then search for a collision in the other hint. That will randomize your measurement, though. I'm not sure whether it's feasible to mount an attack starting from such a joint randomness collision, with two different measurements. Intuitively, I think it would make sense to account for random oracle collision on both queries to be safe.\r\n\r\nWell, you still have to cause a collision on the first hint, right? You have to get lucky twice: you first find a collision on the first hint (i.e., part), then you fix that measurement share and blind, then you find the measurement share and blind for the other aggregator that causes a collision for the second hint.",
          "createdAt": "2024-08-21T16:58:17Z",
          "updatedAt": "2024-08-21T16:58:17Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm, good points, I had forgotten that the attacker can search by just changing the blind, not necessarily the input share. I'm also not sure at the moment how you would build an entire robustness attack from a birthday attack on the joint randomness seed. However, I still don't see why the same attack pattern couldn't build on a birthday attack on one joint randomness part. If you keep all inputs for one hint fixed, then the birthday attack on the other hint has a cost of $2^{128/2}$ queries. If you do two separate birthday attacks on both hints as you say, then that has a cost of $2^{1+128/2}$ queries, which is not much better.",
          "createdAt": "2024-08-21T17:21:36Z",
          "updatedAt": "2024-08-21T17:21:36Z"
        },
        {
          "author": "hannahdaviscrypto",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think a similar offline birthday attack could be mounted against either seed derivation, whether it be the input share => joint randomness hint RO call, or the joint randomness hints => joint randomness seed RO call.\r\n\r\nMaking the joint randomness seed 32 bytes covers the second case here, and a collision in the first case only matters if all hints collide, as Chris said. So the advantage of an attack that searches for collisions one-at-a-time is going to be on the order of q^4/2^256 for two aggregators, and drop more as the number of aggregators increases. That said, the attack wouldn't have to randomize the measurement share; it could fix the nonces and measurement shares and just search among blinds to find collisions (as long as we have three seeds, not one as in the other proposed change). ",
          "createdAt": "2024-08-21T17:21:52Z",
          "updatedAt": "2024-08-21T17:21:52Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> > I think a similar offline birthday attack could be mounted against either seed derivation, whether it be the input share => joint randomness hint RO call, or the joint randomness hints => joint randomness seed RO call.\r\n> \r\n> Making the joint randomness seed 32 bytes covers the second case here, and a collision in the first case only matters if all hints collide, as Chris said. So the advantage of an attack that searches for collisions one-at-a-time is going to be on the order of q^4/2^256 for two aggregators, and drop more as the number of aggregators increases. That said, the attack wouldn't have to randomize the measurement share; it could fix the nonces and measurement shares and just search among blinds to find collisions (as long as we have three seeds, not one as in the other proposed change).\r\n\r\nWhy $q^4$? This being the case, we definitely need to bump the joint randomness hints. At which point I wonder if we should just bump all seeds to 32 bytes, for consistency if nothing else.",
          "createdAt": "2024-08-21T17:46:34Z",
          "updatedAt": "2024-08-21T17:46:34Z"
        }
      ],
      "reviews": []
    }
  ]
}