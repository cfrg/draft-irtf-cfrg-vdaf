"""Definition of DAFs."""

from __future__ import annotations
from common import Bool, Bytes, Error, Unsigned, Vec, gen_rand
from functools import reduce
import sagelib.field as field
from sagelib.prg import PrgSha3
import json


class Daf:
    """A DAF"""

    # Algorithm identifier for this DAF, a 32-bit integer.
    ID: Unsigned = None

    # The number of Aggregators.
    SHARES: Unsigned = None

    # Number of random bytes consumed by `measurement_to_input_shares()`.
    RAND_SIZE = None

    # The measurement type.
    Measurement = None

    # The aggregation parameter type.
    AggParam = None

    # The output share type.
    OutShare = None

    # The aggregate result type.
    AggResult = None

    @classmethod
    def measurement_to_input_shares(Daf,
                                    measurement: Measurement,
                                    rand: Bytes["Daf.RAND_SIZE"],
                                    ) -> tuple[Bytes, Vec[Bytes]]:
        """
        Shard a measurement into a "public share" and a sequence of input
        shares, one for each Aggregator. This method is run by the Client.
        """
        raise Error('not implemented')

    @classmethod
    def is_valid(Daf, agg_param: AggParam,
                 previous_agg_params: Vec[AggParam]) -> Bool:
        """
        Check if `agg_param` is valid for use with an input share that has
        previously been used with all `previous_agg_params`.
        """
        raise Error('not implemented')

    @classmethod
    def prep(Daf,
             agg_id: Unsigned,
             agg_param: AggParam,
             public_share: Bytes,
             input_share: Bytes) -> OutShare:
        """
        Prepare an input share for aggregation. This algorithm takes as input
        the public share and one of the input shares generated by the Client. It
        also takes the Aggregator's ID (a unique integer in range `[0, SHARES)`
        corresponding to the index of `input_share` in the Client's output), and
        an aggreation parameter and returns the corresponding output share.
        """
        raise Error('not implemented')

    @classmethod
    def out_shares_to_agg_share(Daf,
                                agg_param: AggParam,
                                out_shares: Vec[OutShare]) -> Bytes:
        """
        Merge a list of output shares into an aggregate share, encoded as a byte
        string. This is called by an Aggregator after recovering a batch of
        output shares.
        """
        raise Error('not implemented')

    @classmethod
    def agg_shares_to_result(Daf,
                             agg_param: AggParam,
                             agg_shares: Vec[Bytes],
                             num_measurements: Unsigned) -> AggResult:
        """
        Unshard the aggregate shares (encoded as byte strings) and compute the
        aggregate result. This is called by the Collector.
        """
        raise Error('not implemented')


def run_daf(Daf,
            agg_param: Daf.AggParam,
            measurements: Vec[Daf.Measurement]):
    """Run a DAF on a list of measurements."""
    out_shares = [ [] for j in range(Daf.SHARES) ]
    for measurement in measurements:
        # Each Client shards its measurement into input shares and
        # distributes them among the Aggregators.
        rand = gen_rand(Daf.RAND_SIZE)
        (public_share, input_shares) = \
            Daf.measurement_to_input_shares(measurement, rand)

        # Each Aggregator prepares its input share for aggregation.
        for j in range(Daf.SHARES):
            out_shares[j].append(
                Daf.prep(j, agg_param, public_share, input_shares[j]))

    # Each Aggregator aggregates its output shares into an aggregate
    # share and sends it to the Collector.
    agg_shares = []
    for j in range(Daf.SHARES):
        agg_share_j = Daf.out_shares_to_agg_share(agg_param,
                                                  out_shares[j])
        agg_shares.append(agg_share_j)

    # Collector unshards the aggregate result.
    num_measurements = len(measurements)
    agg_result = Daf.agg_shares_to_result(agg_param, agg_shares,
                                          num_measurements)
    return agg_result


##
# TESTS
#

class TestDaf(Daf):
    """A simple DAF used for testing."""

    # Operational parameters
    Field = field.Field128

    # Associated parameters
    ID = 0xFFFFFFFF
    SHARES = 2
    RAND_SIZE = 16

    # Associated types
    OutShare = Vec[Field]
    Measurement = Unsigned
    AggResult = Vec[Unsigned]

    @classmethod
    def measurement_to_input_shares(cls, measurement, rand):
        helper_shares = PrgSha3.expand_into_vec(cls.Field,
                                                rand,
                                                b'',
                                                b'',
                                                cls.SHARES-1)
        leader_share = cls.Field(measurement)
        for helper_share in helper_shares:
            leader_share -= helper_share
        input_shares = [cls.Field.encode_vec([leader_share])]
        for helper_share in helper_shares:
            input_shares.append(cls.Field.encode_vec([helper_share]))
        return (b'dummy public share', input_shares)

    @classmethod
    def prep(cls, _agg_id, _agg_param, _public_share, input_share):
        # For this simple test DAF, the output share is the same as the input
        # share.
        return cls.Field.decode_vec(input_share)

    @classmethod
    def out_shares_to_agg_share(cls, _agg_param, out_shares):
        return cls.Field.encode_vec(
            reduce(lambda x, y: [x[0] + y[0]], out_shares))

    @classmethod
    def agg_shares_to_result(cls, _agg_param, agg_shares, _num_measurements):
        return [reduce(lambda x, y: [x[0] + y[0]],
            map(lambda encoded: cls.Field.decode_vec(encoded),
                agg_shares))[0].as_unsigned()]


def test_daf(Daf,
             agg_param,
             measurements,
             expected_agg_result):
    # Test that the algorithm identifier is in the correct range.
    assert 0 <= Daf.ID and Daf.ID < 2 ** 32

    # Run the DAF on the set of measurements.
    agg_result = run_daf(Daf,
                         agg_param,
                         measurements)
    if agg_result != expected_agg_result:
        print('vdaf test failed ({} on {}): unexpected result: got {}; want {}'.format(
            Daf.__classname__, measurements, agg_result, expected_agg_result))


if __name__ == '__main__':
    test_daf(TestDaf, None, [1, 2, 3, 4], [10])
