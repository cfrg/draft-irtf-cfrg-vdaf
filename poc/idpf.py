"""Definition of IDPFs."""

from __future__ import annotations

from typing import Tuple, Union

import field
from common import Bool, Bytes, Unsigned


class Idpf:
    """An Incremental Distributed Point Function (IDPF)."""

    # Number of keys generated by the IDPF-key generation algorithm.
    SHARES: Unsigned = None

    # Bit length of valid input values (i.e., the length of `alpha` in bits).
    BITS: Unsigned = None

    # The length of each output vector (i.e., the length of `beta_leaf` and
    # each element of `beta_inner`).
    VALUE_LEN: Unsigned = None

    # Size in bytes of each IDPF key share.
    KEY_SIZE: Unsigned = None

    # Number of random bytes consumed by the `gen()` algorithm.
    RAND_SIZE: Unsigned = None

    # The finite field used to represent the inner nodes of the IDPF tree.
    FieldInner: field.Field = None

    # The finite field used to represent the leaf nodes of the IDPF tree.
    FieldLeaf: field.Field = None

    # Type alias for the output of `eval()`.
    Output = Union[list[list[FieldInner]],
                   list[list[FieldLeaf]]]

    # Type alias for a vector over the inner or leaf field.
    FieldVec = Union[list[FieldInner], list[FieldLeaf]]

    @classmethod
    def gen(Idpf,
            alpha: Unsigned,
            beta_inner: list[list[Idpf.FieldInner]],
            beta_leaf: list[Idpf.FieldLeaf],
            binder: bytes,
            rand: bytes["Idpf.RAND_SIZE"]) -> Tuple[bytes, list[bytes]]:
        """
        Generates an IDPF public share and sequence of IDPF-keys of length
        `SHARES`. Value `alpha` is the input to encode. Values `beta_inner` and
        `beta_leaf` are assigned to the values of the nodes on the non-zero
        path of the IDPF tree. String `binder` is a binder string.

        An error is raised if integer `alpha` is larger than or equal to
        `2^BITS`, any elment of `beta_inner` has length other than `VALUE_LEN`,
        or if `beta_leaf` has length other than `VALUE_LEN`.
        """
        raise NotImplementedError()

    @classmethod
    def eval(Idpf,
             agg_id: Unsigned,
             public_share: Bytes,
             key: Bytes,
             level: Unsigned,
             prefixes: Tuple[Unsigned, ...],
             binder: Bytes) -> Output:
        """
        Evaluate an IDPF key at a given level of the tree and with the given
        set of prefixes. The output is a vector where each element is a vector
        of length `VALUE_LEN`. The output field is `FieldLeaf` if `level ==
        BITS` and `FieldInner` otherwise. `binder` must match the binder string
        passed by the Client to `gen`.

        Let `LSB(x, N)` denote the least significant `N` bits of positive
        integer `x`. By definition, a positive integer `x` is said to be the
        length-`L` prefix of positive integer `y` if `LSB(x, L)` is equal to
        the most significant `L` bits of `LSB(y, BITS)`, For example, 6 (110 in
        binary) is the length-3 prefix of 25 (11001), but 7 (111) is not.

        Each element of `prefixes` is an integer in `[0, 2^level)`. For each
        element of `prefixes` that is the length-`level` prefix of the input
        encoded by the IDPF-key generation algorithm (i.e., `alpha`), the sum
        of the corresponding output shares will be equal to one of the
        programmed output vectors (i.e., an element of `beta_inner +
        [beta_leaf]`). For all other elements of `prefixes`, the corresponding
        output shares will sum up to the 0-vector.

        An error is raised if any element of `prefixes` is larger than or equal
        to `2^level` or if `level` is greater than `BITS`.
        """
        raise NotImplementedError()

    @classmethod
    def current_field(Idpf, level):
        return Idpf.FieldInner if level < Idpf.BITS-1 \
            else Idpf.FieldLeaf

    @classmethod
    def is_prefix(Idpf, x: Unsigned, y: Unsigned, L: Unsigned) -> Bool:
        """Returns `True` iff `x` is the prefix of `y` of length `L`."""
        assert 0 < L and L <= Idpf.BITS
        return y >> (Idpf.BITS - L) == x
