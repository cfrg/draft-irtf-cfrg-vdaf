"""Definition of IDPFs."""

from __future__ import annotations

from typing import Union

import field


class Idpf:
    """An Incremental Distributed Point Function (IDPF)."""

    # Number of keys generated by the IDPF-key generation algorithm.
    SHARES: int = None

    # Bit length of valid input values (i.e., the length of `alpha` in bits).
    BITS: int = None

    # The length of each output vector (i.e., the length of `beta_leaf` and
    # each element of `beta_inner`).
    VALUE_LEN: int = None

    # Size in bytes of each IDPF key share.
    KEY_SIZE: int = None

    # Number of random bytes consumed by the `gen()` algorithm.
    RAND_SIZE: int = None

    # The finite field used to represent the inner nodes of the IDPF tree.
    FieldInner: field.Field = None

    # The finite field used to represent the leaf nodes of the IDPF tree.
    FieldLeaf: field.Field = None

    # Type alias for the output of `eval()`.
    Output = Union[list[list[FieldInner]],
                   list[list[FieldLeaf]]]

    # Type alias for a vector over the inner or leaf field.
    FieldVec = Union[list[FieldInner], list[FieldLeaf]]

    @classmethod
    def gen(Idpf,
            alpha: int,
            beta_inner: list[list[Idpf.FieldInner]],
            beta_leaf: list[Idpf.FieldLeaf],
            binder: bytes,
            rand: bytes) -> tuple[bytes, list[bytes]]:
        """
        Generates an IDPF public share and sequence of IDPF-keys of length
        `SHARES`. Input `alpha` is the index to encode. Inputs `beta_inner` and
        `beta_leaf` are assigned to the values of the nodes on the non-zero
        path of the IDPF tree. String `binder` is a binder string.

        Pre-conditions:

            - `alpha` in `range(2**BITS)`
            - `len(beta_inner) == Idpf.BITS - 1`
            - `len(beta_inner[level]) == Idpf.VALUE_LEN` for each `level` in
              `range(Idpf.BITS - 1)`
            - `len(beta_leaf) == Idpf.VALUE_LEN`
            - `len(rand) == Idpf.RAND_SIZE`
        """
        raise NotImplementedError()

    @classmethod
    def eval(Idpf,
             agg_id: int,
             public_share: bytes,
             key: bytes,
             level: int,
             prefixes: tuple[int, ...],
             binder: bytes) -> Output:
        """
        Evaluate an IDPF key share public share at a given level of the tree
        and with the given sequence of prefixes. The output is a vector where
        each element is a vector of length `VALUE_LEN`. The output field is
        `FieldLeaf` if `level == BITS` and `FieldInner` otherwise. `binder`
        must match the binder string passed by the Client to `gen`.

        Let `LSB(x, L)` denote the least significant `L` bits of positive
        integer `x`. By definition, a positive integer `x` is said to be the
        length-`L` prefix of positive integer `y` if `LSB(x, L)` is equal to
        the most significant `L` bits of `LSB(y, BITS)`, For example, 6 (110 in
        binary) is the length-3 prefix of 25 (11001), but 7 (111) is not.

        Each element of `prefixes` is an integer in `[0, 2^level)`. For each
        element of `prefixes` that is the length-`level` prefix of the input
        encoded by the IDPF-key generation algorithm (i.e., `alpha`), the sum
        of the corresponding output shares will be equal to one of the
        programmed output vectors (i.e., an element of `beta_inner +
        [beta_leaf]`). For all other elements of `prefixes`, the corresponding
        output shares will sum up to the 0-vector.

        Pre-conditions:

            - `agg_id` in `range(Idpf.SHARES)`
            - `level` in `range(Idpf.BITS)`
            - `prefix` in `range(2**level)` for each `prefix` in `prefixes`
        """
        raise NotImplementedError()

    @classmethod
    def current_field(Idpf, level):
        return Idpf.FieldInner if level < Idpf.BITS-1 \
            else Idpf.FieldLeaf

    @classmethod
    def is_prefix(Idpf, x: int, y: int, level: int) -> bool:
        """
        Returns `True` iff `x` is the prefix of `y` at level `level`.

        Pre-conditions:

            - `level` in `range(Idpf.BITS)`
        """
        return y >> (Idpf.BITS - 1 - level) == x
