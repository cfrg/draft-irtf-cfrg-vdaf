<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>Verifiable Distributed Aggregation Functions</title>
<meta content="Richard L. Barnes" name="author">
<meta content="David Cook" name="author">
<meta content="Christopher Patton" name="author">
<meta content="Phillipp Schoppmann" name="author">
<meta content="
       This document describes Verifiable Distributed Aggregation Functions (VDAFs), a
family of multi-party protocols for computing aggregate statistics over user
measurements. These protocols are designed to ensure that, as long as at least
one aggregation server executes the protocol honestly, individual measurements
are never seen by any server in the clear. At the same time, VDAFs allow the
servers to detect if a malicious or misconfigured client submitted an invalid
measurement. Two concrete VDAFs are specified, one for general-purpose
aggregation (Prio3) and another for heavy hitters (Poplar1). 
    " name="description">
<meta content="xml2rfc 3.30.0" name="generator">
<meta content="Internet-Draft" name="keyword">
<meta content="draft-irtf-cfrg-vdaf-latest" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.30.0
    Python 3.12.11
    ConfigArgParse 1.7
    google-i18n-address 3.1.1
    intervaltree 3.1.0
    Jinja2 3.1.6
    lxml 5.3.1
    platformdirs 4.3.8
    pycountry 24.6.1
    PyYAML 6.0.2
    requests 2.32.4
    setuptools 80.9.0
    wcwidth 0.2.13
-->
<link href="draft-irtf-cfrg-vdaf.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}

@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Lora SemiBold'), local('Lora-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-semibold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C8A, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-cyrillic.woff2') format('woff2');
  unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-greek.woff2') format('woff2');
  unicode-range: U+0370-0377, U+037A-037F, U+0384-038A, U+038C, U+038E-03A1, U+03A3-03FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C8A, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-cyrillic.woff2') format('woff2');
  unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-greek.woff2') format('woff2');
  unicode-range: U+0370-0377, U+037A-037F, U+0384-038A, U+038C, U+038E-03A1, U+03A3-03FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

:root {
  color-scheme: light dark;
  --background-color: #fff;
  --text-color: #222;
  --title-color: #191919;
  --link-color: #2a6496;
  --highlight-color: #f9f9f9;
  --line-color: #eee;
  --pilcrow-weak: #ddd;
  --pilcrow-strong: #bbb;
  --small-font-size: 14.5px;
  --font-mono: 'Oxygen Mono', monospace;
  --font-title: "Sofia Sans Semi Condensed", sans-serif;
  scrollbar-color: #bbb #eee;
}
body {
  max-width: 600px;
  margin: 75px auto;
  padding: 0 5px;
  color: var(--text-color);
  background-color: var(--background-color);
  font: 16px/22px "Lora", serif;
  scroll-behavior: smooth;
}

.ears {
  display: none;
}

/* headings */
section {
  clear: both;
}
.section-number {
  padding-right: 0.5em;
}
h1, h2, h3, h4, h5, h6 {
  font-family: var(--font-title);
  font-weight: 680;
  margin: 0.8em 0 0.3em;
  font-size-adjust: 0.5;
  color: var(--title-color);
}
h1#title {
  font-size: 32px;
  line-height: 40px;
  clear: both;
}
h1#title, h1#rfcnum {
  margin: 1.5em 0 0.2em;
}
h1#rfcnum + h1#title {
  margin: 0.2em 0;
}

h1, h2, h3 {
  font-size: 22px;
  line-height: 27px;
}
h4, h5, h6 {
  font-size: 20px;
  line-height: 24px;
}

/* general structure */
.author {
  padding-bottom: 0.3em;
  vertical-align: top;
}
#abstract+p {
  font-size: 18px;
  line-height: 24px;
}
#abstract+p code, #abstract+p samp, #abstract+p tt {
  font-size: 16px;
  line-height: 0;
}

p {
  padding: 0;
  margin: 0.5em 0;
  text-align: left;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignRight.art-text pre {
  padding: 0;
  width: auto;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
/* font-family isn't space-separated, but =~ will have to do */
svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
  font-family: var(--font-mono);
}
.alignCenter.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignCenter.art-text pre {
  padding: 0;
  width: auto;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 0.5em 2em;
  & :is(ol, ul) {
    margin-left: 1em;
  }
}
li {
  margin: 0 0 0.25em 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
  & li {
    margin-top: 0.5em;
  }
}
:is(ul, ol).compact, .ulCompact, .olCompact {
  margin: 0 0 0 2em;
  & li {
    margin: 0;
    & :first-child { margin-top: 0; }
    & :last-child { margin-bottom: 0; }
  }
}

/* definition lists */
dl {
  clear: left;
  --indent: 3ch;
  /* --indent: attr(indent ch); not supported in any browser, but we can dream */
  &.olPercent {
    --indent: 5ch;
    & > dt {
      min-width: calc(var(--indent) - 2ch);
    }
  }
  &.olPercent > dt {
    float: none;
  }

  dl > dd > & {
    margin-top: 0.5em;
    margin-bottom: 0;
  }
}
dl:not(.dlNewline) > dt {
  float: left;
  margin-right: 2ch;
  min-width: 8ch;
}
dl > dd {
  margin-bottom: .8em;
  margin-left: var(--indent) !important; /* stupid element overrides */
  min-height: 2ex;
}
:is(dl.compact, .dlCompact) > dd {
  margin-bottom: 0;
  & > :is(:first-child, .break:first-child + *) {
    margin-top: 0;
  }
  & > :is(:last-child) {
    margin-bottom: 0;
  }
}
:is(dd, span).break {
  display: none;
}

/* links */
a, a[href].selfRef:hover {
  text-decoration: none;
}
a[href] {
  color: var(--link-color);
}
a[href].selfRef, .iref + a[href].internal {
  color: var(--text-color);
}
a[href]:hover {
  text-decoration: underline;
}
a[href].selfRef:hover {
  background-color: var(--highlight-color);
}
a.xref:is(.cite, .auto), :is(#status-of-memo, #copyright) a {
  white-space: nowrap;
}

/* Figures */
tt, code, pre {
  background-color: var(--highlight-color);
  font: 14px/22px var(--font-mono);
}
tt, code {
  /* changing the font for inline elements leads to different ascender
     and descender heights; as we want to retain baseline alignment,
     remove leading to avoid altering the final height of lines
     note: this fails if these blocks take an entire line,
     a different solution would be great */
  line-height: 0;
}
:is(h1, h2, h3, h4, h5, h6) :is(tt, code) {
  font-size: 84%;
}
pre {
  border: 1px solid var(--line-color);
  font-size: 13.5px;
  line-height: 16px;
  letter-spacing: -0.2px;
  margin: 5px;
  padding: 5px;
}
img {
  max-width: 100%;
}
figure {
  margin: 0.5em 0;
  padding: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption, caption {
  font-style: italic;
  margin: 0.5em 1.5em;
  text-align: left;
  caption-side: bottom;
}
@media screen {
  /* Auto-collapse boilerplate. */
  :is(#status-of-memo, #copyright) p {
    margin: -2px 0;
    max-height: 0;
    transition: max-height 2s ease, margin 0.5s ease 0.5s;
    overflow: hidden;
  }
  :is(#status-of-memo, #copyright):hover p,
  :is(#status-of-memo, #copyright) h2:target ~ p {
    margin: 0.5em 0;
    max-height: 500px;
    overflow: auto;
  }
  pre, svg {
    display: inline-block;
    /* In the horizontal direction, sometimes people make over-sized figures.
       Scrollbars for those is therefore necessary: auto adds them as necessary..
       In the vertical direction, the line-height can combine with the font
       asender/descender height to produce scrollbars: hidden avoids that. */
    overflow: auto hidden;
  }
  pre {
    max-width: 100%;
    width: calc(100% - 22px - 1em);
  }
  svg {
    max-width: calc(100% - 22px - 1em);
  }
  figure pre {
    display: block;
    width: calc(100% - 25px);
  }
  :is(pre, svg) + .pilcrow {
    display: inline-block;
    vertical-align: text-bottom;
    padding-bottom: 8px;
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 0 2em;
  font-style: italic;
}
blockquote {
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: auto;
  max-width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
}
table.right {
  margin-left: auto;
}
table.center {
  margin-left: auto;
  margin-right: auto;
}
table.left {
  margin-right: auto;
}
table .text-left {
  text-align: left;
}
table .text-center {
  text-align: center;
}
table .text-right {
  text-align: right;
}

thead, tbody {
  border: 1px solid var(--line-color);
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 5px 10px;
}
th {
  background-color: var(--line-color);
}
:is(tr:nth-child(2n), thead+tbody > tr:nth-child(2n+1)) > td {
  background-color: var(--background-color);
}
:is(tr:nth-child(2n+1), thead+tbody > tr:nth-child(2n)) > td {
  background-color: var(--highlight-color);
}
table caption {
  margin: 0;
  padding: 3px 0 3px 1em;
}
table p {
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  margin-left: 3px;
  opacity: 0.2;
  user-select: none;
  &[href] {
    color: var(--pilcrow-weak);
    &:hover { text-decoration: none; }
  }
}
@media not print {
  :hover > a.pilcrow {
    opacity: 1;
  }
  a.pilcrow[href]:hover {
    color: var(--pilcrow-strong);
    background-color: transparent;
  }
}
@media print {
  a.pilcrow {
    display: none;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid var(--line-color);
}
.bcp14 {
  font-variant: small-caps;
  font-weight: 600;
  font-size: var(--small-font-size);
}
.role {
  font-variant: all-small-caps;
}
sub, sup {
  line-height: 1;
  font-size: 80%;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: var(--small-font-size);
  line-height: 18px;
  --identifier-width: 15ch;
  & dt {
    width: var(--identifier-width);
    min-width: var(--identifier-width);
    clear: left;
    float: left;
    text-align: right;
    margin-right: 1ch;
  }
  & dd {
    margin: 0;
    margin-left: calc(1em + var(--identifier-width)) !important;
    min-width: 5em;
  }
  & .authors {
    & .author {
      display: inline-block;
      margin-right: 1.5em;
    }
    & .org {
      font-style: italic;
    }
  }
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #999;
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;

  & nav {
    & ul {
      margin: 0 0.5em 0 0;
      padding: 0;
      list-style: none;
    }
    & li {
      line-height: 1.3em;
      margin: 2px 0;
      padding-left: 1.2em;
      text-indent: -1.2em;
    }
  }
  & a.xref {
    white-space: normal;
  }
}

.references {
  & > dt {
    text-align: right;
    font-weight: bold;
    min-width: 10ch;
    margin-right: 1.5ch;
    &:target::before {
      content: "⇒";
      margin: 0 10px 0 -25px;
    }
  }
  & > dd {
    margin-left: 12ch !important;
    overflow: visible;
    & .refInstance {
      margin-bottom: 0.8em;
    }
    & .ascii {
      margin-bottom: 0.25em;
    }
  }
}

#rfc\.index\.index + ul {
  margin-left: 0;
}

/* authors */
address.vcard {
  font-style: normal;
  max-width: 20em;
  margin: 1em auto 1em 0;

  & .nameRole {
    font-weight: 700;
    margin-left: 0;
  }
  & .label {
    margin: 0.5em 0;
  }
  & .type {
    display: none;
  }
  & .alternative-contact {
    margin: 0.5em 0 0.25em 0;
  }
  & .non-ascii {
    margin: 0 0 0 2em;
  }
  & div.left {
    text-align: left;
  }
  & div.right {
    text-align: right;
  }
}

hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}
@media (min-width: 500px) {
  #authors-addresses > section {
    column-count: 2;
    column-gap: 20px;
  }
  #authors-addresses > section > h2 {
    column-span: all;
  }
  /* hack for break-inside: avoid-column */
  #authors-addresses address {
    display: inline-block;
    break-inside: avoid-column;
  }
}

/* Comments */
.rfcEditorRemove p:first-of-type {
  font-style: italic;
}
.cref {
  background-color: rgba(249, 232, 105, 0.3);
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}

@media screen {
  #toc nav {
    font-family: var(--font-title);
    font-weight: 360;
    & > ul { margin-bottom: 2em; }
    & ul {
      margin: 0 0 0 4px;
      & :is(p, li) {
        margin: 2px 0;
      }
    }
  }
  #toc a.toplink {
    float: right;
  }
}
@media not screen {
  #toc a.toplink {
    display: none;
  }
}


/* TOC layout for smaller screens */
@media screen and (max-width: 929px) {
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 1px 0 0 0;
    margin: 0;
    border-bottom: 1px solid #ccc;
    opacity: 0.6;
  }
  #toc h2 {
    margin: 0;
    padding: 2px 0 2px 6px;
    padding-right: 1em;
    font-size: 18px;
    line-height: 24px;
    min-width: 190px;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
    &::before { /* css hamburger */
      float: right;
      position: relative;
      width: 1em;
      height: 1px;
      left: -164px;
      margin: 8px 0 0 0;
      background: white none repeat scroll 0 0;
      box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
      content: "";
    }
  }
  #toc nav {
    display: none;
    background-color: var(--background-color);
    padding: 0.5em 1em 1em;
    overflow: auto;
    overscroll-behavior: contain;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
  #toc.active {
    opacity: 1;
    & nav { display: block; }
  }
  /* Make the collapsed ToC header render white on gray also when it's a link */
  #toc h2 a,
  #toc h2 a:is(:link, :focus, :hover),
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
  #toc a.toplink {
    margin: 2px 0.5em 0;
  }
}

/* TOC layout for wide screens */
@media screen and (min-width: 930px) {
  body {
    padding-right: 360px;
    padding-right: calc(min(180px + 20%, 500px));
  }
  #toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 480px);
    width: 312px;
    margin: 0;
    padding: 0;
    z-index: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 2em;
    overflow: auto;
    overscroll-behavior: contain;
    scrollbar-width: thin;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
  #toc a.toplink {
    margin: 8px 0.5em 0;
  }
}

/* pagination */
@media print {
  body {
    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre, .vcard {
    page-break-inside: avoid;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  :is(h2, h3, h4, h5, h6)+*, dd {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
}

/* Dark mode. */
@media (prefers-color-scheme: dark) {
:root {
  --background-color: #121212;
  --text-color: #f0f0f0;
  --title-color: #fff;
  --link-color: #4da4f0;
  --highlight-color: #282828;
  --line-color: #444;
  --pilcrow-weak: #444;
  --pilcrow-strong: #666;
  scrollbar-color: #777 #333;
}
}

/* SVG Trick: a prefix match works because only black and white are allowed */
svg :is([stroke="black"], [stroke^="#000"]) {
  stroke: var(--text-color);
}
svg :is([stroke="white"], [stroke^="#fff"]) {
  stroke: var(--background-color);
}
svg :is([fill="black"], [fill^="#000"], :not([fill])) {
  fill: var(--text-color);
}
svg :is([fill="white"], [fill^="#fff"]) {
  fill: var(--background-color);
}
</style>

</head>
<body class="xml2rfc">
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">VDAF</td>
<td class="right">August 2025</td>
</tr></thead>
<tfoot><tr>
<td class="left">Barnes, et al.</td>
<td class="center">Expires 22 February 2026</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">CFRG</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-irtf-cfrg-vdaf-latest</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2025-08-21" class="published">21 August 2025</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Informational</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2026-02-22">22 February 2026</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">R. L. Barnes</div>
<div class="org">Cisco</div>
</div>
<div class="author">
      <div class="author-name">D. Cook</div>
<div class="org">ISRG</div>
</div>
<div class="author">
      <div class="author-name">C. Patton</div>
<div class="org">Cloudflare</div>
</div>
<div class="author">
      <div class="author-name">P. Schoppmann</div>
<div class="org">Google</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">Verifiable Distributed Aggregation Functions</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This document describes Verifiable Distributed Aggregation Functions (VDAFs), a
family of multi-party protocols for computing aggregate statistics over user
measurements. These protocols are designed to ensure that, as long as at least
one aggregation server executes the protocol honestly, individual measurements
are never seen by any server in the clear. At the same time, VDAFs allow the
servers to detect if a malicious or misconfigured client submitted an invalid
measurement. Two concrete VDAFs are specified, one for general-purpose
aggregation (Prio3) and another for heavy hitters (Poplar1).<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<section class="note rfcEditorRemove" id="section-note.1">
      <h2 id="name-discussion-venues">
<a href="#name-discussion-venues" class="section-name selfRef">Discussion Venues</a>
      </h2>
<p id="section-note.1-1">This note is to be removed before publishing as an RFC.<a href="#section-note.1-1" class="pilcrow">¶</a></p>
<p id="section-note.1-2">Discussion of this document takes place on the
    Crypto Forum Research Group mailing list (cfrg@ietf.org),
    which is archived at <span><a href="https://mailarchive.ietf.org/arch/search/?email_list=cfrg">https://mailarchive.ietf.org/arch/search/?email_list=cfrg</a></span>.<a href="#section-note.1-2" class="pilcrow">¶</a></p>
<p id="section-note.1-3">Source for this draft and an issue tracker can be found at
    <span><a href="https://github.com/cfrg/draft-irtf-cfrg-vdaf">https://github.com/cfrg/draft-irtf-cfrg-vdaf</a></span>.<a href="#section-note.1-3" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 22 February 2026.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2025 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="auto internal xref">1</a>.  <a href="#name-introduction" class="internal xref">Introduction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="auto internal xref">1.1</a>.  <a href="#name-change-log" class="internal xref">Change Log</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1" class="keepWithNext"><a href="#section-2" class="auto internal xref">2</a>.  <a href="#name-conventions" class="internal xref">Conventions</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="auto internal xref">3</a>.  <a href="#name-overview" class="internal xref">Overview</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="auto internal xref">4</a>.  <a href="#name-definition-of-dafs" class="internal xref">Definition of DAFs</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="auto internal xref">4.1</a>.  <a href="#name-sharding" class="internal xref">Sharding</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="auto internal xref">4.2</a>.  <a href="#name-preparation" class="internal xref">Preparation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a href="#section-4.3" class="auto internal xref">4.3</a>.  <a href="#name-validity-of-aggregation-par" class="internal xref">Validity of Aggregation Parameters</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4">
                <p id="section-toc.1-1.4.2.4.1"><a href="#section-4.4" class="auto internal xref">4.4</a>.  <a href="#name-aggregation" class="internal xref">Aggregation</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4.2.1">
                    <p id="section-toc.1-1.4.2.4.2.1.1"><a href="#section-4.4.1" class="auto internal xref">4.4.1</a>.  <a href="#name-aggregation-order" class="internal xref">Aggregation Order</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.5">
                <p id="section-toc.1-1.4.2.5.1"><a href="#section-4.5" class="auto internal xref">4.5</a>.  <a href="#name-unsharding" class="internal xref">Unsharding</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.6">
                <p id="section-toc.1-1.4.2.6.1"><a href="#section-4.6" class="auto internal xref">4.6</a>.  <a href="#name-execution-of-a-daf" class="internal xref">Execution of a DAF</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="auto internal xref">5</a>.  <a href="#name-definition-of-vdafs" class="internal xref">Definition of VDAFs</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.1">
                <p id="section-toc.1-1.5.2.1.1"><a href="#section-5.1" class="auto internal xref">5.1</a>.  <a href="#name-sharding-2" class="internal xref">Sharding</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.2">
                <p id="section-toc.1-1.5.2.2.1"><a href="#section-5.2" class="auto internal xref">5.2</a>.  <a href="#name-preparation-2" class="internal xref">Preparation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.3">
                <p id="section-toc.1-1.5.2.3.1"><a href="#section-5.3" class="auto internal xref">5.3</a>.  <a href="#name-validity-of-aggregation-para" class="internal xref">Validity of Aggregation Parameters</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.4">
                <p id="section-toc.1-1.5.2.4.1"><a href="#section-5.4" class="auto internal xref">5.4</a>.  <a href="#name-aggregation-2" class="internal xref">Aggregation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.5">
                <p id="section-toc.1-1.5.2.5.1"><a href="#section-5.5" class="auto internal xref">5.5</a>.  <a href="#name-unsharding-2" class="internal xref">Unsharding</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.6">
                <p id="section-toc.1-1.5.2.6.1"><a href="#section-5.6" class="auto internal xref">5.6</a>.  <a href="#name-execution-of-a-vdaf" class="internal xref">Execution of a VDAF</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.7">
                <p id="section-toc.1-1.5.2.7.1"><a href="#section-5.7" class="auto internal xref">5.7</a>.  <a href="#name-communication-patterns-for-" class="internal xref">Communication Patterns for Preparation</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.7.2.1">
                    <p id="section-toc.1-1.5.2.7.2.1.1"><a href="#section-5.7.1" class="auto internal xref">5.7.1</a>.  <a href="#name-the-ping-pong-topology-only" class="internal xref">The Ping-Pong Topology (Only Two Aggregators)</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5.2.7.2.2">
                    <p id="section-toc.1-1.5.2.7.2.2.1"><a href="#section-5.7.2" class="auto internal xref">5.7.2</a>.  <a href="#name-the-star-topology-any-numbe" class="internal xref">The Star Topology (Any Number of Aggregators)</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="auto internal xref">6</a>.  <a href="#name-preliminaries" class="internal xref">Preliminaries</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="auto internal xref">6.1</a>.  <a href="#name-finite-fields" class="internal xref">Finite Fields</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.1">
                    <p id="section-toc.1-1.6.2.1.2.1.1"><a href="#section-6.1.1" class="auto internal xref">6.1.1</a>.  <a href="#name-auxiliary-functions" class="internal xref">Auxiliary Functions</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.2">
                    <p id="section-toc.1-1.6.2.1.2.2.1"><a href="#section-6.1.2" class="auto internal xref">6.1.2</a>.  <a href="#name-ntt-friendly-fields" class="internal xref">NTT-Friendly Fields</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.3">
                    <p id="section-toc.1-1.6.2.1.2.3.1"><a href="#section-6.1.3" class="auto internal xref">6.1.3</a>.  <a href="#name-parameters" class="internal xref">Parameters</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2">
                <p id="section-toc.1-1.6.2.2.1"><a href="#section-6.2" class="auto internal xref">6.2</a>.  <a href="#name-extendable-output-functions" class="internal xref">Extendable Output Functions (XOFs)</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2.2.1">
                    <p id="section-toc.1-1.6.2.2.2.1.1"><a href="#section-6.2.1" class="auto internal xref">6.2.1</a>.  <a href="#name-xofturboshake128" class="internal xref">XofTurboShake128</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2.2.2">
                    <p id="section-toc.1-1.6.2.2.2.2.1"><a href="#section-6.2.2" class="auto internal xref">6.2.2</a>.  <a href="#name-xoffixedkeyaes128" class="internal xref">XofFixedKeyAes128</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2.2.3">
                    <p id="section-toc.1-1.6.2.2.2.3.1"><a href="#section-6.2.3" class="auto internal xref">6.2.3</a>.  <a href="#name-the-domain-separation-tag-a" class="internal xref">The Domain Separation Tag and Binder String</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="auto internal xref">7</a>.  <a href="#name-prio3" class="internal xref">Prio3</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="auto internal xref">7.1</a>.  <a href="#name-fully-linear-proofs-flps" class="internal xref">Fully Linear Proofs (FLPs)</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.1.2.1">
                    <p id="section-toc.1-1.7.2.1.2.1.1"><a href="#section-7.1.1" class="auto internal xref">7.1.1</a>.  <a href="#name-encoding-the-input" class="internal xref">Encoding the Input</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.1.2.2">
                    <p id="section-toc.1-1.7.2.1.2.2.1"><a href="#section-7.1.2" class="auto internal xref">7.1.2</a>.  <a href="#name-multiple-proofs" class="internal xref">Multiple Proofs</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="auto internal xref">7.2</a>.  <a href="#name-specification" class="internal xref">Specification</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.1">
                    <p id="section-toc.1-1.7.2.2.2.1.1"><a href="#section-7.2.1" class="auto internal xref">7.2.1</a>.  <a href="#name-sharding-3" class="internal xref">Sharding</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.2">
                    <p id="section-toc.1-1.7.2.2.2.2.1"><a href="#section-7.2.2" class="auto internal xref">7.2.2</a>.  <a href="#name-preparation-3" class="internal xref">Preparation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.3">
                    <p id="section-toc.1-1.7.2.2.2.3.1"><a href="#section-7.2.3" class="auto internal xref">7.2.3</a>.  <a href="#name-validity-of-aggregation-param" class="internal xref">Validity of Aggregation Parameters</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.4">
                    <p id="section-toc.1-1.7.2.2.2.4.1"><a href="#section-7.2.4" class="auto internal xref">7.2.4</a>.  <a href="#name-aggregation-3" class="internal xref">Aggregation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.5">
                    <p id="section-toc.1-1.7.2.2.2.5.1"><a href="#section-7.2.5" class="auto internal xref">7.2.5</a>.  <a href="#name-unsharding-3" class="internal xref">Unsharding</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.6">
                    <p id="section-toc.1-1.7.2.2.2.6.1"><a href="#section-7.2.6" class="auto internal xref">7.2.6</a>.  <a href="#name-auxiliary-functions-2" class="internal xref">Auxiliary Functions</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2.2.7">
                    <p id="section-toc.1-1.7.2.2.2.7.1"><a href="#section-7.2.7" class="auto internal xref">7.2.7</a>.  <a href="#name-message-serialization" class="internal xref">Message Serialization</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3">
                <p id="section-toc.1-1.7.2.3.1"><a href="#section-7.3" class="auto internal xref">7.3</a>.  <a href="#name-flp-specification" class="internal xref">FLP Specification</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3.2.1">
                    <p id="section-toc.1-1.7.2.3.2.1.1"><a href="#section-7.3.1" class="auto internal xref">7.3.1</a>.  <a href="#name-overview-2" class="internal xref">Overview</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3.2.2">
                    <p id="section-toc.1-1.7.2.3.2.2.1"><a href="#section-7.3.2" class="auto internal xref">7.3.2</a>.  <a href="#name-validity-circuits" class="internal xref">Validity Circuits</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3.2.3">
                    <p id="section-toc.1-1.7.2.3.2.3.1"><a href="#section-7.3.3" class="auto internal xref">7.3.3</a>.  <a href="#name-generating-the-proof" class="internal xref">Generating the Proof</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3.2.4">
                    <p id="section-toc.1-1.7.2.3.2.4.1"><a href="#section-7.3.4" class="auto internal xref">7.3.4</a>.  <a href="#name-querying-the-proof" class="internal xref">Querying the Proof</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3.2.5">
                    <p id="section-toc.1-1.7.2.3.2.5.1"><a href="#section-7.3.5" class="auto internal xref">7.3.5</a>.  <a href="#name-deciding-validity" class="internal xref">Deciding Validity</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4">
                <p id="section-toc.1-1.7.2.4.1"><a href="#section-7.4" class="auto internal xref">7.4</a>.  <a href="#name-variants" class="internal xref">Variants</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4.2.1">
                    <p id="section-toc.1-1.7.2.4.2.1.1"><a href="#section-7.4.1" class="auto internal xref">7.4.1</a>.  <a href="#name-prio3count" class="internal xref">Prio3Count</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4.2.2">
                    <p id="section-toc.1-1.7.2.4.2.2.1"><a href="#section-7.4.2" class="auto internal xref">7.4.2</a>.  <a href="#name-prio3sum" class="internal xref">Prio3Sum</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4.2.3">
                    <p id="section-toc.1-1.7.2.4.2.3.1"><a href="#section-7.4.3" class="auto internal xref">7.4.3</a>.  <a href="#name-prio3sumvec" class="internal xref">Prio3SumVec</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4.2.4">
                    <p id="section-toc.1-1.7.2.4.2.4.1"><a href="#section-7.4.4" class="auto internal xref">7.4.4</a>.  <a href="#name-prio3histogram" class="internal xref">Prio3Histogram</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.4.2.5">
                    <p id="section-toc.1-1.7.2.4.2.5.1"><a href="#section-7.4.5" class="auto internal xref">7.4.5</a>.  <a href="#name-prio3multihotcountvec" class="internal xref">Prio3MultihotCountVec</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="auto internal xref">8</a>.  <a href="#name-poplar1" class="internal xref">Poplar1</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.1">
                <p id="section-toc.1-1.8.2.1.1"><a href="#section-8.1" class="auto internal xref">8.1</a>.  <a href="#name-incremental-distributed-poi" class="internal xref">Incremental Distributed Point Functions (IDPFs)</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.1.2.1">
                    <p id="section-toc.1-1.8.2.1.2.1.1"><a href="#section-8.1.1" class="auto internal xref">8.1.1</a>.  <a href="#name-encoding-inputs-as-indices" class="internal xref">Encoding Inputs as Indices</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2">
                <p id="section-toc.1-1.8.2.2.1"><a href="#section-8.2" class="auto internal xref">8.2</a>.  <a href="#name-specification-2" class="internal xref">Specification</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.1">
                    <p id="section-toc.1-1.8.2.2.2.1.1"><a href="#section-8.2.1" class="auto internal xref">8.2.1</a>.  <a href="#name-sharding-4" class="internal xref">Sharding</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.2">
                    <p id="section-toc.1-1.8.2.2.2.2.1"><a href="#section-8.2.2" class="auto internal xref">8.2.2</a>.  <a href="#name-preparation-4" class="internal xref">Preparation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.3">
                    <p id="section-toc.1-1.8.2.2.2.3.1"><a href="#section-8.2.3" class="auto internal xref">8.2.3</a>.  <a href="#name-validity-of-aggregation-parame" class="internal xref">Validity of Aggregation Parameters</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.4">
                    <p id="section-toc.1-1.8.2.2.2.4.1"><a href="#section-8.2.4" class="auto internal xref">8.2.4</a>.  <a href="#name-aggregation-5" class="internal xref">Aggregation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.5">
                    <p id="section-toc.1-1.8.2.2.2.5.1"><a href="#section-8.2.5" class="auto internal xref">8.2.5</a>.  <a href="#name-unsharding-4" class="internal xref">Unsharding</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.2.2.6">
                    <p id="section-toc.1-1.8.2.2.2.6.1"><a href="#section-8.2.6" class="auto internal xref">8.2.6</a>.  <a href="#name-message-serialization-2" class="internal xref">Message Serialization</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.3">
                <p id="section-toc.1-1.8.2.3.1"><a href="#section-8.3" class="auto internal xref">8.3</a>.  <a href="#name-idpf-specification" class="internal xref">IDPF Specification</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.3.2.1">
                    <p id="section-toc.1-1.8.2.3.2.1.1"><a href="#section-8.3.1" class="auto internal xref">8.3.1</a>.  <a href="#name-overview-3" class="internal xref">Overview</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.3.2.2">
                    <p id="section-toc.1-1.8.2.3.2.2.1"><a href="#section-8.3.2" class="auto internal xref">8.3.2</a>.  <a href="#name-key-generation" class="internal xref">Key Generation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.3.2.3">
                    <p id="section-toc.1-1.8.2.3.2.3.1"><a href="#section-8.3.3" class="auto internal xref">8.3.3</a>.  <a href="#name-key-evaluation" class="internal xref">Key Evaluation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.3.2.4">
                    <p id="section-toc.1-1.8.2.3.2.4.1"><a href="#section-8.3.4" class="auto internal xref">8.3.4</a>.  <a href="#name-auxiliary-functions-3" class="internal xref">Auxiliary Functions</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="auto internal xref">9</a>.  <a href="#name-security-considerations" class="internal xref">Security Considerations</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.1">
                <p id="section-toc.1-1.9.2.1.1"><a href="#section-9.1" class="auto internal xref">9.1</a>.  <a href="#name-the-verification-key" class="internal xref">The Verification Key</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.2">
                <p id="section-toc.1-1.9.2.2.1"><a href="#section-9.2" class="auto internal xref">9.2</a>.  <a href="#name-the-nonce" class="internal xref">The Nonce</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.3">
                <p id="section-toc.1-1.9.2.3.1"><a href="#section-9.3" class="auto internal xref">9.3</a>.  <a href="#name-the-public-share" class="internal xref">The Public Share</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.4">
                <p id="section-toc.1-1.9.2.4.1"><a href="#section-9.4" class="auto internal xref">9.4</a>.  <a href="#name-the-aggregation-parameter" class="internal xref">The Aggregation Parameter</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.5">
                <p id="section-toc.1-1.9.2.5.1"><a href="#section-9.5" class="auto internal xref">9.5</a>.  <a href="#name-safe-usage-of-idpf-outputs" class="internal xref">Safe Usage of IDPF Outputs</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.6">
                <p id="section-toc.1-1.9.2.6.1"><a href="#section-9.6" class="auto internal xref">9.6</a>.  <a href="#name-safe-usage-of-xofs" class="internal xref">Safe Usage of XOFs</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.7">
                <p id="section-toc.1-1.9.2.7.1"><a href="#section-9.7" class="auto internal xref">9.7</a>.  <a href="#name-choosing-flp-parameters" class="internal xref">Choosing FLP Parameters</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.8">
                <p id="section-toc.1-1.9.2.8.1"><a href="#section-9.8" class="auto internal xref">9.8</a>.  <a href="#name-choosing-the-number-of-aggr" class="internal xref">Choosing the Number of Aggregators</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.9">
                <p id="section-toc.1-1.9.2.9.1"><a href="#section-9.9" class="auto internal xref">9.9</a>.  <a href="#name-defense-in-depth-measures" class="internal xref">Defense-in-Depth Measures</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9.2.10">
                <p id="section-toc.1-1.9.2.10.1"><a href="#section-9.10" class="auto internal xref">9.10</a>. <a href="#name-side-channel-resistance" class="internal xref">Side-Channel Resistance</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="auto internal xref">10</a>. <a href="#name-iana-considerations" class="internal xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#section-11" class="auto internal xref">11</a>. <a href="#name-references" class="internal xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.1">
                <p id="section-toc.1-1.11.2.1.1"><a href="#section-11.1" class="auto internal xref">11.1</a>.  <a href="#name-normative-references" class="internal xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11.2.2">
                <p id="section-toc.1-1.11.2.2.1"><a href="#section-11.2" class="auto internal xref">11.2</a>.  <a href="#name-informative-references" class="internal xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#appendix-A" class="auto internal xref">Appendix A</a>.  <a href="#name-flp-gadgets" class="internal xref">FLP Gadgets</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.1">
                <p id="section-toc.1-1.12.2.1.1"><a href="#appendix-A.1" class="auto internal xref">A.1</a>.  <a href="#name-multiplication" class="internal xref">Multiplication</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.2">
                <p id="section-toc.1-1.12.2.2.1"><a href="#appendix-A.2" class="auto internal xref">A.2</a>.  <a href="#name-polynomial-evaluation" class="internal xref">Polynomial Evaluation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.3">
                <p id="section-toc.1-1.12.2.3.1"><a href="#appendix-A.3" class="auto internal xref">A.3</a>.  <a href="#name-parallel-sum" class="internal xref">Parallel Sum</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.4">
                <p id="section-toc.1-1.12.2.4.1"><a href="#appendix-A.4" class="auto internal xref">A.4</a>.  <a href="#name-shims-for-generating-and-qu" class="internal xref">Shims for Generating and Querying Proofs</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#appendix-B" class="auto internal xref">Appendix B</a>.  <a href="#name-vdaf-preparation-state" class="internal xref">VDAF Preparation State</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a href="#appendix-C" class="auto internal xref">Appendix C</a>.  <a href="#name-test-vectors" class="internal xref">Test Vectors</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14.2.1">
                <p id="section-toc.1-1.14.2.1.1"><a href="#appendix-C.1" class="auto internal xref">C.1</a>.  <a href="#name-schema" class="internal xref">Schema</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14.2.1.2.1">
                    <p id="section-toc.1-1.14.2.1.2.1.1"><a href="#appendix-C.1.1" class="auto internal xref">C.1.1</a>.  <a href="#name-prio3count-2" class="internal xref">Prio3Count</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14.2.1.2.2">
                    <p id="section-toc.1-1.14.2.1.2.2.1"><a href="#appendix-C.1.2" class="auto internal xref">C.1.2</a>.  <a href="#name-prio3sum-2" class="internal xref">Prio3Sum</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14.2.1.2.3">
                    <p id="section-toc.1-1.14.2.1.2.3.1"><a href="#appendix-C.1.3" class="auto internal xref">C.1.3</a>.  <a href="#name-prio3sumvec-2" class="internal xref">Prio3SumVec</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14.2.1.2.4">
                    <p id="section-toc.1-1.14.2.1.2.4.1"><a href="#appendix-C.1.4" class="auto internal xref">C.1.4</a>.  <a href="#name-prio3histogram-2" class="internal xref">Prio3Histogram</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14.2.1.2.5">
                    <p id="section-toc.1-1.14.2.1.2.5.1"><a href="#appendix-C.1.5" class="auto internal xref">C.1.5</a>.  <a href="#name-prio3multihotcountvec-2" class="internal xref">Prio3MultihotCountVec</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14.2.1.2.6">
                    <p id="section-toc.1-1.14.2.1.2.6.1"><a href="#appendix-C.1.6" class="auto internal xref">C.1.6</a>.  <a href="#name-poplar1-2" class="internal xref">Poplar1</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.15">
            <p id="section-toc.1-1.15.1"><a href="#appendix-D" class="auto internal xref"></a><a href="#name-acknowledgments" class="internal xref">Acknowledgments</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.16">
            <p id="section-toc.1-1.16.1"><a href="#appendix-E" class="auto internal xref"></a><a href="#name-authors-addresses" class="internal xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">(RFC EDITOR: remove this paragraph.) The source for this draft and the
reference implementation can be found at
https://github.com/cfrg/draft-irtf-cfrg-vdaf.<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">The ubiquity of the Internet makes it an ideal platform for measurement of
large-scale phenomena, whether public health trends or the behavior of computer
systems at scale. There is substantial overlap, however, between information
that is valuable to measure and information that users consider private.<a href="#section-1-2" class="pilcrow">¶</a></p>
<p id="section-1-3">For example, consider an application that provides health information to users.
The operator of an application might want to know which parts of their
application are used most often, as a way to guide future development of the
application. Specific users' patterns of usage, though, could reveal sensitive
things about them, such as which users are researching a given health
condition.<a href="#section-1-3" class="pilcrow">¶</a></p>
<p id="section-1-4">In many situations, the measurement collector is only interested in aggregate
statistics, e.g., which portions of an application are most used or what
fraction of people have experienced a given disease. Thus systems that provide
aggregate statistics while protecting individual measurements can deliver the
value of the measurements while protecting users' privacy.<a href="#section-1-4" class="pilcrow">¶</a></p>
<p id="section-1-5">This problem is often formulated in terms of differential privacy (DP)
<span>[<a href="#Dwo06" class="cite xref">Dwo06</a>]</span>. Roughly speaking, a data aggregation system that is differentially
private ensures that the degree to which any individual measurement influences
the value of the aggregate result can be precisely controlled. For example, in
systems like RAPPOR <span>[<a href="#EPK14" class="cite xref">EPK14</a>]</span>, each user samples noise from a well-known
distribution and adds it to their measurement before submitting to the
aggregation server. The aggregation server then adds up the noisy measurements,
and because it knows the distribution from which the noise was sampled, it can
estimate the true sum with reasonable accuracy.<a href="#section-1-5" class="pilcrow">¶</a></p>
<p id="section-1-6">Even when noise is added to the measurements, collecting them in the clear
still reveals a significant amount of information to the collector. On the one
hand, depending on the "amount" of noise a client adds to its measurement, it
may be possible for a curious collector to make a reasonable guess of the
measurement's true value. On the other hand, the more noise the clients add,
the less reliable will be the server's estimate of the aggregate. Thus systems
relying solely on a DP mechanism must strike a delicate balance between privacy
and utility.<a href="#section-1-6" class="pilcrow">¶</a></p>
<p id="section-1-7">Another way of constructing a privacy-preserving measurement system is to use
multi-party computation (MPC). The goal of such a system is that no participant
in the protocol should learn anything about an individual measurement beyond
what it can deduce from the aggregate. MPC achieves this goal by distributing
the computation of the aggregate across multiple aggregation servers, one of
which is presumed to be honest, i.e., not under control of the attacker.
Moreover, MPC can be composed with various DP mechanisms to ensure the
aggregate itself does not leak too much information about any one of the
measurements <span>[<a href="#MPRV09" class="cite xref">MPRV09</a>]</span>.<a href="#section-1-7" class="pilcrow">¶</a></p>
<p id="section-1-8">This document describes two classes of MPC protocols, each aiming for a
different set of goals.<a href="#section-1-8" class="pilcrow">¶</a></p>
<p id="section-1-9">In a Distributed Aggregation Function (DAF, <a href="#daf" class="auto internal xref">Section 4</a>), each client splits its
measurement into multiple secret shares, one for each aggregation
server. DAFs require two properties of the secret sharing scheme. First, we can
reconstruct the underlying measurement by simply adding up all of the shares.
(Typically the shares are vectors over some finite field.) Second, given all
but one of the shares, it is impossible to learn anything about the underlying
measurement. These properties give rise to a simple strategy for privately
aggregating the measurements: each aggregation server adds up its measurement
shares locally before revealing their sum to the data collector; then all
the data collector has to do is add up these sums to get the aggregate result.<a href="#section-1-9" class="pilcrow">¶</a></p>
<p id="section-1-10">This strategy is compatible with any aggregation function that can be
represented as the sum of some encoding of the measurements. Examples include:
summary statistics such as sum, mean, and standard deviation; estimation of
quantiles, e.g., median; histograms; linear regression; or counting data
structures, e.g., Bloom filters. However, not all functions fit into this
rubric, as it is constrained to linear computations over the encoded
measurements.<a href="#section-1-10" class="pilcrow">¶</a></p>
<p id="section-1-11">In fact, our framework admits DAFs with slightly more
functionality, computing aggregation functions of the form<a href="#section-1-11" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-1-12">
<pre>
F(agg_param, meas_1, ..., meas_M) =
    G(agg_param, meas_1) + ... + G(agg_param, meas_M)
</pre><a href="#section-1-12" class="pilcrow">¶</a>
</div>
<p id="section-1-13">where <code>meas_1, ..., meas_M</code> are the measurements, <code>G</code> is a possibly
non-linear function, and <code>agg_param</code> is a parameter of that function chosen by
the data collector. This paradigm, known as function secret sharing <span>[<a href="#BGI15" class="cite xref">BGI15</a>]</span>,
allows for more sophisticated data analysis tasks, such as grouping metrics by
private client attributes <span>[<a href="#MPDST25" class="cite xref">MPDST25</a>]</span> or computing heavy hitters <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>.
(More on the latter task below.)<a href="#section-1-13" class="pilcrow">¶</a></p>
<p id="section-1-14">The second class of protocols defined in this document are called Verifiable
Distributed Aggregation Functions (VDAFs, <a href="#vdaf" class="auto internal xref">Section 5</a>). In addition to being
private, VDAFs are verifiable in the following sense. By design, a secret
sharing of a valid measurement, e.g., a number between 1 and 10, is
indistinguishable from a secret sharing of an invalid measurement, e.g., a
number larger than 10. This means that DAFs are vulnerable to attacks from
malicious clients attempting to disrupt the computation by submitting invalid
measurements. VDAFs are designed to allow the servers to interact with one
another in order to detect and remove these measurements prior to
aggregation. We refer to this property as verifiability. (This is also called
robustness in prior work <span>[<a href="#CGB17" class="cite xref">CGB17</a>]</span>, <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>.)<a href="#section-1-14" class="pilcrow">¶</a></p>
<p id="section-1-15">Achieving verifiability using the cryptographic techniques described in this
document requires a significant amount of interaction between the servers. DAFs
on the other hand are non-interactive, making them easier to deploy; but they
do not on their own allow for verifying the validity of the measurements. This
may be tolerable in some applications. For instance, if the client's software
is executed in a trusted execution environment, it may be reasonable to assume
that no client is malicious.<a href="#section-1-15" class="pilcrow">¶</a></p>
<p id="section-1-16">The DAF and VDAF abstractions encompass a variety of MPC techniques in the
literature. These protocols vary in their operational and security
requirements, sometimes in subtle but consequential ways. This document
therefore has two important goals:<a href="#section-1-16" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-1-17">
<li id="section-1-17.1">
          <p id="section-1-17.1.1">Provide higher-level protocols, like <span>[<a href="#DAP" class="cite xref">DAP</a>]</span>, with
a simple, uniform interface for accessing privacy-preserving measurement
schemes, document relevant operational and security requirements, and
specify constraints for safe usage:<a href="#section-1-17.1.1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-1-17.1.2">
<li id="section-1-17.1.2.1">
              <p id="section-1-17.1.2.1.1">General patterns of communications among the various actors involved in
the system (clients, aggregation servers, and the collector of the
aggregate result);<a href="#section-1-17.1.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-1-17.1.2.2">
              <p id="section-1-17.1.2.2.1">Capabilities of a malicious coalition of parties attempting to divulge
information about client measurements; and<a href="#section-1-17.1.2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-1-17.1.2.3">
              <p id="section-1-17.1.2.3.1">Conditions that are necessary to ensure that malicious clients cannot
corrupt the computation.<a href="#section-1-17.1.2.3.1" class="pilcrow">¶</a></p>
</li>
          </ol>
</li>
        <li id="section-1-17.2">
          <p id="section-1-17.2.1">Provide cryptographers with design criteria that provide a clear deployment
roadmap for new constructions of privacy-preserving measurement systems.<a href="#section-1-17.2.1" class="pilcrow">¶</a></p>
</li>
      </ol>
<p id="section-1-18">This document also specifies two concrete VDAF schemes, each based on a protocol
from the literature.<a href="#section-1-18" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1-19.1">
          <p id="section-1-19.1.1">The Prio system <span>[<a href="#CGB17" class="cite xref">CGB17</a>]</span> allows for the privacy-preserving computation of a
variety of aggregate statistics, combining additive secret sharing as described
above with a mechanism for checking the validity of each measurement. In
<a href="#prio3" class="auto internal xref">Section 7</a> we specify Prio3, a VDAF that follows the same overall framework as
the original Prio protocol, but incorporates techniques introduced in
<span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span> that result in significant performance gains.<a href="#section-1-19.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-1-19.2">
          <p id="section-1-19.2.1">The Poplar protocol <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span> solves a problem known as private
heavy-hitters. In this problem, each client holds a bit-string, and the goal
of the aggregation servers is to compute the set of strings that occur at
least <code>T</code> times for some threshold <code>T</code>. The core primitive in their protocol
is a secret sharing of a point function <span>[<a href="#GI14" class="cite xref">GI14</a>]</span> (denoted <code>G</code> above) that
allows the servers to privately count how many of the clients' strings begin
with a given prefix (<code>agg_param</code> in the notation above). In <a href="#poplar1" class="auto internal xref">Section 8</a> we
specify a VDAF called Poplar1 that implements this functionality.<a href="#section-1-19.2.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-1-20">The remainder of this document is organized as follows: <a href="#conventions" class="auto internal xref">Section 2</a> lists
definitions and conventions used in the remainder of the document; <a href="#overview" class="auto internal xref">Section 3</a>
gives a brief overview of DAFs and VDAFs, the parties involved in the
computation, and the requirements for non-collusion; <a href="#daf" class="auto internal xref">Section 4</a> defines the syntax
for DAFs; <a href="#vdaf" class="auto internal xref">Section 5</a> defines the syntax for VDAFs; <a href="#prelim" class="auto internal xref">Section 6</a> defines various
functionalities that are common to our constructions; <a href="#prio3" class="auto internal xref">Section 7</a> specifies
Prio3; <a href="#poplar1" class="auto internal xref">Section 8</a> specifies Poplar1; and <a href="#security" class="auto internal xref">Section 9</a> enumerates security
considerations for DAFs and VDAFs in general and our constructions in
particular.<a href="#section-1-20" class="pilcrow">¶</a></p>
<div id="change-log">
<section id="section-1.1">
        <h3 id="name-change-log">
<a href="#section-1.1" class="section-number selfRef">1.1. </a><a href="#name-change-log" class="section-name selfRef">Change Log</a>
        </h3>
<p id="section-1.1-1">(RFC EDITOR: remove this section.)<a href="#section-1.1-1" class="pilcrow">¶</a></p>
<p id="section-1.1-2">(*) Indicates a change that breaks wire compatibility with the previous draft.<a href="#section-1.1-2" class="pilcrow">¶</a></p>
<p id="section-1.1-3">15:<a href="#section-1.1-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-4.1">
            <p id="section-1.1-4.1.1">Simplify the ping-pong API for 2-party preparation by merging the outbound
message into the state object. This reduces the number of cases the caller
has to handle.<a href="#section-1.1-4.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-4.2">
            <p id="section-1.1-4.2.1">Update the test vector format. First, enrich the test vector schema to
express negative test cases. Second, change the encoding of output shares to
match the aggregate shares.<a href="#section-1.1-4.2.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-5">14:<a href="#section-1.1-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-6.1">
            <p id="section-1.1-6.1.1">Poplar1: When decoding an aggregation parameter, require the padding bits
after each prefix to be cleared.<a href="#section-1.1-6.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-7">13:<a href="#section-1.1-7" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-8.1">
            <p id="section-1.1-8.1.1">(V)DAF: Replace the one-shot aggregation API with a streaming API. Each
Aggregator initializes aggregation, then updates its aggregate share as
output shares are produced. The scheme also specifies a method for merging
multiple aggregate shares.<a href="#section-1.1-8.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-8.2">
            <p id="section-1.1-8.2.1">Poplar1: Move prefix uniqueness and ordering checks from <code>prep_init()</code> to
<code>is_valid()</code>.<a href="#section-1.1-8.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-8.3">
            <p id="section-1.1-8.3.1">Poplar1: Use <code>bool</code> to represent control bits instead of <code>Field2</code>.<a href="#section-1.1-8.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-8.4">
            <p id="section-1.1-8.4.1">Prio3MultihotCountVec: Change the measurement type from <code>list[int]</code> to
<code>list[bool]</code>.<a href="#section-1.1-8.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-8.5">
            <p id="section-1.1-8.5.1">Security considerations: Define our threat model for side channel attacks and
enumerate the parts of the spec that are most relevant to implementers.<a href="#section-1.1-8.5.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-8.6">
            <p id="section-1.1-8.6.1">Improve the specification of each Prio3 variant by listing each
implementation of <code>Valid</code> and <code>Gadget</code> in full. Gadgets are listed in a new
appendix section.<a href="#section-1.1-8.6.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-8.7">
            <p id="section-1.1-8.7.1">Improve the specification of the FLP system by listing the proof-generation,
query, and decision algorithms in full. The wrapper gadgets are listed in the
new section of the appendix for gadgets.<a href="#section-1.1-8.7.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-8.8">
            <p id="section-1.1-8.8.1">Add a section with a high-level overview of the IDPF construction.<a href="#section-1.1-8.8.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-8.9">
            <p id="section-1.1-8.9.1">Move some sections around: move ping-pong and star topologies under
communication patterns for VDAF preparation; move FLP proof generation,
query, and decision algorithms up one level; move privacy considerations for
aggregation parameters up one level; and move safe usage of IDPF outputs up
one level.<a href="#section-1.1-8.9.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-9">12:<a href="#section-1.1-9" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-10.1">
            <p id="section-1.1-10.1.1">(V)DAF: Add an application context string parameter to sharding and
preparation. The motivation for this change is to harden Prio3 against
offline attacks. More generally, however, it allows designing schemes for
which correct execution requires agreement on the application context.
Accordingly, both Prio3 and Poplar1 have been modified to include the context
in the domain separation tag of each XOF invocation. (*)<a href="#section-1.1-10.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-10.2">
            <p id="section-1.1-10.2.1">Prio3: Improve soundness of the base proof system and the circuits of some
variants. Generally speaking, wherever we evaluate a univariate polynomial at
a random point, we can instead evaluate a multivariate polynomial of lower
degree. (*)<a href="#section-1.1-10.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-10.3">
            <p id="section-1.1-10.3.1">Prio3: Replace the helper's measurement and proof share seeds with a single
seed. (*)<a href="#section-1.1-10.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-10.4">
            <p id="section-1.1-10.4.1">Prio3Sum: Update the circuit to support a more general range check and avoid
using joint randomness. (*)<a href="#section-1.1-10.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-10.5">
            <p id="section-1.1-10.5.1">Prio3Histogram, Prio3MultihotCountVec: Move the final reduction of the
intermediate outputs out of the circuit. (*)<a href="#section-1.1-10.5.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-10.6">
            <p id="section-1.1-10.6.1">IDPF: Add the application context string to key generation and evaluation and
bind it to the fixed AES key. (*)<a href="#section-1.1-10.6.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-10.7">
            <p id="section-1.1-10.7.1">IDPF: Use XofTurboShake128 for deriving the leaf nodes in order to ensure the
construction is extractable. (*)<a href="#section-1.1-10.7.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-10.8">
            <p id="section-1.1-10.8.1">IDPF: Simplify the public share encoding. (*)<a href="#section-1.1-10.8.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-10.9">
            <p id="section-1.1-10.9.1">XofTurboShake128: Change <code>SEED_SIZE</code> from 16 bytes to 32 to mitigate offline
attacks on Prio3 robustness. In addition, allow seeds of different lengths so
that we can continue to use XofTurboShake128 with IDPF. (*)<a href="#section-1.1-10.9.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-10.10">
            <p id="section-1.1-10.10.1">XofTurboShake128, XofFixedKeyAes128: Increase the length prefix for the
domain separation tag from one by to two bytes. This is to accommodate the
application context. (*)<a href="#section-1.1-10.10.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-10.11">
            <p id="section-1.1-10.11.1">Reassign codepoints for all Prio3 variants and Poplar1. (*)<a href="#section-1.1-10.11.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-10.12">
            <p id="section-1.1-10.12.1">Security considerations: Add a section on defense-in-depth measures taken by
Prio3 and Poplar1 and more discussion about choosing FLP parameters.<a href="#section-1.1-10.12.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-11">11:<a href="#section-1.1-11" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-12.1">
            <p id="section-1.1-12.1.1">Define message formats for the Poplar1 aggregation parameter and IDPF public
share.<a href="#section-1.1-12.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-12.2">
            <p id="section-1.1-12.2.1">IDPF: Require the IDPF binder must be a random nonce.<a href="#section-1.1-12.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-12.3">
            <p id="section-1.1-12.3.1">VDAF: Replace the pseudocode description of the ping-ping topology with
Python and sketch the star topology.<a href="#section-1.1-12.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-12.4">
            <p id="section-1.1-12.4.1">DAF: Align aggregation parameter validation with VDAF.<a href="#section-1.1-12.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-12.5">
            <p id="section-1.1-12.5.1">Replace <code>Union[A, B]</code> type with <code>A | B</code>.<a href="#section-1.1-12.5.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-12.6">
            <p id="section-1.1-12.6.1">Rename FFT ("Fast Fourier Transform") with NTT ("Number Theoretic
Transform").<a href="#section-1.1-12.6.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-13">10:<a href="#section-1.1-13" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-14.1">
            <p id="section-1.1-14.1.1">Define Prio3MultihotCountVec, a variant of Prio3 for aggregating bit vectors
with bounded weight.<a href="#section-1.1-14.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-14.2">
            <p id="section-1.1-14.2.1">FLP: Allow the output of the circuit to be a vector. This makes it possible
to skip joint randomness derivation in more cases.<a href="#section-1.1-14.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-14.3">
            <p id="section-1.1-14.3.1">Poplar1: On the first round of preparation, handle <code>None</code> as an error.
Previously this message was interpreted as a length-3 vector of zeros.<a href="#section-1.1-14.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-14.4">
            <p id="section-1.1-14.4.1">Prio3: Move specification of the field from the FLP validity circuit to the
VDAF itself.<a href="#section-1.1-14.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-14.5">
            <p id="section-1.1-14.5.1">Clarify the extent to which the attacker controls the network in our threat
models for privacy and robustness.<a href="#section-1.1-14.5.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-14.6">
            <p id="section-1.1-14.6.1">Clean up various aspects of the code, including: Follow existing
object-oriented programming patterns for Python more closely; make the type
hints enforceable; and avoid shadowing variables.<a href="#section-1.1-14.6.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-14.7">
            <p id="section-1.1-14.7.1">Poplar1: Align terminology with <span>[<a href="#BBCGGI23" class="cite xref">BBCGGI23</a>]</span>.<a href="#section-1.1-14.7.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-14.8">
            <p id="section-1.1-14.8.1">IDPF: Add guidance for encoding byte strings as indices.<a href="#section-1.1-14.8.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-15">09:<a href="#section-1.1-15" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-16.1">
            <p id="section-1.1-16.1.1">Poplar1: Make prefix tree traversal stricter by requiring each node to be a
child of a node that was already visited. This change is intended to make it
harder for a malicious Aggregator to steer traversal towards
non-heavy-hitting measurements.<a href="#section-1.1-16.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-16.2">
            <p id="section-1.1-16.2.1">Prio3: Add more explicit guidance for choosing the field size.<a href="#section-1.1-16.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-16.3">
            <p id="section-1.1-16.3.1">IDPF: Define extractability and clarify (un)safe usage of intermediate prefix
counts. Accordingly, add text ensuring public share consistency to security
considerations.<a href="#section-1.1-16.3.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-17">08:<a href="#section-1.1-17" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-18.1">
            <p id="section-1.1-18.1.1">Poplar1: Bind the report nonce to the authenticator vector programmed into
the IDPF. (*)<a href="#section-1.1-18.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-18.2">
            <p id="section-1.1-18.2.1">IdpfPoplar: Modify <code>extend()</code> by stealing each control bit from its
corresponding seed. This improves performance by reducing the number of AES
calls per level from 3 to 2. The cost is a slight reduction in the concrete
privacy bound. (*)<a href="#section-1.1-18.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-18.3">
            <p id="section-1.1-18.3.1">Prio3: Add support for generating and verifying multiple proofs per
measurement. This enables a trade-off between communication cost and runtime:
if more proofs are used, then a smaller field can be used without impacting
robustness. (*)<a href="#section-1.1-18.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-18.4">
            <p id="section-1.1-18.4.1">Replace SHAKE128 with TurboSHAKE128. (*)<a href="#section-1.1-18.4.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-19">07:<a href="#section-1.1-19" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-20.1">
            <p id="section-1.1-20.1.1">Rename PRG to XOF ("eXtendable Output Function"). Accordingly, rename PrgSha3
to XofShake128 and PrgFixedKeyAes128 to XofFixedKeyAes128. "PRG" is a misnomer
since we don't actually treat this object as a pseudorandom generator in
existing security analysis.<a href="#section-1.1-20.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-20.2">
            <p id="section-1.1-20.2.1">Replace cSHAKE128 with SHAKE128, re-implementing domain separation for the
customization string using a simpler scheme. This change addresses the
reality that implementations of cSHAKE128 are less common. (*)<a href="#section-1.1-20.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-20.3">
            <p id="section-1.1-20.3.1">Define a new VDAF, called Prio3SumVec, that generalizes Prio3Sum to a vector
of summands.<a href="#section-1.1-20.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-20.4">
            <p id="section-1.1-20.4.1">Prio3Histogram: Update the codepoint and use the parallel sum optimization
introduced by Prio3SumVec to reduce the proof size. (*)<a href="#section-1.1-20.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-20.5">
            <p id="section-1.1-20.5.1">Daf, Vdaf: Rename interface methods to match verbiage in the draft.<a href="#section-1.1-20.5.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-20.6">
            <p id="section-1.1-20.6.1">Daf: Align with Vdaf by adding a nonce to <code>shard()</code> and <code>prep()</code>.<a href="#section-1.1-20.6.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-20.7">
            <p id="section-1.1-20.7.1">Vdaf: Have <code>prep_init()</code> compute the first prep share. This change is
intended to simplify the interface by making the input to <code>prep_next()</code> not
optional.<a href="#section-1.1-20.7.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-20.8">
            <p id="section-1.1-20.8.1">Prio3: Split sharding into two auxiliary functions, one for sharding with
joint randomness and another without. This change is intended to improve
readability.<a href="#section-1.1-20.8.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-20.9">
            <p id="section-1.1-20.9.1">Fix bugs in the ping-pong interface discovered after implementing it.<a href="#section-1.1-20.9.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-21">06:<a href="#section-1.1-21" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-22.1">
            <p id="section-1.1-22.1.1">Vdaf: Define a wrapper interface for preparation that is suitable for the
"ping-pong" topology in which two Aggregators exchange messages over a
request/response protocol, like HTTP, and take turns executing the
computation until input from the peer is required.<a href="#section-1.1-22.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-22.2">
            <p id="section-1.1-22.2.1">Prio3Histogram: Generalize the measurement type so that the histogram can be
used more easily with discrete domains. (*)<a href="#section-1.1-22.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-22.3">
            <p id="section-1.1-22.3.1">Daf, Vdaf: Change the aggregation parameter validation algorithm to take the
set of previous parameters rather than a list. (The order of the parameters
is irrelevant.)<a href="#section-1.1-22.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-22.4">
            <p id="section-1.1-22.4.1">Daf, Vdaf, Idpf: Add parameter <code>RAND_SIZE</code> that specifies the number of
random bytes consumed by the randomized algorithm (<code>shard()</code> for Daf and Vdaf
and <code>gen()</code> for Idpf).<a href="#section-1.1-22.4.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-23">05:<a href="#section-1.1-23" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-24.1">
            <p id="section-1.1-24.1.1">IdpfPoplar: Replace PrgSha3 with PrgFixedKeyAes128, a fixed-key mode for
AES-128 based on a construction from <span>[<a href="#GKWWY20" class="cite xref">GKWWY20</a>]</span>. This change is intended to
improve performance of IDPF evaluation. Note that the new PRG is not suitable
for all applications. (*)<a href="#section-1.1-24.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-24.2">
            <p id="section-1.1-24.2.1">Idpf: Add a binder string to the key-generation and evaluation algorithms.
This is used to plumb the nonce generated by the Client to the PRG.<a href="#section-1.1-24.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-24.3">
            <p id="section-1.1-24.3.1">Plumb random coins through the interface of randomized algorithms.
Specifically, add a random input to (V)DAF sharding algorithm and IDPF
key-generation algorithm and require implementations to specify the length of
the random input. Accordingly, update Prio3, Poplar1, and IdpfPoplar to match
the new interface. This change is intended to improve coverage of test
vectors.<a href="#section-1.1-24.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-24.4">
            <p id="section-1.1-24.4.1">Use little-endian byte-order for field element encoding. (*)<a href="#section-1.1-24.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-24.5">
            <p id="section-1.1-24.5.1">Poplar1: Move the last step of sketch evaluation from <code>prep_next()</code> to
<code>prep_shares_to_prep()</code>.<a href="#section-1.1-24.5.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-25">04:<a href="#section-1.1-25" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-26.1">
            <p id="section-1.1-26.1.1">Align security considerations with the security analysis of <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>.<a href="#section-1.1-26.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-26.2">
            <p id="section-1.1-26.2.1">Vdaf: Pass the nonce to the sharding algorithm.<a href="#section-1.1-26.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-26.3">
            <p id="section-1.1-26.3.1">Vdaf: Rather than allow the application to choose the nonce length, have each
implementation of the Vdaf interface specify the expected nonce length. (*)<a href="#section-1.1-26.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-26.4">
            <p id="section-1.1-26.4.1">Prg: Split "info string" into two components: the "customization string",
intended for domain separation; and the "binder string", used to bind the
output to ephemeral values, like the nonce, associated with execution of a
(V)DAF.<a href="#section-1.1-26.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-26.5">
            <p id="section-1.1-26.5.1">Replace PrgAes128 with PrgSha3, an implementation of the Prg interface based
on SHA-3, and use the new scheme as the default. Accordingly, replace
Prio3Aes128Count with Prio3Count, Poplar1Aes128 with Poplar1, and so on. SHA-3
is a safer choice for instantiating a random oracle, which is used in the
analysis of Prio3 of <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>. (*)<a href="#section-1.1-26.5.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-26.6">
            <p id="section-1.1-26.6.1">Prio3, Poplar1: Ensure each invocation of the Prg uses a distinct
customization string, as suggested by <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>. This is intended to make
domain separation clearer, thereby simplifying security analysis. (*)<a href="#section-1.1-26.6.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-26.7">
            <p id="section-1.1-26.7.1">Prio3: Replace "joint randomness hints" sent in each input share with "joint
randomness parts" sent in the public share. This reduces communication
overhead when the number of shares exceeds two. (*)<a href="#section-1.1-26.7.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-26.8">
            <p id="section-1.1-26.8.1">Prio3: Bind nonce to joint randomness parts. This is intended to address
birthday attacks on robustness pointed out by <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>. (*)<a href="#section-1.1-26.8.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-26.9">
            <p id="section-1.1-26.9.1">Poplar1: Use different Prg invocations for producing the correlated randomness
for inner and leaf nodes of the IDPF tree. This is intended to simplify
implementations. (*)<a href="#section-1.1-26.9.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-26.10">
            <p id="section-1.1-26.10.1">Poplar1: Don't bind the candidate prefixes to the verifier randomness. This is
intended to improve performance, while not impacting security. According to
the analysis of <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>, it is necessary to restrict Poplar1 usage such
that no report is aggregated more than once at a given level of the IDPF tree;
otherwise, attacks on privacy may be possible. In light of this restriction,
there is no added benefit of binding to the prefixes themselves. (*)<a href="#section-1.1-26.10.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-26.11">
            <p id="section-1.1-26.11.1">Poplar1: During preparation, assert that all candidate prefixes are unique
and appear in order. Uniqueness is required to avoid erroneously rejecting a
valid report; the ordering constraint ensures the uniqueness check can be
performed efficiently. (*)<a href="#section-1.1-26.11.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-26.12">
            <p id="section-1.1-26.12.1">Poplar1: Increase the maximum candidate prefix count in the encoding of the
aggregation parameter. (*)<a href="#section-1.1-26.12.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-26.13">
            <p id="section-1.1-26.13.1">Poplar1: Bind the nonce to the correlated randomness derivation. This is
intended to provide defense-in-depth by ensuring the Aggregators reject the
report if the nonce does not match what the Client used for sharding. (*)<a href="#section-1.1-26.13.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-26.14">
            <p id="section-1.1-26.14.1">Poplar1: Clarify that the aggregation parameter encoding is <span class="bcp14">OPTIONAL</span>.
Accordingly, update implementation considerations around cross-aggregation
state.<a href="#section-1.1-26.14.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-26.15">
            <p id="section-1.1-26.15.1">IdpfPoplar: Add implementation considerations around branching on the values
of control bits.<a href="#section-1.1-26.15.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-26.16">
            <p id="section-1.1-26.16.1">IdpfPoplar: When decoding the control bits in the public share, assert
that the trailing bits of the final byte are all zero. (*)<a href="#section-1.1-26.16.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-27">03:<a href="#section-1.1-27" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-28.1">
            <p id="section-1.1-28.1.1">Define codepoints for (V)DAFs and use them for domain separation in Prio3 and
Poplar1. (*)<a href="#section-1.1-28.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-28.2">
            <p id="section-1.1-28.2.1">Prio3: Align joint randomness computation with revised paper <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>.
This change mitigates an attack on robustness. (*)<a href="#section-1.1-28.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-28.3">
            <p id="section-1.1-28.3.1">Prio3: Remove an intermediate PRG evaluation from query randomness generation.
(*)<a href="#section-1.1-28.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-28.4">
            <p id="section-1.1-28.4.1">Add additional guidance for choosing FFT-friendly fields.<a href="#section-1.1-28.4.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-29">02:<a href="#section-1.1-29" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-30.1">
            <p id="section-1.1-30.1.1">Complete the initial specification of Poplar1.<a href="#section-1.1-30.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-30.2">
            <p id="section-1.1-30.2.1">Extend (V)DAF syntax to include a "public share" output by the Client and
distributed to all of the Aggregators. This is to accommodate "extractable"
IDPFs as required for Poplar1. (See <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>, Section 4.3 for details.)<a href="#section-1.1-30.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-30.3">
            <p id="section-1.1-30.3.1">Extend (V)DAF syntax to allow the unsharding step to take into account the
number of measurements aggregated.<a href="#section-1.1-30.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-30.4">
            <p id="section-1.1-30.4.1">Extend FLP syntax by adding a method for decoding the aggregate result from a
vector of field elements. The new method takes into account the number of
measurements.<a href="#section-1.1-30.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-30.5">
            <p id="section-1.1-30.5.1">Prio3: Align aggregate result computation with updated FLP syntax.<a href="#section-1.1-30.5.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-30.6">
            <p id="section-1.1-30.6.1">Prg: Add a method for statefully generating a vector of field elements.<a href="#section-1.1-30.6.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-30.7">
            <p id="section-1.1-30.7.1">Field: Require that field elements are fully reduced before decoding. (*)<a href="#section-1.1-30.7.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-30.8">
            <p id="section-1.1-30.8.1">Define new field Field255.<a href="#section-1.1-30.8.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-1.1-31">01:<a href="#section-1.1-31" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-32.1">
            <p id="section-1.1-32.1.1">Require that VDAFs specify serialization of aggregate shares.<a href="#section-1.1-32.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-32.2">
            <p id="section-1.1-32.2.1">Define Distributed Aggregation Functions (DAFs).<a href="#section-1.1-32.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-32.3">
            <p id="section-1.1-32.3.1">Prio3: Move proof verifier check from <code>prep_next()</code> to
<code>prep_shares_to_prep()</code>. (*)<a href="#section-1.1-32.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-32.4">
            <p id="section-1.1-32.4.1">Remove public parameter and replace verification parameter with a
"verification key" and "Aggregator ID".<a href="#section-1.1-32.4.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
</section>
</div>
<div id="conventions">
<section id="section-2">
      <h2 id="name-conventions">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-conventions" class="section-name selfRef">Conventions</a>
      </h2>
<p id="section-2-1">The key words "<span class="bcp14">MUST</span>", "<span class="bcp14">MUST NOT</span>", "<span class="bcp14">REQUIRED</span>", "<span class="bcp14">SHALL</span>", "<span class="bcp14">SHALL NOT</span>", "<span class="bcp14">SHOULD</span>", "<span class="bcp14">SHOULD NOT</span>", "<span class="bcp14">RECOMMENDED</span>", "<span class="bcp14">NOT RECOMMENDED</span>",
"<span class="bcp14">MAY</span>", and "<span class="bcp14">OPTIONAL</span>" in this document are to be interpreted as
described in BCP 14 <span>[<a href="#RFC2119" class="cite xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="cite xref">RFC8174</a>]</span> when, and only when, they
appear in all capitals, as shown here.<a href="#section-2-1" class="pilcrow">¶</a></p>
<p id="section-2-2">Algorithms in this document are written in Python (compatible with Python 3.12
or later). A fatal error in a program (e.g., failure to parse one of the
function parameters) is usually handled by raising an exception.<a href="#section-2-2" class="pilcrow">¶</a></p>
<p id="section-2-3">In Python, array indexing starts with <code>0</code>, e.g., <code>x[0]</code> is the first element
and <code>x[len(x)-1]</code> is the last of <code>x</code>. We can also index from the end of the
list, e.g., <code>x[-1]</code> is the last element of <code>x</code>.<a href="#section-2-3" class="pilcrow">¶</a></p>
<p id="section-2-4">Python uses the symbols <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> as binary operators. When the
operands are integers, these have the usual meaning, except:<a href="#section-2-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-2-5.1">
          <p id="section-2-5.1.1">Division results in a floating point number. Python includes a similar
operator, <code>x // y</code>, which is short for <code>floor(x / y)</code>.<a href="#section-2-5.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-5.2">
          <p id="section-2-5.2.1">When <code>x</code> and <code>y</code> are byte strings, <code>x + y</code> denotes their concatenation, i.e.,
<code>concat(x, y)</code> as defined below.<a href="#section-2-5.2.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-2-6">Note that we overload these operators when defining finite fields; see
<a href="#field" class="auto internal xref">Section 6.1</a>.<a href="#section-2-6" class="pilcrow">¶</a></p>
<p id="section-2-7">Exponentiation is denoted by <code>x ** y</code> in Python. We also sometimes use more
conventional notation for exponentiation, namely <code>x^y</code>.<a href="#section-2-7" class="pilcrow">¶</a></p>
<p id="section-2-8">Type hints are used to define input and output types:<a href="#section-2-8" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-2-9.1">
          <p id="section-2-9.1.1">The type variable <code>F</code> is used in signatures to signify any type that is a
subclass of <code>Field</code> (<a href="#field" class="auto internal xref">Section 6.1</a>).<a href="#section-2-9.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-9.2">
          <p id="section-2-9.2.1"><code>bytes</code> is a byte string.<a href="#section-2-9.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-9.3">
          <p id="section-2-9.3.1"><code>int</code> is an integer.<a href="#section-2-9.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-9.4">
          <p id="section-2-9.4.1"><code>Generic</code> is used in class definitions to explicitly declare type variables
of generic classes.<a href="#section-2-9.4.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-9.5">
          <p id="section-2-9.5.1"><code>Any</code> is the universal supertype, which admits values of any type.<a href="#section-2-9.5.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-9.6">
          <p id="section-2-9.6.1"><code>Optional[T]</code> is shorthand for <code>T | None</code>. Its value may be <code>None</code> or have
type <code>T</code>.<a href="#section-2-9.6.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-9.7">
          <p id="section-2-9.7.1"><code>Self</code> represents the containing class of the method definition in which it
appears.<a href="#section-2-9.7.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-9.8">
          <p id="section-2-9.8.1"><code>Sequence[T]</code> is either a list or tuple of values of type <code>T</code>.<a href="#section-2-9.8.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-2-10">This document defines several byte-string constants. When comprised of printable
ASCII characters, they are written as Python 3 byte-string literals (e.g.,
<code>b'some constant string'</code>).<a href="#section-2-10" class="pilcrow">¶</a></p>
<p id="section-2-11">A global constant <code>VERSION</code> of type <code>int</code> is defined, which algorithms are free
to use as desired. Its value <span class="bcp14">SHALL</span> be <code>12</code>.<a href="#section-2-11" class="pilcrow">¶</a></p>
<p id="section-2-12">This document describes algorithms for multi-party computations in which the
parties typically communicate over a network. Wherever a quantity is defined
that must be transmitted from one party to another, this document prescribes
a particular encoding of that quantity as a byte string.<a href="#section-2-12" class="pilcrow">¶</a></p>
<p id="section-2-13">Some common functionalities:<a href="#section-2-13" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-2-14.1">
          <p id="section-2-14.1.1"><code>additive_secret_share(x: list[F], num_shares: int, field: type[F]) -&gt;
list[list[F]]</code> takes a vector <code>x</code> of field elements and returns <code>num_shares</code>
vectors of length <code>len(x)</code> such that they all add up to the input vector.
Note that this function is not used normatively in this document.<a href="#section-2-14.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-14.2">
          <p id="section-2-14.2.1"><code>byte(x: int) -&gt; bytes</code> returns the representation of the integer <code>x</code> in the
range <code>[0, 256)</code> as a single-byte byte string.<a href="#section-2-14.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-14.3">
          <p id="section-2-14.3.1"><code>cast(typ: type[T], x: object) -&gt; T</code> returns the input value unchanged.
This is only present to assist with static analysis of the Python code.
Type checkers will ignore the inferred type of the input value, and assume
the output value has the given type.<a href="#section-2-14.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-14.4">
          <p id="section-2-14.4.1"><code>concat(parts: list[bytes]) -&gt; bytes</code> returns the concatenation of the input
byte strings, i.e., <code>parts[0] + ... + parts[len(parts)-1]</code>.<a href="#section-2-14.4.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-14.5">
          <p id="section-2-14.5.1"><code>from_be_bytes(encoded: bytes) -&gt; int</code> decodes a big-endian byte string,
i.e., returns the integer <code>x</code> for which <code>to_be_bytes(x, len(encoded)) ==
encoded</code>.<a href="#section-2-14.5.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-14.6">
          <p id="section-2-14.6.1"><code>from_le_bytes(encoded: bytes) -&gt; int</code> decodes a little-endian byte string,
i.e., returns the integer <code>x</code> for which <code>to_le_bytes(x, len(encoded)) ==
encoded</code>.<a href="#section-2-14.6.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-14.7">
          <p id="section-2-14.7.1"><code>front(len: int, x: list[Any]) -&gt; tuple[list[Any], list[Any]]</code> splits <code>x</code>
into two vectors, where the first vector is made up of the first <code>len</code>
elements of <code>x</code> and the second is made up of the remaining elements. This
function is equivalent to <code>(x[:len], x[len:])</code>.<a href="#section-2-14.7.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-14.8">
          <p id="section-2-14.8.1"><code>gen_rand(len: int) -&gt; bytes</code> returns a byte array of the requested length
(<code>len</code>) generated by a cryptographically secure pseudorandom number generator
(CSPRNG).<a href="#section-2-14.8.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-14.9">
          <p id="section-2-14.9.1"><code>next_power_of_2(x: int) -&gt; int</code> returns the smallest integer
greater than or equal to <code>x</code> that is also a power of two.<a href="#section-2-14.9.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-14.10">
          <p id="section-2-14.10.1"><code>range(stop: int)</code> or <code>range(start: int, stop: int[, step: int])</code> is the range
function from the Python standard library. The one-argument form returns the
integers from zero (inclusive) to <code>stop</code> (exclusive). The two- and
three-argument forms allow overriding the start of the range and overriding
the step between successive output values.<a href="#section-2-14.10.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-14.11">
          <p id="section-2-14.11.1"><code>to_be_bytes(x: int, len: int) -&gt; bytes</code> converts an integer <code>x</code> whose value
is in the range <code>[0, 2^(8*len))</code> to a big-endian byte string of length <code>len</code>.<a href="#section-2-14.11.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-14.12">
          <p id="section-2-14.12.1"><code>to_le_bytes(x: int, len: int) -&gt; bytes</code> converts an integer <code>x</code> whose value
is in the range <code>[0, 2^(8*len))</code> to a little-endian byte string of length
<code>len</code>.<a href="#section-2-14.12.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-14.13">
          <p id="section-2-14.13.1"><code>poly_eval(field: type[F], p: list[F], x: F) -&gt; F</code> returns the result of
evaluating the polynomial, <code>p(x)</code>. The coefficients of polynomials are stored
in lists in ascending order of degree, starting with the constant
coefficient. The <code>field</code> parameter is the class object for <code>F</code> and is used by
the implementation to construct field elements. (See <a href="#field" class="auto internal xref">Section 6.1</a>.)<a href="#section-2-14.13.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-14.14">
          <p id="section-2-14.14.1"><code>poly_interp(field: type[F], inputs: list[F], outputs: list[F]) -&gt; list[F]</code>
returns the coefficients of the lowest degree polynomial <code>p</code> for which
<code>p(inputs[k]) == outputs[k]</code> for all <code>k</code>. Normally this will be computed
using the Number Theoretic Transform (NTT) <span>[<a href="#SML24" class="cite xref">SML24</a>]</span>.<a href="#section-2-14.14.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-14.15">
          <p id="section-2-14.15.1"><code>poly_mul(field: type[F], p: list[F], q: list[F]) -&gt; list[F]</code> returns
the product of two polynomials.<a href="#section-2-14.15.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-14.16">
          <p id="section-2-14.16.1"><code>poly_strip(field: type[F], p: list[F]) -&gt; list[F]</code> strips the zeros from the
end of the input polynomial's list of coefficients. That is, it returns
<code>p[:i]</code> where <code>i</code> is the index of the highest-degree non-zero coefficient of
<code>p</code>.<a href="#section-2-14.16.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-14.17">
          <p id="section-2-14.17.1"><code>xor(left: bytes, right: bytes) -&gt; bytes</code> returns the bitwise XOR of <code>left</code>
and <code>right</code>. An exception is raised if the inputs are not the same length.<a href="#section-2-14.17.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-2-14.18">
          <p id="section-2-14.18.1"><code>zeros(len: int) -&gt; bytes</code> returns an array of bytes of the requested
length (<code>len</code>). Each element of the array is set to zero.<a href="#section-2-14.18.1" class="pilcrow">¶</a></p>
</li>
      </ul>
</section>
</div>
<div id="overview">
<section id="section-3">
      <h2 id="name-overview">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-overview" class="section-name selfRef">Overview</a>
      </h2>
<span id="name-overall-data-flow-of-a-vdaf"></span><div id="overall-flow">
<figure id="figure-1">
        <div id="section-3-1.1">
          <div class="alignLeft art-svg artwork" id="section-3-1.1.1">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="336" width="536" viewBox="0 0 536 336" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
              <path d="M 8,176 L 8,208" fill="none" stroke="black"></path>
              <path d="M 80,176 L 80,208" fill="none" stroke="black"></path>
              <path d="M 96,48 L 96,176" fill="none" stroke="black"></path>
              <path d="M 96,208 L 96,304" fill="none" stroke="black"></path>
              <path d="M 112,144 L 112,192" fill="none" stroke="black"></path>
              <path d="M 136,288 L 136,320" fill="none" stroke="black"></path>
              <path d="M 144,32 L 144,64" fill="none" stroke="black"></path>
              <path d="M 144,128 L 144,160" fill="none" stroke="black"></path>
              <path d="M 208,72 L 208,120" fill="none" stroke="black"></path>
              <path d="M 208,168 L 208,192" fill="none" stroke="black"></path>
              <path d="M 208,272 L 208,280" fill="none" stroke="black"></path>
              <path d="M 264,32 L 264,64" fill="none" stroke="black"></path>
              <path d="M 264,128 L 264,160" fill="none" stroke="black"></path>
              <path d="M 272,288 L 272,320" fill="none" stroke="black"></path>
              <path d="M 288,144 L 288,192" fill="none" stroke="black"></path>
              <path d="M 304,48 L 304,176" fill="none" stroke="black"></path>
              <path d="M 304,208 L 304,304" fill="none" stroke="black"></path>
              <path d="M 328,176 L 328,208" fill="none" stroke="black"></path>
              <path d="M 424,176 L 424,208" fill="none" stroke="black"></path>
              <path d="M 144,32 L 264,32" fill="none" stroke="black"></path>
              <path d="M 96,48 L 136,48" fill="none" stroke="black"></path>
              <path d="M 264,48 L 304,48" fill="none" stroke="black"></path>
              <path d="M 144,64 L 264,64" fill="none" stroke="black"></path>
              <path d="M 144,128 L 264,128" fill="none" stroke="black"></path>
              <path d="M 112,144 L 136,144" fill="none" stroke="black"></path>
              <path d="M 272,144 L 288,144" fill="none" stroke="black"></path>
              <path d="M 144,160 L 264,160" fill="none" stroke="black"></path>
              <path d="M 8,176 L 96,176" fill="none" stroke="black"></path>
              <path d="M 304,176 L 424,176" fill="none" stroke="black"></path>
              <path d="M 80,192 L 112,192" fill="none" stroke="black"></path>
              <path d="M 288,192 L 320,192" fill="none" stroke="black"></path>
              <path d="M 424,192 L 448,192" fill="none" stroke="black"></path>
              <path d="M 8,208 L 96,208" fill="none" stroke="black"></path>
              <path d="M 304,208 L 424,208" fill="none" stroke="black"></path>
              <path d="M 136,288 L 272,288" fill="none" stroke="black"></path>
              <path d="M 96,304 L 128,304" fill="none" stroke="black"></path>
              <path d="M 280,304 L 304,304" fill="none" stroke="black"></path>
              <path d="M 136,320 L 272,320" fill="none" stroke="black"></path>
              <polygon class="arrowhead" points="456,192 444,186.4 444,197.6" fill="black" transform="rotate(0,448,192)"></polygon>
              <polygon class="arrowhead" points="328,208 316,202.4 316,213.6" fill="black" transform="rotate(0,320,208)"></polygon>
              <polygon class="arrowhead" points="328,192 316,186.4 316,197.6" fill="black" transform="rotate(0,320,192)"></polygon>
              <polygon class="arrowhead" points="328,176 316,170.4 316,181.6" fill="black" transform="rotate(0,320,176)"></polygon>
              <polygon class="arrowhead" points="216,280 204,274.4 204,285.6" fill="black" transform="rotate(90,208,280)"></polygon>
              <polygon class="arrowhead" points="216,168 204,162.4 204,173.6" fill="black" transform="rotate(270,208,168)"></polygon>
              <polygon class="arrowhead" points="216,120 204,114.4 204,125.6" fill="black" transform="rotate(90,208,120)"></polygon>
              <polygon class="arrowhead" points="216,72 204,66.4 204,77.6" fill="black" transform="rotate(270,208,72)"></polygon>
              <polygon class="arrowhead" points="144,144 132,138.4 132,149.6" fill="black" transform="rotate(0,136,144)"></polygon>
              <polygon class="arrowhead" points="144,48 132,42.4 132,53.6" fill="black" transform="rotate(0,136,48)"></polygon>
              <polygon class="arrowhead" points="136,304 124,298.4 124,309.6" fill="black" transform="rotate(0,128,304)"></polygon>
              <g class="text">
                <text x="196" y="52">Aggregator</text>
                <text x="248" y="52">0</text>
                <text x="64" y="68">input</text>
                <text x="352" y="68">aggregate</text>
                <text x="60" y="84">shares</text>
                <text x="340" y="84">shares</text>
                <text x="196" y="148">Aggregator</text>
                <text x="248" y="148">1</text>
                <text x="44" y="196">Client</text>
                <text x="376" y="196">Collector</text>
                <text x="496" y="196">aggregate</text>
                <text x="208" y="228">...</text>
                <text x="208" y="260">|</text>
                <text x="188" y="308">Aggregator</text>
                <text x="248" y="308">N-1</text>
              </g>
            </svg><a href="#section-3-1.1.1" class="pilcrow">¶</a>
</div>
</div>
<figcaption><a href="#figure-1" class="selfRef">Figure 1</a>:
<a href="#name-overall-data-flow-of-a-vdaf" class="selfRef">Overall data flow of a (V)DAF.</a>
        </figcaption></figure>
</div>
<p id="section-3-2">In a DAF- or VDAF-based private measurement system, we distinguish between
three types of actors: Clients, Aggregators, and the Collector.  The overall
flow of the measurement process is as follows:<a href="#section-3-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3-3.1">
          <p id="section-3-3.1.1">To submit an individual measurement, the Client shards the measurement into
"input shares" and sends one input share to each Aggregator. We sometimes
refer to this sequence of input shares collectively as the Client's "report".<a href="#section-3-3.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-3-3.2">
          <p id="section-3-3.2.1">The Aggregators refine their input shares into "output shares":<a href="#section-3-3.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-3-3.2.2.1">
              <p id="section-3-3.2.2.1.1">Output shares are in one-to-one correspondence with the input shares.<a href="#section-3-3.2.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-3-3.2.2.2">
              <p id="section-3-3.2.2.2.1">Just as each Aggregator receives one input share of each measurement, if
this process succeeds, then each aggregator holds one output share.<a href="#section-3-3.2.2.2.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-3-3.2.2.3">
              <p id="section-3-3.2.2.3.1">In VDAFs, Aggregators will need to exchange information among themselves
as part of the validation process.<a href="#section-3-3.2.2.3.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</li>
        <li class="normal" id="section-3-3.3">
          <p id="section-3-3.3.1">As each Aggregator recovers output shares, it accumulates them into an
"aggregate share" for the batch of measurements.<a href="#section-3-3.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-3-3.4">
          <p id="section-3-3.4.1">The Aggregators submit their aggregate shares to the Collector, who combines
them to obtain the aggregate result over the batch.<a href="#section-3-3.4.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-3-4">Aggregators are a new class of actor relative to traditional measurement systems
where Clients submit measurements to a single server.  They are critical for
both the privacy properties of the system and, in the case of VDAFs, the
validity of the aggregate results obtained.  The privacy properties of the
system are assured by non-collusion among Aggregators, and Aggregators are the
entities that perform validation of Client measurements.  Thus Clients trust
Aggregators not to collude (typically it is required that at least one
Aggregator is honest; see <a href="#num-aggregators" class="auto internal xref">Section 9.8</a>), and Collectors trust
Aggregators to correctly run the protocol.<a href="#section-3-4" class="pilcrow">¶</a></p>
<p id="section-3-5">Within the bounds of the non-collusion requirements of a given (V)DAF instance,
it is possible for the same entity to play more than one role.  For example, the
Collector could also act as an Aggregator, effectively using the other
Aggregator(s) to augment a basic client-server protocol.<a href="#section-3-5" class="pilcrow">¶</a></p>
<p id="section-3-6">In this document, we describe the computations performed by the actors in this
system. It is up to the higher-level protocol making use of the (V)DAF to
arrange for the required information to be delivered to the proper actors in the
proper sequence. In general, we assume that all communications are confidential
and mutually authenticated, with the exception that Clients submitting
measurements may be anonymous.<a href="#section-3-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="daf">
<section id="section-4">
      <h2 id="name-definition-of-dafs">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-definition-of-dafs" class="section-name selfRef">Definition of DAFs</a>
      </h2>
<p id="section-4-1">By way of a gentle introduction to VDAFs, this section describes a simpler class
of schemes called Distributed Aggregation Functions (DAFs). Unlike VDAFs, DAFs
do not provide verifiability of the computation. Clients must therefore be
trusted to compute their input shares correctly. Because of this fact, the use
of a DAF is <span class="bcp14">NOT RECOMMENDED</span> for most applications. See <a href="#security" class="auto internal xref">Section 9</a> for
additional discussion.<a href="#section-4-1" class="pilcrow">¶</a></p>
<p id="section-4-2">A DAF scheme is used to compute a particular "aggregation function" over a set
of measurements generated by Clients. Depending on the aggregation function, the
Collector might select an "aggregation parameter" and disseminate it to the
Aggregators. The semantics of this parameter is specific to the aggregation
function, but in general it is used to represent the set of "queries" that can
be made by the Collector on the batch of measurements. For example, the
aggregation parameter is used to represent the candidate prefixes in the
Poplar1 VDAF (<a href="#poplar1" class="auto internal xref">Section 8</a>).<a href="#section-4-2" class="pilcrow">¶</a></p>
<p id="section-4-3">Execution of a DAF has four distinct stages:<a href="#section-4-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4-4.1">
          <p id="section-4-4.1.1">Sharding: Each Client generates input shares from its measurement and
distributes them among the Aggregators. In addition to the input shares, the
client generates a "public share" during this step that is disseminated to
all of the Aggregators.<a href="#section-4-4.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-4-4.2">
          <p id="section-4-4.2.1">Preparation: Each Aggregator converts each input share into an output share
compatible with the aggregation function. This computation involves the
aggregation parameter. In general, each aggregation parameter may result in a
different output share.<a href="#section-4-4.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-4-4.3">
          <p id="section-4-4.3.1">Aggregation: Each Aggregator combines a sequence of output shares into its
aggregate share and sends the aggregate share to the Collector.<a href="#section-4-4.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-4-4.4">
          <p id="section-4-4.4.1">Unsharding: The Collector combines the aggregate shares into the aggregate
result.<a href="#section-4-4.4.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-4-5">Sharding and preparation are done once per measurement. Aggregation and
unsharding are done over a batch of measurements (more precisely, over the
recovered output shares).<a href="#section-4-5" class="pilcrow">¶</a></p>
<p id="section-4-6">A concrete DAF specifies the algorithm for the computation needed in each of
these stages. The interface, denoted <code>Daf</code>, is defined in the remainder of this
section. In addition, a concrete DAF defines the associated constants and types
enumerated in the following table.<a href="#section-4-6" class="pilcrow">¶</a></p>
<span id="name-constants-and-types-defined"></span><div id="daf-param">
<table class="center" id="table-1">
        <caption>
<a href="#table-1" class="selfRef">Table 1</a>:
<a href="#name-constants-and-types-defined" class="selfRef">Constants and types defined by each concrete DAF.</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Parameter</th>
            <th class="text-left" rowspan="1" colspan="1">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>ID: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Algorithm identifier for this DAF, in the range <code>[0, 2^32)</code>.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>SHARES: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Number of input shares into which each measurement is sharded.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>NONCE_SIZE: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Size of the nonce associated with the report.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>RAND_SIZE: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Size of the random byte string consumed by the sharding algorithm.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>Measurement</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each measurement.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>PublicShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each public share.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>InputShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each input share.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>AggParam</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of the aggregation parameter.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>OutShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each output share.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>AggShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of the aggregate share.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>AggResult</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of the aggregate result.</td>
          </tr>
        </tbody>
      </table>
</div>
<p id="section-4-8">The types in this table define the inputs and outputs of DAF methods at various
stages of the computation. Some of these values need to be written to the
network in order to carry out the computation. In particular, it is <span class="bcp14">RECOMMENDED</span>
that concrete instantiations of the <code>Daf</code> interface specify a standard encoding
for the <code>PublicShare</code>, <code>InputShare</code>, <code>AggParam</code>, and <code>AggShare</code> types.<a href="#section-4-8" class="pilcrow">¶</a></p>
<div id="sec-daf-shard">
<section id="section-4.1">
        <h3 id="name-sharding">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-sharding" class="section-name selfRef">Sharding</a>
        </h3>
<span id="name-illustration-of-the-shardin"></span><div id="shard-flow">
<figure id="figure-2">
          <div id="section-4.1-1.1">
            <div class="alignLeft art-svg artwork" id="section-4.1-1.1.1">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="384" width="432" viewBox="0 0 432 384" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                <path d="M 8,144 L 8,176" fill="none" stroke="black"></path>
                <path d="M 24,96 L 24,136" fill="none" stroke="black"></path>
                <path d="M 24,176 L 24,272" fill="none" stroke="black"></path>
                <path d="M 24,304 L 24,336" fill="none" stroke="black"></path>
                <path d="M 64,240 L 64,272" fill="none" stroke="black"></path>
                <path d="M 64,296 L 64,336" fill="none" stroke="black"></path>
                <path d="M 144,176 L 144,272" fill="none" stroke="black"></path>
                <path d="M 144,304 L 144,336" fill="none" stroke="black"></path>
                <path d="M 192,240 L 192,272" fill="none" stroke="black"></path>
                <path d="M 192,304 L 192,336" fill="none" stroke="black"></path>
                <path d="M 264,176 L 264,272" fill="none" stroke="black"></path>
                <path d="M 264,304 L 264,336" fill="none" stroke="black"></path>
                <path d="M 312,176 L 312,192" fill="none" stroke="black"></path>
                <path d="M 312,224 L 312,272" fill="none" stroke="black"></path>
                <path d="M 312,304 L 312,336" fill="none" stroke="black"></path>
                <path d="M 384,144 L 384,176" fill="none" stroke="black"></path>
                <path d="M 8,46 L 48,46" fill="none" stroke="black"></path>
                <path d="M 8,50 L 48,50" fill="none" stroke="black"></path>
                <path d="M 8,144 L 384,144" fill="none" stroke="black"></path>
                <path d="M 8,176 L 384,176" fill="none" stroke="black"></path>
                <path d="M 64,240 L 136,240" fill="none" stroke="black"></path>
                <path d="M 152,240 L 256,240" fill="none" stroke="black"></path>
                <path d="M 272,240 L 312,240" fill="none" stroke="black"></path>
                <polygon class="arrowhead" points="320,336 308,330.4 308,341.6" fill="black" transform="rotate(90,312,336)"></polygon>
                <polygon class="arrowhead" points="272,336 260,330.4 260,341.6" fill="black" transform="rotate(90,264,336)"></polygon>
                <polygon class="arrowhead" points="272,272 260,266.4 260,277.6" fill="black" transform="rotate(90,264,272)"></polygon>
                <polygon class="arrowhead" points="200,336 188,330.4 188,341.6" fill="black" transform="rotate(90,192,336)"></polygon>
                <polygon class="arrowhead" points="152,336 140,330.4 140,341.6" fill="black" transform="rotate(90,144,336)"></polygon>
                <polygon class="arrowhead" points="152,272 140,266.4 140,277.6" fill="black" transform="rotate(90,144,272)"></polygon>
                <polygon class="arrowhead" points="72,336 60,330.4 60,341.6" fill="black" transform="rotate(90,64,336)"></polygon>
                <polygon class="arrowhead" points="32,336 20,330.4 20,341.6" fill="black" transform="rotate(90,24,336)"></polygon>
                <polygon class="arrowhead" points="32,272 20,266.4 20,277.6" fill="black" transform="rotate(90,24,272)"></polygon>
                <polygon class="arrowhead" points="32,136 20,130.4 20,141.6" fill="black" transform="rotate(90,24,136)"></polygon>
                <g class="text">
                  <text x="28" y="36">Client</text>
                  <text x="48" y="84">measurement</text>
                  <text x="40" y="164">shard</text>
                  <text x="232" y="212">...</text>
                  <text x="348" y="212">public_share</text>
                  <text x="64" y="292">input_share_0</text>
                  <text x="184" y="292">input_share_1</text>
                  <text x="340" y="292">input_share_[SHARES-1]</text>
                  <text x="232" y="324">...</text>
                  <text x="44" y="356">Aggregator</text>
                  <text x="96" y="356">0</text>
                  <text x="164" y="356">Aggregator</text>
                  <text x="216" y="356">1</text>
                  <text x="292" y="356">Aggregator</text>
                  <text x="372" y="356">SHARES-1</text>
                </g>
              </svg><a href="#section-4.1-1.1.1" class="pilcrow">¶</a>
</div>
</div>
<figcaption><a href="#figure-2" class="selfRef">Figure 2</a>:
<a href="#name-illustration-of-the-shardin" class="selfRef">Illustration of the sharding algorithm.</a>
          </figcaption></figure>
</div>
<p id="section-4.1-2">The sharding algorithm run by each Client is defined as follows:<a href="#section-4.1-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.1-3.1">
            <p id="section-4.1-3.1.1"><code>daf.shard(ctx: bytes, measurement: Measurement, nonce: bytes, rand: bytes)
-&gt; tuple[PublicShare, list[InputShare]]</code> consumes the "application context"
(defined below), a measurement, and a nonce and produces the public share,
distributed to each of the Aggregators, and the input shares, one for each
Aggregator.<a href="#section-4.1-3.1.1" class="pilcrow">¶</a></p>
<p id="section-4.1-3.1.2">
Pre-conditions:<a href="#section-4.1-3.1.2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.1-3.1.3.1">
                <p id="section-4.1-3.1.3.1.1"><code>nonce</code> <span class="bcp14">MUST</span> have length equal to <code>daf.NONCE_SIZE</code> and <span class="bcp14">MUST</span> be generated
using a cryptographically secure random number generator (CSPRNG).<a href="#section-4.1-3.1.3.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-4.1-3.1.3.2">
                <p id="section-4.1-3.1.3.2.1"><code>rand</code> consists of the random bytes consumed by the algorithm. It <span class="bcp14">MUST</span> have
length equal to <code>daf.RAND_SIZE</code> and <span class="bcp14">MUST</span> be generated using a CSPRNG.<a href="#section-4.1-3.1.3.2.1" class="pilcrow">¶</a></p>
</li>
            </ul>
<p id="section-4.1-3.1.4">
Post-conditions:<a href="#section-4.1-3.1.4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.1-3.1.5.1">
                <p id="section-4.1-3.1.5.1.1">The number of input shares <span class="bcp14">MUST</span> equal <code>daf.SHARES</code>.<a href="#section-4.1-3.1.5.1.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
        </ul>
<p id="section-4.1-4">Sharding is bound to a specific "application context". The application context
is a string intended to uniquely identify an instance of the higher level
protocol that uses the DAF. The goal of binding the application to DAF
execution is to ensure that aggregation succeeds only if the Clients and
Aggregators agree on the application context. (Preparation binds the
application context, too; see <a href="#sec-daf-prepare" class="auto internal xref">Section 4.2</a>.) Note that, unlike VDAFs
(<a href="#vdaf" class="auto internal xref">Section 5</a>), there is no explicit signal of disagreement; it may only manifest
as a garbled aggregate result.<a href="#section-4.1-4" class="pilcrow">¶</a></p>
<p id="section-4.1-5">The nonce is a public random value associated with the report. It is referred
to as a nonce because normally it will also be used as a unique identifier for
that report in the context of some application. The randomness requirement is
especially important for VDAFs, where it may be used by the Aggregators to
derive per-report randomness for verification of the computation. See
<a href="#nonce-requirements" class="auto internal xref">Section 9.2</a> for details.<a href="#section-4.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-daf-prepare">
<section id="section-4.2">
        <h3 id="name-preparation">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-preparation" class="section-name selfRef">Preparation</a>
        </h3>
<span id="name-illustration-of-preparation"></span><div id="daf-prep-flow">
<figure id="figure-3">
          <div id="section-4.2-1.1">
            <div class="alignLeft art-svg artwork" id="section-4.2-1.1.1">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="240" width="488" viewBox="0 0 488 240" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                <path d="M 8,128 L 8,160" fill="none" stroke="black"></path>
                <path d="M 24,96 L 24,120" fill="none" stroke="black"></path>
                <path d="M 24,160 L 24,192" fill="none" stroke="black"></path>
                <path d="M 104,128 L 104,160" fill="none" stroke="black"></path>
                <path d="M 128,128 L 128,160" fill="none" stroke="black"></path>
                <path d="M 144,96 L 144,120" fill="none" stroke="black"></path>
                <path d="M 144,160 L 144,192" fill="none" stroke="black"></path>
                <path d="M 224,128 L 224,160" fill="none" stroke="black"></path>
                <path d="M 312,128 L 312,160" fill="none" stroke="black"></path>
                <path d="M 328,96 L 328,120" fill="none" stroke="black"></path>
                <path d="M 328,160 L 328,192" fill="none" stroke="black"></path>
                <path d="M 408,128 L 408,160" fill="none" stroke="black"></path>
                <path d="M 8,46 L 96,46" fill="none" stroke="black"></path>
                <path d="M 8,50 L 96,50" fill="none" stroke="black"></path>
                <path d="M 128,46 L 216,46" fill="none" stroke="black"></path>
                <path d="M 128,50 L 216,50" fill="none" stroke="black"></path>
                <path d="M 312,46 L 456,46" fill="none" stroke="black"></path>
                <path d="M 312,50 L 456,50" fill="none" stroke="black"></path>
                <path d="M 8,128 L 104,128" fill="none" stroke="black"></path>
                <path d="M 128,128 L 224,128" fill="none" stroke="black"></path>
                <path d="M 312,128 L 408,128" fill="none" stroke="black"></path>
                <path d="M 8,160 L 104,160" fill="none" stroke="black"></path>
                <path d="M 128,160 L 224,160" fill="none" stroke="black"></path>
                <path d="M 312,160 L 408,160" fill="none" stroke="black"></path>
                <polygon class="arrowhead" points="336,192 324,186.4 324,197.6" fill="black" transform="rotate(90,328,192)"></polygon>
                <polygon class="arrowhead" points="336,120 324,114.4 324,125.6" fill="black" transform="rotate(90,328,120)"></polygon>
                <polygon class="arrowhead" points="152,192 140,186.4 140,197.6" fill="black" transform="rotate(90,144,192)"></polygon>
                <polygon class="arrowhead" points="152,120 140,114.4 140,125.6" fill="black" transform="rotate(90,144,120)"></polygon>
                <polygon class="arrowhead" points="32,192 20,186.4 20,197.6" fill="black" transform="rotate(90,24,192)"></polygon>
                <polygon class="arrowhead" points="32,120 20,114.4 20,125.6" fill="black" transform="rotate(90,24,120)"></polygon>
                <g class="text">
                  <text x="44" y="36">Aggregator</text>
                  <text x="96" y="36">0</text>
                  <text x="164" y="36">Aggregator</text>
                  <text x="216" y="36">1</text>
                  <text x="348" y="36">Aggregator</text>
                  <text x="428" y="36">SHARES-1</text>
                  <text x="56" y="84">input_share_0</text>
                  <text x="176" y="84">input_share_1</text>
                  <text x="396" y="84">input_share_[SHARES-1]</text>
                  <text x="296" y="100">...</text>
                  <text x="36" y="148">prep</text>
                  <text x="156" y="148">prep</text>
                  <text x="340" y="148">prep</text>
                  <text x="296" y="180">...</text>
                  <text x="48" y="212">out_share_0</text>
                  <text x="168" y="212">out_share_1</text>
                  <text x="388" y="212">out_share_[SHARES-1]</text>
                </g>
              </svg><a href="#section-4.2-1.1.1" class="pilcrow">¶</a>
</div>
</div>
<figcaption><a href="#figure-3" class="selfRef">Figure 3</a>:
<a href="#name-illustration-of-preparation" class="selfRef">Illustration of preparation.</a>
          </figcaption></figure>
</div>
<p id="section-4.2-2">Once an Aggregator has received the public share and its input share, the next
step is to prepare the input share for aggregation. This is accomplished using
the preparation algorithm:<a href="#section-4.2-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.2-3.1">
            <p id="section-4.2-3.1.1"><code>daf.prep(ctx: bytes, agg_id: int, agg_param: AggParam, nonce: bytes,
public_share: PublicShare, input_share: InputShare) -&gt; OutShare</code> consumes the
public share and one of the input shares generated by the Client, the
application context, the Aggregator's unique identifier, the aggregation
parameter selected by the Collector, and the report nonce and returns an
output share.<a href="#section-4.2-3.1.1" class="pilcrow">¶</a></p>
<p id="section-4.2-3.1.2">
Pre-conditions:<a href="#section-4.2-3.1.2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.2-3.1.3.1">
                <p id="section-4.2-3.1.3.1.1"><code>agg_id</code> <span class="bcp14">MUST</span> be in the range <code>[0, daf.SHARES)</code> and match the index of
<code>input_share</code> in the sequence of input shares produced by the Client.<a href="#section-4.2-3.1.3.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-4.2-3.1.3.2">
                <p id="section-4.2-3.1.3.2.1"><code>nonce</code> <span class="bcp14">MUST</span> have length <code>daf.NONCE_SIZE</code>.<a href="#section-4.2-3.1.3.2.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
        </ul>
<p id="section-4.2-4">The Aggregators <span class="bcp14">MUST</span> agree on the value of the aggregation parameter.
Otherwise, the aggregate result may be computed incorrectly by the Collector.<a href="#section-4.2-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-daf-validity-scopes">
<section id="section-4.3">
        <h3 id="name-validity-of-aggregation-par">
<a href="#section-4.3" class="section-number selfRef">4.3. </a><a href="#name-validity-of-aggregation-par" class="section-name selfRef">Validity of Aggregation Parameters</a>
        </h3>
<p id="section-4.3-1">In general, it is permissible to aggregate a batch of reports multiple times.
However, to prevent privacy violations, DAFs may impose certain restrictions on
the aggregation parameters selected by the Collector. Restrictions are
expressed by the aggregation parameter validity function:<a href="#section-4.3-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3-2.1">
            <p id="section-4.3-2.1.1"><code>daf.is_valid(agg_param: AggParam, previous_agg_params: list[AggParam]) -&gt;
bool</code> returns <code>True</code> if <code>agg_param</code> is allowed given the sequence
<code>previous_agg_params</code> of previously accepted aggregation parameters.<a href="#section-4.3-2.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-4.3-3">Prior to accepting an aggregation parameter from the Collector and beginning
preparation, each Aggregator <span class="bcp14">MUST</span> validate it using this function.<a href="#section-4.3-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-daf-aggregate">
<section id="section-4.4">
        <h3 id="name-aggregation">
<a href="#section-4.4" class="section-number selfRef">4.4. </a><a href="#name-aggregation" class="section-name selfRef">Aggregation</a>
        </h3>
<span id="name-illustration-of-aggregation"></span><div id="aggregate-flow">
<figure id="figure-4">
          <div id="section-4.4-1.1">
            <div class="alignLeft art-svg artwork" id="section-4.4-1.1.1">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="432" width="392" viewBox="0 0 392 432" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                <path d="M 8,80 L 8,112" fill="none" stroke="black"></path>
                <path d="M 112,80 L 112,112" fill="none" stroke="black"></path>
                <path d="M 152,80 L 152,112" fill="none" stroke="black"></path>
                <path d="M 152,160 L 152,192" fill="none" stroke="black"></path>
                <path d="M 152,320 L 152,352" fill="none" stroke="black"></path>
                <path d="M 176,112 L 176,152" fill="none" stroke="black"></path>
                <path d="M 176,192 L 176,224" fill="none" stroke="black"></path>
                <path d="M 176,288 L 176,312" fill="none" stroke="black"></path>
                <path d="M 176,352 L 176,384" fill="none" stroke="black"></path>
                <path d="M 256,80 L 256,112" fill="none" stroke="black"></path>
                <path d="M 256,160 L 256,192" fill="none" stroke="black"></path>
                <path d="M 256,320 L 256,352" fill="none" stroke="black"></path>
                <path d="M 8,46 L 96,46" fill="none" stroke="black"></path>
                <path d="M 8,50 L 96,50" fill="none" stroke="black"></path>
                <path d="M 8,80 L 112,80" fill="none" stroke="black"></path>
                <path d="M 152,80 L 256,80" fill="none" stroke="black"></path>
                <path d="M 112,96 L 144,96" fill="none" stroke="black"></path>
                <path d="M 264,96 L 288,96" fill="none" stroke="black"></path>
                <path d="M 8,112 L 112,112" fill="none" stroke="black"></path>
                <path d="M 152,112 L 256,112" fill="none" stroke="black"></path>
                <path d="M 152,160 L 256,160" fill="none" stroke="black"></path>
                <path d="M 264,176 L 288,176" fill="none" stroke="black"></path>
                <path d="M 152,192 L 256,192" fill="none" stroke="black"></path>
                <path d="M 152,320 L 256,320" fill="none" stroke="black"></path>
                <path d="M 264,336 L 288,336" fill="none" stroke="black"></path>
                <path d="M 152,352 L 256,352" fill="none" stroke="black"></path>
                <polygon class="arrowhead" points="272,336 260,330.4 260,341.6" fill="black" transform="rotate(180,264,336)"></polygon>
                <polygon class="arrowhead" points="272,176 260,170.4 260,181.6" fill="black" transform="rotate(180,264,176)"></polygon>
                <polygon class="arrowhead" points="272,96 260,90.4 260,101.6" fill="black" transform="rotate(180,264,96)"></polygon>
                <polygon class="arrowhead" points="184,384 172,378.4 172,389.6" fill="black" transform="rotate(90,176,384)"></polygon>
                <polygon class="arrowhead" points="184,312 172,306.4 172,317.6" fill="black" transform="rotate(90,176,312)"></polygon>
                <polygon class="arrowhead" points="184,224 172,218.4 172,229.6" fill="black" transform="rotate(90,176,224)"></polygon>
                <polygon class="arrowhead" points="184,152 172,146.4 172,157.6" fill="black" transform="rotate(90,176,152)"></polygon>
                <polygon class="arrowhead" points="152,96 140,90.4 140,101.6" fill="black" transform="rotate(0,144,96)"></polygon>
                <g class="text">
                  <text x="44" y="36">Aggregator</text>
                  <text x="96" y="36">j</text>
                  <text x="52" y="100">agg_init</text>
                  <text x="204" y="100">agg_update</text>
                  <text x="344" y="100">out_share_0</text>
                  <text x="204" y="180">agg_update</text>
                  <text x="344" y="180">out_share_1</text>
                  <text x="176" y="260">...</text>
                  <text x="204" y="340">agg_update</text>
                  <text x="344" y="340">out_share_M</text>
                  <text x="200" y="404">agg_share_j</text>
                </g>
              </svg><a href="#section-4.4-1.1.1" class="pilcrow">¶</a>
</div>
</div>
<figcaption><a href="#figure-4" class="selfRef">Figure 4</a>:
<a href="#name-illustration-of-aggregation" class="selfRef">Illustration of aggregation. The number of measurements in the batch is denoted by M.</a>
          </figcaption></figure>
</div>
<p id="section-4.4-2">Once an Aggregator holds an output share, it adds it into its aggregate share
for the batch. This streaming aggregation process is implemented by the
following pair of algorithms:<a href="#section-4.4-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.4-3.1">
            <p id="section-4.4-3.1.1"><code>daf.agg_init(agg_param: AggParam) -&gt; AggShare</code> returns an empty aggregate
share. It is called to initialize aggregation of a batch of measurements.<a href="#section-4.4-3.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.4-3.2">
            <p id="section-4.4-3.2.1"><code>daf.agg_update(agg_param: AggParam, agg_share: AggShare, out_share:
OutShare) -&gt; AggShare</code> accumulates an output share into an aggregate share
and returns the updated aggregate share.<a href="#section-4.4-3.2.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-4.4-4">In many situations it is desirable to split an aggregate share across multiple
storage elements, then merge the aggregate shares together just before
releasing the completed aggregate share to the Collector. DAFs facilitate this
with the following method:<a href="#section-4.4-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.4-5.1">
            <p id="section-4.4-5.1.1"><code>daf.merge(agg_param: AggParam, agg_shares: list[AggShare]) -&gt; AggShare</code>
merges a sequence of aggregate shares into a single aggregate share.<a href="#section-4.4-5.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<div id="agg-order">
<section id="section-4.4.1">
          <h4 id="name-aggregation-order">
<a href="#section-4.4.1" class="section-number selfRef">4.4.1. </a><a href="#name-aggregation-order" class="section-name selfRef">Aggregation Order</a>
          </h4>
<p id="section-4.4.1-1">For most DAFs and VDAFs, the outcome of aggregation is not sensitive to the
order in which output shares are aggregated. This means that aggregate shares
can be updated or merged with other aggregate shares in any order. For
instance, for both Prio3 (<a href="#prio3" class="auto internal xref">Section 7</a>) and Poplar1 (<a href="#poplar1" class="auto internal xref">Section 8</a>), the aggregate
shares and output shares both have the same type, a vector over some finite
field (<a href="#field" class="auto internal xref">Section 6.1</a>); and aggregation involves simply adding vectors together.<a href="#section-4.4.1-1" class="pilcrow">¶</a></p>
<p id="section-4.4.1-2">In theory, however, there may be a DAF or VDAF for which correct execution
requires each Aggregator to aggregate output shares in the same order.<a href="#section-4.4.1-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="sec-daf-unshard">
<section id="section-4.5">
        <h3 id="name-unsharding">
<a href="#section-4.5" class="section-number selfRef">4.5. </a><a href="#name-unsharding" class="section-name selfRef">Unsharding</a>
        </h3>
<span id="name-illustration-of-unsharding"></span><div id="unshard-flow">
<figure id="figure-5">
          <div id="section-4.5-1.1">
            <div class="alignLeft art-svg artwork" id="section-4.5-1.1.1">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="288" width="456" viewBox="0 0 456 288" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                <path d="M 8,128 L 8,160" fill="none" stroke="black"></path>
                <path d="M 24,88 L 24,120" fill="none" stroke="black"></path>
                <path d="M 24,160 L 24,192" fill="none" stroke="black"></path>
                <path d="M 152,88 L 152,120" fill="none" stroke="black"></path>
                <path d="M 312,88 L 312,120" fill="none" stroke="black"></path>
                <path d="M 392,128 L 392,160" fill="none" stroke="black"></path>
                <path d="M 8,46 L 96,46" fill="none" stroke="black"></path>
                <path d="M 8,50 L 96,50" fill="none" stroke="black"></path>
                <path d="M 136,46 L 224,46" fill="none" stroke="black"></path>
                <path d="M 136,50 L 224,50" fill="none" stroke="black"></path>
                <path d="M 296,46 L 440,46" fill="none" stroke="black"></path>
                <path d="M 296,50 L 440,50" fill="none" stroke="black"></path>
                <path d="M 8,128 L 392,128" fill="none" stroke="black"></path>
                <path d="M 8,160 L 392,160" fill="none" stroke="black"></path>
                <path d="M 8,254 L 72,254" fill="none" stroke="black"></path>
                <path d="M 8,258 L 72,258" fill="none" stroke="black"></path>
                <polygon class="arrowhead" points="320,120 308,114.4 308,125.6" fill="black" transform="rotate(90,312,120)"></polygon>
                <polygon class="arrowhead" points="160,120 148,114.4 148,125.6" fill="black" transform="rotate(90,152,120)"></polygon>
                <polygon class="arrowhead" points="32,192 20,186.4 20,197.6" fill="black" transform="rotate(90,24,192)"></polygon>
                <polygon class="arrowhead" points="32,120 20,114.4 20,125.6" fill="black" transform="rotate(90,24,120)"></polygon>
                <g class="text">
                  <text x="44" y="36">Aggregator</text>
                  <text x="96" y="36">0</text>
                  <text x="172" y="36">Aggregator</text>
                  <text x="224" y="36">1</text>
                  <text x="332" y="36">Aggregator</text>
                  <text x="412" y="36">SHARES-1</text>
                  <text x="48" y="84">agg_share_0</text>
                  <text x="176" y="84">agg_share_1</text>
                  <text x="372" y="84">agg_share_[SHARES-1]</text>
                  <text x="48" y="148">unshard</text>
                  <text x="44" y="212">agg_result</text>
                  <text x="40" y="244">Collector</text>
                </g>
              </svg><a href="#section-4.5-1.1.1" class="pilcrow">¶</a>
</div>
</div>
<figcaption><a href="#figure-5" class="selfRef">Figure 5</a>:
<a href="#name-illustration-of-unsharding" class="selfRef">Illustration of unsharding.</a>
          </figcaption></figure>
</div>
<p id="section-4.5-2">After the Aggregators have aggregated all measurements in the batch, each sends
its aggregate share to the Collector, who runs the unsharding algorithm to
recover the aggregate result:<a href="#section-4.5-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.5-3.1">
            <p id="section-4.5-3.1.1"><code>daf.unshard(agg_param: AggParam, agg_shares: list[AggShare],
num_measurements: int) -&gt; AggResult</code> consumes the aggregate shares
and produces the aggregate result.<a href="#section-4.5-3.1.1" class="pilcrow">¶</a></p>
<p id="section-4.5-3.1.2">
Pre-conditions:<a href="#section-4.5-3.1.2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.5-3.1.3.1">
                <p id="section-4.5-3.1.3.1.1">The length of <code>agg_shares</code> <span class="bcp14">MUST</span> be <code>SHARES</code>.<a href="#section-4.5-3.1.3.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-4.5-3.1.3.2">
                <p id="section-4.5-3.1.3.2.1"><code>num_measurements</code> <span class="bcp14">MUST</span> equal the number of measurements in the batch.<a href="#section-4.5-3.1.3.2.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
        </ul>
</section>
</div>
<div id="daf-execution">
<section id="section-4.6">
        <h3 id="name-execution-of-a-daf">
<a href="#section-4.6" class="section-number selfRef">4.6. </a><a href="#name-execution-of-a-daf" class="section-name selfRef">Execution of a DAF</a>
        </h3>
<p id="section-4.6-1">Secure execution of a DAF involves simulating the following procedure over an
insecure network.<a href="#section-4.6-1" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-4.6-2">
<pre>
def run_daf(
        daf: Daf[
            Measurement,
            AggParam,
            PublicShare,
            InputShare,
            OutShare,
            AggShare,
            AggResult,
        ],
        ctx: bytes,
        agg_param: AggParam,
        measurements: list[Measurement]) -&gt; AggResult:
    agg_shares: list[AggShare]
    agg_shares = [daf.agg_init(agg_param)
                  for _ in range(daf.SHARES)]
    for measurement in measurements:
        # Sharding
        nonce = gen_rand(daf.NONCE_SIZE)
        rand = gen_rand(daf.RAND_SIZE)
        (public_share, input_shares) = \
            daf.shard(ctx, measurement, nonce, rand)

        # Preparation, aggregation
        for j in range(daf.SHARES):
            out_share = daf.prep(ctx, j, agg_param, nonce,
                                 public_share, input_shares[j])
            agg_shares[j] = daf.agg_update(agg_param,
                                           agg_shares[j],
                                           out_share)

    # Unsharding
    num_measurements = len(measurements)
    agg_result = daf.unshard(agg_param, agg_shares,
                             num_measurements)
    return agg_result
</pre><a href="#section-4.6-2" class="pilcrow">¶</a>
</div>
<p id="section-4.6-3">The inputs to this procedure include the parameters of the aggregation function
computed by the DAF: an aggregation parameter and a sequence of measurements.
They also include the application context. The procedure prescribes how a DAF is
executed in a "benign" environment in which there is no adversary and the
messages are passed among the protocol participants over secure point-to-point
channels. In reality, these channels need to be instantiated by some "wrapper
protocol", such as <span>[<a href="#DAP" class="cite xref">DAP</a>]</span>, that realizes these channels using suitable
cryptographic mechanisms. Moreover, some fraction of the Aggregators (or
Clients) may be malicious and diverge from their prescribed behaviors.
<a href="#security" class="auto internal xref">Section 9</a> describes the execution of the DAF in various adversarial
environments and what properties the wrapper protocol needs to provide in each.<a href="#section-4.6-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="vdaf">
<section id="section-5">
      <h2 id="name-definition-of-vdafs">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-definition-of-vdafs" class="section-name selfRef">Definition of VDAFs</a>
      </h2>
<p id="section-5-1">VDAFs are identical to DAFs except that preparation is an interactive process
carried out by the Aggregators. If successful, this process results in each
Aggregator computing an output share. The process will fail if, for example,
the underlying measurement is invalid.<a href="#section-5-1" class="pilcrow">¶</a></p>
<p id="section-5-2">Failure manifests as an exception raised by one of the algorithms defined in
this section. If an exception is raised during preparation, the Aggregators
<span class="bcp14">MUST</span> remove the report from the batch and not attempt to aggregate it.
Otherwise, a malicious Client can cause the Collector to compute a malformed
aggregate result.<a href="#section-5-2" class="pilcrow">¶</a></p>
<p id="section-5-3">The remainder of this section defines the VDAF interface, which we denote by
<code>Vdaf</code>. The attributes listed in <a href="#vdaf-param" class="auto internal xref">Table 2</a> are defined by each concrete
VDAF.<a href="#section-5-3" class="pilcrow">¶</a></p>
<span id="name-constants-and-types-defined-"></span><div id="vdaf-param">
<table class="center" id="table-2">
        <caption>
<a href="#table-2" class="selfRef">Table 2</a>:
<a href="#name-constants-and-types-defined-" class="selfRef">Constants and types defined by each concrete VDAF.</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Parameter</th>
            <th class="text-left" rowspan="1" colspan="1">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>ID: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Algorithm identifier for this VDAF, in the range <code>[0, 2^32)</code>.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>SHARES: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Number of input shares into which each measurement is sharded.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>ROUNDS: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Number of rounds of communication during preparation.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>NONCE_SIZE: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Size of the report nonce.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>RAND_SIZE: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Size of the random byte string consumed during sharding.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>VERIFY_KEY_SIZE: int</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Size of the verification key used during preparation.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>Measurement</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each measurement.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>PublicShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each public share.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>InputShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each input share.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>AggParam</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of the aggregation parameter.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>OutShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each output share.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>AggShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of the aggregate share.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>AggResult</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of the aggregate result.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>PrepState</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of the prep state.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>PrepShare</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each prep share.</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>PrepMessage</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Type of each prep message.</td>
          </tr>
        </tbody>
      </table>
</div>
<p id="section-5-5">Some of the types in the table above need to be written to the network in
order to carry out the computation. It is <span class="bcp14">RECOMMENDED</span> that concrete
instantiations of the <code>Vdaf</code> interface specify a method of encoding the
<code>PublicShare</code>, <code>InputShare</code>, <code>AggParam</code>, <code>AggShare</code>, <code>PrepShare</code>, and
<code>PrepMessage</code> types.<a href="#section-5-5" class="pilcrow">¶</a></p>
<p id="section-5-6">Each VDAF is identified by a unique 32-bit integer, denoted <code>ID</code>. Identifiers
for each VDAF specified in this document are defined in <a href="#codepoints" class="auto internal xref">Table 18</a>. The
following method is used by both Prio3 and Poplar1:<a href="#section-5-6" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-5-7">
<pre>
def domain_separation_tag(self, usage: int, ctx: bytes) -&gt; bytes:
    """
    Format domain separation tag for this VDAF with the given
    application context and usage.

    Pre-conditions:

        - `usage` in the range `[0, 2^16)`
    """
    return format_dst(0, self.ID, usage) + ctx
</pre><a href="#section-5-7" class="pilcrow">¶</a>
</div>
<p id="section-5-8">The output, called the "domain separation tag", is used in our constructions
for domain separation. Function <code>format_dst()</code> is defined in <a href="#dst-binder" class="auto internal xref">Section 6.2.3</a>.<a href="#section-5-8" class="pilcrow">¶</a></p>
<div id="sec-vdaf-shard">
<section id="section-5.1">
        <h3 id="name-sharding-2">
<a href="#section-5.1" class="section-number selfRef">5.1. </a><a href="#name-sharding-2" class="section-name selfRef">Sharding</a>
        </h3>
<p id="section-5.1-1">Sharding is as described for DAFs in <a href="#sec-daf-shard" class="auto internal xref">Section 4.1</a>. The public share and
input shares encode additional information used during preparation to validate
the output shares before they are aggregated (e.g., the "proof shares" in
<a href="#prio3" class="auto internal xref">Section 7</a>).<a href="#section-5.1-1" class="pilcrow">¶</a></p>
<p id="section-5.1-2">Like DAFs, sharding is bound to the application context via the application
context string. Again, this is intended to ensure that aggregation succeeds
only if the Clients and Aggregators agree on the application context. Unlike
DAFs, however, disagreement on the context should manifest as a preparation
failure, causing the report to be rejected without garbling the aggregate
result. The application context also provides some defense-in-depth against
cross protocol attacks; see <a href="#deep" class="auto internal xref">Section 9.9</a>.<a href="#section-5.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-vdaf-prepare">
<section id="section-5.2">
        <h3 id="name-preparation-2">
<a href="#section-5.2" class="section-number selfRef">5.2. </a><a href="#name-preparation-2" class="section-name selfRef">Preparation</a>
        </h3>
<span id="name-illustration-of-interactive"></span><div id="prep-flow">
<figure id="figure-6">
          <div id="section-5.2-1.1">
            <div class="alignLeft art-svg artwork" id="section-5.2-1.1.1">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="496" width="528" viewBox="0 0 528 496" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                <path d="M 8,128 L 8,160" fill="none" stroke="black"></path>
                <path d="M 8,208 L 8,240" fill="none" stroke="black"></path>
                <path d="M 8,288 L 8,320" fill="none" stroke="black"></path>
                <path d="M 24,96 L 24,120" fill="none" stroke="black"></path>
                <path d="M 24,160 L 24,200" fill="none" stroke="black"></path>
                <path d="M 24,240 L 24,280" fill="none" stroke="black"></path>
                <path d="M 24,320 L 24,352" fill="none" stroke="black"></path>
                <path d="M 24,416 L 24,448" fill="none" stroke="black"></path>
                <path d="M 88,160 L 88,280" fill="none" stroke="black"></path>
                <path d="M 88,320 L 88,352" fill="none" stroke="black"></path>
                <path d="M 104,128 L 104,160" fill="none" stroke="black"></path>
                <path d="M 104,288 L 104,320" fill="none" stroke="black"></path>
                <path d="M 128,128 L 128,160" fill="none" stroke="black"></path>
                <path d="M 128,288 L 128,320" fill="none" stroke="black"></path>
                <path d="M 144,96 L 144,120" fill="none" stroke="black"></path>
                <path d="M 144,160 L 144,200" fill="none" stroke="black"></path>
                <path d="M 144,240 L 144,280" fill="none" stroke="black"></path>
                <path d="M 144,320 L 144,352" fill="none" stroke="black"></path>
                <path d="M 144,416 L 144,448" fill="none" stroke="black"></path>
                <path d="M 208,160 L 208,280" fill="none" stroke="black"></path>
                <path d="M 208,320 L 208,352" fill="none" stroke="black"></path>
                <path d="M 224,128 L 224,160" fill="none" stroke="black"></path>
                <path d="M 224,288 L 224,320" fill="none" stroke="black"></path>
                <path d="M 312,128 L 312,160" fill="none" stroke="black"></path>
                <path d="M 312,288 L 312,320" fill="none" stroke="black"></path>
                <path d="M 328,96 L 328,120" fill="none" stroke="black"></path>
                <path d="M 328,160 L 328,200" fill="none" stroke="black"></path>
                <path d="M 328,240 L 328,280" fill="none" stroke="black"></path>
                <path d="M 328,320 L 328,352" fill="none" stroke="black"></path>
                <path d="M 328,416 L 328,448" fill="none" stroke="black"></path>
                <path d="M 392,160 L 392,280" fill="none" stroke="black"></path>
                <path d="M 392,320 L 392,352" fill="none" stroke="black"></path>
                <path d="M 408,128 L 408,160" fill="none" stroke="black"></path>
                <path d="M 408,288 L 408,320" fill="none" stroke="black"></path>
                <path d="M 416,208 L 416,240" fill="none" stroke="black"></path>
                <path d="M 448,224 L 448,336" fill="none" stroke="black"></path>
                <path d="M 8,46 L 96,46" fill="none" stroke="black"></path>
                <path d="M 8,50 L 96,50" fill="none" stroke="black"></path>
                <path d="M 128,46 L 216,46" fill="none" stroke="black"></path>
                <path d="M 128,50 L 216,50" fill="none" stroke="black"></path>
                <path d="M 312,46 L 456,46" fill="none" stroke="black"></path>
                <path d="M 312,50 L 456,50" fill="none" stroke="black"></path>
                <path d="M 8,128 L 104,128" fill="none" stroke="black"></path>
                <path d="M 128,128 L 224,128" fill="none" stroke="black"></path>
                <path d="M 312,128 L 408,128" fill="none" stroke="black"></path>
                <path d="M 8,160 L 104,160" fill="none" stroke="black"></path>
                <path d="M 128,160 L 224,160" fill="none" stroke="black"></path>
                <path d="M 312,160 L 408,160" fill="none" stroke="black"></path>
                <path d="M 8,208 L 80,208" fill="none" stroke="black"></path>
                <path d="M 96,208 L 200,208" fill="none" stroke="black"></path>
                <path d="M 216,208 L 384,208" fill="none" stroke="black"></path>
                <path d="M 400,208 L 416,208" fill="none" stroke="black"></path>
                <path d="M 8,240 L 80,240" fill="none" stroke="black"></path>
                <path d="M 96,240 L 200,240" fill="none" stroke="black"></path>
                <path d="M 216,240 L 384,240" fill="none" stroke="black"></path>
                <path d="M 400,240 L 416,240" fill="none" stroke="black"></path>
                <path d="M 8,288 L 104,288" fill="none" stroke="black"></path>
                <path d="M 128,288 L 224,288" fill="none" stroke="black"></path>
                <path d="M 312,288 L 408,288" fill="none" stroke="black"></path>
                <path d="M 8,320 L 104,320" fill="none" stroke="black"></path>
                <path d="M 128,320 L 224,320" fill="none" stroke="black"></path>
                <path d="M 312,320 L 408,320" fill="none" stroke="black"></path>
                <path d="M 432,208 C 440.83064,208 448,215.16936 448,224" fill="none" stroke="black"></path>
                <path d="M 432,352 C 440.83064,352 448,344.83064 448,336" fill="none" stroke="black"></path>
                <polygon class="arrowhead" points="400,352 388,346.4 388,357.6" fill="black" transform="rotate(90,392,352)"></polygon>
                <polygon class="arrowhead" points="400,280 388,274.4 388,285.6" fill="black" transform="rotate(90,392,280)"></polygon>
                <polygon class="arrowhead" points="336,448 324,442.4 324,453.6" fill="black" transform="rotate(90,328,448)"></polygon>
                <polygon class="arrowhead" points="336,352 324,346.4 324,357.6" fill="black" transform="rotate(90,328,352)"></polygon>
                <polygon class="arrowhead" points="336,280 324,274.4 324,285.6" fill="black" transform="rotate(90,328,280)"></polygon>
                <polygon class="arrowhead" points="336,200 324,194.4 324,205.6" fill="black" transform="rotate(90,328,200)"></polygon>
                <polygon class="arrowhead" points="336,120 324,114.4 324,125.6" fill="black" transform="rotate(90,328,120)"></polygon>
                <polygon class="arrowhead" points="216,352 204,346.4 204,357.6" fill="black" transform="rotate(90,208,352)"></polygon>
                <polygon class="arrowhead" points="216,280 204,274.4 204,285.6" fill="black" transform="rotate(90,208,280)"></polygon>
                <polygon class="arrowhead" points="152,448 140,442.4 140,453.6" fill="black" transform="rotate(90,144,448)"></polygon>
                <polygon class="arrowhead" points="152,352 140,346.4 140,357.6" fill="black" transform="rotate(90,144,352)"></polygon>
                <polygon class="arrowhead" points="152,280 140,274.4 140,285.6" fill="black" transform="rotate(90,144,280)"></polygon>
                <polygon class="arrowhead" points="152,200 140,194.4 140,205.6" fill="black" transform="rotate(90,144,200)"></polygon>
                <polygon class="arrowhead" points="152,120 140,114.4 140,125.6" fill="black" transform="rotate(90,144,120)"></polygon>
                <polygon class="arrowhead" points="96,352 84,346.4 84,357.6" fill="black" transform="rotate(90,88,352)"></polygon>
                <polygon class="arrowhead" points="96,280 84,274.4 84,285.6" fill="black" transform="rotate(90,88,280)"></polygon>
                <polygon class="arrowhead" points="32,448 20,442.4 20,453.6" fill="black" transform="rotate(90,24,448)"></polygon>
                <polygon class="arrowhead" points="32,352 20,346.4 20,357.6" fill="black" transform="rotate(90,24,352)"></polygon>
                <polygon class="arrowhead" points="32,280 20,274.4 20,285.6" fill="black" transform="rotate(90,24,280)"></polygon>
                <polygon class="arrowhead" points="32,200 20,194.4 20,205.6" fill="black" transform="rotate(90,24,200)"></polygon>
                <polygon class="arrowhead" points="32,120 20,114.4 20,125.6" fill="black" transform="rotate(90,24,120)"></polygon>
                <g class="text">
                  <text x="44" y="36">Aggregator</text>
                  <text x="96" y="36">0</text>
                  <text x="164" y="36">Aggregator</text>
                  <text x="216" y="36">1</text>
                  <text x="348" y="36">Aggregator</text>
                  <text x="428" y="36">SHARES-1</text>
                  <text x="56" y="84">input_share_0</text>
                  <text x="176" y="84">input_share_1</text>
                  <text x="396" y="84">input_share_[SHARES-1]</text>
                  <text x="296" y="100">...</text>
                  <text x="56" y="148">prep_init</text>
                  <text x="176" y="148">prep_init</text>
                  <text x="360" y="148">prep_init</text>
                  <text x="296" y="180">...</text>
                  <text x="304" y="228">prep_shares_to_prep</text>
                  <text x="296" y="260">...</text>
                  <text x="464" y="276">x</text>
                  <text x="500" y="276">ROUNDS</text>
                  <text x="56" y="308">prep_next</text>
                  <text x="176" y="308">prep_next</text>
                  <text x="360" y="308">prep_next</text>
                  <text x="296" y="340">...</text>
                  <text x="24" y="388">...</text>
                  <text x="144" y="388">...</text>
                  <text x="328" y="388">...</text>
                  <text x="296" y="420">...</text>
                  <text x="48" y="468">out_share_0</text>
                  <text x="168" y="468">out_share_1</text>
                  <text x="364" y="468">out_share_[SHARES-1]</text>
                </g>
              </svg><a href="#section-5.2-1.1.1" class="pilcrow">¶</a>
</div>
</div>
<figcaption><a href="#figure-6" class="selfRef">Figure 6</a>:
<a href="#name-illustration-of-interactive" class="selfRef">Illustration of interactive VDAF preparation.</a>
          </figcaption></figure>
</div>
<p id="section-5.2-2">Preparation is organized into a number of rounds. The number of rounds depends
on the VDAF: Prio3 (<a href="#prio3" class="auto internal xref">Section 7</a>) has one round and Poplar1 (<a href="#poplar1" class="auto internal xref">Section 8</a>) has two.<a href="#section-5.2-2" class="pilcrow">¶</a></p>
<p id="section-5.2-3">Aggregators retain some local state between successive rounds of preparation.
This is referred to as "preparation state" or "prep state" for short.<a href="#section-5.2-3" class="pilcrow">¶</a></p>
<p id="section-5.2-4">During each round, each Aggregator broadcasts a message called a
"preparation share", or "prep share" for short. The prep shares are then
combined into a single message called the "preparation message", or "prep
message". The prep message <span class="bcp14">MAY</span> be computed by any one of the Aggregators.<a href="#section-5.2-4" class="pilcrow">¶</a></p>
<p id="section-5.2-5">The prep message is disseminated to each of the Aggregators to begin the next
round. An Aggregator begins the first round with its input share and it begins
each subsequent round with the current prep state and the previous prep
message. Its output in the last round is its output share and its output in
each of the preceding rounds is a prep share.<a href="#section-5.2-5" class="pilcrow">¶</a></p>
<p id="section-5.2-6">Just as for DAFs (<a href="#sec-daf-prepare" class="auto internal xref">Section 4.2</a>), preparation involves an aggregation
parameter. The aggregation parameter is consumed by each Aggregator before the
first round of communication.<a href="#section-5.2-6" class="pilcrow">¶</a></p>
<p id="section-5.2-7">Unlike DAFs, VDAF preparation involves a secret "verification key" held by each
of the Aggregators. This key is used to verify validity of the output shares
they compute. It is up to the high level protocol in which the VDAF is used to
arrange for the distribution of the verification key prior to generating and
processing reports. See <a href="#security" class="auto internal xref">Section 9</a> for details.<a href="#section-5.2-7" class="pilcrow">¶</a></p>
<p id="section-5.2-8">Preparation is implemented by the following set of algorithms:<a href="#section-5.2-8" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.2-9.1">
            <p id="section-5.2-9.1.1"><code>vdaf.prep_init(verify_key: bytes, ctx: bytes, agg_id: int, agg_param:
AggParam, nonce: bytes, public_share: PublicShare, input_share: InputShare)
-&gt; tuple[PrepState, PrepShare]</code> is the deterministic preparation state
initialization algorithm run by each Aggregator. It consumes the shared
verification key, the application context, the Aggregator's unique
identifier, the aggregation parameter chosen by the Collector, the report
nonce, the public share, and one of the input shares generated by the Client.
It produces the Aggregator's initial prep state and prep share.<a href="#section-5.2-9.1.1" class="pilcrow">¶</a></p>
<p id="section-5.2-9.1.2">
Protocols <span class="bcp14">MUST</span> ensure that public share consumed by each of the Aggregators is
identical. This is security critical for VDAFs such as Poplar1.<a href="#section-5.2-9.1.2" class="pilcrow">¶</a></p>
<p id="section-5.2-9.1.3">
Pre-conditions:<a href="#section-5.2-9.1.3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.2-9.1.4.1">
                <p id="section-5.2-9.1.4.1.1"><code>verify_key</code> <span class="bcp14">MUST</span> have length <code>vdaf.VERIFY_KEY_SIZE</code>.<a href="#section-5.2-9.1.4.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-5.2-9.1.4.2">
                <p id="section-5.2-9.1.4.2.1"><code>agg_id</code> <span class="bcp14">MUST</span> be the integer in the range <code>[0, vdaf.SHARES)</code> that matches the
index of <code>input_share</code> in the sequence of input shares output by the
Client.<a href="#section-5.2-9.1.4.2.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-5.2-9.1.4.3">
                <p id="section-5.2-9.1.4.3.1"><code>nonce</code> <span class="bcp14">MUST</span> have length <code>vdaf.NONCE_SIZE</code>.<a href="#section-5.2-9.1.4.3.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
          <li class="normal" id="section-5.2-9.2">
            <p id="section-5.2-9.2.1"><code>vdaf.prep_shares_to_prep(ctx: bytes, agg_param: AggParam, prep_shares:
list[PrepShare]) -&gt; PrepMessage</code> is the deterministic preparation message
pre-processing algorithm. It combines the prep shares produced by the
Aggregators in the previous round into the prep message consumed by each
Aggregator to start the next round.<a href="#section-5.2-9.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-5.2-9.3">
            <p id="section-5.2-9.3.1"><code>vdaf.prep_next(ctx: bytes, prep_state: PrepState, prep_msg: PrepMessage) -&gt;
tuple[PrepState, PrepShare] | OutShare</code> is the deterministic
preparation state update algorithm run by each Aggregator. It updates the
Aggregator's prep state (<code>prep_state</code>) and returns either its next prep state
and prep share for the next round or, if this is the last round, its output
share.<a href="#section-5.2-9.3.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-5.2-10">An exception may be raised by one of these algorithms, in which case the report
<span class="bcp14">MUST</span> be deemed invalid and not processed any further.<a href="#section-5.2-10" class="pilcrow">¶</a></p>
<p id="section-5.2-11">Implementation note: The preparation process accomplishes two tasks: recovery
of output shares from the input shares and ensuring that the recovered output
shares are valid. The abstraction boundary is drawn so that an Aggregator only
recovers an output share if the underlying data is deemed valid (at least,
based on the Aggregator's view of the protocol). Another way to draw this
boundary would be to have the Aggregators recover output shares first, then
verify that they are valid. However, this would allow the possibility of
misusing the API by, say, aggregating an invalid output share. Moreover, in
protocols like Prio+ <span>[<a href="#AGJOP21" class="cite xref">AGJOP21</a>]</span> based on oblivious transfer, it is necessary
for the Aggregators to interact in order to recover aggregatable output shares
at all.<a href="#section-5.2-11" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-vdaf-validity-scopes">
<section id="section-5.3">
        <h3 id="name-validity-of-aggregation-para">
<a href="#section-5.3" class="section-number selfRef">5.3. </a><a href="#name-validity-of-aggregation-para" class="section-name selfRef">Validity of Aggregation Parameters</a>
        </h3>
<p id="section-5.3-1">Aggregation parameter validation is as described for DAFs in
<a href="#sec-daf-validity-scopes" class="auto internal xref">Section 4.3</a>. Again, each Aggregator <span class="bcp14">MUST</span> validate each
aggregation parameter received from the Collector before beginning preparation
with that parameter.<a href="#section-5.3-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-vdaf-aggregate">
<section id="section-5.4">
        <h3 id="name-aggregation-2">
<a href="#section-5.4" class="section-number selfRef">5.4. </a><a href="#name-aggregation-2" class="section-name selfRef">Aggregation</a>
        </h3>
<p id="section-5.4-1">Aggregation is identical to DAF aggregation as described in
<a href="#sec-daf-aggregate" class="auto internal xref">Section 4.4</a>. As with DAFs, computation of the VDAF aggregate is not
usually sensitive to the order in which output shares are aggregated. See
<a href="#agg-order" class="auto internal xref">Section 4.4.1</a>.<a href="#section-5.4-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-vdaf-unshard">
<section id="section-5.5">
        <h3 id="name-unsharding-2">
<a href="#section-5.5" class="section-number selfRef">5.5. </a><a href="#name-unsharding-2" class="section-name selfRef">Unsharding</a>
        </h3>
<p id="section-5.5-1">Unsharding is identical to DAF unsharding as described in <a href="#sec-daf-unshard" class="auto internal xref">Section 4.5</a>.<a href="#section-5.5-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="vdaf-execution">
<section id="section-5.6">
        <h3 id="name-execution-of-a-vdaf">
<a href="#section-5.6" class="section-number selfRef">5.6. </a><a href="#name-execution-of-a-vdaf" class="section-name selfRef">Execution of a VDAF</a>
        </h3>
<p id="section-5.6-1">The following function describes the sequence of computations that are carried
out during VDAF execution:<a href="#section-5.6-1" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-5.6-2">
<pre>
def run_vdaf(
        vdaf: Vdaf[
            Measurement,
            AggParam,
            PublicShare,
            InputShare,
            OutShare,
            AggShare,
            AggResult,
            PrepState,
            PrepShare,
            PrepMessage,
        ],
        verify_key: bytes,
        agg_param: AggParam,
        ctx: bytes,
        measurements: list[Measurement]) -&gt; AggResult:
    """
    Execute the VDAF for the given measurements, aggregation
    parameter (`agg_param`), application context (`ctx`), and
    verification key (`verify_key`).
    """
    agg_shares = [vdaf.agg_init(agg_param)
                  for _ in range(vdaf.SHARES)]
    for measurement in measurements:
        # Sharding: The Client shards its measurement into a report
        # consisting of a public share and a sequence of input
        # shares.
        nonce = gen_rand(vdaf.NONCE_SIZE)
        rand = gen_rand(vdaf.RAND_SIZE)
        (public_share, input_shares) = \
            vdaf.shard(ctx, measurement, nonce, rand)

        # Initialize preparation: Each Aggregator receives its report
        # share (the public share and its input share) from the
        # Client and initializes preparation.
        prep_states = []
        outbound_prep_shares = []
        for j in range(vdaf.SHARES):
            (state, share) = vdaf.prep_init(verify_key, ctx, j,
                                            agg_param,
                                            nonce,
                                            public_share,
                                            input_shares[j])
            prep_states.append(state)
            outbound_prep_shares.append(share)

        # Complete preparation: The Aggregators execute each round of
        # preparation until each computes an output share. A round
        # begins by gathering the prep shares and combining them into
        # the prep message. The round ends when each uses the prep
        # message to transition to the next state.
        for i in range(vdaf.ROUNDS - 1):
            prep_msg = vdaf.prep_shares_to_prep(ctx,
                                                agg_param,
                                                outbound_prep_shares)

            outbound_prep_shares = []
            for j in range(vdaf.SHARES):
                out = vdaf.prep_next(ctx, prep_states[j], prep_msg)
                assert isinstance(out, tuple)
                (prep_states[j], prep_share) = out
                outbound_prep_shares.append(prep_share)

        prep_msg = vdaf.prep_shares_to_prep(ctx,
                                            agg_param,
                                            outbound_prep_shares)

        # Aggregation: Each Aggregator updates its aggregate share
        # with its output share.
        for j in range(vdaf.SHARES):
            out_share = vdaf.prep_next(ctx, prep_states[j], prep_msg)
            assert not isinstance(out_share, tuple)
            agg_shares[j] = vdaf.agg_update(agg_param,
                                            agg_shares[j],
                                            out_share)

    # Unsharding: The Collector receives the aggregate shares from
    # the Aggregators and combines them into the aggregate result.
    num_measurements = len(measurements)
    agg_result = vdaf.unshard(agg_param, agg_shares,
                              num_measurements)
    return agg_result
</pre><a href="#section-5.6-2" class="pilcrow">¶</a>
</div>
<p id="section-5.6-3">Depending on the VDAF, preparation and aggregation may be carried out multiple
times on the same sequence of reports.<a href="#section-5.6-3" class="pilcrow">¶</a></p>
<p id="section-5.6-4">In practice, VDAF execution is distributed across Clients, Aggregators, and
Collectors that exchange messages (i.e., report shares, prep shares, and
aggregate shares) over an insecure network. The application must therefore take
some additional steps in order to securely execute the VDAF in this
environment. See <a href="#security" class="auto internal xref">Section 9</a> for details.<a href="#section-5.6-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="vdaf-prep-comm">
<section id="section-5.7">
        <h3 id="name-communication-patterns-for-">
<a href="#section-5.7" class="section-number selfRef">5.7. </a><a href="#name-communication-patterns-for-" class="section-name selfRef">Communication Patterns for Preparation</a>
        </h3>
<p id="section-5.7-1">The only stage of VDAF execution that requires interaction is preparation
(<a href="#sec-vdaf-prepare" class="auto internal xref">Section 5.2</a>). There are a number of ways to coordinate this
interaction; the best strategy depends largely on the number of Aggregators
(i.e., <code>vdaf.SHARES</code>). This section describes two strategies, one specialized
for two Aggregators and another that is suitable for any number of Aggregators.<a href="#section-5.7-1" class="pilcrow">¶</a></p>
<p id="section-5.7-2">In each round of preparation, each Aggregator writes a prep share to some
broadcast channel, which is then processed into the prep message using the
public <code>prep_shares_to_prep()</code> algorithm and broadcast to the Aggregators to
start the next round. Our goal in this section is to realize this broadcast
channel.<a href="#section-5.7-2" class="pilcrow">¶</a></p>
<p id="section-5.7-3">The state machine of each Aggregator is shown below.<a href="#section-5.7-3" class="pilcrow">¶</a></p>
<span id="name-state-machine-of-vdaf-prepa"></span><div id="vdaf-prep-state-machine">
<figure id="figure-7">
          <div id="section-5.7-4.1">
            <div class="alignLeft art-svg artwork" id="section-5.7-4.1.1">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="144" width="504" viewBox="0 0 504 144" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                <path d="M 16,32 L 16,64" fill="none" stroke="black"></path>
                <path d="M 16,96 L 16,128" fill="none" stroke="black"></path>
                <path d="M 152,32 L 152,64" fill="none" stroke="black"></path>
                <path d="M 184,32 L 184,64" fill="none" stroke="black"></path>
                <path d="M 320,32 L 320,64" fill="none" stroke="black"></path>
                <path d="M 416,40 L 416,64" fill="none" stroke="black"></path>
                <path d="M 416,96 L 416,120" fill="none" stroke="black"></path>
                <path d="M 16,32 L 40,32" fill="none" stroke="black"></path>
                <path d="M 128,32 L 152,32" fill="none" stroke="black"></path>
                <path d="M 184,32 L 320,32" fill="none" stroke="black"></path>
                <path d="M 56,80 L 88,80" fill="none" stroke="black"></path>
                <path d="M 16,128 L 160,128" fill="none" stroke="black"></path>
                <polygon class="arrowhead" points="424,120 412,114.4 412,125.6" fill="black" transform="rotate(90,416,120)"></polygon>
                <polygon class="arrowhead" points="424,40 412,34.4 412,45.6" fill="black" transform="rotate(270,416,40)"></polygon>
                <polygon class="arrowhead" points="328,64 316,58.4 316,69.6" fill="black" transform="rotate(90,320,64)"></polygon>
                <polygon class="arrowhead" points="168,128 156,122.4 156,133.6" fill="black" transform="rotate(0,160,128)"></polygon>
                <polygon class="arrowhead" points="136,32 124,26.4 124,37.6" fill="black" transform="rotate(180,128,32)"></polygon>
                <polygon class="arrowhead" points="96,80 84,74.4 84,85.6" fill="black" transform="rotate(0,88,80)"></polygon>
                <polygon class="arrowhead" points="48,32 36,26.4 36,37.6" fill="black" transform="rotate(0,40,32)"></polygon>
                <g class="text">
                  <text x="84" y="36">Rejected</text>
                  <text x="424" y="36">Finished(out_share)</text>
                  <text x="24" y="84">Start</text>
                  <text x="184" y="84">Continued(prep_state,</text>
                  <text x="320" y="84">prep_round,</text>
                  <text x="408" y="84">outbound)</text>
                  <text x="296" y="132">FinishedWithOutbound(out_share,</text>
                  <text x="464" y="132">outbound)</text>
                </g>
              </svg><a href="#section-5.7-4.1.1" class="pilcrow">¶</a>
</div>
</div>
<figcaption><a href="#figure-7" class="selfRef">Figure 7</a>:
<a href="#name-state-machine-of-vdaf-prepa" class="selfRef">State machine of VDAF preparation.</a>
          </figcaption></figure>
</div>
<p id="section-5.7-5">State transitions are made when the state is acted upon by the Aggregator's
local inputs and/or messages sent by its co-Aggregators. The initial state is
<code>Start</code>. The terminal states are: <code>Rejected</code>, indicating that the report cannot
be processed any further; <code>Finished(out_share)</code>, indicating that the
Aggregator has recovered an output share <code>out_share</code>; and
<code>FinishedWithOutbound(out_share, outbound)</code>, indicating that the Aggregator has
recovered an output share, and has one more outbound message to send. For
completeness, we define these states in <a href="#topo-states" class="auto internal xref">Appendix B</a>.<a href="#section-5.7-5" class="pilcrow">¶</a></p>
<p id="section-5.7-6">The methods described in this section are defined in terms of opaque byte
strings. A compatible <code>Vdaf</code> <span class="bcp14">MUST</span> specify methods for encoding public shares,
input shares, prep shares, prep messages, and aggregation parameters.<a href="#section-5.7-6" class="pilcrow">¶</a></p>
<p id="section-5.7-7">Implementations of Prio3 and Poplar1 <span class="bcp14">MUST</span> use the encoding schemes specified in
<a href="#prio3-encode" class="auto internal xref">Section 7.2.7</a> and <a href="#poplar1-encode" class="auto internal xref">Section 8.2.6</a> respectively.<a href="#section-5.7-7" class="pilcrow">¶</a></p>
<div id="ping-pong-topo">
<section id="section-5.7.1">
          <h4 id="name-the-ping-pong-topology-only">
<a href="#section-5.7.1" class="section-number selfRef">5.7.1. </a><a href="#name-the-ping-pong-topology-only" class="section-name selfRef">The Ping-Pong Topology (Only Two Aggregators)</a>
          </h4>
<p id="section-5.7.1-1">For VDAFs with precisely two Aggregators (i.e., <code>vdaf.SHARES == 2</code>), the
following "ping pong" communication pattern can be used. It is compatible with
any request/response transport protocol, such as HTTP.<a href="#section-5.7.1-1" class="pilcrow">¶</a></p>
<p id="section-5.7.1-2">Let us call the initiating Aggregator the "Leader" and the responding
Aggregator the "Helper". The high-level idea is that the Leader and Helper will
take turns running the computation locally until input from their peer is
required:<a href="#section-5.7.1-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5.7.1-3.1">
              <p id="section-5.7.1-3.1.1">For a 1-round VDAF (e.g., Prio3 in <a href="#prio3" class="auto internal xref">Section 7</a>), the Leader sends its prep share
to the Helper, who computes the prep message locally, computes its output
share, then sends the prep message to the Leader. Preparation requires just
one round trip between the Leader and the Helper.<a href="#section-5.7.1-3.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-5.7.1-3.2">
              <p id="section-5.7.1-3.2.1">For a 2-round VDAF (e.g., Poplar1 in <a href="#poplar1" class="auto internal xref">Section 8</a>), the Leader sends its
first-round prep share to the Helper, who replies with the first-round prep
message and its second-round prep share. In the next request, the Leader
computes its second-round prep share locally, computes its output share, and
sends the second-round prep message to the Helper. Finally, the Helper
computes its own output share.<a href="#section-5.7.1-3.2.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-5.7.1-3.3">
              <p id="section-5.7.1-3.3.1">In general, each request includes the Leader's prep share for the previous
round and/or the prep message for the current round; correspondingly, each
response consists of the prep message for the current round and the Helper's
prep share for the next round.<a href="#section-5.7.1-3.3.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-5.7.1-4">The Aggregators proceed in this ping-ponging fashion until a step of the
computation fails (indicating the report is invalid and should be rejected) or
preparation is completed. All told there are <code>ceil((vdaf.ROUNDS+1)/2)</code>
requests sent.<a href="#section-5.7.1-4" class="pilcrow">¶</a></p>
<p id="section-5.7.1-5">We specify protocol messages in the presentation language of TLS; see <span><a href="https://rfc-editor.org/rfc/rfc8446#section-3" class="relref">Section 3</a> of [<a href="#RFC8446" class="cite xref">RFC8446</a>]</span>. Each message is structured as follows:<a href="#section-5.7.1-5" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-5.7.1-6">
<pre>
enum {
  initialize(0),
  continue(1),
  finish(2),
  (255)
} MessageType;

struct {
  MessageType type;
  select (Message.type) {
    case initialize:
      opaque prep_share&lt;0..2^32-1&gt;;
    case continue:
      opaque prep_msg&lt;0..2^32-1&gt;;
      opaque prep_share&lt;0..2^32-1&gt;;
    case finish:
      opaque prep_msg&lt;0..2^32-1&gt;;
  };
} Message;
</pre><a href="#section-5.7.1-6" class="pilcrow">¶</a>
</div>
<p id="section-5.7.1-7">These messages trigger all transitions in the state machine in
<a href="#vdaf-prep-state-machine" class="auto internal xref">Figure 7</a>, except for the Leader's initial transition. The
Leader's state is initialized using its local inputs with the following method
on class <code>Vdaf</code>:<a href="#section-5.7.1-7" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-5.7.1-8">
<pre>
def ping_pong_leader_init(
        self,
        vdaf_verify_key: bytes,
        ctx: bytes,
        agg_param: bytes,
        nonce: bytes,
        public_share: bytes,
        input_share: bytes) -&gt; Continued | Rejected:
    """Called by the Leader to initialize ping-ponging."""
    try:
        (prep_state, prep_share) = self.prep_init(
            vdaf_verify_key,
            ctx,
            0,
            self.decode_agg_param(agg_param),
            nonce,
            self.decode_public_share(public_share),
            self.decode_input_share(0, input_share),
        )

        encoded_prep_share = self.encode_prep_share(prep_share)
        return Continued(
            prep_state, 0,
            encode(0, encoded_prep_share),  # initialize
        )
    except Exception:
        return Rejected()
</pre><a href="#section-5.7.1-8" class="pilcrow">¶</a>
</div>
<p id="section-5.7.1-9">The output is the <code>State</code> to which the Leader has transitioned. If the Leader's
state is <code>Rejected</code>, then processing halts. Otherwise, if the state is
<code>Continued</code>, then processing continues. In this case, the state also includes
the Leader's outbound message. The function <code>encode</code> is used to encode the
outbound message, which has the message type of <code>initialize</code> (identified by the
number <code>0</code>).<a href="#section-5.7.1-9" class="pilcrow">¶</a></p>
<p id="section-5.7.1-10">To continue processing the report, the Leader sends the outbound message to the
Helper. The Helper's initial transition is computed using the following
procedure:<a href="#section-5.7.1-10" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-5.7.1-11">
<pre>
def ping_pong_helper_init(
    self,
    vdaf_verify_key: bytes,
    ctx: bytes,
    agg_param: bytes,
    nonce: bytes,
    public_share: bytes,
    input_share: bytes,
    inbound: bytes,  # encoded ping pong Message
) -&gt; Continued | FinishedWithOutbound | Rejected:
    """
    Called by the Helper in response to the Leader's initial
    message.
    """

    try:
        (prep_state, prep_share) = self.prep_init(
            vdaf_verify_key,
            ctx,
            1,
            self.decode_agg_param(agg_param),
            nonce,
            self.decode_public_share(public_share),
            self.decode_input_share(1, input_share),
        )

        (inbound_type, inbound_items) = decode(inbound)
        if inbound_type != 0:  # initialize
            return Rejected()

        encoded_prep_share = inbound_items[0]
        prep_shares = [
            self.decode_prep_share(prep_state, encoded_prep_share),
            prep_share,
        ]
        return self.ping_pong_transition(
            ctx,
            self.decode_agg_param(agg_param),
            prep_shares,
            prep_state,
            0,
        )
    except Exception:
        return Rejected()
</pre><a href="#section-5.7.1-11" class="pilcrow">¶</a>
</div>
<p id="section-5.7.1-12">The procedure <code>decode()</code> decodes the inbound message and returns the
MessageType variant (<code>initialize</code>, <code>continue</code>, or <code>finish</code>) and the fields of
the message. The procedure <code>ping_pong_transition()</code> takes in the prep shares,
combines them into the prep message, and computes the next prep state of the
caller:<a href="#section-5.7.1-12" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-5.7.1-13">
<pre>
def ping_pong_transition(
        self,
        ctx: bytes,
        agg_param: AggParam,
        prep_shares: list[PrepShare],
        prep_state: PrepState,
        prep_round: int) -&gt; Continued | FinishedWithOutbound:
    prep_msg = self.prep_shares_to_prep(ctx,
                                        agg_param,
                                        prep_shares)
    encoded_prep_msg = self.encode_prep_msg(prep_msg)
    out = self.prep_next(ctx, prep_state, prep_msg)
    if prep_round+1 == self.ROUNDS:
        return FinishedWithOutbound(
            out,
            encode(2, encoded_prep_msg),  # finalize
        )
    (prep_state, prep_share) = cast(
        tuple[PrepState, PrepShare], out)
    encoded_prep_share = self.encode_prep_share(prep_share)
    return Continued(
        prep_state, prep_round+1,
        encode(1, encoded_prep_msg, encoded_prep_share)  # continue
    )
</pre><a href="#section-5.7.1-13" class="pilcrow">¶</a>
</div>
<p id="section-5.7.1-14">The output is the <code>State</code> to which the Helper has transitioned. If the Helper's
state is <code>Finished</code> or <code>Rejected</code>, then processing halts. Otherwise, if the
state is <code>Continued</code> or <code>FinishedWithOutbound</code>, then the state include an
outbound message and processing continues.<a href="#section-5.7.1-14" class="pilcrow">¶</a></p>
<p id="section-5.7.1-15">To continue processing, the Helper sends the outbound message to the Leader.
The Leader computes its next state transition using the following method on
class <code>Vdaf</code>:<a href="#section-5.7.1-15" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-5.7.1-16">
<pre>
def ping_pong_leader_continued(
    self,
    ctx: bytes,
    agg_param: bytes,
    state: Continued,
    inbound: bytes,  # encoded ping pong Message
) -&gt; State:
    """
    Called by the Leader to start the next step of ping-ponging.
    """
    return self.ping_pong_continued(
        True, ctx, agg_param, state, inbound)

def ping_pong_continued(
    self,
    is_leader: bool,
    ctx: bytes,
    agg_param: bytes,
    state: Continued,
    inbound: bytes,  # encoded ping pong Message
) -&gt; State:
    try:
        prep_round = state.prep_round

        (inbound_type, inbound_items) = decode(inbound)
        if inbound_type == 0:  # initialize
            return Rejected()

        encoded_prep_msg = inbound_items[0]
        prep_msg = self.decode_prep_msg(
            state.prep_state,
            encoded_prep_msg,
        )
        out = self.prep_next(ctx, state.prep_state, prep_msg)
        if prep_round+1 &lt; self.ROUNDS and \
                inbound_type == 1:  # continue
            (prep_state, prep_share) = cast(
                tuple[PrepState, PrepShare], out)
            encoded_prep_share = inbound_items[1]
            prep_shares = [
                self.decode_prep_share(
                    prep_state,
                    encoded_prep_share,
                ),
                prep_share,
            ]
            if is_leader:
                prep_shares.reverse()
            return self.ping_pong_transition(
                ctx,
                self.decode_agg_param(agg_param),
                prep_shares,
                prep_state,
                prep_round+1,
            )
        elif prep_round+1 == self.ROUNDS and \
                inbound_type == 2:  # finish
            return Finished(out)
        else:
            return Rejected()
    except Exception:
        return Rejected()
</pre><a href="#section-5.7.1-16" class="pilcrow">¶</a>
</div>
<p id="section-5.7.1-17">If the Leader's state is <code>Finished</code> or <code>Rejected</code>, then processing halts.
Otherwise, if the Leader's state is <code>Continued</code> or <code>FinishedWithOutbound</code>, the
Leader sends the outbound message to the Helper. The Helper computes its next
state transition using the following method on class <code>Vdaf</code>:<a href="#section-5.7.1-17" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-5.7.1-18">
<pre>
def ping_pong_helper_continued(
    self,
    ctx: bytes,
    agg_param: bytes,
    state: Continued,
    inbound: bytes,  # encoded ping pong Message
) -&gt; State:
    """Called by the Helper to continue ping-ponging."""
    return self.ping_pong_continued(
        False, ctx, agg_param, state, inbound)
</pre><a href="#section-5.7.1-18" class="pilcrow">¶</a>
</div>
<p id="section-5.7.1-19">They continue in this way until processing halts. Note that, depending on the
number of rounds of preparation that are required, when one party reaches the
<code>Finished</code> state, there may be one more message to send before the peer can
also finish processing (i.e., the outbound message is not <code>None</code>).<a href="#section-5.7.1-19" class="pilcrow">¶</a></p>
</section>
</div>
<div id="star-topo">
<section id="section-5.7.2">
          <h4 id="name-the-star-topology-any-numbe">
<a href="#section-5.7.2" class="section-number selfRef">5.7.2. </a><a href="#name-the-star-topology-any-numbe" class="section-name selfRef">The Star Topology (Any Number of Aggregators)</a>
          </h4>
<p id="section-5.7.2-1">The ping-pong topology of the previous section is only suitable for applications
of VDAFs involving exactly two Aggregators. In applications with more than two
Aggregators, the star topology described in this section can
be used instead.<a href="#section-5.7.2-1" class="pilcrow">¶</a></p>
<p id="section-5.7.2-2">We again designate an Aggregator to initiate the computation. We refer to this
Aggregator as the Leader and to all other Aggregators as Helpers.<a href="#section-5.7.2-2" class="pilcrow">¶</a></p>
<p id="section-5.7.2-3">At the start of each round, the Leader requests from each Helper its prep
share. After gathering each of the prep shares, the Leader computes the next
prep message (via <code>vdaf.prep_shares_to_prep()</code>) and broadcasts it to the
Helpers. At this point, each Aggregator runs <code>vdaf.prep_next()</code> locally to
either recover an output share or, if more rounds of preparation are required,
compute its updated state and prep share. If another round is required, then
the Helper responds to the broadcast message with its next prep share.<a href="#section-5.7.2-3" class="pilcrow">¶</a></p>
<p id="section-5.7.2-4">The Aggregators proceed in this way until each recovers an output share or some
step of the computation fails.<a href="#section-5.7.2-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="prelim">
<section id="section-6">
      <h2 id="name-preliminaries">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-preliminaries" class="section-name selfRef">Preliminaries</a>
      </h2>
<p id="section-6-1">This section describes the primitives that are common to the VDAFs specified in
this document.<a href="#section-6-1" class="pilcrow">¶</a></p>
<div id="field">
<section id="section-6.1">
        <h3 id="name-finite-fields">
<a href="#section-6.1" class="section-number selfRef">6.1. </a><a href="#name-finite-fields" class="section-name selfRef">Finite Fields</a>
        </h3>
<p id="section-6.1-1">Both Prio3 and Poplar1 use finite fields of prime order. Finite field
elements are represented by a class <code>Field</code> with the following associated
parameters:<a href="#section-6.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-2.1">
            <p id="section-6.1-2.1.1"><code>MODULUS: int</code> is the prime modulus that defines the field.<a href="#section-6.1-2.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-6.1-2.2">
            <p id="section-6.1-2.2.1"><code>ENCODED_SIZE: int</code> is the number of bytes used to encode a field element
as a byte string.<a href="#section-6.1-2.2.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-6.1-3">Concrete fields, i.e., subclasses of <code>Field</code>, implement the following class
methods:<a href="#section-6.1-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-4.1">
            <p id="section-6.1-4.1.1"><code>Field.zeros(length: int) -&gt; list[Self]</code> returns a vector of zeros of the
requested length.<a href="#section-6.1-4.1.1" class="pilcrow">¶</a></p>
<p id="section-6.1-4.1.2">
Pre-conditions:<a href="#section-6.1-4.1.2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-4.1.3.1">
                <p id="section-6.1-4.1.3.1.1"><code>length</code> <span class="bcp14">MUST</span> be greater than or equal <code>0</code>.<a href="#section-6.1-4.1.3.1.1" class="pilcrow">¶</a></p>
</li>
            </ul>
<p id="section-6.1-4.1.4">
Post-conditions:<a href="#section-6.1-4.1.4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-4.1.5.1">
                <p id="section-6.1-4.1.5.1.1">The length of the output <span class="bcp14">MUST</span> be <code>length</code>.<a href="#section-6.1-4.1.5.1.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
          <li class="normal" id="section-6.1-4.2">
            <p id="section-6.1-4.2.1"><code>Field.rand_vec(length: int) -&gt; list[Self]</code> returns a vector of random field
elements and has the same pre- and post-conditions as for <code>Field.zeros()</code>.
Note that this function is not used normatively in the specification of
either Prio3 or Poplar1.<a href="#section-6.1-4.2.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-6.1-5">A field element is an instance of a concrete <code>Field</code>. Addition,
subtraction, multiplication, division, negation, and inversion are denoted,
respectively, <code>x + y</code>, <code>x - y</code>, <code>x * y</code>, <code>x / y</code>, <code>-x</code>, and <code>x.inv()</code>.<a href="#section-6.1-5" class="pilcrow">¶</a></p>
<p id="section-6.1-6">We sometimes need to convert a field element to an <code>int</code>, which we denote by
<code>x.int()</code>. Likewise, each concrete <code>Field</code> implements a constructor for
converting an integer into a field element:<a href="#section-6.1-6" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1-7.1">
            <p id="section-6.1-7.1.1"><code>Field(integer: int)</code> returns <code>integer</code> represented as a field element. The
value of <code>integer</code> <span class="bcp14">MUST</span> be in the range <code>(-Field.MODULUS, Field.MODULUS)</code>;
negative values are treated as negations.<a href="#section-6.1-7.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<div id="auxiliary-functions">
<section id="section-6.1.1">
          <h4 id="name-auxiliary-functions">
<a href="#section-6.1.1" class="section-number selfRef">6.1.1. </a><a href="#name-auxiliary-functions" class="section-name selfRef">Auxiliary Functions</a>
          </h4>
<p id="section-6.1.1-1">The following class methods on <code>Field</code> are used to encode and decode vectors of
field elements as byte strings:<a href="#section-6.1.1-1" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-6.1.1-2">
<pre>
def encode_vec(cls, vec: list[Self]) -&gt; bytes:
    """
    Encode a vector of field elements `vec` as a byte string.
    """
    encoded = bytes()
    for x in vec:
        encoded += to_le_bytes(x.int(), cls.ENCODED_SIZE)
    return encoded

def decode_vec(cls, encoded: bytes) -&gt; list[Self]:
    """
    Parse a vector of field elements from `encoded`.
    """
    if len(encoded) % cls.ENCODED_SIZE != 0:
        raise ValueError(
            'input length must be a multiple of the size of an '
            'encoded field element')

    vec = []
    while len(encoded) &gt; 0:
        (encoded_x, encoded) = front(cls.ENCODED_SIZE, encoded)
        x = from_le_bytes(encoded_x)
        if x &gt;= cls.MODULUS:
            raise ValueError('modulus overflow')
        vec.append(cls(x))
    return vec
</pre><a href="#section-6.1.1-2" class="pilcrow">¶</a>
</div>
<p id="section-6.1.1-3"><code>Field</code> provides the following class methods for representing an integer as a
sequence of field elements, each of which represents a bit of the input. These
are used to encode measurements in some variants of Prio3
(<a href="#prio3-instantiations" class="auto internal xref">Section 7.4</a>).<a href="#section-6.1.1-3" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-6.1.1-4">
<pre>
def encode_into_bit_vec(
        cls,
        val: int,
        bits: int) -&gt; list[Self]:
    """
    Encode the bit representation of `val` with at most `bits` number
    of bits, as a vector of field elements.

    Pre-conditions:

        - `val &gt;= 0`
        - `bits &gt;= 0`
    """
    if val &gt;= 2 ** bits:
        # Sanity check we are able to represent `val` with `bits`
        # number of bits.
        raise ValueError("Number of bits is not enough to represent "
                         "the input integer.")
    encoded = []
    for l in range(bits):
        encoded.append(cls((val &gt;&gt; l) &amp; 1))
    return encoded

def decode_from_bit_vec(cls, vec: list[Self]) -&gt; Self:
    """
    Decode the field element from the bit representation, expressed
    as a vector of field elements `vec`.

    This may also be used with secret shares of a bit representation,
    since it is linear.
    """
    bits = len(vec)
    if cls.MODULUS &gt;&gt; bits == 0:
        raise ValueError("Number of bits is too large to be "
                         "represented by field modulus.")
    decoded = cls(0)
    for (l, bit) in enumerate(vec):
        decoded += cls(1 &lt;&lt; l) * bit
    return decoded
</pre><a href="#section-6.1.1-4" class="pilcrow">¶</a>
</div>
<p id="section-6.1.1-5">Finally, the following functions define arithmetic on vectors over a finite
field. Note that an exception is raised by each function if the operands are
not the same length.<a href="#section-6.1.1-5" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-6.1.1-6">
<pre>
def vec_sub(left: list[F], right: list[F]) -&gt; list[F]:
    """
    Subtract the right operand from the left and return the result.
    """
    if len(left) != len(right):
        raise ValueError("mismatched vector sizes")
    return list(map(lambda x: x[0] - x[1], zip(left, right)))

def vec_add(left: list[F], right: list[F]) -&gt; list[F]:
    """Add the right operand to the left and return the result."""
    if len(left) != len(right):
        raise ValueError("mismatched vector sizes")
    return list(map(lambda x: x[0] + x[1], zip(left, right)))

def vec_neg(vec: list[F]) -&gt; list[F]:
    """Negate the input vector."""
    return list(map(lambda x: -x, vec))
</pre><a href="#section-6.1.1-6" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="field-ntt-friendly">
<section id="section-6.1.2">
          <h4 id="name-ntt-friendly-fields">
<a href="#section-6.1.2" class="section-number selfRef">6.1.2. </a><a href="#name-ntt-friendly-fields" class="section-name selfRef">NTT-Friendly Fields</a>
          </h4>
<p id="section-6.1.2-1">Some VDAFs, including Prio3, require fields that are suitable for efficient
computation of the number theoretic transform (NTT) <span>[<a href="#SML24" class="cite xref">SML24</a>]</span>, as this allows
for fast polynomial interpolation. Specifically, a field is said to be
"NTT-friendly" if, in addition to the interface described in <a href="#field" class="auto internal xref">Section 6.1</a>, it
provides the following interface:<a href="#section-6.1.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.1.2-2.1">
              <p id="section-6.1.2-2.1.1"><code>Field.gen() -&gt; Self</code> is a class method that returns the generator of a large
subgroup of the multiplicative group. To be NTT-friendly, the order of this
subgroup <span class="bcp14">MUST</span> be a power of 2.<a href="#section-6.1.2-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-6.1.2-2.2">
              <p id="section-6.1.2-2.2.1"><code>GEN_ORDER: int</code> is the order of the multiplicative subgroup generated by
<code>Field.gen()</code>. This is the smallest positive integer for which
<code>Field.gen()**Field.GEN_ORDER == Field(1)</code>.<a href="#section-6.1.2-2.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-6.1.2-3">The size of the subgroup dictates how large interpolated polynomials can be. It
is <span class="bcp14">RECOMMENDED</span> that a generator is chosen with order at least <code>2^20</code>.<a href="#section-6.1.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="parameters">
<section id="section-6.1.3">
          <h4 id="name-parameters">
<a href="#section-6.1.3" class="section-number selfRef">6.1.3. </a><a href="#name-parameters" class="section-name selfRef">Parameters</a>
          </h4>
<p id="section-6.1.3-1"><a href="#fields" class="auto internal xref">Table 3</a> defines finite fields used in the remainder of this document.<a href="#section-6.1.3-1" class="pilcrow">¶</a></p>
<span id="name-parameters-for-the-finite-f"></span><div id="fields">
<table class="center" id="table-3">
            <caption>
<a href="#table-3" class="selfRef">Table 3</a>:
<a href="#name-parameters-for-the-finite-f" class="selfRef">Parameters for the finite fields used in this document.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Field64</th>
                <th class="text-left" rowspan="1" colspan="1">Field128</th>
                <th class="text-left" rowspan="1" colspan="1">Field255</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">MODULUS</td>
                <td class="text-left" rowspan="1" colspan="1">2^32 * 4294967295 + 1</td>
                <td class="text-left" rowspan="1" colspan="1">2^66 * 4611686018427387897 + 1</td>
                <td class="text-left" rowspan="1" colspan="1">2^255 - 19</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">ENCODED_SIZE</td>
                <td class="text-left" rowspan="1" colspan="1">8</td>
                <td class="text-left" rowspan="1" colspan="1">16</td>
                <td class="text-left" rowspan="1" colspan="1">32</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">Generator</td>
                <td class="text-left" rowspan="1" colspan="1">7^4294967295</td>
                <td class="text-left" rowspan="1" colspan="1">7^4611686018427387897</td>
                <td class="text-left" rowspan="1" colspan="1">n/a</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">GEN_ORDER</td>
                <td class="text-left" rowspan="1" colspan="1">2^32</td>
                <td class="text-left" rowspan="1" colspan="1">2^66</td>
                <td class="text-left" rowspan="1" colspan="1">n/a</td>
              </tr>
            </tbody>
          </table>
</div>
</section>
</div>
</section>
</div>
<div id="xof">
<section id="section-6.2">
        <h3 id="name-extendable-output-functions">
<a href="#section-6.2" class="section-number selfRef">6.2. </a><a href="#name-extendable-output-functions" class="section-name selfRef">Extendable Output Functions (XOFs)</a>
        </h3>
<p id="section-6.2-1">VDAFs in this specification use eXtendable Output Functions (XOFs) for two
purposes:<a href="#section-6.2-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-6.2-2">
<li id="section-6.2-2.1">
            <p id="section-6.2-2.1.1">Extracting short, pseudorandom strings we call "seeds" from high entropy
inputs<a href="#section-6.2-2.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-6.2-2.2">
            <p id="section-6.2-2.2.1">Expanding seeds into long, pseudorandom outputs<a href="#section-6.2-2.2.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<p id="section-6.2-3">Concrete XOFs implement a class <code>Xof</code> providing the following interface:<a href="#section-6.2-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.2-4.1">
            <p id="section-6.2-4.1.1"><code>SEED_SIZE: int</code> is the size (in bytes) of a seed.<a href="#section-6.2-4.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-6.2-4.2">
            <p id="section-6.2-4.2.1"><code>Xof(seed: bytes, dst: bytes, binder: bytes)</code> constructs an instance of the
XOF from the given seed and a domain separation tag and binder string as
defined in <a href="#dst-binder" class="auto internal xref">Section 6.2.3</a>. The length of the seed will typically be
<code>SEED_SIZE</code>, but some XOFs may support multiple seed sizes. The seed <span class="bcp14">MUST</span> be
generated securely, i.e., it is either the output of a CSPRNG or a
previous invocation of the XOF.<a href="#section-6.2-4.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-6.2-4.3">
            <p id="section-6.2-4.3.1"><code>xof.next(length: int)</code> returns the next chunk of the output of the
initialized XOF as a byte string. The length of the chunk <span class="bcp14">MUST</span> be <code>length</code>.<a href="#section-6.2-4.3.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-6.2-5">The following methods are provided for all concrete XOFs. The first is a class
method used to derive a fresh seed from an existing one. The second is an
instance method used to compute a sequence of field elements. The third is a
class method that provides a one-shot interface for expanding a seed into a
field vector.<a href="#section-6.2-5" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-6.2-6">
<pre>
def derive_seed(cls,
                seed: bytes,
                dst: bytes,
                binder: bytes) -&gt; bytes:
    """
    Derive a new seed.

    Pre-conditions:

        - `len(seed) == cls.SEED_SIZE`
    """
    xof = cls(seed, dst, binder)
    return xof.next(cls.SEED_SIZE)

def next_vec(self, field: type[F], length: int) -&gt; list[F]:
    """
    Output the next `length` field elements.

    Pre-conditions:

        - `field` is sub-class of `Field`
        - `length &gt; 0`
    """
    m = next_power_of_2(field.MODULUS) - 1
    vec: list[F] = []
    while len(vec) &lt; length:
        x = from_le_bytes(self.next(field.ENCODED_SIZE))
        x &amp;= m
        if x &lt; field.MODULUS:
            vec.append(field(x))
    return vec

def expand_into_vec(cls,
                    field: type[F],
                    seed: bytes,
                    dst: bytes,
                    binder: bytes,
                    length: int) -&gt; list[F]:
    """
    Expand the input `seed` into a vector of `length` field elements.

    Pre-conditions:

        - `field` is sub-class of `Field`
        - `len(seed) == cls.SEED_SIZE`
        - `length &gt; 0`
    """
    xof = cls(seed, dst, binder)
    return xof.next_vec(field, length)
</pre><a href="#section-6.2-6" class="pilcrow">¶</a>
</div>
<div id="xof-turboshake128">
<section id="section-6.2.1">
          <h4 id="name-xofturboshake128">
<a href="#section-6.2.1" class="section-number selfRef">6.2.1. </a><a href="#name-xofturboshake128" class="section-name selfRef">XofTurboShake128</a>
          </h4>
<p id="section-6.2.1-1">This section describes XofTurboShake128, an XOF based on the TurboSHAKE128
function specified in <span>[<a href="#TurboSHAKE" class="cite xref">TurboSHAKE</a>]</span>. This
XOF is <span class="bcp14">RECOMMENDED</span> for all use cases for DAFs and VDAFs.<a href="#section-6.2.1-1" class="pilcrow">¶</a></p>
<ul class="normal ulEmpty">
<li class="normal ulEmpty" id="section-6.2.1-2.1">
              <p id="section-6.2.1-2.1.1">TODO Update the <span>[<a href="#TurboSHAKE" class="cite xref">TurboSHAKE</a>]</span> reference to point to the RFC instead of the
draft.<a href="#section-6.2.1-2.1.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-6.2.1-3">Pre-conditions:<a href="#section-6.2.1-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.2.1-4.1">
              <p id="section-6.2.1-4.1.1">The default seed length is <code>32</code>. The seed <span class="bcp14">MAY</span> have a different length, but it
<span class="bcp14">MUST</span> not exceed 255. Otherwise initialization will raise an exception.<a href="#section-6.2.1-4.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-6.2.1-4.2">
              <p id="section-6.2.1-4.2.1">The length of the domain separation string <code>dst</code> passed to XofTurboShake128
<span class="bcp14">MUST NOT</span> exceed 65535 bytes. Otherwise initialization will raise an
exception.<a href="#section-6.2.1-4.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<div class="lang-python sourcecode" id="section-6.2.1-5">
<pre>
class XofTurboShake128(Xof):
    """XOF wrapper for TurboSHAKE128."""

    # Associated parameters
    SEED_SIZE = 32

    def __init__(self, seed: bytes, dst: bytes, binder: bytes):
        self.l = 0
        self.m = \
            to_le_bytes(len(dst), 2) + dst \
            to_le_bytes(len(seed), 1) + seed + \
            binder

    def next(self, length: int) -&gt; bytes:
        self.l += length

        # Function `TurboSHAKE128(M, D, L)` is as defined in
        # Section 2.2 of [TurboSHAKE].
        #
        # Implementation note: rather than re-generate the output
        # stream each time `next()` is invoked, most implementations
        # of TurboSHAKE128 will expose an "absorb-then-squeeze" API
        # that allows stateful handling of the stream.
        stream = TurboSHAKE128(self.m, 1, self.l)
        return stream[-length:]
</pre><a href="#section-6.2.1-5" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="xof-fixed-key-aes128">
<section id="section-6.2.2">
          <h4 id="name-xoffixedkeyaes128">
<a href="#section-6.2.2" class="section-number selfRef">6.2.2. </a><a href="#name-xoffixedkeyaes128" class="section-name selfRef">XofFixedKeyAes128</a>
          </h4>
<p id="section-6.2.2-1">The XOF in the previous section can be used safely wherever a XOF is needed in
this document. However, there are some situations where TurboSHAKE128 creates a
performance bottleneck and a more efficient XOF can be used safely instead.<a href="#section-6.2.2-1" class="pilcrow">¶</a></p>
<p id="section-6.2.2-2">This section describes XofFixedKeyAes128, which is used to implement the IDPF
of Poplar1 (<a href="#idpf-bbcggi21" class="auto internal xref">Section 8.3</a>). It is <span class="bcp14">NOT RECOMMENDED</span> to use this XOF for any
other purpose. See <a href="#xof-vs-ro" class="auto internal xref">Section 9.6</a> for a more detailed discussion.<a href="#section-6.2.2-2" class="pilcrow">¶</a></p>
<p id="section-6.2.2-3">XofFixedKeyAes128 uses the AES-128 blockcipher <span>[<a href="#AES" class="cite xref">AES</a>]</span> for most of the
computation, thereby taking advantage of the hardware implementations of this
blockcipher that are widely available. AES-128 is used in a fixed-key mode of
operation; the key is derived during initialization using TurboSHAKE128.<a href="#section-6.2.2-3" class="pilcrow">¶</a></p>
<p id="section-6.2.2-4">Pre-conditions:<a href="#section-6.2.2-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6.2.2-5.1">
              <p id="section-6.2.2-5.1.1">The length of the seed <span class="bcp14">MUST</span> be <code>16</code>.<a href="#section-6.2.2-5.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-6.2.2-5.2">
              <p id="section-6.2.2-5.2.1">The length of the domain separation string <code>dst</code> passed to XofFixedKeyAes128
<span class="bcp14">MUST NOT</span> exceed 65535 bytes. Otherwise initialization will raise an
exception.<a href="#section-6.2.2-5.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<div class="breakable lang-python sourcecode" id="section-6.2.2-6">
<pre>
class XofFixedKeyAes128(Xof):
    """
    XOF based on a circular collision-resistant hash function from
    fixed-key AES.
    """

    # Associated parameters
    SEED_SIZE = 16

    def __init__(self, seed: bytes, dst: bytes, binder: bytes):
        if len(seed) != self.SEED_SIZE:
            raise ValueError("incorrect seed size")

        self.length_consumed = 0

        # Use TurboSHAKE128 to derive a key from the binder string
        # and domain separation tag. Note that the AES key does not
        # need to be kept secret from any party. However, when used
        # with an IDPF, we require the binder to be a random nonce.
        #
        # Implementation note: this step can be cached across XOF
        # evaluations with many different seeds.
        dst_length = to_le_bytes(len(dst), 2)
        self.fixed_key = TurboSHAKE128(
            dst_length + dst + binder,
            2,
            16,
        )
        self.seed = seed

    def next(self, length: int) -&gt; bytes:
        offset = self.length_consumed % 16
        new_length = self.length_consumed + length
        block_range = range(
            self.length_consumed // 16,
            new_length // 16 + 1
        )
        self.length_consumed = new_length

        hashed_blocks = [
            self.hash_block(xor(self.seed, to_le_bytes(i, 16)))
            for i in block_range
        ]
        return concat(hashed_blocks)[offset:offset+length]

    def hash_block(self, block: bytes) -&gt; bytes:
        """
        The multi-instance tweakable circular correlation-robust hash
        function of [GKWWY20] (Section 4.2). The tweak here is the
        key that stays constant for all XOF evaluations of the same
        Client, but differs between Clients.

        Function `AES128(key, block)` is the AES-128 blockcipher.
        """
        lo, hi = block[:8], block[8:]
        sigma_block = concat([hi, xor(hi, lo)])
        return xor(AES128(self.fixed_key, sigma_block), sigma_block)
</pre><a href="#section-6.2.2-6" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="dst-binder">
<section id="section-6.2.3">
          <h4 id="name-the-domain-separation-tag-a">
<a href="#section-6.2.3" class="section-number selfRef">6.2.3. </a><a href="#name-the-domain-separation-tag-a" class="section-name selfRef">The Domain Separation Tag and Binder String</a>
          </h4>
<p id="section-6.2.3-1">XOFs are used to map a seed to a finite domain, e.g., a fresh seed or a vector
of field elements. To ensure domain separation, derivation is bound to some
distinguished domain separation tag. The domain separation tag encodes the
following values:<a href="#section-6.2.3-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-6.2.3-2">
<li id="section-6.2.3-2.1">
              <p id="section-6.2.3-2.1.1">The document version (i.e.,<code>VERSION</code>);<a href="#section-6.2.3-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-6.2.3-2.2">
              <p id="section-6.2.3-2.2.1">The "class" of the algorithm using the output (e.g., DAF, VDAF, or IDPF as
defined in <a href="#idpf" class="auto internal xref">Section 8.1</a>);<a href="#section-6.2.3-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-6.2.3-2.3">
              <p id="section-6.2.3-2.3.1">A unique identifier for the algorithm (e.g., <code>VDAF.ID</code>); and<a href="#section-6.2.3-2.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-6.2.3-2.4">
              <p id="section-6.2.3-2.4.1">Some indication of how the output is used (e.g., for deriving the measurement
shares in Prio3 <a href="#prio3" class="auto internal xref">Section 7</a>).<a href="#section-6.2.3-2.4.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<p id="section-6.2.3-3">The following algorithm is used in the remainder of this document in order to
format the domain separation tag:<a href="#section-6.2.3-3" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-6.2.3-4">
<pre>
def format_dst(algo_class: int,
               algo: int,
               usage: int) -&gt; bytes:
    """
    Format XOF domain separation tag.

    Pre-conditions:

        - `algo_class` in the range `[0, 2^8)`
        - `algo` in the range `[0, 2^32)`
        - `usage` in the range `[0, 2^16)`
    """
    return concat([
        to_be_bytes(VERSION, 1),
        to_be_bytes(algo_class, 1),
        to_be_bytes(algo, 4),
        to_be_bytes(usage, 2),
    ])
</pre><a href="#section-6.2.3-4" class="pilcrow">¶</a>
</div>
<p id="section-6.2.3-5">It is also sometimes necessary to bind the output to some ephemeral value that
multiple parties need to agree on. We call this input the "binder string".<a href="#section-6.2.3-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="prio3">
<section id="section-7">
      <h2 id="name-prio3">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-prio3" class="section-name selfRef">Prio3</a>
      </h2>
<p id="section-7-1">This section describes Prio3, a VDAF for general-purpose aggregation. Prio3 is
suitable for a wide variety of aggregation functions, including (but not
limited to) sum, mean, standard deviation, histograms, and linear regression.
It is compatible with any aggregation function that has the following
structure:<a href="#section-7-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7-2.1">
          <p id="section-7-2.1.1">Each measurement is encoded as a vector over some finite field.<a href="#section-7-2.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-7-2.2">
          <p id="section-7-2.2.1">Measurement validity is determined by an "arithmetic circuit" evaluated over
the encoded measurement. An arithmetic circuit is a function comprised of
arithmetic operations in the field. (We specify these in full detail in
<a href="#flp-bbcggi19-valid" class="auto internal xref">Section 7.3.2</a>.)<a href="#section-7-2.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-7-2.3">
          <p id="section-7-2.3.1">The aggregate result is obtained by summing up the encoded measurements and
computing some function of the sum.<a href="#section-7-2.3.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-7-3">Clients protect the privacy of their measurements by secret sharing them and
distributing the shares among the Aggregators. To ensure each measurement is
valid, the Aggregators run a multi-party computation on their shares, the
result of which is the output of the arithmetic circuit. This involves
verification of a "Fully Linear Proof (FLP)" (<a href="#flp" class="auto internal xref">Section 7.1</a>) generated by the Client.
FLPs are the core component of Prio3, as they specify the types of
measurements and how they are encoded, verified, and aggregated. In fact Prio3
can be thought of as a transformation of an FLP into a VDAF.<a href="#section-7-3" class="pilcrow">¶</a></p>
<p id="section-7-4">Prio3 does not have an aggregation parameter. Instead, each output share is
derived from each input share by applying a fixed map. See <a href="#poplar1" class="auto internal xref">Section 8</a> for an
example of a VDAF that makes meaningful use of the aggregation parameter.<a href="#section-7-4" class="pilcrow">¶</a></p>
<p id="section-7-5">The remainder of this section is structured as follows. The interface of FLPs is
described in <a href="#flp" class="auto internal xref">Section 7.1</a>. The generic transformation of an FLP into Prio3 is
specified in <a href="#prio3-construction" class="auto internal xref">Section 7.2</a>. Next, a concrete FLP suitable for any
validity circuit is specified in <a href="#flp-bbcggi19" class="auto internal xref">Section 7.3</a>. Finally, variants of Prio3
for various types of aggregation tasks are specified in
<a href="#prio3-instantiations" class="auto internal xref">Section 7.4</a>. Test vectors for each variant can be found in
<a href="#test-vectors" class="auto internal xref">Appendix C</a>.<a href="#section-7-5" class="pilcrow">¶</a></p>
<div id="flp">
<section id="section-7.1">
        <h3 id="name-fully-linear-proofs-flps">
<a href="#section-7.1" class="section-number selfRef">7.1. </a><a href="#name-fully-linear-proofs-flps" class="section-name selfRef">Fully Linear Proofs (FLPs)</a>
        </h3>
<p id="section-7.1-1">Conceptually, an FLP is a two-party protocol executed by a prover and a
verifier. The verifier is restricted to only access the messages it receives
from the prover via linear queries. In actual use in Prio3, however, the
prover's computation is carried out by the Client, and the verifier's
computation is distributed among the Aggregators. The Client generates a
"proof" of its measurement's validity and distributes shares of the proof to
the Aggregators. During preparation, each Aggregator performs some computation
on its measurement share and proof share locally, then broadcasts the result in
its prep share. The validity decision is then made by the
<code>prep_shares_to_prep()</code> algorithm (<a href="#sec-vdaf-prepare" class="auto internal xref">Section 5.2</a>).<a href="#section-7.1-1" class="pilcrow">¶</a></p>
<p id="section-7.1-2">As usual, we describe the interface implemented by a concrete FLP in terms of
an object <code>flp</code> of type <code>Flp</code> that specifies the set of methods and parameters
a concrete FLP must provide.<a href="#section-7.1-2" class="pilcrow">¶</a></p>
<p id="section-7.1-3">The parameters provided by a concrete FLP are listed in <a href="#flp-param" class="auto internal xref">Table 4</a>. A
concrete FLP specifies the following algorithms for generating and verifying
proofs of validity (encoding is described below in <a href="#flp-encode" class="auto internal xref">Section 7.1.1</a>):<a href="#section-7.1-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1-4.1">
            <p id="section-7.1-4.1.1"><code>flp.prove(meas: list[F], prove_rand: list[F], joint_rand: list[F]) -&gt;
list[F]</code> is the proof-generation algorithm run by the prover. Its inputs are
the encoded measurement, the "prover randomness" <code>prove_rand</code>, and the "joint
randomness" <code>joint_rand</code>. The prover randomness is used only by the prover,
but the joint randomness is shared by both the prover and verifier.<a href="#section-7.1-4.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-7.1-4.2">
            <p id="section-7.1-4.2.1"><code>flp.query(meas: list[F], proof: list[F], query_rand: list[F], joint_rand:
list[F], num_shares: int) -&gt; list[F]</code> is the linear query algorithm run by the
verifier on the encoded measurement and proof. The result of the query (i.e.,
the output of this function) is called the "verifier message". In addition to
the measurement and proof, this algorithm takes as input the query randomness
<code>query_rand</code> and the joint randomness <code>joint_rand</code>. The former is used only
by the verifier. <code>num_shares</code> specifies the number of shares (more on this
below).<a href="#section-7.1-4.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-7.1-4.3">
            <p id="section-7.1-4.3.1"><code>flp.decide(verifier: list[F]) -&gt; bool</code> is the deterministic decision
algorithm run by the verifier. It takes as input the verifier message and
outputs a boolean indicating if the measurement from which it was generated
is valid.<a href="#section-7.1-4.3.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-7.1-5">Our application requires that the FLP is "fully linear" in the sense defined in
<span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>. As a practical matter, what this property implies is that, when
run on a share of the measurement and proof, the query algorithm outputs a
share of the verifier message (hereafter the "verifier share"). Furthermore,
the privacy property of the FLP system ensures that the verifier message
reveals nothing about the measurement other than the fact that it is valid.
Therefore, to decide if a measurement is valid, the Aggregators will run the
query algorithm locally, exchange verifier shares, combine them to recover the
verifier message, and run the decision algorithm.<a href="#section-7.1-5" class="pilcrow">¶</a></p>
<p id="section-7.1-6">The query algorithm includes a parameter <code>num_shares</code> that specifies the number
of shares of the measurement and proof that were generated. If these data are
not secret shared, then <code>num_shares == 1</code>. This parameter is useful for
normalizing constants in arithmetic circuits so that each Aggregator properly
computes a secret share of the circuit's output. See <a href="#flp-bbcggi19" class="auto internal xref">Section 7.3</a> for
details.<a href="#section-7.1-6" class="pilcrow">¶</a></p>
<p id="section-7.1-7">An FLP is executed by the prover and verifier as follows:<a href="#section-7.1-7" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.1-8">
<pre>
def run_flp(
        flp: Flp[Measurement, AggResult, F],
        meas: list[F],
        num_shares: int) -&gt; bool:
    """Run the FLP on an encoded measurement."""

    joint_rand = flp.field.rand_vec(flp.JOINT_RAND_LEN)
    prove_rand = flp.field.rand_vec(flp.PROVE_RAND_LEN)
    query_rand = flp.field.rand_vec(flp.QUERY_RAND_LEN)

    # Prover generates the proof.
    proof = flp.prove(meas, prove_rand, joint_rand)

    # Shard the measurement and the proof.
    meas_shares = additive_secret_share(
        meas,
        num_shares,
        flp.field,
    )
    proof_shares = additive_secret_share(
        proof,
        num_shares,
        flp.field,
    )

    # Verifier queries the meas shares and proof shares.
    verifier_shares = [
        flp.query(
            meas_share,
            proof_share,
            query_rand,
            joint_rand,
            num_shares,
        )
        for meas_share, proof_share in zip(meas_shares, proof_shares)
    ]

    # Combine the verifier shares into the verifier.
    verifier = flp.field.zeros(len(verifier_shares[0]))
    for verifier_share in verifier_shares:
        verifier = vec_add(verifier, verifier_share)

    # Verifier decides if the measurement is valid.
    return flp.decide(verifier)
</pre><a href="#section-7.1-8" class="pilcrow">¶</a>
</div>
<p id="section-7.1-9">The proof system is designed so that, if <code>meas</code> is valid, then <code>run_flp(flp,
meas, num_shares)</code> always returns <code>True</code>. On the other hand, if <code>meas</code> is
invalid, then as long as <code>joint_rand</code> and <code>query_rand</code> are generated uniform
randomly, the output is <code>False</code> with high probability. False positives are
possible: there is a small probability that a verifier accepts an invalid input
as valid. An FLP is said to be "sound" if this probability is sufficiently
small. The soundness of the FLP depends on a variety of parameters, like the
length of the input and the size of the field. See <a href="#flp-bbcggi19" class="auto internal xref">Section 7.3</a> for
details.<a href="#section-7.1-9" class="pilcrow">¶</a></p>
<p id="section-7.1-10">Note that soundness of an FLP system is not the same as verifiability for the
VDAF that uses it. In particular, soundness of the FLP is necessary, but
insufficient for verifiability of Prio3 (<a href="#prio3" class="auto internal xref">Section 7</a>). See
<a href="#security-multiproof" class="auto internal xref">Section 9.7</a> for details.<a href="#section-7.1-10" class="pilcrow">¶</a></p>
<p id="section-7.1-11">We remark that <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span> defines a larger class of fully linear proof
systems than we consider here. In particular, what is called an "FLP" here is
called a 1.5-round, public-coin, interactive oracle proof system in their
paper.<a href="#section-7.1-11" class="pilcrow">¶</a></p>
<span id="name-flp-parameters"></span><div id="flp-param">
<table class="center" id="table-4">
          <caption>
<a href="#table-4" class="selfRef">Table 4</a>:
<a href="#name-flp-parameters" class="selfRef">FLP parameters.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Parameter</th>
              <th class="text-left" rowspan="1" colspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PROVE_RAND_LEN: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the prover randomness, the number of random field elements consumed by the prover when generating a proof.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>QUERY_RAND_LEN: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the query randomness, the number of random field elements consumed by the verifier.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>JOINT_RAND_LEN: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the joint randomness, the number of random field elements shared by the prover and verifier.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>MEAS_LEN: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the encoded measurement (<a href="#flp-encode" class="auto internal xref">Section 7.1.1</a>).</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>OUTPUT_LEN: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the aggregatable output (<a href="#flp-encode" class="auto internal xref">Section 7.1.1</a>).</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PROOF_LEN: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the proof.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>VERIFIER_LEN: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length of the verifier message generated by querying the measurement and proof.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Measurement</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Type of the measurement.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggResult</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Type of the aggregate result.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>field: type[F]</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Class object for the field (<a href="#field" class="auto internal xref">Section 6.1</a>).</td>
            </tr>
          </tbody>
        </table>
</div>
<div id="flp-encode">
<section id="section-7.1.1">
          <h4 id="name-encoding-the-input">
<a href="#section-7.1.1" class="section-number selfRef">7.1.1. </a><a href="#name-encoding-the-input" class="section-name selfRef">Encoding the Input</a>
          </h4>
<p id="section-7.1.1-1">The type of measurement being aggregated is defined by the FLP. Hence, the FLP
also specifies a method of encoding raw measurements as a vector of field
elements:<a href="#section-7.1.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1.1-2.1">
              <p id="section-7.1.1-2.1.1"><code>flp.encode(measurement: Measurement) -&gt; list[F]</code> encodes a raw measurement
as a vector of field elements.<a href="#section-7.1.1-2.1.1" class="pilcrow">¶</a></p>
<p id="section-7.1.1-2.1.2">
Post-conditions:<a href="#section-7.1.1-2.1.2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1.1-2.1.3.1">
                  <p id="section-7.1.1-2.1.3.1.1">The encoded measurement <span class="bcp14">MUST</span> have length <code>flp.MEAS_LEN</code>.<a href="#section-7.1.1-2.1.3.1.1" class="pilcrow">¶</a></p>
</li>
              </ul>
</li>
          </ul>
<p id="section-7.1.1-3">For some FLPs, the encoded measurement also includes redundant field elements
that are useful for checking the proof, but which are not needed after the
proof has been checked. An example is the <code>Sum</code> type defined in <a href="#prio3sum" class="auto internal xref">Section 7.4.2</a>
for which each measurement is an integer in the range <code>[0, max_measurement]</code>.
The range check requires encoding the measurement with several field elements,
though just one is needed for aggregation. Thus the FLP defines an algorithm
for truncating the encoded measurement to the length of the aggregatable output:<a href="#section-7.1.1-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1.1-4.1">
              <p id="section-7.1.1-4.1.1"><code>flp.truncate(meas: list[F]) -&gt; list[F]</code> maps an encoded measurement (e.g.,
the bit-encoding of the measurement) to an aggregatable output (e.g., the
singleton vector containing the measurement).<a href="#section-7.1.1-4.1.1" class="pilcrow">¶</a></p>
<p id="section-7.1.1-4.1.2">
Pre-conditions:<a href="#section-7.1.1-4.1.2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1.1-4.1.3.1">
                  <p id="section-7.1.1-4.1.3.1.1">The length of the input <span class="bcp14">MUST</span> be <code>flp.MEAS_LEN</code><a href="#section-7.1.1-4.1.3.1.1" class="pilcrow">¶</a></p>
</li>
              </ul>
<p id="section-7.1.1-4.1.4">
Post-conditions:<a href="#section-7.1.1-4.1.4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1.1-4.1.5.1">
                  <p id="section-7.1.1-4.1.5.1.1">The length of the output <span class="bcp14">MUST</span> be <code>flp.OUTPUT_LEN</code>.<a href="#section-7.1.1-4.1.5.1.1" class="pilcrow">¶</a></p>
</li>
              </ul>
</li>
          </ul>
<p id="section-7.1.1-5">Once the aggregate shares have been transmitted to the Collector, their sum can
be converted into the aggregate result. This could be a projection from the
FLP's field to the integers, or it could include additional post-processing.
Either way, this functionality is implemented by the following method:<a href="#section-7.1.1-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1.1-6.1">
              <p id="section-7.1.1-6.1.1"><code>flp.decode(output: list[F], num_measurements: int) -&gt; AggResult</code> maps a sum
of aggregate shares to an aggregate result.<a href="#section-7.1.1-6.1.1" class="pilcrow">¶</a></p>
<p id="section-7.1.1-6.1.2">
Pre-conditions:<a href="#section-7.1.1-6.1.2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.1.1-6.1.3.1">
                  <p id="section-7.1.1-6.1.3.1.1">The length of the output <span class="bcp14">MUST</span> be <code>OUTPUT_LEN</code>.<a href="#section-7.1.1-6.1.3.1.1" class="pilcrow">¶</a></p>
</li>
                <li class="normal" id="section-7.1.1-6.1.3.2">
                  <p id="section-7.1.1-6.1.3.2.1"><code>num_measurements</code> <span class="bcp14">MUST</span> equal the number of measurements that were
aggregated.<a href="#section-7.1.1-6.1.3.2.1" class="pilcrow">¶</a></p>
</li>
              </ul>
</li>
          </ul>
<p id="section-7.1.1-7">We remark that, taken together, these three functionalities correspond to the
notion of "Affine-aggregatable encodings (AFEs)" from <span>[<a href="#CGB17" class="cite xref">CGB17</a>]</span>.<a href="#section-7.1.1-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="multiproofs">
<section id="section-7.1.2">
          <h4 id="name-multiple-proofs">
<a href="#section-7.1.2" class="section-number selfRef">7.1.2. </a><a href="#name-multiple-proofs" class="section-name selfRef">Multiple Proofs</a>
          </h4>
<p id="section-7.1.2-1">It is sometimes desirable to generate and verify multiple independent proofs
for the same input. First, this improves the soundness of the proof system
without having to change any of its parameters. Second, it allows a smaller
field to be used (e.g., replace Field128 with Field64)
without sacrificing soundness. This is useful because it reduces the overall
communication of the protocol. (This is a trade-off, of course, since
generating and verifying more proofs requires more time.) Given these benefits,
this feature is implemented by Prio3 (<a href="#prio3" class="auto internal xref">Section 7</a>).<a href="#section-7.1.2-1" class="pilcrow">¶</a></p>
<p id="section-7.1.2-2">To generate these proofs for a specific measurement, the prover calls
<code>flp.prove()</code> multiple times, each time using fresh prover and joint
randomness. The verifier checks each proof independently, each time with fresh
query randomness. It accepts the measurement only if the decision algorithm
accepts on each proof.<a href="#section-7.1.2-2" class="pilcrow">¶</a></p>
<p id="section-7.1.2-3">See <a href="#security-multiproof" class="auto internal xref">Section 9.7</a> for guidance on choosing the field size and number
of proofs.<a href="#section-7.1.2-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="prio3-construction">
<section id="section-7.2">
        <h3 id="name-specification">
<a href="#section-7.2" class="section-number selfRef">7.2. </a><a href="#name-specification" class="section-name selfRef">Specification</a>
        </h3>
<p id="section-7.2-1">This section specifies <code>Prio3</code>, an implementation of the <code>Vdaf</code> interface
defined in <a href="#vdaf" class="auto internal xref">Section 5</a>. The parameters and types required by the <code>Vdaf</code> interface
are defined in <a href="#prio3-param" class="auto internal xref">Table 5</a>. The methods required for sharding, preparation,
aggregation, and unsharding are described in the remaining subsections. These
methods refer to constants enumerated in <a href="#prio3-const" class="auto internal xref">Table 6</a>.<a href="#section-7.2-1" class="pilcrow">¶</a></p>
<span id="name-parameters-for-prio3"></span><div id="prio3-param">
<table class="center" id="table-5">
          <caption>
<a href="#table-5" class="selfRef">Table 5</a>:
<a href="#name-parameters-for-prio3" class="selfRef">Parameters for Prio3.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Parameter</th>
              <th class="text-left" rowspan="1" colspan="1">Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>flp</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">An instance of <code>Flp</code> (<a href="#flp" class="auto internal xref">Section 7.1</a>).</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>xof</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>XofTurboShake128</code> (<a href="#xof-turboshake128" class="auto internal xref">Section 6.2.1</a>)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PROOFS</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Any <code>int</code> in the range <code>[1, 256)</code>.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>VERIFY_KEY_SIZE</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>xof.SEED_SIZE</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>RAND_SIZE</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>xof.SEED_SIZE * SHARES if flp.JOINT_RAND_LEN == 0 else 2 * xof.SEED_SIZE * SHARES</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>NONCE_SIZE</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>16</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>ROUNDS</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>1</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>SHARES</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Any <code>int</code> in the range <code>[2, 256)</code>.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Measurement</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">As defined by <code>flp</code>.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggParam</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>None</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PublicShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Optional[list[bytes]]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>InputShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>tuple[list[F], list[F], Optional[bytes]] | tuple[bytes, Optional[bytes]]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>OutShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>list[F]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>list[F]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggResult</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">As defined by <code>flp</code>.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PrepState</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>tuple[list[F], Optional[bytes]]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PrepShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>tuple[list[F], Optional[bytes]]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PrepMessage</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Optional[bytes]</code>
</td>
            </tr>
          </tbody>
        </table>
</div>
<span id="name-constants-used-by-prio3"></span><div id="prio3-const">
<table class="center" id="table-6">
          <caption>
<a href="#table-6" class="selfRef">Table 6</a>:
<a href="#name-constants-used-by-prio3" class="selfRef">Constants used by Prio3.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Variable</th>
              <th class="text-left" rowspan="1" colspan="1">Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>USAGE_MEAS_SHARE: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">1</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>USAGE_PROOF_SHARE: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">2</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>USAGE_JOINT_RANDOMNESS: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">3</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>USAGE_PROVE_RANDOMNESS: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">4</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>USAGE_QUERY_RANDOMNESS: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">5</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>USAGE_JOINT_RAND_SEED: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">6</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>USAGE_JOINT_RAND_PART: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">7</td>
            </tr>
          </tbody>
        </table>
</div>
<div id="sharding">
<section id="section-7.2.1">
          <h4 id="name-sharding-3">
<a href="#section-7.2.1" class="section-number selfRef">7.2.1. </a><a href="#name-sharding-3" class="section-name selfRef">Sharding</a>
          </h4>
<p id="section-7.2.1-1">Recall from <a href="#flp" class="auto internal xref">Section 7.1</a> that the FLP syntax calls for "joint randomness" shared by
the prover (i.e., the Client) and the verifier (i.e., the Aggregators). VDAFs
have no such notion. Instead, the Client derives the joint randomness from its
measurement in a way that allows the Aggregators to reconstruct it from their
shares. (This idea is based on the Fiat-Shamir heuristic and is described in
Section 6.2.3 of <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>.)<a href="#section-7.2.1-1" class="pilcrow">¶</a></p>
<p id="section-7.2.1-2">The sharding algorithm involves the following steps:<a href="#section-7.2.1-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-7.2.1-3">
<li id="section-7.2.1-3.1">
              <p id="section-7.2.1-3.1.1">Encode the Client's measurement as specified by the FLP<a href="#section-7.2.1-3.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-7.2.1-3.2">
              <p id="section-7.2.1-3.2.1">Shard the measurement into a sequence of measurement shares<a href="#section-7.2.1-3.2.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-7.2.1-3.3">
              <p id="section-7.2.1-3.3.1">Derive the joint randomness from the measurement shares and nonce<a href="#section-7.2.1-3.3.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-7.2.1-3.4">
              <p id="section-7.2.1-3.4.1">Generate the proof using the derived joint randomness<a href="#section-7.2.1-3.4.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-7.2.1-3.5">
              <p id="section-7.2.1-3.5.1">Shard the proof into a sequence of proof shares<a href="#section-7.2.1-3.5.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<p id="section-7.2.1-4">As described in <a href="#multiproofs" class="auto internal xref">Section 7.1.2</a>, the probability of an invalid measurement
being deemed valid can be decreased by generating and verifying multiple
proofs. To support this:<a href="#section-7.2.1-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.2.1-5.1">
              <p id="section-7.2.1-5.1.1">In step 3, derive as much joint randomness as required by <code>PROOFS</code> proofs<a href="#section-7.2.1-5.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.2.1-5.2">
              <p id="section-7.2.1-5.2.1">Repeat step 4 <code>PROOFS</code> times, each time with a unique joint randomness<a href="#section-7.2.1-5.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-7.2.1-6">Depending on the FLP, joint randomness may not be required. In particular, when
<code>flp.JOINT_RAND_LEN == 0</code>, the Client does not derive the joint randomness
(Step 3).<a href="#section-7.2.1-6" class="pilcrow">¶</a></p>
<p id="section-7.2.1-7">The sharding algorithm is specified below:<a href="#section-7.2.1-7" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.2.1-8">
<pre>
def shard(
        self,
        ctx: bytes,
        measurement: Measurement,
        nonce: bytes,
        rand: bytes) -&gt; tuple[
            Optional[list[bytes]],
            list[Prio3InputShare]]:
    if len(nonce) != self.NONCE_SIZE:
        raise ValueError("incorrect nonce size")
    if len(rand) != self.RAND_SIZE:
        raise ValueError("incorrect size of random bytes argument")

    l = self.xof.SEED_SIZE
    seeds = [rand[i:i + l] for i in range(0, self.RAND_SIZE, l)]

    meas = self.flp.encode(measurement)
    if self.flp.JOINT_RAND_LEN &gt; 0:
        return self.shard_with_joint_rand(ctx, meas, nonce, seeds)
    else:
        return self.shard_without_joint_rand(ctx, meas, seeds)
</pre><a href="#section-7.2.1-8" class="pilcrow">¶</a>
</div>
<p id="section-7.2.1-9">It starts by splitting the randomness into seeds. It then encodes the
measurement as prescribed by the FLP and calls one of two methods, depending on
whether joint randomness is required by the FLP. The methods are defined in the
subsections below.<a href="#section-7.2.1-9" class="pilcrow">¶</a></p>
<div id="prio3-shard-without-joint-rand">
<section id="section-7.2.1.1">
            <h5 id="name-flps-without-joint-randomne">
<a href="#section-7.2.1.1" class="section-number selfRef">7.2.1.1. </a><a href="#name-flps-without-joint-randomne" class="section-name selfRef">FLPs Without Joint Randomness</a>
            </h5>
<p id="section-7.2.1.1-1">The following method is used for FLPs that do not require joint randomness,
i.e., when <code>flp.JOINT_RAND_LEN == 0</code>. It consists of the following steps:<a href="#section-7.2.1.1-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-7.2.1.1-2">
<li id="section-7.2.1.1-2.1">
                <p id="section-7.2.1.1-2.1.1">Shard the encoded measurement into shares<a href="#section-7.2.1.1-2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.2.1.1-2.2">
                <p id="section-7.2.1.1-2.2.1">Generate proofs and shard each into shares<a href="#section-7.2.1.1-2.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.2.1.1-2.3">
                <p id="section-7.2.1.1-2.3.1">Encode each measurement share and shares of each proof into an input share<a href="#section-7.2.1.1-2.3.1" class="pilcrow">¶</a></p>
</li>
            </ol>
<p id="section-7.2.1.1-3">Only one pair of measurement and proof(s) share (called the "Leader" shares)
are vectors of field elements. The other shares (called the "Helper"
shares) are represented instead by an XOF seed, which is expanded into vectors
of field elements. The methods on <code>Prio3</code> for deriving the prover randomness,
measurement shares, and proof shares are defined in <a href="#prio3-auxiliary" class="auto internal xref">Section 7.2.6</a>.<a href="#section-7.2.1.1-3" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-7.2.1.1-4">
<pre>
def shard_without_joint_rand(
        self,
        ctx: bytes,
        meas: list[F],
        seeds: list[bytes]) -&gt; tuple[
            Optional[list[bytes]],
            list[Prio3InputShare[F]]]:
    helper_shares, seeds = front(self.SHARES - 1, seeds)
    (prove_seed,), seeds = front(1, seeds)

    # Shard the encoded measurement into shares.
    leader_meas_share = meas
    for j in range(self.SHARES - 1):
        leader_meas_share = vec_sub(
            leader_meas_share,
            self.helper_meas_share(ctx, j + 1, helper_shares[j]),
        )

    # Generate and shard each proof into shares.
    prove_rands = self.prove_rands(ctx, prove_seed)
    leader_proofs_share = []
    for _ in range(self.PROOFS):
        prove_rand, prove_rands = front(
            self.flp.PROVE_RAND_LEN, prove_rands)
        leader_proofs_share += self.flp.prove(meas, prove_rand, [])
    for j in range(self.SHARES - 1):
        leader_proofs_share = vec_sub(
            leader_proofs_share,
            self.helper_proofs_share(
                ctx,
                j + 1,
                helper_shares[j],
            ),
        )

    # Each Aggregator's input share contains its measurement share
    # and its share of the proof(s).
    input_shares: list[Prio3InputShare[F]] = []
    input_shares.append((
        leader_meas_share,
        leader_proofs_share,
        None,
    ))
    for j in range(self.SHARES - 1):
        input_shares.append((
            helper_shares[j],
            None,
        ))
    return (None, input_shares)
</pre><a href="#section-7.2.1.1-4" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="flps-with-joint-randomness">
<section id="section-7.2.1.2">
            <h5 id="name-flps-with-joint-randomness">
<a href="#section-7.2.1.2" class="section-number selfRef">7.2.1.2. </a><a href="#name-flps-with-joint-randomness" class="section-name selfRef">FLPs With Joint Randomness</a>
            </h5>
<p id="section-7.2.1.2-1">The following method is used for FLPs that require joint randomness, i.e., for
which <code>flp.JOINT_RAND_LEN &gt; 0</code>. Joint randomness derivation involves an
additional XOF seed for each Aggregator called the "blind". The computation
involves the following steps:<a href="#section-7.2.1.2-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-7.2.1.2-2">
<li id="section-7.2.1.2-2.1">
                <p id="section-7.2.1.2-2.1.1">Compute a "joint randomness part" from each measurement share and blind<a href="#section-7.2.1.2-2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.2.1.2-2.2">
                <p id="section-7.2.1.2-2.2.1">Compute a "joint randomness seed" from the joint randomness parts<a href="#section-7.2.1.2-2.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-7.2.1.2-2.3">
                <p id="section-7.2.1.2-2.3.1">Compute the joint randomness for each proof evaluation from the joint
randomness seed<a href="#section-7.2.1.2-2.3.1" class="pilcrow">¶</a></p>
</li>
            </ol>
<p id="section-7.2.1.2-3">This three-step process is designed to ensure that the joint randomness does
not leak the measurement to the Aggregators while preventing a malicious Client
from tampering with the joint randomness in a way that causes the Aggregators
to accept an invalid measurement. To save a round of communication between the
Aggregators later, the Client encodes the joint randomness parts in the public
share. (See <a href="#prio3-preparation" class="auto internal xref">Section 7.2.2</a> for details.)<a href="#section-7.2.1.2-3" class="pilcrow">¶</a></p>
<p id="section-7.2.1.2-4">All functions used in the following listing are defined in <a href="#prio3-auxiliary" class="auto internal xref">Section 7.2.6</a>:<a href="#section-7.2.1.2-4" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-7.2.1.2-5">
<pre>
def shard_with_joint_rand(
        self,
        ctx: bytes,
        meas: list[F],
        nonce: bytes,
        seeds: list[bytes]) -&gt; tuple[
            Optional[list[bytes]],
            list[Prio3InputShare[F]]]:
    helper_seeds, seeds = front((self.SHARES - 1) * 2, seeds)
    helper_shares = [
        helper_seeds[i]
        for i in range(0, (self.SHARES - 1) * 2, 2)
    ]
    helper_blinds = [
        helper_seeds[i]
        for i in range(1, (self.SHARES - 1) * 2, 2)
    ]
    (leader_blind, prove_seed), seeds = front(2, seeds)

    # Shard the encoded measurement into shares and compute the
    # joint randomness parts.
    leader_meas_share = meas
    joint_rand_parts = []
    for j in range(self.SHARES - 1):
        helper_meas_share = self.helper_meas_share(
            ctx, j + 1, helper_shares[j])
        leader_meas_share = vec_sub(leader_meas_share,
                                    helper_meas_share)
        joint_rand_parts.append(self.joint_rand_part(
            ctx, j + 1, helper_blinds[j],
            helper_meas_share, nonce))
    joint_rand_parts.insert(0, self.joint_rand_part(
        ctx, 0, leader_blind, leader_meas_share, nonce))

    # Generate each proof and shard it into proof shares.
    prove_rands = self.prove_rands(ctx, prove_seed)
    joint_rands = self.joint_rands(
        ctx, self.joint_rand_seed(ctx, joint_rand_parts))
    leader_proofs_share = []
    for _ in range(self.PROOFS):
        prove_rand, prove_rands = front(
            self.flp.PROVE_RAND_LEN, prove_rands)
        joint_rand, joint_rands = front(
            self.flp.JOINT_RAND_LEN, joint_rands)
        leader_proofs_share += self.flp.prove(
            meas,
            prove_rand,
            joint_rand,
        )
    for j in range(self.SHARES - 1):
        leader_proofs_share = vec_sub(
            leader_proofs_share,
            self.helper_proofs_share(
                ctx,
                j + 1,
                helper_shares[j],
            ),
        )

    # Each Aggregator's input share contains its measurement share,
    # share of proof(s), and blind. The public share contains the
    # Aggregators' joint randomness parts.
    input_shares: list[Prio3InputShare[F]] = []
    input_shares.append((
        leader_meas_share,
        leader_proofs_share,
        leader_blind,
    ))
    for j in range(self.SHARES - 1):
        input_shares.append((
            helper_shares[j],
            helper_blinds[j],
        ))
    return (joint_rand_parts, input_shares)
</pre><a href="#section-7.2.1.2-5" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="prio3-preparation">
<section id="section-7.2.2">
          <h4 id="name-preparation-3">
<a href="#section-7.2.2" class="section-number selfRef">7.2.2. </a><a href="#name-preparation-3" class="section-name selfRef">Preparation</a>
          </h4>
<p id="section-7.2.2-1">This section describes the process of recovering output shares from the input
shares. The high-level idea is that each Aggregator first queries its
measurement share and proof(s) share(s) locally, then broadcasts its verifier
share(s) in its prep share. The shares of verifier(s) are then combined into
the verifier message(s) used to decide whether to accept.<a href="#section-7.2.2-1" class="pilcrow">¶</a></p>
<p id="section-7.2.2-2">In addition, the Aggregators must recompute the same joint randomness used by
the Client to generate the proof(s). In order to avoid an extra round of
communication, the Client includes the joint randomness parts in the public
share. This leaves open the possibility that the Client cheated by, say,
forcing the Aggregators to use joint randomness that biases the proof check
procedure some way in its favor. To mitigate this, the Aggregators also check
that they have all computed the same joint randomness seed before accepting
their output shares. To do so, they exchange their parts of the joint
randomness along with their shares of verifier(s).<a href="#section-7.2.2-2" class="pilcrow">¶</a></p>
<p id="section-7.2.2-3">Implementation note: the prep state for Prio3 includes the output share that
will be released once preparation is complete. In some situations, it may be
necessary for the Aggregator to encode this state as bytes and store it for
retrieval later on. For all but the first Aggregator, it is possible to save
storage by storing the measurement share rather than output share itself. It is
relatively inexpensive to expand this seed into the measurement share, then
truncate the measurement share to get the output share.<a href="#section-7.2.2-3" class="pilcrow">¶</a></p>
<p id="section-7.2.2-4">All functions used in the following listing are defined in <a href="#prio3-auxiliary" class="auto internal xref">Section 7.2.6</a>:<a href="#section-7.2.2-4" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-7.2.2-5">
<pre>
def prep_init(
        self,
        verify_key: bytes,
        ctx: bytes,
        agg_id: int,
        _agg_param: None,
        nonce: bytes,
        public_share: Optional[list[bytes]],
        input_share: Prio3InputShare[F]) -&gt; tuple[
            Prio3PrepState[F],
            Prio3PrepShare[F]]:
    joint_rand_parts = public_share
    (meas_share, proofs_share, blind) = \
        self.expand_input_share(ctx, agg_id, input_share)
    out_share = self.flp.truncate(meas_share)

    # Compute the joint randomness.
    joint_rand: list[F] = []
    corrected_joint_rand_seed, joint_rand_part = None, None
    if self.flp.JOINT_RAND_LEN &gt; 0:
        assert blind is not None
        assert joint_rand_parts is not None
        joint_rand_part = self.joint_rand_part(
            ctx, agg_id, blind, meas_share, nonce)
        joint_rand_parts = list(joint_rand_parts)
        joint_rand_parts[agg_id] = joint_rand_part
        corrected_joint_rand_seed = self.joint_rand_seed(
            ctx, joint_rand_parts)
        joint_rands = self.joint_rands(
            ctx, corrected_joint_rand_seed)

    # Query the measurement and proof(s) share(s).
    query_rands = self.query_rands(verify_key, ctx, nonce)
    verifiers_share = []
    for _ in range(self.PROOFS):
        proof_share, proofs_share = front(
            self.flp.PROOF_LEN, proofs_share)
        query_rand, query_rands = front(
            self.flp.QUERY_RAND_LEN, query_rands)
        if self.flp.JOINT_RAND_LEN &gt; 0:
            joint_rand, joint_rands = front(
                self.flp.JOINT_RAND_LEN, joint_rands)
        verifiers_share += self.flp.query(
            meas_share,
            proof_share,
            query_rand,
            joint_rand,
            self.SHARES,
        )

    prep_state = (out_share, corrected_joint_rand_seed)
    prep_share = (verifiers_share, joint_rand_part)
    return (prep_state, prep_share)

def prep_shares_to_prep(
        self,
        ctx: bytes,
        _agg_param: None,
        prep_shares: list[Prio3PrepShare[F]]) -&gt; Optional[bytes]:
    # Unshard each set of verifier shares into each verifier message.
    verifiers = self.flp.field.zeros(
        self.flp.VERIFIER_LEN * self.PROOFS)
    joint_rand_parts = []
    for (verifiers_share, joint_rand_part) in prep_shares:
        verifiers = vec_add(verifiers, verifiers_share)
        if self.flp.JOINT_RAND_LEN &gt; 0:
            assert joint_rand_part is not None
            joint_rand_parts.append(joint_rand_part)

    # Verify that each proof is well-formed and input is valid.
    for _ in range(self.PROOFS):
        verifier, verifiers = front(self.flp.VERIFIER_LEN, verifiers)
        if not self.flp.decide(verifier):
            raise ValueError('proof verifier check failed')

    # Combine the joint randomness parts computed by the
    # Aggregators into the true joint randomness seed. This is
    # used in the last step.
    joint_rand_seed = None
    if self.flp.JOINT_RAND_LEN &gt; 0:
        joint_rand_seed = self.joint_rand_seed(ctx, joint_rand_parts)
    return joint_rand_seed

def prep_next(
    self,
    _ctx: bytes,
    prep_state: Prio3PrepState[F],
    prep_msg: Optional[bytes]
) -&gt; tuple[Prio3PrepState[F], Prio3PrepShare[F]] | list[F]:
    joint_rand_seed = prep_msg
    (out_share, corrected_joint_rand_seed) = prep_state

    # If joint randomness was used, check that the value computed by
    # the Aggregators matches the value indicated by the Client.
    if joint_rand_seed != corrected_joint_rand_seed:
        raise ValueError('joint randomness check failed')

    return out_share
</pre><a href="#section-7.2.2-5" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="validity-of-aggregation-parameters">
<section id="section-7.2.3">
          <h4 id="name-validity-of-aggregation-param">
<a href="#section-7.2.3" class="section-number selfRef">7.2.3. </a><a href="#name-validity-of-aggregation-param" class="section-name selfRef">Validity of Aggregation Parameters</a>
          </h4>
<p id="section-7.2.3-1"><code>Prio3</code> only permits a report to be aggregated once.<a href="#section-7.2.3-1" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.2.3-2">
<pre>
def is_valid(
        self,
        _agg_param: None,
        previous_agg_params: list[None]) -&gt; bool:
    return len(previous_agg_params) == 0
</pre><a href="#section-7.2.3-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="aggregation">
<section id="section-7.2.4">
          <h4 id="name-aggregation-3">
<a href="#section-7.2.4" class="section-number selfRef">7.2.4. </a><a href="#name-aggregation-3" class="section-name selfRef">Aggregation</a>
          </h4>
<p id="section-7.2.4-1">Aggregating a set of output shares is simply a matter of adding up the vectors
element-wise.<a href="#section-7.2.4-1" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.2.4-2">
<pre>
def agg_init(self, _agg_param: None) -&gt; list[F]:
    return self.flp.field.zeros(self.flp.OUTPUT_LEN)

def agg_update(self,
               _agg_param: None,
               agg_share: list[F],
               out_share: list[F]) -&gt; list[F]:
    return vec_add(agg_share, out_share)

def merge(self,
          _agg_param: None,
          agg_shares: list[list[F]]) -&gt; list[F]:
    agg = self.agg_init(None)
    for agg_share in agg_shares:
        agg = vec_add(agg, agg_share)
    return agg
</pre><a href="#section-7.2.4-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="unsharding">
<section id="section-7.2.5">
          <h4 id="name-unsharding-3">
<a href="#section-7.2.5" class="section-number selfRef">7.2.5. </a><a href="#name-unsharding-3" class="section-name selfRef">Unsharding</a>
          </h4>
<p id="section-7.2.5-1">To unshard a set of aggregate shares, the Collector first adds up the vectors
element-wise, then decodes the aggregate result from the sum according to the
FLP (<a href="#flp-encode" class="auto internal xref">Section 7.1.1</a>).<a href="#section-7.2.5-1" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.2.5-2">
<pre>
def unshard(
        self,
        _agg_param: None,
        agg_shares: list[list[F]],
        num_measurements: int) -&gt; AggResult:
    agg = self.merge(None, agg_shares)
    return self.flp.decode(agg, num_measurements)
</pre><a href="#section-7.2.5-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="prio3-auxiliary">
<section id="section-7.2.6">
          <h4 id="name-auxiliary-functions-2">
<a href="#section-7.2.6" class="section-number selfRef">7.2.6. </a><a href="#name-auxiliary-functions-2" class="section-name selfRef">Auxiliary Functions</a>
          </h4>
<p id="section-7.2.6-1">This section defines a number of auxiliary functions referenced by the main
algorithms for Prio3 in the preceding sections.<a href="#section-7.2.6-1" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-7.2.6-2">
<pre>
def helper_meas_share(
        self,
        ctx: bytes,
        agg_id: int,
        share: bytes) -&gt; list[F]:
    return self.xof.expand_into_vec(
        self.flp.field,
        share,
        self.domain_separation_tag(USAGE_MEAS_SHARE, ctx),
        byte(agg_id),
        self.flp.MEAS_LEN,
    )

def helper_proofs_share(
        self,
        ctx: bytes,
        agg_id: int,
        share: bytes) -&gt; list[F]:
    return self.xof.expand_into_vec(
        self.flp.field,
        share,
        self.domain_separation_tag(USAGE_PROOF_SHARE, ctx),
        byte(self.PROOFS) + byte(agg_id),
        self.flp.PROOF_LEN * self.PROOFS,
    )

def expand_input_share(
        self,
        ctx: bytes,
        agg_id: int,
        input_share: Prio3InputShare[F]) -&gt; tuple[
            list[F],
            list[F],
            Optional[bytes]]:
    if agg_id &gt; 0:
        assert len(input_share) == 2
        (share, blind) = input_share
        meas_share = self.helper_meas_share(ctx, agg_id, share)
        proofs_share = self.helper_proofs_share(ctx, agg_id, share)
    else:
        assert len(input_share) == 3
        (meas_share, proofs_share, blind) = input_share
    return (meas_share, proofs_share, blind)

def prove_rands(self, ctx: bytes, prove_seed: bytes) -&gt; list[F]:
    return self.xof.expand_into_vec(
        self.flp.field,
        prove_seed,
        self.domain_separation_tag(USAGE_PROVE_RANDOMNESS, ctx),
        byte(self.PROOFS),
        self.flp.PROVE_RAND_LEN * self.PROOFS,
    )

def query_rands(
        self,
        verify_key: bytes,
        ctx: bytes,
        nonce: bytes) -&gt; list[F]:
    return self.xof.expand_into_vec(
        self.flp.field,
        verify_key,
        self.domain_separation_tag(USAGE_QUERY_RANDOMNESS, ctx),
        byte(self.PROOFS) + nonce,
        self.flp.QUERY_RAND_LEN * self.PROOFS,
    )

def joint_rand_part(
        self,
        ctx: bytes,
        agg_id: int,
        blind: bytes,
        meas_share: list[F],
        nonce: bytes) -&gt; bytes:
    return self.xof.derive_seed(
        blind,
        self.domain_separation_tag(USAGE_JOINT_RAND_PART, ctx),
        byte(agg_id) + nonce + self.flp.field.encode_vec(meas_share),
    )

def joint_rand_seed(self,
                    ctx: bytes,
                    joint_rand_parts: list[bytes]) -&gt; bytes:
    """Derive the joint randomness seed from its parts."""
    return self.xof.derive_seed(
        zeros(self.xof.SEED_SIZE),
        self.domain_separation_tag(USAGE_JOINT_RAND_SEED, ctx),
        concat(joint_rand_parts),
    )

def joint_rands(self,
                ctx: bytes,
                joint_rand_seed: bytes) -&gt; list[F]:
    """Derive the joint randomness from its seed."""
    return self.xof.expand_into_vec(
        self.flp.field,
        joint_rand_seed,
        self.domain_separation_tag(USAGE_JOINT_RANDOMNESS, ctx),
        byte(self.PROOFS),
        self.flp.JOINT_RAND_LEN * self.PROOFS,
    )
</pre><a href="#section-7.2.6-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="prio3-encode">
<section id="section-7.2.7">
          <h4 id="name-message-serialization">
<a href="#section-7.2.7" class="section-number selfRef">7.2.7. </a><a href="#name-message-serialization" class="section-name selfRef">Message Serialization</a>
          </h4>
<p id="section-7.2.7-1">This section defines serialization formats for messages exchanged over the
network while executing Prio3. Messages are defined in the presentation
language of TLS as defined in <span><a href="https://rfc-editor.org/rfc/rfc8446#section-3" class="relref">Section 3</a> of [<a href="#RFC8446" class="cite xref">RFC8446</a>]</span>.<a href="#section-7.2.7-1" class="pilcrow">¶</a></p>
<p id="section-7.2.7-2">Let <code>prio3</code> denote an instance of <code>Prio3</code>. In the remainder we use <code>S</code> as an
alias for <code>prio3.xof.SEED_SIZE</code> and <code>F</code> as an alias for
<code>prio3.field.ENCODED_SIZE</code>. XOF seeds are represented as follows:<a href="#section-7.2.7-2" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7-3">
<pre>
opaque Prio3Seed[S];
</pre><a href="#section-7.2.7-3" class="pilcrow">¶</a>
</div>
<p id="section-7.2.7-4">Field elements are encoded in little-endian byte order (as defined in
<a href="#field" class="auto internal xref">Section 6.1</a>) and represented as follows:<a href="#section-7.2.7-4" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7-5">
<pre>
opaque Prio3Field[F];
</pre><a href="#section-7.2.7-5" class="pilcrow">¶</a>
</div>
<div id="public-share">
<section id="section-7.2.7.1">
            <h5 id="name-public-share">
<a href="#section-7.2.7.1" class="section-number selfRef">7.2.7.1. </a><a href="#name-public-share" class="section-name selfRef">Public Share</a>
            </h5>
<p id="section-7.2.7.1-1">The contents of the public share depend on whether joint randomness is
required for the underlying FLP (i.e., <code>prio3.flp.JOINT_RAND_LEN &gt; 0</code>). If
joint randomness is not used, then the public share is the empty string.
Otherwise, if joint randomness is used, then the public share encodes the joint
randomness parts as follows:<a href="#section-7.2.7.1-1" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7.1-2">
<pre>
struct {
    Prio3Seed joint_rand_parts[S * prio3.SHARES];
} Prio3PublicShareWithJointRand;
</pre><a href="#section-7.2.7.1-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="input-share">
<section id="section-7.2.7.2">
            <h5 id="name-input-share">
<a href="#section-7.2.7.2" class="section-number selfRef">7.2.7.2. </a><a href="#name-input-share" class="section-name selfRef">Input Share</a>
            </h5>
<p id="section-7.2.7.2-1">Just as for the public share, the content of the input shares depends on
whether joint randomness is used. If so, then each input share includes the
Aggregator's blind for generating its joint randomness part.<a href="#section-7.2.7.2-1" class="pilcrow">¶</a></p>
<p id="section-7.2.7.2-2">In addition, the encoding of the input shares depends on which aggregator is
receiving the message. If the aggregator ID is <code>0</code>, then the input share
includes the full measurement share and proofs(s) share(s). Otherwise, if the
aggregator ID is greater than <code>0</code>, then the measurement and shares of proof(s)
are represented by an XOF seed. We shall call the former the "Leader" and the
latter the "Helpers".<a href="#section-7.2.7.2-2" class="pilcrow">¶</a></p>
<p id="section-7.2.7.2-3">In total there are four variants of the input share. When joint randomness is
not used, the Leader's share is structured as follows:<a href="#section-7.2.7.2-3" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7.2-4">
<pre>
struct {
    Prio3Field meas_share[F * prio3.flp.MEAS_LEN];
    Prio3Field proofs_share[F * prio3.flp.PROOF_LEN * prio3.PROOFS];
} Prio3LeaderShare;
</pre><a href="#section-7.2.7.2-4" class="pilcrow">¶</a>
</div>
<p id="section-7.2.7.2-5">When joint randomness is not used, the Helpers' shares are structured
as follows:<a href="#section-7.2.7.2-5" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7.2-6">
<pre>
struct {
    Prio3Seed share;
} Prio3HelperShare;
</pre><a href="#section-7.2.7.2-6" class="pilcrow">¶</a>
</div>
<p id="section-7.2.7.2-7">When joint randomness is used, the Leader's input share is structured as
follows:<a href="#section-7.2.7.2-7" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7.2-8">
<pre>
struct {
    Prio3LeaderShare inner;
    Prio3Seed blind;
} Prio3LeaderShareWithJointRand;
</pre><a href="#section-7.2.7.2-8" class="pilcrow">¶</a>
</div>
<p id="section-7.2.7.2-9">Finally, when joint randomness is used, the Helpers' shares are structured as
follows:<a href="#section-7.2.7.2-9" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7.2-10">
<pre>
struct {
    Prio3HelperShare inner;
    Prio3Seed blind;
} Prio3HelperShareWithJointRand;
</pre><a href="#section-7.2.7.2-10" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="prep-share">
<section id="section-7.2.7.3">
            <h5 id="name-prep-share">
<a href="#section-7.2.7.3" class="section-number selfRef">7.2.7.3. </a><a href="#name-prep-share" class="section-name selfRef">Prep Share</a>
            </h5>
<p id="section-7.2.7.3-1">When joint randomness is not used, the prep share is structured as follows:<a href="#section-7.2.7.3-1" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7.3-2">
<pre>
struct {
    Prio3Field verifiers_share[F * V];
} Prio3PrepShare;
</pre><a href="#section-7.2.7.3-2" class="pilcrow">¶</a>
</div>
<p id="section-7.2.7.3-3">where <code>V = prio3.flp.VERIFIER_LEN * prio3.PROOFS</code>. When joint randomness is
used, the prep share includes the Aggregator's joint randomness part and is
structured as follows:<a href="#section-7.2.7.3-3" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7.3-4">
<pre>
struct {
    Prio3Field verifiers_share[F * V];
    Prio3Seed joint_rand_part;
} Prio3PrepShareWithJointRand;
</pre><a href="#section-7.2.7.3-4" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="prep-message">
<section id="section-7.2.7.4">
            <h5 id="name-prep-message">
<a href="#section-7.2.7.4" class="section-number selfRef">7.2.7.4. </a><a href="#name-prep-message" class="section-name selfRef">Prep Message</a>
            </h5>
<p id="section-7.2.7.4-1">When joint randomness is not used, the prep message is the empty string.
Otherwise the prep message consists of the joint randomness seed computed by
the Aggregators:<a href="#section-7.2.7.4-1" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7.4-2">
<pre>
struct {
    Prio3Seed joint_rand;
} Prio3PrepMessageWithJointRand;
</pre><a href="#section-7.2.7.4-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="aggregation-1">
<section id="section-7.2.7.5">
            <h5 id="name-aggregation-4">
<a href="#section-7.2.7.5" class="section-number selfRef">7.2.7.5. </a><a href="#name-aggregation-4" class="section-name selfRef">Aggregation</a>
            </h5>
<p id="section-7.2.7.5-1">Aggregate shares are structured as follows:<a href="#section-7.2.7.5-1" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-7.2.7.5-2">
<pre>
struct {
    Prio3Field agg_share[F * prio3.flp.OUTPUT_LEN];
} Prio3AggShare;
</pre><a href="#section-7.2.7.5-2" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="flp-bbcggi19">
<section id="section-7.3">
        <h3 id="name-flp-specification">
<a href="#section-7.3" class="section-number selfRef">7.3. </a><a href="#name-flp-specification" class="section-name selfRef">FLP Specification</a>
        </h3>
<p id="section-7.3-1">This section specifies an implementation of the <code>Flp</code> interface (<a href="#flp" class="auto internal xref">Section 7.1</a>) based
on the construction from <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, Section 4.2. The types and parameters
required by this interface are listed in the table below.<a href="#section-7.3-1" class="pilcrow">¶</a></p>
<p id="section-7.3-2">We begin in <a href="#flp-bbcggi19-overview" class="auto internal xref">Section 7.3.1</a> with an overview of the proof system and
some extensions to it. <a href="#flp-bbcggi19-valid" class="auto internal xref">Section 7.3.2</a> defines validity circuits, the
core component of the proof system that determines measurement validity and how
measurements are aggregated. The proof-generation algorithm, query algorithm,
and decision algorithm are defined in <a href="#flp-bbcggi19-construction-prove" class="auto internal xref">Section 7.3.3</a>,
<a href="#flp-bbcggi19-construction-query" class="auto internal xref">Section 7.3.4</a>, and <a href="#flp-bbcggi19-construction-decide" class="auto internal xref">Section 7.3.5</a>
respectively.<a href="#section-7.3-2" class="pilcrow">¶</a></p>
<span id="name-flp-parameters-for-a-validi"></span><div id="flp-bbcggi19-param">
<table class="center" id="table-7">
          <caption>
<a href="#table-7" class="selfRef">Table 7</a>:
<a href="#name-flp-parameters-for-a-validi" class="selfRef">FLP parameters for a validity circuit.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Parameter</th>
              <th class="text-left" rowspan="1" colspan="1">Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>valid</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">An instance of <code>Valid</code> (<a href="#flp-bbcggi19-valid" class="auto internal xref">Section 7.3.2</a>).</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>field</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>valid.field</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PROVE_RAND_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>valid.prove_rand_len()</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>QUERY_RAND_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>valid.query_rand_len()</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>JOINT_RAND_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>valid.JOINT_RAND_LEN</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>MEAS_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>valid.MEAS_LEN</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>OUTPUT_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>valid.OUTPUT_LEN</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PROOF_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>valid.proof_len()</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>VERIFIER_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>valid.verifier_len()</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Measurement</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">As defined by <code>valid</code>.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggResult</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">As defined by <code>valid</code>.</td>
            </tr>
          </tbody>
        </table>
</div>
<div id="flp-bbcggi19-overview">
<section id="section-7.3.1">
          <h4 id="name-overview-2">
<a href="#section-7.3.1" class="section-number selfRef">7.3.1. </a><a href="#name-overview-2" class="section-name selfRef">Overview</a>
          </h4>
<p id="section-7.3.1-1">An FLP is a type of "zero-knowledge proof". A conventional zero-knowledge proof
system involves two parties:<a href="#section-7.3.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.1-2.1">
              <p id="section-7.3.1-2.1.1">The prover, who holds a measurement and generates a proof of the
measurement's validity<a href="#section-7.3.1-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.3.1-2.2">
              <p id="section-7.3.1-2.2.1">The verifier who holds an encryption of, or commitment to, the measurement
and checks the proof<a href="#section-7.3.1-2.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-7.3.1-3">Our proof system is much the same, except the verifier is split across multiple
Aggregators, each of which has a secret share of the measurement rather than a
commitment to it.<a href="#section-7.3.1-3" class="pilcrow">¶</a></p>
<p id="section-7.3.1-4">Validity is defined in terms of an arithmetic circuit evaluated over the
measurement. The inputs to this circuit are elements of a finite field that
comprise the encoded measurement; the gates of the circuit are multiplication,
addition, and subtraction operations; and the output of the circuit is a single
field element. If the value is zero, then the measurement is deemed valid;
otherwise, if the output is non-zero, then the measurement is deemed invalid.<a href="#section-7.3.1-4" class="pilcrow">¶</a></p>
<p id="section-7.3.1-5">For example, the simplest circuit specified in this document is the following
(<a href="#prio3count" class="auto internal xref">Section 7.4.1</a>):<a href="#section-7.3.1-5" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.3.1-6">
<pre>
C(x) = x * (x-1)
</pre><a href="#section-7.3.1-6" class="pilcrow">¶</a>
</div>
<p id="section-7.3.1-7">This circuit contains one subtraction gate (<code>x-1</code>) and one multiplication gate
(<code>x * (x-1)</code>). Observe that <code>C(x) = 0</code> if and only if <code>x</code> is in the range
<code>[0, 2)</code>.<a href="#section-7.3.1-7" class="pilcrow">¶</a></p>
<p id="section-7.3.1-8">The goal of the proof system is to allow each Aggregator to privately and
correctly compute a share of <code>C(x)</code> from its share of <code>x</code>. Then all they need
to do to determine validity is to broadcast their shares of <code>C(x)</code>.<a href="#section-7.3.1-8" class="pilcrow">¶</a></p>
<p id="section-7.3.1-9">Suppose for a moment that <code>C</code> is an affine arithmetic circuit, meaning its only
operations are addition, subtraction, and multiplication-by-constant. (The
circuit above is non-affine because it contains a multiplication gate with two
non-constant inputs.) Then each Aggregator can compute its share locally, since<a href="#section-7.3.1-9" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.3.1-10">
<pre>
C(x_shares[0] + ... + x_shares[SHARES-1]) =
    C(x_shares[0]) + ... + C(x_shares[SHARES-1])
</pre><a href="#section-7.3.1-10" class="pilcrow">¶</a>
</div>
<p id="section-7.3.1-11">(Note that, for this equality to hold, it is necessary to scale any addition of
a constant in the circuit by <code>1/SHARES</code>.) However, this is not the case if <code>C</code>
contains multiplication gates with two non-constant inputs. Thus our goal is to
transform these multiplication gates into computations on secret shared data
that each Aggregator can perform locally.<a href="#section-7.3.1-11" class="pilcrow">¶</a></p>
<p id="section-7.3.1-12">The key idea is to have the prover construct a polynomial <code>p</code> such that <code>p(j)</code>
is equal to the output of the <code>j</code>-th multiplication gate. Polynomial evaluation
is fully linear, which means the coefficients of the polynomial can be secret
shared in a way that allows each Aggregator to compute a share of <code>p(j)</code> for
any <code>j</code>. These intermediate results can then be combined with the affine
arithmetic operations of the validity circuit to produce the final output.<a href="#section-7.3.1-12" class="pilcrow">¶</a></p>
<p id="section-7.3.1-13">Applying this idea to the example circuit <code>C</code> above:<a href="#section-7.3.1-13" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-7.3.1-14">
<li id="section-7.3.1-14.1">
              <p id="section-7.3.1-14.1.1">The Client, given its measurement <code>x</code>, constructs the lowest degree
polynomial <code>p</code> for which <code>p(0) = s</code> and <code>p(1) = x * (x-1)</code>, where <code>s</code> is a
random blinding value generated by the Client. (The blinding value is to
protect the privacy of the measurement.) It then sends shares of <code>x</code> and
shares of the coefficients of <code>p</code> to each of the Aggregators.<a href="#section-7.3.1-14.1.1" class="pilcrow">¶</a></p>
</li>
            <li id="section-7.3.1-14.2">
              <p id="section-7.3.1-14.2.1">Each Aggregator locally computes and broadcasts its share of <code>p(1)</code>, which
is equal to its share of <code>C(x)</code>.<a href="#section-7.3.1-14.2.1" class="pilcrow">¶</a></p>
</li>
          </ol>
<p id="section-7.3.1-15">In fact, our FLP is slightly more general than this. We can replace the
multiplication gate with any non-affine sub-circuit and apply the same idea.
For example, in <a href="#prio3sum" class="auto internal xref">Section 7.4.2</a>, the validity circuit uses the following
sub-circuit multiple times:<a href="#section-7.3.1-15" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.3.1-16">
<pre>
Range2(x) = x * (x-1) = x^2 - x
</pre><a href="#section-7.3.1-16" class="pilcrow">¶</a>
</div>
<p id="section-7.3.1-17">(This is the same functionality computed by the example circuit <code>C</code> above.)
Here again we can interpolate the lowest degree polynomial <code>p</code> for which <code>p(j)</code>
is the value of the <code>j</code>-th call to <code>Range2</code> in the validity circuit. Each
validity circuit defines a sub-circuit that encapsulates its non-affine
arithmetic operations. We refer to this sub-circuit as the "gadget".<a href="#section-7.3.1-17" class="pilcrow">¶</a></p>
<p id="section-7.3.1-18">Finally, the proof system has one more important component. It is possible for
a malicious Client to produce a gadget polynomial <code>p</code> that would result in
<code>C(x)</code> being computed incorrectly, potentially resulting in an invalid
measurement being accepted. To prevent this, the Aggregators perform a
probabilistic test to check that the gadget polynomial was constructed
properly. This "gadget test", and the procedure for constructing the
polynomial, are described in detail in <a href="#flp-bbcggi19-construction-prove" class="auto internal xref">Section 7.3.3</a>.<a href="#section-7.3.1-18" class="pilcrow">¶</a></p>
<div id="flp-bbcggi19-overview-extensions">
<section id="section-7.3.1.1">
            <h5 id="name-extensions">
<a href="#section-7.3.1.1" class="section-number selfRef">7.3.1.1. </a><a href="#name-extensions" class="section-name selfRef">Extensions</a>
            </h5>
<p id="section-7.3.1.1-1">The FLP described in <a href="#flp-bbcggi19" class="auto internal xref">Section 7.3</a> extends the proof system of
<span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, Section 4.2 in a few ways.<a href="#section-7.3.1.1-1" class="pilcrow">¶</a></p>
<p id="section-7.3.1.1-2">First, the validity circuit in our construction includes an additional, random
input (this is the "joint randomness" derived from the measurement shares in
Prio3; see <a href="#prio3-construction" class="auto internal xref">Section 7.2</a>). This allows for circuit optimizations that
trade a small soundness error for a shorter proof. For example, consider a
circuit that recognizes the set of length-<code>N</code> vectors for which each element is
either one or zero. A deterministic circuit could be constructed for this
language, but it would involve a large number of multiplications that would
result in a large proof. (See the discussion in <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, Section 5.2 for
details). A much shorter proof can be constructed for the following randomized
circuit:<a href="#section-7.3.1.1-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.3.1.1-3">
<pre>
C(x, r) = r * Range2(x[0]) + ... + r^N * Range2(x[N-1])
</pre><a href="#section-7.3.1.1-3" class="pilcrow">¶</a>
</div>
<p id="section-7.3.1.1-4">(Note that this is a special case of <span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, Theorem 5.2.) Here <code>x</code> is
the length-<code>N</code> input and <code>r</code> is a random field element. The gadget circuit
<code>Range2</code> is the "range-check" polynomial described above, i.e., <code>Range2(x) =
x^2 - x</code>. The idea is that, if <code>x</code> is valid, i.e., each <code>x[j]</code> is in
the range <code>[0, 2)</code>, then the circuit will evaluate to zero regardless of the
value of <code>r</code>; but if some <code>x[j]</code> is not in the range <code>[0, 2)</code>, then the output
will be non-zero with high probability.<a href="#section-7.3.1.1-4" class="pilcrow">¶</a></p>
<p id="section-7.3.1.1-5">The second extension implemented by our FLP allows the validity circuit to
contain multiple gadget types. (This generalization was suggested in
<span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>, Remark 4.5.) This provides additional flexibility for designing
circuits by allowing multiple, non-affine sub-circuits. For example, the
following circuit is allowed:<a href="#section-7.3.1.1-5" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.3.1.1-6">
<pre>
C(x, r) = r * Range2(x[0]) + ... + r^L * Range2(x[L-1]) + \
            r^(L+1) * Range3(x[L]) + ... + r^N * Range3(x[N-1])
</pre><a href="#section-7.3.1.1-6" class="pilcrow">¶</a>
</div>
<p id="section-7.3.1.1-7">where <code>Range3(x) = x^3 - 3x^2 + 2x</code>. This circuit checks that the first <code>L</code>
inputs are in the range <code>[0, 2)</code> and the last <code>N-L</code> inputs are in the range
<code>[0, 3)</code>. The same circuit can be expressed using a simpler gadget, namely
multiplication, but the resulting proof would be longer.<a href="#section-7.3.1.1-7" class="pilcrow">¶</a></p>
<p id="section-7.3.1.1-8">Third, rather than interpolate the gadget polynomial at inputs <code>1</code>, <code>2</code>, ...,
<code>j</code>, ..., where <code>j</code> is the <code>j</code>-th invocation of the gadget, we use roots of
unity for the field. This allows us to construct each gadget polynomial via the
number theoretic transform <span>[<a href="#SML24" class="cite xref">SML24</a>]</span>, which is far more efficient than generic
formulas. Note that the roots of unity are powers of the generator for the
NTT-friendly field (see <a href="#field-ntt-friendly" class="auto internal xref">Section 6.1.2</a>).<a href="#section-7.3.1.1-8" class="pilcrow">¶</a></p>
<p id="section-7.3.1.1-9">Finally, the validity circuit in our FLP may have any number of outputs (at
least one). The input is said to be valid if each of the outputs is zero. To
save bandwidth, we take a random linear combination of the outputs. If each of
the outputs is zero, then the reduced output will be zero; but if one of the
outputs is non-zero, then the reduced output will be non-zero with high
probability.<a href="#section-7.3.1.1-9" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="flp-bbcggi19-valid">
<section id="section-7.3.2">
          <h4 id="name-validity-circuits">
<a href="#section-7.3.2" class="section-number selfRef">7.3.2. </a><a href="#name-validity-circuits" class="section-name selfRef">Validity Circuits</a>
          </h4>
<p id="section-7.3.2-1">An instance of the proof system is defined in terms of a validity circuit that
implements the <code>Valid</code> interface specified in this section. The parameters are
listed in the table below.<a href="#section-7.3.2-1" class="pilcrow">¶</a></p>
<span id="name-validity-circuit-parameters"></span><table class="center" id="table-8">
            <caption>
<a href="#table-8" class="selfRef">Table 8</a>:
<a href="#name-validity-circuit-parameters" class="selfRef">Validity circuit parameters.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGETS: list[Gadget]</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">A list of gadgets.</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>GADGET_CALLS: list[int]</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Number of times each gadget is called.</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>MEAS_LEN: int</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Length of the measurement.</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>JOINT_RAND_LEN: int</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Length of the joint randomness.</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>EVAL_OUTPUT_LEN: int</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Length of the circuit output.</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>OUTPUT_LEN: int</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Length of the aggregatable output.</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Measurement</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Type of the measurement.</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>AggResult</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Type of the aggregate result.</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>field: type[F]</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">Class object for the field (<a href="#field-ntt-friendly" class="auto internal xref">Section 6.1.2</a>)</td>
              </tr>
            </tbody>
          </table>
<p id="section-7.3.2-3">The circuit is invoked with the following method:<a href="#section-7.3.2-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.2-4.1">
              <p id="section-7.3.2-4.1.1"><code>valid.eval(meas: list[F], joint_rand: list[F], num_shares: int) -&gt; list[F]</code>
evaluates the arithmetic circuit on a measurement and joint randomness. The
output is a list of field elements: if every element is equal to
<code>valid.field(0)</code>, then the circuit is said to "accept" the measurement;
otherwise, if any element is not equal to <code>valid.field(0)</code>, then the circuit
is said to "reject" the measurement.<a href="#section-7.3.2-4.1.1" class="pilcrow">¶</a></p>
<p id="section-7.3.2-4.1.2">
This method can also be called on a secret share of the measurement, in which
case it produces a secret share of the output.<a href="#section-7.3.2-4.1.2" class="pilcrow">¶</a></p>
<p id="section-7.3.2-4.1.3">
The circuit must be composed of affine gates and gadget calls, so that the
verifier may check the prover's proof and circuit evaluation using linear
queries. This means that all non-affine multiplications in the circuit must
be encapsulated in gadget calls. Additions of constants must be rescaled by
the inverse of <code>num_shares</code>.<a href="#section-7.3.2-4.1.3" class="pilcrow">¶</a></p>
<p id="section-7.3.2-4.1.4">
Pre-conditions:<a href="#section-7.3.2-4.1.4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.2-4.1.5.1">
                  <p id="section-7.3.2-4.1.5.1.1">The length of <code>meas</code> <span class="bcp14">MUST</span> be <code>valid.MEAS_LEN</code>.<a href="#section-7.3.2-4.1.5.1.1" class="pilcrow">¶</a></p>
</li>
                <li class="normal" id="section-7.3.2-4.1.5.2">
                  <p id="section-7.3.2-4.1.5.2.1">The length of <code>joint_rand</code> <span class="bcp14">MUST</span> be <code>valid.JOINT_RAND_LEN</code>.<a href="#section-7.3.2-4.1.5.2.1" class="pilcrow">¶</a></p>
</li>
                <li class="normal" id="section-7.3.2-4.1.5.3">
                  <p id="section-7.3.2-4.1.5.3.1"><code>num_shares</code> <span class="bcp14">MUST</span> be the number of secret shares of <code>meas</code>, or <code>1</code> if
<code>meas</code> is not secret shared.<a href="#section-7.3.2-4.1.5.3.1" class="pilcrow">¶</a></p>
</li>
              </ul>
<p id="section-7.3.2-4.1.6">
Post-conditions:<a href="#section-7.3.2-4.1.6" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.2-4.1.7.1">
                  <p id="section-7.3.2-4.1.7.1.1">The length of the output <span class="bcp14">MUST</span> be <code>valid.EVAL_OUTPUT_LEN</code>.<a href="#section-7.3.2-4.1.7.1.1" class="pilcrow">¶</a></p>
</li>
              </ul>
</li>
          </ul>
<p id="section-7.3.2-5">Each circuit has a list of gadgets, denoted <code>GADGETS</code>, that are invoked by
<code>valid.eval()</code>. The circuit evaluated by the gadget should be non-affine, and <span class="bcp14">MUST</span>
be arithmetic, i.e., composed only of multiplication, addition, and subtraction
gates. An instance of class <code>Gadget</code> has the following interface:<a href="#section-7.3.2-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.2-6.1">
              <p id="section-7.3.2-6.1.1"><code>ARITY: int</code> is the number of input wires. For example, the multiplication
gadget <code>Mul(x,y) = x*y</code> has arity of 2.<a href="#section-7.3.2-6.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.3.2-6.2">
              <p id="section-7.3.2-6.2.1"><code>DEGREE: int</code> is the arithmetic degree of the gadget circuit. This is defined
to be the degree of the polynomial that computes it. This exists
because the circuit is arithmetic. For example, <code>Mul</code> has degree 2.<a href="#section-7.3.2-6.2.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.3.2-6.3">
              <p id="section-7.3.2-6.3.1"><code>gadget.eval(field: type[F], inp: list[F]) -&gt; F</code> evaluates the gadget over
the given inputs and field.<a href="#section-7.3.2-6.3.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.3.2-6.4">
              <p id="section-7.3.2-6.4.1"><code>gadget.eval_poly(field: type[F], inp_poly: list[list[F]]) -&gt; list[F]</code> is the
same as <code>gadget.eval()</code> except it evaluates the circuit over the polynomial
ring of the field. This is well defined because the circuit is arithmetic.<a href="#section-7.3.2-6.4.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-7.3.2-7">In addition to the list of gadgets, the validity circuit specifies how many
times each gadget is called (<code>GADGET_CALLS</code>). The circuit needs to define an
ordering of the calls it makes to each gadget, so that all parties agree on how
to identify recorded wire values. It also specifies the length of the circuit's
input (<code>MEAS_LEN</code>), the length of the joint randomness (<code>JOINT_RAND_LEN</code>), and
the length of the circuit's output (<code>EVAL_OUTPUT_LEN</code>).<a href="#section-7.3.2-7" class="pilcrow">¶</a></p>
<p id="section-7.3.2-8">A validity circuit also specifies parameters and methods needed for Prio3
aggregation. These are used to implement the interface in <a href="#flp-encode" class="auto internal xref">Section 7.1.1</a>:<a href="#section-7.3.2-8" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.3.2-9.1">
              <p id="section-7.3.2-9.1.1"><code>valid.encode(measurement: Measurement) -&gt; list[F]</code> returns a vector of
length <code>MEAS_LEN</code> representing a measurement of type <code>Measurement</code>.<a href="#section-7.3.2-9.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.3.2-9.2">
              <p id="section-7.3.2-9.2.1"><code>valid.truncate(meas: list[F]) -&gt; list[F]</code> returns a vector of length
<code>OUTPUT_LEN</code> representing (a share of) an aggregatable output.<a href="#section-7.3.2-9.2.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.3.2-9.3">
              <p id="section-7.3.2-9.3.1"><code>valid.decode(agg: list[F], num_measurements: int) -&gt; AggResult</code> returns an
aggregate result of type <code>AggResult</code>. This computation may depend on the
number of outputs aggregated.<a href="#section-7.3.2-9.3.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-7.3.2-10">Finally, the following are helper methods used to instantiate parameters of the
<code>Flp</code> interface (<a href="#flp" class="auto internal xref">Section 7.1</a>):<a href="#section-7.3.2-10" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.3.2-11">
<pre>
def prove_rand_len(self) -&gt; int:
    """Length of the prover randomness."""
    return sum(g.ARITY for g in self.GADGETS)

def query_rand_len(self) -&gt; int:
    """Length of the query randomness."""
    query_rand_len = len(self.GADGETS)
    if self.EVAL_OUTPUT_LEN &gt; 1:
        query_rand_len += self.EVAL_OUTPUT_LEN
    return query_rand_len

def proof_len(self) -&gt; int:
    """Length of the proof."""
    length = 0
    for (g, g_calls) in zip(self.GADGETS, self.GADGET_CALLS):
        p = next_power_of_2(1 + g_calls)
        length += g.ARITY + g.DEGREE * (p - 1) + 1
    return length

def verifier_len(self) -&gt; int:
    """Length of the verifier message."""
    length = 1
    for g in self.GADGETS:
        length += g.ARITY + 1
    return length
</pre><a href="#section-7.3.2-11" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="flp-bbcggi19-construction-prove">
<section id="section-7.3.3">
          <h4 id="name-generating-the-proof">
<a href="#section-7.3.3" class="section-number selfRef">7.3.3. </a><a href="#name-generating-the-proof" class="section-name selfRef">Generating the Proof</a>
          </h4>
<span id="name-components-of-the-proof-gen"></span><figure id="figure-8">
            <div id="section-7.3.3-1.1">
              <div class="alignLeft art-svg artwork" id="section-7.3.3-1.1.1">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="240" width="296" viewBox="0 0 296 240" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                  <path d="M 8,32 L 8,192" fill="none" stroke="black"></path>
                  <path d="M 24,192 L 24,224" fill="none" stroke="black"></path>
                  <path d="M 32,64 L 32,160" fill="none" stroke="black"></path>
                  <path d="M 56,96 L 56,128" fill="none" stroke="black"></path>
                  <path d="M 128,96 L 128,128" fill="none" stroke="black"></path>
                  <path d="M 152,64 L 152,160" fill="none" stroke="black"></path>
                  <path d="M 176,32 L 176,72" fill="none" stroke="black"></path>
                  <path d="M 176,104 L 176,192" fill="none" stroke="black"></path>
                  <path d="M 8,32 L 176,32" fill="none" stroke="black"></path>
                  <path d="M 32,64 L 152,64" fill="none" stroke="black"></path>
                  <path d="M 160,80 L 200,80" fill="none" stroke="black"></path>
                  <path d="M 56,96 L 128,96" fill="none" stroke="black"></path>
                  <path d="M 160,96 L 200,96" fill="none" stroke="black"></path>
                  <path d="M 184,112 L 200,112" fill="none" stroke="black"></path>
                  <path d="M 56,128 L 128,128" fill="none" stroke="black"></path>
                  <path d="M 32,160 L 152,160" fill="none" stroke="black"></path>
                  <path d="M 8,192 L 176,192" fill="none" stroke="black"></path>
                  <polygon class="arrowhead" points="192,112 180,106.4 180,117.6" fill="black" transform="rotate(180,184,112)"></polygon>
                  <polygon class="arrowhead" points="168,96 156,90.4 156,101.6" fill="black" transform="rotate(180,160,96)"></polygon>
                  <polygon class="arrowhead" points="168,80 156,74.4 156,85.6" fill="black" transform="rotate(180,160,80)"></polygon>
                  <polygon class="arrowhead" points="32,224 20,218.4 20,229.6" fill="black" transform="rotate(90,24,224)"></polygon>
                  <g class="text">
                    <text x="48" y="52">prove()</text>
                    <text x="64" y="84">Valid</text>
                    <text x="228" y="84">meas</text>
                    <text x="232" y="100">joint</text>
                    <text x="276" y="100">rand</text>
                    <text x="92" y="116">Gadget</text>
                    <text x="232" y="116">prove</text>
                    <text x="276" y="116">rand</text>
                    <text x="56" y="228">proof</text>
                  </g>
                </svg><a href="#section-7.3.3-1.1.1" class="pilcrow">¶</a>
</div>
</div>
<figcaption><a href="#figure-8" class="selfRef">Figure 8</a>:
<a href="#name-components-of-the-proof-gen" class="selfRef">Components of the proof generation algorithm.</a>
            </figcaption></figure>
<p id="section-7.3.3-2">The proof generation algorithm invokes the validity circuit on the encoded
measurement and joint randomness. The validity circuit in turn invokes the
gadgets defined by the circuit. The prove randomness is used to construct the
gadget polynomials that the verifier will use to compute the outputs of each
gadget.<a href="#section-7.3.3-2" class="pilcrow">¶</a></p>
<p id="section-7.3.3-3">To generate the gadget polynomials, the prover evaluates the validity circuit,
and records the values on each input wire of each call to each gadget. This is
accomplished by "wrapping" each gadget in a class <code>ProveGadget</code> that records
the wire inputs. We list this class in <a href="#gadget-wrappers" class="auto internal xref">Appendix A.4</a>. We denote the value
of the <code>j</code>-th wire for the <code>k</code>-th invocation of gadget <code>g</code> as <code>g.wires[j][k]</code>.<a href="#section-7.3.3-3" class="pilcrow">¶</a></p>
<p id="section-7.3.3-4">Next, we compute each of the "wire polynomials" for each gadget. The <code>j</code>-th
wire polynomial is the lowest degree polynomial that evaluates to
<code>g.wire[j][k]</code> at a sequence of fixed points. We obtain the gadget polynomial by
evaluating the gadget on the wire polynomials.<a href="#section-7.3.3-4" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.3.3-5">
<pre>
def prove(self,
          meas: list[F],
          prove_rand: list[F],
          joint_rand: list[F]) -&gt; list[F]:
    # Evaluate the validity circuit, recording the value of each
    # input wire for each evaluation of each gadget.
    valid = ProveGadget.wrap(self.valid, prove_rand)
    valid.eval(meas, joint_rand, 1)

    # Construct the proof, which consists of the wire seeds and
    # gadget polynomial for each gadget.
    proof = []
    for g in cast(list[ProveGadget[F]], valid.GADGETS):
        p = len(g.wires[0])

        # Compute the wire polynomials for this gadget. For each `j`,
        # find the lowest degree polynomial `wire_poly` for which
        # `wire_poly(alpha^k) = g.wires[j][k]` for all `k`. Note that
        # each `g.wires[j][0]` is set to the seed of wire `j`, which
        # is included in the prove randomness.
        #
        # Implementation note: `alpha` is a root of unity, which
        # means `poly_interp()` can be evaluated using the NTT. Note
        # that `g.wires[j]` is padded with 0s to a power of 2.
        alpha = self.field.gen() ** (self.field.GEN_ORDER // p)
        wire_inp = [alpha ** k for k in range(p)]
        wire_polys = []
        for j in range(g.ARITY):
            wire_poly = poly_interp(self.field, wire_inp, g.wires[j])
            wire_polys.append(wire_poly)

        # Compute the gadget polynomial by evaluating the gadget on
        # the wire polynomials. By construction we have that
        # `gadget_poly(alpha^k)` is the `k`-th output.
        gadget_poly = g.eval_poly(self.field, wire_polys)

        for j in range(g.ARITY):
            proof.append(g.wires[j][0])
        proof += gadget_poly

    return proof
</pre><a href="#section-7.3.3-5" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="flp-bbcggi19-construction-query">
<section id="section-7.3.4">
          <h4 id="name-querying-the-proof">
<a href="#section-7.3.4" class="section-number selfRef">7.3.4. </a><a href="#name-querying-the-proof" class="section-name selfRef">Querying the Proof</a>
          </h4>
<span id="name-components-of-the-query-alg"></span><figure id="figure-9">
            <div id="section-7.3.4-1.1">
              <div class="alignLeft art-svg artwork" id="section-7.3.4-1.1.1">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="272" width="312" viewBox="0 0 312 272" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                  <path d="M 8,64 L 8,224" fill="none" stroke="black"></path>
                  <path d="M 24,224 L 24,256" fill="none" stroke="black"></path>
                  <path d="M 32,96 L 32,192" fill="none" stroke="black"></path>
                  <path d="M 56,128 L 56,160" fill="none" stroke="black"></path>
                  <path d="M 96,48 L 96,128" fill="none" stroke="black"></path>
                  <path d="M 128,128 L 128,160" fill="none" stroke="black"></path>
                  <path d="M 152,96 L 152,192" fill="none" stroke="black"></path>
                  <path d="M 176,64 L 176,104" fill="none" stroke="black"></path>
                  <path d="M 176,136 L 176,224" fill="none" stroke="black"></path>
                  <path d="M 8,64 L 88,64" fill="none" stroke="black"></path>
                  <path d="M 104,64 L 176,64" fill="none" stroke="black"></path>
                  <path d="M 32,96 L 88,96" fill="none" stroke="black"></path>
                  <path d="M 104,96 L 152,96" fill="none" stroke="black"></path>
                  <path d="M 160,112 L 200,112" fill="none" stroke="black"></path>
                  <path d="M 56,128 L 88,128" fill="none" stroke="black"></path>
                  <path d="M 104,128 L 128,128" fill="none" stroke="black"></path>
                  <path d="M 160,128 L 200,128" fill="none" stroke="black"></path>
                  <path d="M 184,144 L 200,144" fill="none" stroke="black"></path>
                  <path d="M 56,160 L 128,160" fill="none" stroke="black"></path>
                  <path d="M 32,192 L 152,192" fill="none" stroke="black"></path>
                  <path d="M 8,224 L 176,224" fill="none" stroke="black"></path>
                  <polygon class="arrowhead" points="192,144 180,138.4 180,149.6" fill="black" transform="rotate(180,184,144)"></polygon>
                  <polygon class="arrowhead" points="168,128 156,122.4 156,133.6" fill="black" transform="rotate(180,160,128)"></polygon>
                  <polygon class="arrowhead" points="168,112 156,106.4 156,117.6" fill="black" transform="rotate(180,160,112)"></polygon>
                  <polygon class="arrowhead" points="104,128 92,122.4 92,133.6" fill="black" transform="rotate(90,96,128)"></polygon>
                  <polygon class="arrowhead" points="32,256 20,250.4 20,261.6" fill="black" transform="rotate(90,24,256)"></polygon>
                  <g class="text">
                    <text x="72" y="36">proof</text>
                    <text x="128" y="36">(share)</text>
                    <text x="48" y="84">query()</text>
                    <text x="64" y="116">Valid</text>
                    <text x="228" y="116">meas</text>
                    <text x="280" y="116">(share)</text>
                    <text x="232" y="132">joint</text>
                    <text x="276" y="132">rand</text>
                    <text x="92" y="148">Gadget</text>
                    <text x="232" y="148">query</text>
                    <text x="276" y="148">rand</text>
                    <text x="68" y="260">verifier</text>
                    <text x="136" y="260">(share)</text>
                  </g>
                </svg><a href="#section-7.3.4-1.1.1" class="pilcrow">¶</a>
</div>
</div>
<figcaption><a href="#figure-9" class="selfRef">Figure 9</a>:
<a href="#name-components-of-the-query-alg" class="selfRef">Components of the query algorithm.</a>
            </figcaption></figure>
<p id="section-7.3.4-2">The query algorithm invokes the validity circuit on the encoded measurement and
joint randomness. It evaluates the gadget polynomials encoded by the proof
(share) to produce (a share of) each gadget output. The verifier (share)
consists of (a share of) the validity circuit's output and (a share of) each
gadget test. The gadget tests consume the query randomness.<a href="#section-7.3.4-2" class="pilcrow">¶</a></p>
<p id="section-7.3.4-3">The goal of each gadget test is to ensure the inputs used by the prover to
generate the gadget polynomial match the inputs we used to evaluate it. We do
this by partially reconstructing the gadget polynomial and evaluating it at a random
point: when we evaluate the gadget polynomial at the same point, we expect to
get the same result.<a href="#section-7.3.4-3" class="pilcrow">¶</a></p>
<p id="section-7.3.4-4">To start a gadget test, we first construct the (shares of the) wire polynomials
just as the prover did. First, we record the input (share) of the <code>j</code>-th wire
of the <code>k</code>-th invocation of the gadget as <code>g.wires[j][k]</code>. Again, this is
accomplished by a wrapper gadget, <code>QueryGadget</code>, listed in <a href="#gadget-wrappers" class="auto internal xref">Appendix A.4</a>.
This gadget also evaluates the gadget polynomial for each gadget invocation in
order to produce the gadget's output. Then we compute the wire polynomials from
the recorded values.<a href="#section-7.3.4-4" class="pilcrow">¶</a></p>
<p id="section-7.3.4-5">Next, we choose a random point <code>t</code> (parsed from the query randomness), evaluate
each wire polynomial at <code>t</code>, and evaluate the gadget polynomial at <code>t</code>. The
results are recorded in the verifier message passed to the decision algorithm,
where we finish the test.<a href="#section-7.3.4-5" class="pilcrow">¶</a></p>
<p id="section-7.3.4-6">The random point <code>t</code> <span class="bcp14">MUST NOT</span> be one of the fixed evaluation points used to
interpolate the wire polynomials. Otherwise, the verifier message may partially
leak the encoded measurement.<a href="#section-7.3.4-6" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-7.3.4-7">
<pre>
def query(self,
          meas: list[F],
          proof: list[F],
          query_rand: list[F],
          joint_rand: list[F],
          num_shares: int) -&gt; list[F]:
    # Evaluate the validity circuit, recording the value of each
    # input wire for each evaluation of each gadget. Use the gadget
    # polynomials encoded by `proof` to compute the gadget outputs.
    valid = QueryGadget.wrap(self.valid, proof)
    out = valid.eval(meas, joint_rand, num_shares)

    # Reduce the output.
    if self.valid.EVAL_OUTPUT_LEN &gt; 1:
        (rand, query_rand) = front(
            self.valid.EVAL_OUTPUT_LEN,
            query_rand,
        )
        v = self.field(0)
        for (r, out_elem) in zip(rand, out):
            v += r * out_elem
    else:
        [v] = out

    # Construct the verifier message, which consists of the reduced
    # circuit output and each gadget test.
    verifier = [v]
    for (g, t) in zip(cast(list[QueryGadget[F]], valid.GADGETS),
                      query_rand):
        p = len(g.wires[0])

        # Abort if `t` is one of the inputs used to compute the wire
        # polynomials so that the verifier message doesn't leak the
        # gadget output. It suffices to check if `t` is a root of
        # unity, which implies it is a power of `alpha`.
        if t ** p == self.field(1):
            raise ValueError('test point is a root of unity')

        # To test the gadget, we re-compute the wire polynomials and
        # check for consistency with the gadget polynomial provided
        # by the prover. To start, evaluate the gadget polynomial and
        # each of the wire polynomials at the random point `t`.
        wire_checks = []
        wire_inp = [g.alpha ** k for k in range(p)]
        for j in range(g.ARITY):
            wire_poly = poly_interp(self.field, wire_inp, g.wires[j])
            wire_checks.append(poly_eval(self.field, wire_poly, t))

        gadget_check = poly_eval(self.field, g.poly, t)

        verifier += wire_checks
        verifier.append(gadget_check)

    return verifier
</pre><a href="#section-7.3.4-7" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="flp-bbcggi19-construction-decide">
<section id="section-7.3.5">
          <h4 id="name-deciding-validity">
<a href="#section-7.3.5" class="section-number selfRef">7.3.5. </a><a href="#name-deciding-validity" class="section-name selfRef">Deciding Validity</a>
          </h4>
<span id="name-components-of-the-decision-"></span><figure id="figure-10">
            <div id="section-7.3.5-1.1">
              <div class="alignLeft art-svg artwork" id="section-7.3.5-1.1.1">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="144" width="168" viewBox="0 0 168 144" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
                  <path d="M 8,64 L 8,96" fill="none" stroke="black"></path>
                  <path d="M 24,32 L 24,56" fill="none" stroke="black"></path>
                  <path d="M 24,96 L 24,128" fill="none" stroke="black"></path>
                  <path d="M 160,64 L 160,96" fill="none" stroke="black"></path>
                  <path d="M 8,64 L 160,64" fill="none" stroke="black"></path>
                  <path d="M 8,96 L 160,96" fill="none" stroke="black"></path>
                  <polygon class="arrowhead" points="32,128 20,122.4 20,133.6" fill="black" transform="rotate(90,24,128)"></polygon>
                  <polygon class="arrowhead" points="32,56 20,50.4 20,61.6" fill="black" transform="rotate(90,24,56)"></polygon>
                  <g class="text">
                    <text x="68" y="36">verifier</text>
                    <text x="44" y="84">Decide</text>
                    <text x="68" y="132">is_valid</text>
                  </g>
                </svg><a href="#section-7.3.5-1.1.1" class="pilcrow">¶</a>
</div>
</div>
<figcaption><a href="#figure-10" class="selfRef">Figure 10</a>:
<a href="#name-components-of-the-decision-" class="selfRef">Components of the decision algorithm.</a>
            </figcaption></figure>
<p id="section-7.3.5-2">The decision algorithm consumes the verifier message. (Each of the Aggregators
computes an additive share of the verifier message after the previous step.) The
verifier message consists of the reduced circuit output and the gadget tests.<a href="#section-7.3.5-2" class="pilcrow">¶</a></p>
<p id="section-7.3.5-3">To finish each gadget test, we evaluate the gadget on the wire checks: if the
encoded measurement and joint randomness used to generate the proof are the
same as the measurement (share) and joint randomness used to verify the proof,
then the output of the gadget will be equal to the gadget check; otherwise, the
output will not equal the gadget check with high probability.<a href="#section-7.3.5-3" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.3.5-4">
<pre>
def decide(self, verifier: list[F]) -&gt; bool:
    # Check the output of the validity circuit.
    ([v], verifier) = front(1, verifier)
    if v != self.field(0):
        return False

    # Complete each gadget test.
    for g in self.valid.GADGETS:
        (wire_checks, verifier) = front(g.ARITY, verifier)
        ([gadget_check], verifier) = front(1, verifier)
        if g.eval(self.field, wire_checks) != gadget_check:
            return False

    return True
</pre><a href="#section-7.3.5-4" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="prio3-instantiations">
<section id="section-7.4">
        <h3 id="name-variants">
<a href="#section-7.4" class="section-number selfRef">7.4. </a><a href="#name-variants" class="section-name selfRef">Variants</a>
        </h3>
<p id="section-7.4-1">This section specifies instantiations of Prio3 for various aggregation tasks.
Each variant is determined by a field (<a href="#field" class="auto internal xref">Section 6.1</a>), a validity circuit
(<a href="#flp-bbcggi19-valid" class="auto internal xref">Section 7.3.2</a>),and the number of proofs to generate and verify. All
gadgets are listed in <a href="#gadgets" class="auto internal xref">Appendix A</a>. Test vectors for each can be found in
<a href="#test-vectors" class="auto internal xref">Appendix C</a>.<a href="#section-7.4-1" class="pilcrow">¶</a></p>
<div id="prio3count">
<section id="section-7.4.1">
          <h4 id="name-prio3count">
<a href="#section-7.4.1" class="section-number selfRef">7.4.1. </a><a href="#name-prio3count" class="section-name selfRef">Prio3Count</a>
          </h4>
<span id="name-parameters-for-prio3count"></span><table class="center" id="table-9">
            <caption>
<a href="#table-9" class="selfRef">Table 9</a>:
<a href="#name-parameters-for-prio3count" class="selfRef">Parameters for Prio3Count.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>field</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field64</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Count(field)</code> (this section)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>PROOFS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
            </tbody>
          </table>
<p id="section-7.4.1-2">Our first variant of Prio3 is for a simple counter: each measurement is either
one or zero and the aggregate result is the sum of the measurements. Its
validity circuit uses the multiplication gadget <code>Mul</code> specified in
<a href="#gadget-mul" class="auto internal xref">Appendix A.1</a>, which takes two inputs and multiplies them. The circuit is
specified below:<a href="#section-7.4.1-2" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-7.4.1-3">
<pre>
class Count(Valid[int, int, F]):
    GADGETS: list[Gadget[F]] = [Mul()]
    GADGET_CALLS = [1]
    MEAS_LEN = 1
    JOINT_RAND_LEN = 0
    OUTPUT_LEN = 1
    EVAL_OUTPUT_LEN = 1

    # Class object for the field.
    field: type[F]

    def __init__(self, field: type[F]):
        self.field = field

    def encode(self, measurement: int) -&gt; list[F]:
        return [self.field(measurement)]

    def eval(
            self,
            meas: list[F],
            joint_rand: list[F],
            _num_shares: int) -&gt; list[F]:
        squared = self.GADGETS[0].eval(self.field,
                                       [meas[0], meas[0]])
        return [squared - meas[0]]

    def truncate(self, meas: list[F]) -&gt; list[F]:
        return meas

    def decode(self, output: list[F], _num_measurements: int) -&gt; int:
        return output[0].int()
</pre><a href="#section-7.4.1-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="prio3sum">
<section id="section-7.4.2">
          <h4 id="name-prio3sum">
<a href="#section-7.4.2" class="section-number selfRef">7.4.2. </a><a href="#name-prio3sum" class="section-name selfRef">Prio3Sum</a>
          </h4>
<span id="name-parameters-for-prio3sum"></span><table class="center" id="table-10">
            <caption>
<a href="#table-10" class="selfRef">Table 10</a>:
<a href="#name-parameters-for-prio3sum" class="selfRef">Parameters for Prio3Sum.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>field</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field64</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Sum(field, max_measurement)</code> (this section)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>PROOFS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
            </tbody>
          </table>
<p id="section-7.4.2-2">The next variant of Prio3 supports summing of integers in a pre-determined
range. Each measurement is an integer in the range <code>[0, max_measurement]</code>,
where <code>max_measurement</code> defines the largest valid measurement.<a href="#section-7.4.2-2" class="pilcrow">¶</a></p>
<p id="section-7.4.2-3">The range check is accomplished by encoding the measurement as a bit vector,
encoding the measurement plus an offset as a bit vector, then checking that the
two encoded integers are consistent. Let<a href="#section-7.4.2-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.4.2-4.1">
              <p id="section-7.4.2-4.1.1"><code>bits = max_measurement.bit_length()</code>, the number of bits needed to encode
the largest valid measurement<a href="#section-7.4.2-4.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.4.2-4.2">
              <p id="section-7.4.2-4.2.1"><code>offset = 2^bits - 1 - max_measurement</code><a href="#section-7.4.2-4.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-7.4.2-5">The first bit-encoded integer is the measurement itself. Note that only
measurements between <code>0</code> and <code>2^bits - 1</code> can be encoded this way with as many
bits. The second bit-encoded integer is the sum of the measurement and
<code>offset</code>. Observe that this sum can only be encoded this way if it is between
<code>0</code> and <code>2^bits - 1</code>, which implies that the measurement is between <code>-offset</code>
and <code>max_measurement</code>.<a href="#section-7.4.2-5" class="pilcrow">¶</a></p>
<p id="section-7.4.2-6">The circuit first checks that each entry of both bit vectors is a one or a
zero. It then decodes both the measurement and the offset measurement, and
subtracts the offset from the latter. It then checks if these two values are
equal. Since both the measurement and the measurement plus <code>offset</code> are in the
same range of <code>[0, 2^bits)</code>, this means that the measurement itself is between
<code>0</code> and <code>max_measurement</code>.<a href="#section-7.4.2-6" class="pilcrow">¶</a></p>
<p id="section-7.4.2-7">The circuit uses the polynomial-evaluation gadget <code>PolyEval</code> specified in
<a href="#gadget-poly-eval" class="auto internal xref">Appendix A.2</a>. The polynomial is <code>p(x) = x^2 - x</code>, which is equal to <code>0</code>
if and only if <code>x</code> is in the range <code>[0, 2)</code>. The complete circuit is specified
below:<a href="#section-7.4.2-7" class="pilcrow">¶</a></p>
<p id="section-7.4.2-8">Note that decoding a sequence of bits into an integer is a linear operation,
specifically, a linear combination with a sequence of powers of two, so it can
be done within a validity circuit using "free" affine gates. Furthermore,
decoding secret shares of a bit-encoded integer will produce secret shares of
the original integer.<a href="#section-7.4.2-8" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-7.4.2-9">
<pre>
class Sum(Valid[int, int, F]):
    GADGETS: list[Gadget[F]] = [PolyEval([0, -1, 1])]
    JOINT_RAND_LEN = 0
    OUTPUT_LEN = 1
    field: type[F]

    def __init__(self, field: type[F], max_measurement: int):
        self.field = field
        self.bits = max_measurement.bit_length()
        self.offset = self.field(2**self.bits - 1 - max_measurement)
        self.max_measurement = max_measurement
        self.GADGET_CALLS = [2 * self.bits]
        self.MEAS_LEN = 2 * self.bits
        self.EVAL_OUTPUT_LEN = 2 * self.bits + 1

    def encode(self, measurement: int) -&gt; list[F]:
        encoded = []
        encoded += self.field.encode_into_bit_vec(
            measurement,
            self.bits
        )
        encoded += self.field.encode_into_bit_vec(
            measurement + self.offset.int(),
            self.bits
        )
        return encoded

    def eval(
            self,
            meas: list[F],
            joint_rand: list[F],
            num_shares: int) -&gt; list[F]:
        shares_inv = self.field(num_shares).inv()

        out = []
        for b in meas:
            out.append(self.GADGETS[0].eval(self.field, [b]))

        range_check = self.offset * shares_inv + \
            self.field.decode_from_bit_vec(meas[:self.bits]) - \
            self.field.decode_from_bit_vec(meas[self.bits:])
        out.append(range_check)
        return out

    def truncate(self, meas: list[F]) -&gt; list[F]:
        return [self.field.decode_from_bit_vec(meas[:self.bits])]

    def decode(self, output: list[F], _num_measurements: int) -&gt; int:
        return output[0].int()
</pre><a href="#section-7.4.2-9" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="prio3sumvec">
<section id="section-7.4.3">
          <h4 id="name-prio3sumvec">
<a href="#section-7.4.3" class="section-number selfRef">7.4.3. </a><a href="#name-prio3sumvec" class="section-name selfRef">Prio3SumVec</a>
          </h4>
<span id="name-parameters-for-prio3sumvec"></span><table class="center" id="table-11">
            <caption>
<a href="#table-11" class="selfRef">Table 11</a>:
<a href="#name-parameters-for-prio3sumvec" class="selfRef">Parameters for Prio3SumVec.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>field</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field128</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>SumVec(field, length, bits, chunk_length)</code> (this section)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>PROOFS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
            </tbody>
          </table>
<p id="section-7.4.3-2">This instance of Prio3 supports summing vectors of integers. It has three
parameters: <code>length</code>, <code>bits</code>, and <code>chunk_length</code>. Each measurement is a vector
of positive integers with length equal to the <code>length</code> parameter. Each element
of the measurement is an integer in the range <code>[0, 2^bits)</code>. It is <span class="bcp14">RECOMMENDED</span>
to set <code>chunk_length</code> to an integer near the square root of <code>length * bits</code>
(see <a href="#parallel-sum-chunk-length" class="auto internal xref">Section 7.4.3.1</a>).<a href="#section-7.4.3-2" class="pilcrow">¶</a></p>
<p id="section-7.4.3-3">The circuit is denoted <code>SumVec</code>. Each measurement is encoded as a vector of
field elements with a length of <code>length * bits</code>. The field elements in the
encoded vector represent all the bits of the measurement vector's elements,
consecutively, in LSB to MSB order.<a href="#section-7.4.3-3" class="pilcrow">¶</a></p>
<p id="section-7.4.3-4">The validity circuit uses the <code>ParallelSum</code> gadget in <a href="#gadget-parallel-sum" class="auto internal xref">Appendix A.3</a>.
This gadget applies an arithmetic subcircuit to multiple inputs in parallel,
then sums the results. Along with the subcircuit, the
parallel-sum gadget is parameterized by an integer, denoted <code>count</code>, specifying
how many times to call the subcircuit. It takes in a list of inputs and passes
them through to instances of the subcircuit in the same order. It returns the
sum of the subcircuit outputs.<a href="#section-7.4.3-4" class="pilcrow">¶</a></p>
<p id="section-7.4.3-5">Note that only the <code>ParallelSum</code> gadget itself, and not its subcircuit,
participates in the FLP's wire recording during evaluation, gadget consistency
proofs, and proof validation, even though the subcircuit is provided to
<code>ParallelSum</code> gadget as an implementation of the <code>Gadget</code> interface.<a href="#section-7.4.3-5" class="pilcrow">¶</a></p>
<p id="section-7.4.3-6">The <code>SumVec</code> validity circuit checks that the encoded measurement consists of
ones and zeros. Rather than use the <code>PolyEval</code> gadget on each element, as in
the <code>Sum</code> validity circuit, it instead uses <code>Mul</code> subcircuits (<a href="#gadget-mul" class="auto internal xref">Appendix A.1</a>)
and "free" constant multiplication and addition gates to simultaneously
evaluate the same range check polynomial on each element, and multiply by a
constant. One of the two <code>Mul</code> subcircuit inputs is equal to a measurement
element multiplied by a power of one of the elements of the joint randomness
vector, and the other is equal to the same measurement element minus one. These
<code>Mul</code> subcircuits are evaluated by a <code>ParallelSum</code> gadget, and the results are
added up both within the <code>ParallelSum</code> gadget and after it.<a href="#section-7.4.3-6" class="pilcrow">¶</a></p>
<p id="section-7.4.3-7">The complete circuit is specified below:<a href="#section-7.4.3-7" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-7.4.3-8">
<pre>
class SumVec(Valid[list[int], list[int], F]):
    EVAL_OUTPUT_LEN = 1
    length: int
    bits: int
    chunk_length: int
    field: type[F]

    def __init__(self,
                 field: type[F],
                 length: int,
                 bits: int,
                 chunk_length: int):
        """
        Instantiate the `SumVec` circuit for measurements with
        `length` elements, each in the range `[0, 2^bits)`.
        """
        self.field = field
        self.length = length
        self.bits = bits
        self.chunk_length = chunk_length
        self.GADGETS = [ParallelSum(Mul(), chunk_length)]
        self.GADGET_CALLS = [
            (length * bits + chunk_length - 1) // chunk_length
        ]
        self.MEAS_LEN = length * bits
        self.OUTPUT_LEN = length
        self.JOINT_RAND_LEN = self.GADGET_CALLS[0]

    def encode(self, measurement: list[int]) -&gt; list[F]:
        encoded = []
        for val in measurement:
            encoded += self.field.encode_into_bit_vec(
                val, self.bits)
        return encoded

    def eval(
            self,
            meas: list[F],
            joint_rand: list[F],
            num_shares: int) -&gt; list[F]:
        out = self.field(0)
        shares_inv = self.field(num_shares).inv()
        for i in range(self.GADGET_CALLS[0]):
            r = joint_rand[i]
            r_power = r
            inputs: list[Optional[F]]
            inputs = [None] * (2 * self.chunk_length)
            for j in range(self.chunk_length):
                index = i * self.chunk_length + j
                if index &lt; len(meas):
                    meas_elem = meas[index]
                else:
                    meas_elem = self.field(0)

                inputs[j * 2] = r_power * meas_elem
                inputs[j * 2 + 1] = meas_elem - shares_inv

                r_power *= r

            out += self.GADGETS[0].eval(
                self.field,
                cast(list[F], inputs),
            )

        return [out]

    def truncate(self, meas: list[F]) -&gt; list[F]:
        truncated = []
        for i in range(self.length):
            truncated.append(self.field.decode_from_bit_vec(
                meas[i * self.bits: (i + 1) * self.bits]
            ))
        return truncated

    def decode(
            self,
            output: list[F],
            _num_measurements: int) -&gt; list[int]:
        return [x.int() for x in output]
</pre><a href="#section-7.4.3-8" class="pilcrow">¶</a>
</div>
<div id="parallel-sum-chunk-length">
<section id="section-7.4.3.1">
            <h5 id="name-selection-of-parallelsum-ch">
<a href="#section-7.4.3.1" class="section-number selfRef">7.4.3.1. </a><a href="#name-selection-of-parallelsum-ch" class="section-name selfRef">Selection of <code>ParallelSum</code> Chunk Length</a>
            </h5>
<p id="section-7.4.3.1-1">The <code>chunk_length</code> parameter provides a trade-off between the arity of the
<code>ParallelSum</code> gadget (<a href="#gadget-parallel-sum" class="auto internal xref">Appendix A.3</a>) and the number of times the
gadget is called. The proof length is asymptotically minimized when the chunk
length is near the square root of the length of the encoded measurement.
However, the relationship between VDAF parameters and proof length is
complicated, involving two forms of rounding:<a href="#section-7.4.3.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.4.3.1-2.1">
                <p id="section-7.4.3.1-2.1.1">The circuit pads the inputs to its last <code>ParallelSum</code> gadget call, up to
the chunk length.<a href="#section-7.4.3.1-2.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-7.4.3.1-2.2">
                <p id="section-7.4.3.1-2.2.1">The proof system rounds the degree of wire polynomials, determined by the
number of times a gadget is called, up to the next power of two.<a href="#section-7.4.3.1-2.2.1" class="pilcrow">¶</a></p>
</li>
            </ul>
<p id="section-7.4.3.1-3">Therefore, the optimal choice of <code>chunk_length</code> for a concrete measurement size
will vary, and must be found through trial and error. Setting <code>chunk_length</code>
equal to the square root of the appropriate measurement length will result in
proofs up to 50% larger than the optimal proof size.<a href="#section-7.4.3.1-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="prio3histogram">
<section id="section-7.4.4">
          <h4 id="name-prio3histogram">
<a href="#section-7.4.4" class="section-number selfRef">7.4.4. </a><a href="#name-prio3histogram" class="section-name selfRef">Prio3Histogram</a>
          </h4>
<span id="name-parameters-for-prio3histogr"></span><table class="center" id="table-12">
            <caption>
<a href="#table-12" class="selfRef">Table 12</a>:
<a href="#name-parameters-for-prio3histogr" class="selfRef">Parameters for Prio3Histogram.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>field</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field128</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Histogram(field, length, chunk_length)</code> (this section)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>PROOFS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
            </tbody>
          </table>
<p id="section-7.4.4-2">This variant of Prio3 allows for estimating the distribution of some quantity
by computing a simple histogram. Each measurement increments one histogram
bucket, out of a set of fixed buckets. (Bucket indexing begins at <code>0</code>.) For
example, the buckets might quantize the real numbers, and each measurement
would report the bucket that the corresponding client's real-numbered value
falls into. The aggregate result counts the number of measurements in each
bucket.<a href="#section-7.4.4-2" class="pilcrow">¶</a></p>
<p id="section-7.4.4-3">The validity circuit is denoted <code>Histogram</code>. It has two parameters: <code>length</code>,
the number of histogram buckets; and <code>chunk_length</code>, which is used by a
circuit optimization described below. It is <span class="bcp14">RECOMMENDED</span> to set <code>chunk_length</code>
to an integer near the square root of <code>length</code> (see
<a href="#parallel-sum-chunk-length" class="auto internal xref">Section 7.4.3.1</a>).<a href="#section-7.4.4-3" class="pilcrow">¶</a></p>
<p id="section-7.4.4-4">The measurement is encoded as a one-hot vector representing the bucket into
which the measurement falls. The circuit checks for one-hotness in two steps,
by checking that the encoded measurement consists of ones and zeros, and by
checking that the sum of all elements in the encoded measurement is equal to
one. The individual checks constitute the output of the circuit.<a href="#section-7.4.4-4" class="pilcrow">¶</a></p>
<p id="section-7.4.4-5">As in the <code>SumVec</code> validity circuit (<a href="#prio3sumvec" class="auto internal xref">Section 7.4.3</a>), the first part of the
validity circuit uses the <code>ParallelSum</code> (<a href="#gadget-parallel-sum" class="auto internal xref">Appendix A.3</a>) gadget to
perform range checks while achieving a smaller proof size. The <code>ParallelSum</code>
gadget uses <code>Mul</code> subcircuits (<a href="#gadget-mul" class="auto internal xref">Appendix A.1</a>) to evaluate a range check
polynomial on each element, and includes an additional constant multiplication.
One of the two <code>Mul</code> subcircuit inputs is equal to a measurement element
multiplied by a power of an element of the joint randomness vector, and the
other is equal to the same measurement element minus one. The results are added
up both within the <code>ParallelSum</code> gadget and after it.<a href="#section-7.4.4-5" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-7.4.4-6">
<pre>
class Histogram(Valid[int, list[int], F]):
    EVAL_OUTPUT_LEN = 2
    field: type[F]
    length: int
    chunk_length: int

    def __init__(self,
                 field: type[F],
                 length: int,
                 chunk_length: int):
        """
        Instantiate an instance of the `Histogram` circuit with the
        given `length` and `chunk_length`.
        """
        self.field = field
        self.length = length
        self.chunk_length = chunk_length
        self.GADGETS = [ParallelSum(Mul(), chunk_length)]
        self.GADGET_CALLS = [
            (length + chunk_length - 1) // chunk_length]
        self.MEAS_LEN = self.length
        self.OUTPUT_LEN = self.length
        self.JOINT_RAND_LEN = self.GADGET_CALLS[0]

    def encode(self, measurement: int) -&gt; list[F]:
        encoded = [self.field(0)] * self.length
        encoded[measurement] = self.field(1)
        return encoded

    def eval(
            self,
            meas: list[F],
            joint_rand: list[F],
            num_shares: int) -&gt; list[F]:
        # Check that each bucket is one or zero.
        range_check = self.field(0)
        shares_inv = self.field(num_shares).inv()
        for i in range(self.GADGET_CALLS[0]):
            r = joint_rand[i]
            r_power = r
            inputs: list[Optional[F]]
            inputs = [None] * (2 * self.chunk_length)
            for j in range(self.chunk_length):
                index = i * self.chunk_length + j
                if index &lt; len(meas):
                    meas_elem = meas[index]
                else:
                    meas_elem = self.field(0)

                inputs[j * 2] = r_power * meas_elem
                inputs[j * 2 + 1] = meas_elem - shares_inv

                r_power *= r

            range_check += self.GADGETS[0].eval(
                self.field,
                cast(list[F], inputs),
            )

        # Check that the buckets sum to 1.
        sum_check = -shares_inv
        for b in meas:
            sum_check += b

        return [range_check, sum_check]

    def truncate(self, meas: list[F]) -&gt; list[F]:
        return meas

    def decode(
            self,
            output: list[F],
            _num_measurements: int) -&gt; list[int]:
        return [bucket_count.int()
                for bucket_count in output]
</pre><a href="#section-7.4.4-6" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="prio3multihotcountvec">
<section id="section-7.4.5">
          <h4 id="name-prio3multihotcountvec">
<a href="#section-7.4.5" class="section-number selfRef">7.4.5. </a><a href="#name-prio3multihotcountvec" class="section-name selfRef">Prio3MultihotCountVec</a>
          </h4>
<span id="name-parameters-for-prio3multiho"></span><table class="center" id="table-13">
            <caption>
<a href="#table-13" class="selfRef">Table 13</a>:
<a href="#name-parameters-for-prio3multiho" class="selfRef">Parameters for Prio3MultihotCountVec.</a>
            </caption>
<thead>
              <tr>
                <th class="text-left" rowspan="1" colspan="1">Parameter</th>
                <th class="text-left" rowspan="1" colspan="1">Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>field</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Field128</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>Valid</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>MultihotCountVec(field, length, max_weight, chunk_length)</code> (this section)</td>
              </tr>
              <tr>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>PROOFS</code>
</td>
                <td class="text-left" rowspan="1" colspan="1">
                  <code>1</code>
</td>
              </tr>
            </tbody>
          </table>
<p id="section-7.4.5-2">For this instance of Prio3, each measurement is a vector of Boolean
values, where the number of <code>True</code> values is bounded. This provides a
functionality similar to Prio3Histogram except that more than one entry (or none
at all) may be non-zero. This allows Prio3MultihotCountVec to be composed with a
randomized response mechanism, like <span>[<a href="#EPK14" class="cite xref">EPK14</a>]</span>, for providing differential
privacy. (For example, each Client would set each entry with some small
probability.)<a href="#section-7.4.5-2" class="pilcrow">¶</a></p>
<p id="section-7.4.5-3">The validity circuit is denoted <code>MultihotCountVec</code> and has three parameters:
<code>length</code>, the number of entries in the count vector; <code>max_weight</code>, the maximum
number of <code>True</code> entries (i.e., the weight must be at most <code>max_weight</code>); and
<code>chunk_length</code>, used the same way as in <a href="#prio3sumvec" class="auto internal xref">Section 7.4.3</a> and <a href="#prio3histogram" class="auto internal xref">Section 7.4.4</a>.<a href="#section-7.4.5-3" class="pilcrow">¶</a></p>
<p id="section-7.4.5-4">Validation works as follows. Let<a href="#section-7.4.5-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7.4.5-5.1">
              <p id="section-7.4.5-5.1.1"><code>bits_for_weight = max_weight.bit_length()</code><a href="#section-7.4.5-5.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7.4.5-5.2">
              <p id="section-7.4.5-5.2.1"><code>offset = 2^bits_for_weight - 1 - max_weight</code><a href="#section-7.4.5-5.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-7.4.5-6">The Client reports the weight of the count vector by adding <code>offset</code> to it and
bit-encoding the result. Observe that only a weight of at most <code>max_weight</code> can
be encoded with <code>bits_for_weight</code> bits.<a href="#section-7.4.5-6" class="pilcrow">¶</a></p>
<p id="section-7.4.5-7">The verifier checks that each entry of the encoded measurement is a bit (i.e.,
either one or zero). It then decodes the reported weight and subtracts it from
<code>offset + sum(count_vec)</code>, where <code>count_vec</code> is the count vector. The result is
zero if and only if the reported weight is equal to the true weight. The two
checks constitute the output of the circuit. The complete circuit is defined
below.<a href="#section-7.4.5-7" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-7.4.5-8">
<pre>
class MultihotCountVec(Valid[list[bool], list[int], F]):
    EVAL_OUTPUT_LEN = 2
    field: type[F]

    def __init__(self,
                 field: type[F],
                 length: int,
                 max_weight: int,
                 chunk_length: int):
        """
        Instantiate an instance of the this circuit with the given
        `length`, `max_weight`, and `chunk_length`.

        Pre-conditions:

            - `length &gt; 0`
            - `0 &lt; max_weight` and `max_weight &lt;= length`
            - `chunk_length &gt; 0`
        """
        self.field = field

        # Compute the number of bits to represent `max_weight`.
        self.bits_for_weight = max_weight.bit_length()
        self.offset = self.field(
            2**self.bits_for_weight - 1 - max_weight)

        # Make sure `offset + length` doesn't overflow the field
        # modulus. Otherwise we may not correctly compute the sum
        # measurement vector entries during circuit evaluation.
        if self.field.MODULUS - self.offset.int() &lt;= length:
            raise ValueError('length and max_weight are too large '
                             'for the current field size')

        self.length = length
        self.max_weight = max_weight
        self.chunk_length = chunk_length
        self.GADGETS: list[Gadget[F]] = [
            ParallelSum(Mul(), chunk_length),
        ]
        self.GADGET_CALLS = [
            (length + self.bits_for_weight + chunk_length - 1)
            // chunk_length
        ]
        self.MEAS_LEN = self.length + self.bits_for_weight
        self.OUTPUT_LEN = self.length
        self.JOINT_RAND_LEN = self.GADGET_CALLS[0]

    def encode(self, measurement: list[bool]) -&gt; list[F]:
        if len(measurement) != self.length:
            raise ValueError('invalid Client measurement length')

        # The first part is the vector of counters.
        count_vec = [self.field(int(x)) for x in measurement]

        # The second part is the reported weight.
        weight_reported = sum(count_vec, self.field(0))

        encoded = []
        encoded += count_vec
        encoded += self.field.encode_into_bit_vec(
            (self.offset + weight_reported).int(),
            self.bits_for_weight)
        return encoded

    def eval(
            self,
            meas: list[F],
            joint_rand: list[F],
            num_shares: int) -&gt; list[F]:
        # Check that each entry in the input vector is one or zero.
        range_check = self.field(0)
        shares_inv = self.field(num_shares).inv()
        for i in range(self.GADGET_CALLS[0]):
            r = joint_rand[i]
            r_power = r
            inputs: list[Optional[F]]
            inputs = [None] * (2 * self.chunk_length)
            for j in range(self.chunk_length):
                index = i * self.chunk_length + j
                if index &lt; len(meas):
                    meas_elem = meas[index]
                else:
                    meas_elem = self.field(0)

                inputs[j * 2] = r_power * meas_elem
                inputs[j * 2 + 1] = meas_elem - shares_inv

                r_power *= r

            range_check += self.GADGETS[0].eval(
                self.field,
                cast(list[F], inputs),
            )

        # Check that the weight `offset` plus the sum of the counters
        # is equal to the value claimed by the Client.
        count_vec = meas[:self.length]
        weight = sum(count_vec, self.field(0))
        weight_reported = \
            self.field.decode_from_bit_vec(meas[self.length:])
        weight_check = self.offset*shares_inv + weight - \
            weight_reported

        return [range_check, weight_check]

    def truncate(self, meas: list[F]) -&gt; list[F]:
        return meas[:self.length]

    def decode(
            self,
            output: list[F],
            _num_measurements: int) -&gt; list[int]:
        return [bucket_count.int() for
                bucket_count in output]
</pre><a href="#section-7.4.5-8" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="poplar1">
<section id="section-8">
      <h2 id="name-poplar1">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-poplar1" class="section-name selfRef">Poplar1</a>
      </h2>
<p id="section-8-1">This section specifies Poplar1, a VDAF for the following task. Each Client
holds a bit-string of length <code>BITS</code> and the Collector chooses a sequence of
<code>L</code>-bit strings, where <code>L &lt;= BITS</code>. We will refer to the latter as the
"candidate prefixes". The goal is to count how many of the Clients' inputs
begin with each candidate prefix.<a href="#section-8-1" class="pilcrow">¶</a></p>
<p id="section-8-2">This functionality is the core component of the heavy hitters protocol of
<span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>. The goal of this protocol is to compute the subset of inputs held
by at least <code>T</code> Clients for some threshold <code>T</code>. It invokes Poplar1 as follows:<a href="#section-8-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-8-3">
<li id="section-8-3.1">
          <p id="section-8-3.1.1">Each Client shards its string into secret shares and uploads one share to
each of the Aggregators.<a href="#section-8-3.1.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-8-3.2">
          <p id="section-8-3.2.1">The Collector picks an initial set of candidate prefixes, say <code>0</code> and <code>1</code>,
and sends them to the Aggregators.<a href="#section-8-3.2.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-8-3.3">
          <p id="section-8-3.3.1">The Aggregators run VDAF preparation and aggregation on each of the reports
and send their aggregate shares to the Collector.<a href="#section-8-3.3.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-8-3.4">
          <p id="section-8-3.4.1">The Collector unshards the aggregate result, which consists of the hit count
for each candidate prefix. For each prefix <code>p</code> with hit count at least <code>T</code>,
the Collector adds <code>p || 0</code> and <code>p || 1</code> to the next generation of
candidate prefixes and repeats Step 2.<a href="#section-8-3.4.1" class="pilcrow">¶</a></p>
</li>
      </ol>
<p id="section-8-4">Poplar1 is constructed from an "Incremental Distributed Point Function (IDPF)",
a primitive described by <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span> that generalizes the notion of a
Distributed Point Function (DPF) <span>[<a href="#GI14" class="cite xref">GI14</a>]</span>. Briefly, a DPF is used to distribute
the computation of a "point function", a function that evaluates to zero on
every input except at a programmable "point". The computation is distributed in
such a way that no one party knows either the point or what it evaluates to.<a href="#section-8-4" class="pilcrow">¶</a></p>
<p id="section-8-5">An IDPF generalizes this "point" to a path on a full binary tree from the root
to one of the leaves. It is evaluated on an "index" representing a unique node
of the tree. If the node is on the programmed path, then the function evaluates
to a non-zero value; otherwise it evaluates to zero. This structure allows an
IDPF to provide the functionality required for the above protocol: to compute
the hit count for an index, just evaluate each set of IDPF shares at that index
and add up the results.<a href="#section-8-5" class="pilcrow">¶</a></p>
<p id="section-8-6">Consider the sub-tree constructed from a set of input strings and a target
threshold <code>T</code> by including all indices with hit count at least <code>T</code>. We shall
refer to this structure as the "prefix tree" for the batch of measurements and
target threshold. To compute the <code>T</code>-heavy-hitters for the batch, the
Aggregators and Collector first compute the prefix tree, then extract the heavy
hitters from the leaves of this tree. Note that the prefix tree leaks more
information about the set than the heavy hitters themselves; see
<a href="#agg-param-security" class="auto internal xref">Section 9.4</a> for more discussion.<a href="#section-8-6" class="pilcrow">¶</a></p>
<p id="section-8-7">Poplar1 composes an IDPF with the arithmetic sketch of <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>, Section
4.2. (The paper calls this a "secure sketch", but the underlying technique was
later generalized in <span>[<a href="#BBCGGI23" class="cite xref">BBCGGI23</a>]</span>, where it is called "arithmetic sketching".)
The sketch ensures that evaluating a set of input shares on a set of unique
candidate prefixes results in shares of a zero vector or a "one-hot" vector,
i.e., a vector that is zero everywhere except for in at most one position.
Moreover, the value at that position should be one.<a href="#section-8-7" class="pilcrow">¶</a></p>
<p id="section-8-8">The remainder of this section is structured as follows. The syntax of IDPFs is
defined in <a href="#idpf" class="auto internal xref">Section 8.1</a>. The Poplar1 VDAF is defined in <a href="#poplar1-construction" class="auto internal xref">Section 8.2</a> in
terms of a generic IDPF. A specification of the IDPF of <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span> is given in
<a href="#idpf-bbcggi21" class="auto internal xref">Section 8.3</a>. Test vectors for Poplar1 can be found in <a href="#test-vectors" class="auto internal xref">Appendix C</a>.<a href="#section-8-8" class="pilcrow">¶</a></p>
<div id="idpf">
<section id="section-8.1">
        <h3 id="name-incremental-distributed-poi">
<a href="#section-8.1" class="section-number selfRef">8.1. </a><a href="#name-incremental-distributed-poi" class="section-name selfRef">Incremental Distributed Point Functions (IDPFs)</a>
        </h3>
<p id="section-8.1-1">An IDPF is defined over a domain of size <code>2^BITS</code>, where <code>BITS</code> is a constant.
Indices into the IDPF tree are bit strings. (In Poplar1, each Client's bit
string is an index; see <a href="#poplar1-idpf-index-encoding" class="auto internal xref">Section 8.1.1</a> for details.) The Client
specifies an index <code>alpha</code> and a vector of values <code>beta</code>, one for each "level"
<code>L</code> in the range <code>[0, BITS)</code>. The key generation algorithm generates one IDPF
"key" for each Aggregator. When evaluated at level <code>L</code> and index <code>prefix</code>, each
IDPF key returns an additive share of <code>beta[L]</code> if <code>prefix</code> is the <code>L</code>-bit
prefix of <code>alpha</code> and shares of zero otherwise.<a href="#section-8.1-1" class="pilcrow">¶</a></p>
<p id="section-8.1-2">Each of the programmed points <code>beta</code> is a vector of elements of some finite
field. We distinguish two types of fields: one for inner nodes (denoted
<code>FieldInner</code>), and one for leaf nodes (<code>FieldLeaf</code>). (Our instantiation of
Poplar1 (<a href="#poplar1-construction" class="auto internal xref">Section 8.2</a>) will use a much larger field for leaf nodes
than for inner nodes. This is to ensure the IDPF is "extractable" as defined in
<span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>, Definition 1. See <a href="#idpf-extract" class="auto internal xref">Section 9.5</a> for details.)<a href="#section-8.1-2" class="pilcrow">¶</a></p>
<p id="section-8.1-3">A concrete IDPF defines the types and parameters enumerated in <a href="#idpf-param" class="auto internal xref">Table 14</a>.
In the remainder we write <code>Output</code> as shorthand for the type
<code>list[list[FieldInner]] | list[list[FieldLeaf]]</code>. (This type denotes either a
vector of inner node field elements or leaf node field elements.) The scheme is
comprised of the following algorithms:<a href="#section-8.1-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-8.1-4.1">
            <p id="section-8.1-4.1.1"><code>idpf.gen(alpha: tuple[bool, ...], beta_inner: list[list[FieldInner]], beta_leaf:
list[FieldLeaf], ctx: bytes, nonce: bytes, rand: bytes) -&gt; tuple[PublicShare,
list[bytes]]</code> is the IDPF-key generation algorithm. Its inputs are the index
<code>alpha</code>, the values <code>beta</code>, the application context, and the report nonce.<a href="#section-8.1-4.1.1" class="pilcrow">¶</a></p>
<p id="section-8.1-4.1.2">
The output is a public part (of type <code>PublicShare</code>) that is sent to each
Aggregator and a vector of private IDPF keys, one for each Aggregator. The
nonce and application context are used to derive the fixed AES key for
XofFixedKeyAes128 (<a href="#xof-fixed-key-aes128" class="auto internal xref">Section 6.2.2</a>). Looking ahead, this key is used
for extending a node's seed into the seeds for the child nodes at each level
of the tree; see <a href="#idpf-bbcggi21" class="auto internal xref">Section 8.3</a>.<a href="#section-8.1-4.1.2" class="pilcrow">¶</a></p>
<p id="section-8.1-4.1.3">
Pre-conditions:<a href="#section-8.1-4.1.3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-8.1-4.1.4.1">
                <p id="section-8.1-4.1.4.1.1"><code>alpha</code> <span class="bcp14">MUST</span> have length <code>BITS</code>.<a href="#section-8.1-4.1.4.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-8.1-4.1.4.2">
                <p id="section-8.1-4.1.4.2.1"><code>beta_inner</code> <span class="bcp14">MUST</span> have length <code>BITS - 1</code>.<a href="#section-8.1-4.1.4.2.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-8.1-4.1.4.3">
                <p id="section-8.1-4.1.4.3.1"><code>beta_inner[level]</code> <span class="bcp14">MUST</span> have length <code>VALUE_LEN</code> for each <code>level</code> in
 the range <code>[0, BITS - 1)</code>.<a href="#section-8.1-4.1.4.3.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-8.1-4.1.4.4">
                <p id="section-8.1-4.1.4.4.1"><code>beta_leaf</code> <span class="bcp14">MUST</span> have length <code>VALUE_LEN</code>.<a href="#section-8.1-4.1.4.4.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-8.1-4.1.4.5">
                <p id="section-8.1-4.1.4.5.1"><code>rand</code> <span class="bcp14">MUST</span> be generated by a CSPRNG and have length <code>RAND_SIZE</code>.<a href="#section-8.1-4.1.4.5.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-8.1-4.1.4.6">
                <p id="section-8.1-4.1.4.6.1"><code>nonce</code> <span class="bcp14">MUST</span> be generated by a CSPRNG (see <a href="#nonce-requirements" class="auto internal xref">Section 9.2</a> for
details) and have length <code>idpf.NONCE_SIZE</code>.<a href="#section-8.1-4.1.4.6.1" class="pilcrow">¶</a></p>
</li>
            </ul>
<p id="section-8.1-4.1.5">
Post-conditions:<a href="#section-8.1-4.1.5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-8.1-4.1.6.1">
                <p id="section-8.1-4.1.6.1.1">The number of IDPF keys <span class="bcp14">MUST</span> be <code>idpf.SHARES</code>.<a href="#section-8.1-4.1.6.1.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
          <li class="normal" id="section-8.1-4.2">
            <p id="section-8.1-4.2.1"><code>idpf.eval(agg_id: int, public_share: PublicShare, key: bytes, level: int,
prefixes: Sequence[tuple[bool, ...]], ctx: bytes, nonce: bytes) -&gt; Output</code> is
the IDPF-key evaluation algorithm run by each Aggregator. Its inputs are the
Aggregator's unique identifier, the public share distributed to all of the
Aggregators, the Aggregator's IDPF key, the "level" at which to evaluate the
IDPF, the sequence of candidate prefixes, the application context, and the
report nonce. It returns the share of the value corresponding to each
candidate prefix.<a href="#section-8.1-4.2.1" class="pilcrow">¶</a></p>
<p id="section-8.1-4.2.2">
Pre-conditions:<a href="#section-8.1-4.2.2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-8.1-4.2.3.1">
                <p id="section-8.1-4.2.3.1.1"><code>agg_id</code> <span class="bcp14">MUST</span> be in the range <code>[0, idpf.SHARES)</code> and match the index of
<code>key</code> in the sequence of IDPF keys output by the Client.<a href="#section-8.1-4.2.3.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-8.1-4.2.3.2">
                <p id="section-8.1-4.2.3.2.1"><code>level</code> <span class="bcp14">MUST</span> be in the range <code>[0, BITS)</code>.<a href="#section-8.1-4.2.3.2.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-8.1-4.2.3.3">
                <p id="section-8.1-4.2.3.3.1">Each prefix <span class="bcp14">MUST</span> be distinct and have length <code>level + 1</code>.<a href="#section-8.1-4.2.3.3.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-8.1-4.2.3.4">
                <p id="section-8.1-4.2.3.4.1">The length of the nonce <span class="bcp14">MUST</span> be <code>idpf.NONCE_SIZE</code>.<a href="#section-8.1-4.2.3.4.1" class="pilcrow">¶</a></p>
</li>
            </ul>
<p id="section-8.1-4.2.4">
Post-conditions:<a href="#section-8.1-4.2.4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-8.1-4.2.5.1">
                <p id="section-8.1-4.2.5.1.1">The length of the output <span class="bcp14">MUST</span> be <code>len(prefixes)</code><a href="#section-8.1-4.2.5.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-8.1-4.2.5.2">
                <p id="section-8.1-4.2.5.2.1">The length of each element of the output <span class="bcp14">MUST</span> be <code>idpf.VALUE_LEN</code><a href="#section-8.1-4.2.5.2.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-8.1-4.2.5.3">
                <p id="section-8.1-4.2.5.3.1">If <code>level == idpf.BITS - 1</code>, then the output field <span class="bcp14">MUST</span> be <code>FieldLeaf</code> and
 <code>FieldInner</code> otherwise<a href="#section-8.1-4.2.5.3.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
        </ul>
<p id="section-8.1-5">In addition, the IDPF provides the following method:<a href="#section-8.1-5" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-8.1-6">
<pre>
def current_field(
        self,
        level: int) -&gt; type[FieldInner] | type[FieldLeaf]:
    if level &lt; self.BITS - 1:
        return self.field_inner
    return self.field_leaf
</pre><a href="#section-8.1-6" class="pilcrow">¶</a>
</div>
<p id="section-8.1-7">Finally, an implementation note. The interface for IDPFs specified here is
stateless, in the sense that there is no state carried between IDPF evaluations.
This is to align the IDPF syntax with the VDAF abstraction boundary, which does
not include shared state across VDAF evaluations. In practice, of course, it
will often be beneficial to expose a stateful API for IDPFs and carry the state
across evaluations. See <a href="#idpf-bbcggi21" class="auto internal xref">Section 8.3</a> for details.<a href="#section-8.1-7" class="pilcrow">¶</a></p>
<span id="name-constants-and-types-defined-b"></span><div id="idpf-param">
<table class="center" id="table-14">
          <caption>
<a href="#table-14" class="selfRef">Table 14</a>:
<a href="#name-constants-and-types-defined-b" class="selfRef">Constants and types defined by a concrete IDPF.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Parameter</th>
              <th class="text-left" rowspan="1" colspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>SHARES: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Number of IDPF keys output by IDPF-key generator.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>BITS: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Length in bits of each input string.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>VALUE_LEN: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Number of field elements of each output value.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>RAND_SIZE: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Size of the random string consumed by the IDPF-key generator.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>NONCE_SIZE: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Size of the random nonce generated by the Client.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>KEY_SIZE: int</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Size in bytes of each IDPF key.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>FieldInner</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Implementation of <code>Field</code> (<a href="#field" class="auto internal xref">Section 6.1</a>) used for values of inner nodes.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>FieldLeaf</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Implementation of <code>Field</code> used for values of leaf nodes.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PublicShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Type of public share for this IDPF.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Output</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Alias of <code>list[list[FieldInner]] | list[list[FieldLeaf]]</code>.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>FieldVec</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Alias of <code>list[FieldInner] | list[FieldLeaf].</code>
</td>
            </tr>
          </tbody>
        </table>
</div>
<div id="poplar1-idpf-index-encoding">
<section id="section-8.1.1">
          <h4 id="name-encoding-inputs-as-indices">
<a href="#section-8.1.1" class="section-number selfRef">8.1.1. </a><a href="#name-encoding-inputs-as-indices" class="section-name selfRef">Encoding Inputs as Indices</a>
          </h4>
<p id="section-8.1.1-1">How data are represented as IDPF indices is up to the application. When the
inputs are fixed-length byte strings, the most natural choice of representation
is as a bit string formed from all the bits of the byte string, first ordered by
byte position, then ordered from most significant bit to least significant bit
within each byte. This ensures that, when a byte string is a prefix of another,
so too is its corresponding index. (Index prefixes are defined in <a href="#idpf" class="auto internal xref">Section 8.1</a>.) For
example,<a href="#section-8.1.1-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-8.1.1-2">
<pre>
Byte string: 01 02
Bit string: 00000001 00000010
</pre><a href="#section-8.1.1-2" class="pilcrow">¶</a>
</div>
<p id="section-8.1.1-3">is a prefix of<a href="#section-8.1.1-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-8.1.1-4">
<pre>
Byte string: 01 02 03
Bit string: 00000001 00000010 00000011
</pre><a href="#section-8.1.1-4" class="pilcrow">¶</a>
</div>
<p id="section-8.1.1-5">Additionally, lexicographic ordering is preserved by this mapping from a byte
string to a bit string.<a href="#section-8.1.1-5" class="pilcrow">¶</a></p>
<p id="section-8.1.1-6">When the inputs are variable length, it is necessary to pad each input to some
fixed length. Further, the padding scheme must be non-ambiguous. For example,
each input could be padded with <code>b"\x01"</code> followed by as many <code>b"\x00"</code> bytes
as needed.<a href="#section-8.1.1-6" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="poplar1-construction">
<section id="section-8.2">
        <h3 id="name-specification-2">
<a href="#section-8.2" class="section-number selfRef">8.2. </a><a href="#name-specification-2" class="section-name selfRef">Specification</a>
        </h3>
<p id="section-8.2-1">This section specifies <code>Poplar1</code>, an implementation of the <code>Vdaf</code> interface
(<a href="#vdaf" class="auto internal xref">Section 5</a>). It is defined in terms of the <code>Idpf</code> implementation of
<a href="#idpf-bbcggi21" class="auto internal xref">Section 8.3</a> with <code>SHARES == 2</code> and <code>VALUE_LEN == 2</code> and
<code>XofTurboShake128</code> as specified in <a href="#xof-turboshake128" class="auto internal xref">Section 6.2.1</a>. The associated
constants and types required by the <code>Vdaf</code> interface are defined in
<a href="#poplar1-param" class="auto internal xref">Table 15</a>. The methods required for sharding, preparation, aggregation,
and unsharding are described in the remaining subsections. These methods make
use of constants defined in <a href="#poplar1-const" class="auto internal xref">Table 16</a>.<a href="#section-8.2-1" class="pilcrow">¶</a></p>
<span id="name-vdaf-parameters-for-poplar1"></span><div id="poplar1-param">
<table class="center" id="table-15">
          <caption>
<a href="#table-15" class="selfRef">Table 15</a>:
<a href="#name-vdaf-parameters-for-poplar1" class="selfRef">VDAF parameters for Poplar1.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Parameter</th>
              <th class="text-left" rowspan="1" colspan="1">Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>idpf</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">As specified in <a href="#idpf-bbcggi21" class="auto internal xref">Section 8.3</a>.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>xof</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>XofTurboShake128</code> (<a href="#xof-turboshake128" class="auto internal xref">Section 6.2.1</a>)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>VERIFY_KEY_SIZE</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>xof.SEED_SIZE</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>RAND_SIZE</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>xof.SEED_SIZE * 3 + idpf.RAND_SIZE</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>NONCE_SIZE</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>16</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>ROUNDS</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>2</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>SHARES</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>2</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Measurement</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>tuple[bool, ...]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggParam</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>tuple[int, Sequence[tuple[bool, ...]]]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PublicShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">As defined by <code>idpf</code>.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>InputShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>tuple[bytes, bytes, list[FieldInner], list[FieldLeaf]]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>OutShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>FieldVec</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>FieldVec</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>AggResult</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>list[int]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PrepState</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>tuple[bytes, int, FieldVec]</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PrepShare</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>FieldVec</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>PrepMessage</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Optional[FieldVec]</code>
</td>
            </tr>
          </tbody>
        </table>
</div>
<span id="name-constants-used-by-poplar1"></span><div id="poplar1-const">
<table class="center" id="table-16">
          <caption>
<a href="#table-16" class="selfRef">Table 16</a>:
<a href="#name-constants-used-by-poplar1" class="selfRef">Constants used by Poplar1.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Variable</th>
              <th class="text-left" rowspan="1" colspan="1">Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">USAGE_SHARD_RAND: int</td>
              <td class="text-left" rowspan="1" colspan="1">1</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">USAGE_CORR_INNER: int</td>
              <td class="text-left" rowspan="1" colspan="1">2</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">USAGE_CORR_LEAF: int</td>
              <td class="text-left" rowspan="1" colspan="1">3</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">USAGE_VERIFY_RAND: int</td>
              <td class="text-left" rowspan="1" colspan="1">4</td>
            </tr>
          </tbody>
        </table>
</div>
<div id="sharding-1">
<section id="section-8.2.1">
          <h4 id="name-sharding-4">
<a href="#section-8.2.1" class="section-number selfRef">8.2.1. </a><a href="#name-sharding-4" class="section-name selfRef">Sharding</a>
          </h4>
<p id="section-8.2.1-1">The Client's measurement is an IDPF index, denoted <code>alpha</code>, whose type is a
sequence of bits <code>tuple[bool, ...]</code> (See <a href="#poplar1-idpf-index-encoding" class="auto internal xref">Section 8.1.1</a> for
guidelines on index encoding.)<a href="#section-8.2.1-1" class="pilcrow">¶</a></p>
<p id="section-8.2.1-2">The programmed IDPF values are pairs of field elements <code>(1, k)</code> where each <code>k</code> is
chosen at random. This random value is used as part of the arithmetic sketching
protocol of <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>, Appendix C.4. After evaluating their IDPF key shares
on a given sequence of candidate prefixes, the Aggregators use the sketching
protocol to verify that they hold shares of a zero vector or a one-hot vector at
a given level of the IDPF tree.<a href="#section-8.2.1-2" class="pilcrow">¶</a></p>
<p id="section-8.2.1-3">In addition to programming <code>k</code> into the IDPF output, for each level of the
tree, the Client generates random elements <code>a</code>, <code>b</code>, and <code>c</code> and computes<a href="#section-8.2.1-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-8.2.1-4">
<pre>
    A = -2*a + k
    B = a^2 + b - k*a + c
</pre><a href="#section-8.2.1-4" class="pilcrow">¶</a>
</div>
<p id="section-8.2.1-5">and sends additive shares of <code>a</code>, <code>b</code>, <code>c</code>, <code>A</code> and <code>B</code> to each of the
Aggregators. These help the Aggregators evaluate the sketch during preparation.<a href="#section-8.2.1-5" class="pilcrow">¶</a></p>
<p id="section-8.2.1-6">Putting everything together, the sharding algorithm is defined as
follows.<a href="#section-8.2.1-6" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-8.2.1-7">
<pre>
def shard(
    self,
    ctx: bytes,
    measurement: tuple[bool, ...],
    nonce: bytes,
    rand: bytes,
) -&gt; tuple[Poplar1PublicShare, list[Poplar1InputShare]]:
    if len(nonce) != self.NONCE_SIZE:
        raise ValueError("incorrect nonce size")
    if len(rand) != self.RAND_SIZE:
        raise ValueError("incorrect size of random bytes argument")

    l = self.xof.SEED_SIZE

    # Split the random input into the random input for IDPF key
    # generation, correlated randomness, and sharding.
    if len(rand) != self.RAND_SIZE:
        raise ValueError('incorrect rand size')
    idpf_rand, rand = front(self.idpf.RAND_SIZE, rand)
    seeds = [rand[i:i + l] for i in range(0, 3 * l, l)]
    corr_seed, seeds = front(2, seeds)
    (shard_seed,), seeds = front(1, seeds)

    xof = self.xof(
        shard_seed,
        self.domain_separation_tag(USAGE_SHARD_RAND, ctx),
        nonce,
    )

    # Construct the IDPF values for each level of the IDPF tree.
    # Each "data" value is 1; in addition, the Client generates
    # a random "authenticator" value used by the Aggregators to
    # evaluate the sketch during preparation. This sketch is used
    # to verify the one-hotness of their output shares.
    beta_inner = [
        [self.idpf.field_inner(1), k]
        for k in xof.next_vec(self.idpf.field_inner,
                              self.idpf.BITS - 1)
    ]
    beta_leaf = [self.idpf.field_leaf(1)] + \
        xof.next_vec(self.idpf.field_leaf, 1)

    # Generate the IDPF keys.
    (public_share, keys) = self.idpf.gen(
        measurement,
        beta_inner,
        beta_leaf,
        ctx,
        nonce,
        idpf_rand,
    )

    # Generate correlated randomness used by the Aggregators to
    # evaluate the sketch over their output shares. Seeds are used
    # to encode shares of the `(a, b, c)` triples. (See [BBCGGI21,
    # Appendix C.4].)
    corr_offsets: list[Field] = vec_add(
        self.xof.expand_into_vec(
            self.idpf.field_inner,
            corr_seed[0],
            self.domain_separation_tag(USAGE_CORR_INNER, ctx),
            byte(0) + nonce,
            3 * (self.idpf.BITS - 1),
        ),
        self.xof.expand_into_vec(
            self.idpf.field_inner,
            corr_seed[1],
            self.domain_separation_tag(USAGE_CORR_INNER, ctx),
            byte(1) + nonce,
            3 * (self.idpf.BITS - 1),
        ),
    )
    corr_offsets += vec_add(
        self.xof.expand_into_vec(
            self.idpf.field_leaf,
            corr_seed[0],
            self.domain_separation_tag(USAGE_CORR_LEAF, ctx),
            byte(0) + nonce,
            3,
        ),
        self.xof.expand_into_vec(
            self.idpf.field_leaf,
            corr_seed[1],
            self.domain_separation_tag(USAGE_CORR_LEAF, ctx),
            byte(1) + nonce,
            3,
        ),
    )

    # For each level of the IDPF tree, shares of the `(A, B)`
    # pairs are computed from the corresponding `(a, b, c)`
    # triple and authenticator value `k`.
    corr_inner: list[list[Field64]] = [[], []]
    for level in range(self.idpf.BITS):
        field = cast(type[Field], self.idpf.current_field(level))
        k = beta_inner[level][1] if level &lt; self.idpf.BITS - 1 \
            else beta_leaf[1]
        (a, b, c), corr_offsets = corr_offsets[:3], corr_offsets[3:]
        A = -field(2) * a + k
        B = a ** 2 + b - a * k + c
        corr1 = xof.next_vec(field, 2)
        corr0 = vec_sub([A, B], corr1)
        if level &lt; self.idpf.BITS - 1:
            corr_inner[0] += cast(list[Field64], corr0)
            corr_inner[1] += cast(list[Field64], corr1)
        else:
            corr_leaf = [
                cast(list[Field255], corr0),
                cast(list[Field255], corr1),
            ]

    # Each input share consists of the Aggregator's IDPF key
    # and a share of the correlated randomness.
    input_shares = list(zip(keys, corr_seed, corr_inner, corr_leaf))
    return (public_share, input_shares)
</pre><a href="#section-8.2.1-7" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="poplar1-prep">
<section id="section-8.2.2">
          <h4 id="name-preparation-4">
<a href="#section-8.2.2" class="section-number selfRef">8.2.2. </a><a href="#name-preparation-4" class="section-name selfRef">Preparation</a>
          </h4>
<p id="section-8.2.2-1">The aggregation parameter encodes a sequence of candidate prefixes. When an
Aggregator receives an input share from the Client, it begins by evaluating its
IDPF share on each candidate prefix, recovering a <code>data_share</code> and <code>auth_share</code>
for each. The Aggregators use these and the correlation shares provided by the
Client to verify that the sequence of <code>data_share</code> values are additive shares of
a zero vector or a one-hot vector.<a href="#section-8.2.2-1" class="pilcrow">¶</a></p>
<p id="section-8.2.2-2">Aggregators <span class="bcp14">MUST</span> ensure the candidate prefixes are all unique and appear in
lexicographic order. (This is enforced in the definition of <code>is_valid()</code>
below.) Uniqueness is necessary to ensure the refined measurement (i.e., the sum
of the output shares) is in fact a one-hot vector. Otherwise, sketch
verification might fail, causing the Aggregators to erroneously reject a report
that is actually valid. Note that enforcing the order is not strictly necessary,
but this does allow uniqueness to be determined more efficiently.<a href="#section-8.2.2-2" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-8.2.2-3">
<pre>
def prep_init(
        self,
        verify_key: bytes,
        ctx: bytes,
        agg_id: int,
        agg_param: Poplar1AggParam,
        nonce: bytes,
        public_share: Poplar1PublicShare,
        input_share: Poplar1InputShare) -&gt; tuple[
            Poplar1PrepState,
            FieldVec]:
    (level, prefixes) = agg_param
    (key, corr_seed, corr_inner, corr_leaf) = input_share
    field = self.idpf.current_field(level)

    # Evaluate the IDPF key at the given set of prefixes.
    value = self.idpf.eval(
        agg_id, public_share, key, level, prefixes, ctx, nonce)

    # Get shares of the correlated randomness for evaluating the
    # Aggregator's share of the sketch.
    if level &lt; self.idpf.BITS - 1:
        corr_xof = self.xof(
            corr_seed,
            self.domain_separation_tag(USAGE_CORR_INNER, ctx),
            byte(agg_id) + nonce,
        )
        # Fast-forward the XOF state to the current level.
        corr_xof.next_vec(field, 3 * level)
    else:
        corr_xof = self.xof(
            corr_seed,
            self.domain_separation_tag(USAGE_CORR_LEAF, ctx),
            byte(agg_id) + nonce,
        )
    (a_share, b_share, c_share) = corr_xof.next_vec(field, 3)
    if level &lt; self.idpf.BITS - 1:
        (A_share, B_share) = cast(
            list[Field],
            corr_inner[2 * level:2 * (level + 1)],
        )
    else:
        (A_share, B_share) = cast(list[Field], corr_leaf)

    # Evaluate the Aggregator's share of the sketch. These are
    # called the "masked input values" [BBCGGI21, Appendix C.4].
    verify_rand_xof = self.xof(
        verify_key,
        self.domain_separation_tag(USAGE_VERIFY_RAND, ctx),
        nonce + to_be_bytes(level, 2),
    )
    verify_rand = cast(
        list[Field],
        verify_rand_xof.next_vec(field, len(prefixes)),
    )
    sketch_share = cast(
        list[Field],
        [a_share, b_share, c_share],
    )
    out_share = []
    for (i, r) in enumerate(verify_rand):
        data_share = cast(Field, value[i][0])
        auth_share = cast(Field, value[i][1])
        sketch_share[0] += data_share * r
        sketch_share[1] += data_share * r ** 2
        sketch_share[2] += auth_share * r
        out_share.append(data_share)

    prep_mem = [A_share, B_share, field(agg_id)] + out_share
    return (
        (
            b'evaluate sketch',
            level,
            cast(FieldVec, prep_mem),
        ),
        cast(FieldVec, sketch_share),
    )

def prep_next(
    self,
    _ctx: bytes,
    prep_state: Poplar1PrepState,
    prep_msg: Optional[FieldVec]
) -&gt; tuple[Poplar1PrepState, FieldVec] | FieldVec:
    prev_sketch = cast(list[Field], prep_msg)
    (step, level, prep_mem) = prep_state

    if step == b'evaluate sketch':
        if prev_sketch is None:
            raise ValueError('expected value, got none')
        elif len(prev_sketch) != 3:
            raise ValueError('incorrect sketch length')
        A_share = cast(Field, prep_mem[0])
        B_share = cast(Field, prep_mem[1])
        agg_id = cast(Field, prep_mem[2])
        prep_mem = prep_mem[3:]
        sketch_share = [
            agg_id * (prev_sketch[0] ** 2
                      - prev_sketch[1]
                      - prev_sketch[2])
            + A_share * prev_sketch[0]
            + B_share
        ]
        return cast(
            tuple[Poplar1PrepState, FieldVec],
            (
                (
                    b'reveal sketch',
                    level,
                    prep_mem,
                ),
                sketch_share,
            )
        )

    elif step == b'reveal sketch':
        if prev_sketch is None:
            return prep_mem  # Output shares
        else:
            raise ValueError('invalid prep message')

    raise ValueError('invalid prep state')

def prep_shares_to_prep(
        self,
        _ctx: bytes,
        agg_param: Poplar1AggParam,
        prep_shares: list[FieldVec]) -&gt; Optional[FieldVec]:
    if len(prep_shares) != 2:
        raise ValueError('incorrect number of prep shares')
    (level, _) = agg_param
    field = self.idpf.current_field(level)
    sketch = vec_add(
        cast(list[Field], prep_shares[0]),
        cast(list[Field], prep_shares[1]),
    )
    if len(sketch) == 3:
        return cast(FieldVec, sketch)
    elif len(sketch) == 1:
        if sketch == field.zeros(1):
            # In order to reduce communication overhead, let `None`
            # denote a successful sketch verification.
            return None
        else:
            raise ValueError('sketch verification failed')
    else:
        raise ValueError('incorrect sketch length')
</pre><a href="#section-8.2.2-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="validity-of-aggregation-parameters-1">
<section id="section-8.2.3">
          <h4 id="name-validity-of-aggregation-parame">
<a href="#section-8.2.3" class="section-number selfRef">8.2.3. </a><a href="#name-validity-of-aggregation-parame" class="section-name selfRef">Validity of Aggregation Parameters</a>
          </h4>
<p id="section-8.2.3-1">Aggregation parameters are valid for a given input share if no aggregation
parameter with the same level has been used with the same input share before.
The whole preparation phase <span class="bcp14">MUST NOT</span> be run more than once for a given
combination of input share and level. This function checks that candidate
prefixes are unique and lexicographically sorted, checks that levels are
increasing between calls, and also enforces that the prefixes at each level are
suffixes of the previous level's prefixes.<a href="#section-8.2.3-1" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-8.2.3-2">
<pre>
def is_valid(
        self,
        agg_param: Poplar1AggParam,
        previous_agg_params: list[Poplar1AggParam]) -&gt; bool:
    """
    Checks that candidate prefixes are unique and lexicographically
    sorted, checks that levels are increasing between calls, and also
    enforces that the prefixes at each level are suffixes of the
    previous level's prefixes.
    """
    (level, prefixes) = agg_param

    # Ensure that candidate prefixes are all unique and appear in
    # lexicographic order.
    for i in range(1, len(prefixes)):
        if prefixes[i - 1] &gt;= prefixes[i]:
            return False

    if len(previous_agg_params) &lt; 1:
        return True

    (last_level, last_prefixes) = previous_agg_params[-1]
    last_prefixes_set = set(last_prefixes)

    # Check that level increased.
    if level &lt;= last_level:
        return False

    # Check that prefixes are suffixes of the last level's prefixes.
    for prefix in prefixes:
        last_prefix = get_ancestor(prefix, last_level)
        if last_prefix not in last_prefixes_set:
            # Current prefix not a suffix of last level's prefixes.
            return False
    return True

def get_ancestor(
        index: tuple[bool, ...],
        level: int) -&gt; tuple[bool, ...]:
    """
    Helper function to determine the prefix of `index` at
    `level`.
    """
    return index[:level + 1]
</pre><a href="#section-8.2.3-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="aggregation-2">
<section id="section-8.2.4">
          <h4 id="name-aggregation-5">
<a href="#section-8.2.4" class="section-number selfRef">8.2.4. </a><a href="#name-aggregation-5" class="section-name selfRef">Aggregation</a>
          </h4>
<p id="section-8.2.4-1">Aggregation involves simply adding up the output shares.<a href="#section-8.2.4-1" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-8.2.4-2">
<pre>
def agg_init(self, agg_param: Poplar1AggParam) -&gt; FieldVec:
    (level, prefixes) = agg_param
    field = self.idpf.current_field(level)
    return field.zeros(len(prefixes))

def agg_update(self,
               agg_param: Poplar1AggParam,
               agg_share: FieldVec,
               out_share: FieldVec) -&gt; FieldVec:
    a = cast(list[Field], agg_share)
    o = cast(list[Field], out_share)
    return cast(FieldVec, vec_add(a, o))

def merge(self,
          agg_param: Poplar1AggParam,
          agg_shares: list[FieldVec]) -&gt; FieldVec:
    (level, prefixes) = agg_param
    field = self.idpf.current_field(level)
    agg = cast(list[Field], field.zeros(len(prefixes)))
    for agg_share in agg_shares:
        agg = vec_add(agg, cast(list[Field], agg_share))
    return cast(FieldVec, agg)
</pre><a href="#section-8.2.4-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="unsharding-1">
<section id="section-8.2.5">
          <h4 id="name-unsharding-4">
<a href="#section-8.2.5" class="section-number selfRef">8.2.5. </a><a href="#name-unsharding-4" class="section-name selfRef">Unsharding</a>
          </h4>
<p id="section-8.2.5-1">Finally, the Collector unshards the aggregate result by adding up the aggregate
shares.<a href="#section-8.2.5-1" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-8.2.5-2">
<pre>
def unshard(
        self,
        agg_param: Poplar1AggParam,
        agg_shares: list[FieldVec],
        _num_measurements: int) -&gt; list[int]:
    agg = self.merge(agg_param, agg_shares)
    return [x.int() for x in agg]
</pre><a href="#section-8.2.5-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="poplar1-encode">
<section id="section-8.2.6">
          <h4 id="name-message-serialization-2">
<a href="#section-8.2.6" class="section-number selfRef">8.2.6. </a><a href="#name-message-serialization-2" class="section-name selfRef">Message Serialization</a>
          </h4>
<p id="section-8.2.6-1">This section defines serialization formats for messages exchanged over the
network while executing <code>Poplar1</code>. Messages are defined in the presentation
language of TLS as defined in <span><a href="https://rfc-editor.org/rfc/rfc8446#section-3" class="relref">Section 3</a> of [<a href="#RFC8446" class="cite xref">RFC8446</a>]</span>.<a href="#section-8.2.6-1" class="pilcrow">¶</a></p>
<p id="section-8.2.6-2">Let <code>poplar1</code> be an instance of <code>Poplar1</code>. In the remainder we use <code>Fi</code> as an
alias for <code>poplar1.idpf.field_inner.ENCODED_SIZE</code>, <code>Fl</code> as an alias for
<code>poplar1.idpf.field_leaf.ENCODED_SIZE</code>, and <code>B</code> as an alias for
<code>poplar1.idpf.BITS</code>.<a href="#section-8.2.6-2" class="pilcrow">¶</a></p>
<p id="section-8.2.6-3">Elements of the inner field are encoded in little-endian byte order (as defined
in <a href="#field" class="auto internal xref">Section 6.1</a>) and are represented as follows:<a href="#section-8.2.6-3" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6-4">
<pre>
opaque Poplar1FieldInner[Fi];
</pre><a href="#section-8.2.6-4" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6-5">Likewise, elements of the leaf field are encoded in little-endian byte order
(as defined in <a href="#field" class="auto internal xref">Section 6.1</a>) and are represented as follows:<a href="#section-8.2.6-5" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6-6">
<pre>
opaque Poplar1FieldLeaf[Fl];
</pre><a href="#section-8.2.6-6" class="pilcrow">¶</a>
</div>
<div id="public-share-1">
<section id="section-8.2.6.1">
            <h5 id="name-public-share-2">
<a href="#section-8.2.6.1" class="section-number selfRef">8.2.6.1. </a><a href="#name-public-share-2" class="section-name selfRef">Public Share</a>
            </h5>
<p id="section-8.2.6.1-1">The public share of the IDPF scheme in <a href="#idpf-bbcggi21" class="auto internal xref">Section 8.3</a> consists of a sequence
of "correction words". A correction word has three components:<a href="#section-8.2.6.1-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-8.2.6.1-2">
<li id="section-8.2.6.1-2.1">
                <p id="section-8.2.6.1-2.1.1">the XOF seed of type <code>bytes</code>;<a href="#section-8.2.6.1-2.1.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-8.2.6.1-2.2">
                <p id="section-8.2.6.1-2.2.1">the control bits of type <code>tuple[bool, bool]</code>; and<a href="#section-8.2.6.1-2.2.1" class="pilcrow">¶</a></p>
</li>
              <li id="section-8.2.6.1-2.3">
                <p id="section-8.2.6.1-2.3.1">the payload of type <code>list[Field64]</code> for the first <code>BITS-1</code> words and
<code>list[Field255]</code> for the last word.<a href="#section-8.2.6.1-2.3.1" class="pilcrow">¶</a></p>
</li>
            </ol>
<p id="section-8.2.6.1-3">The encoding is a straightforward structure of arrays, except that the control
bits are packed as tightly as possible. The encoded public share is structured
as follows:<a href="#section-8.2.6.1-3" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.1-4">
<pre>
struct {
    opaque packed_control_bits[packed_len];
    opaque seed[poplar1.idpf.KEY_SIZE*B];
    Poplar1FieldInner payload_inner[Fi*poplar1.idpf.VALUE_LEN*(B-1)];
    Poplar1FieldLeaf payload_leaf[Fl*poplar1.idpf.VALUE_LEN];
} Poplar1PublicShare;
</pre><a href="#section-8.2.6.1-4" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.1-5">Here <code>packed_len = (2*B + 7) // 8</code> is the length of the packed control bits.
Field <code>packed_control_bits</code> is encoded with the following function:<a href="#section-8.2.6.1-5" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-8.2.6.1-6">
<pre>
packed_control_buf = [int(0)] * packed_len
for i, bit in enumerate(control_bits):
    packed_control_buf[i // 8] |= bit &lt;&lt; (i % 8)
packed_control_bits = bytes(packed_control_buf)
</pre><a href="#section-8.2.6.1-6" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.1-7">It encodes each group of eight bits into a byte, in LSB to MSB order, padding the most
significant bits of the last byte with zeros as necessary, and returns the byte
array. Decoding performs the reverse operation: it takes in a byte array
and a number of bits, and returns a list of bits, extracting eight bits from
each byte in turn, in LSB to MSB order, and stopping after the requested number
of bits. If the byte array has an incorrect length, or if unused bits in the
last bytes are not zero, it throws an error:<a href="#section-8.2.6.1-7" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-8.2.6.1-8">
<pre>
control_bits = []
for i in range(length):
    control_bits.append(bool(
        (packed_control_bits[i // 8] &gt;&gt; (i % 8)) &amp; 1
    ))
leftover_bits = packed_control_bits[-1] &gt;&gt; (
    (length + 7) % 8 + 1
)
if (length + 7) // 8 != len(packed_control_bits) or \
        leftover_bits != 0:
    raise ValueError('trailing bits')
</pre><a href="#section-8.2.6.1-8" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="input-share-1">
<section id="section-8.2.6.2">
            <h5 id="name-input-share-2">
<a href="#section-8.2.6.2" class="section-number selfRef">8.2.6.2. </a><a href="#name-input-share-2" class="section-name selfRef">Input Share</a>
            </h5>
<p id="section-8.2.6.2-1">Each input share is structured as follows:<a href="#section-8.2.6.2-1" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.2-2">
<pre>
struct {
    opaque idpf_key[poplar1.idpf.KEY_SIZE];
    opaque corr_seed[poplar1.xof.SEED_SIZE];
    Poplar1FieldInner corr_inner[Fi * 2 * (B- 1)];
    Poplar1FieldLeaf corr_leaf[Fl * 2];
} Poplar1InputShare;
</pre><a href="#section-8.2.6.2-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="prep-share-1">
<section id="section-8.2.6.3">
            <h5 id="name-prep-share-2">
<a href="#section-8.2.6.3" class="section-number selfRef">8.2.6.3. </a><a href="#name-prep-share-2" class="section-name selfRef">Prep Share</a>
            </h5>
<p id="section-8.2.6.3-1">Encoding of the prep share depends on the round of sketching: if the first
round, then each sketch share has three field elements; if the second round,
then each sketch share has one field element. The field that is used depends on
the level of the IDPF tree specified by the aggregation parameter, either the
inner field or the leaf field.<a href="#section-8.2.6.3-1" class="pilcrow">¶</a></p>
<p id="section-8.2.6.3-2">For the first round and inner field:<a href="#section-8.2.6.3-2" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.3-3">
<pre>
struct {
    Poplar1FieldInner sketch_share[Fi * 3];
} Poplar1PrepShareRoundOneInner;
</pre><a href="#section-8.2.6.3-3" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.3-4">For the first round and leaf field:<a href="#section-8.2.6.3-4" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.3-5">
<pre>
struct {
    Poplar1FieldLeaf sketch_share[Fl * 3];
} Poplar1PrepShareRoundOneLeaf;
</pre><a href="#section-8.2.6.3-5" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.3-6">For the second round and inner field:<a href="#section-8.2.6.3-6" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.3-7">
<pre>
struct {
    Poplar1FieldInner sketch_share;
} Poplar1PrepShareRoundTwoInner;
</pre><a href="#section-8.2.6.3-7" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.3-8">For the second round and leaf field:<a href="#section-8.2.6.3-8" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.3-9">
<pre>
struct {
    Poplar1FieldLeaf sketch_share;
} Poplar1PrepShareRoundTwoLeaf;
</pre><a href="#section-8.2.6.3-9" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="prep-message-1">
<section id="section-8.2.6.4">
            <h5 id="name-prep-message-2">
<a href="#section-8.2.6.4" class="section-number selfRef">8.2.6.4. </a><a href="#name-prep-message-2" class="section-name selfRef">Prep Message</a>
            </h5>
<p id="section-8.2.6.4-1">Likewise, the structure of the prep message for Poplar1 depends on the
sketching round and field. For the first round and inner field:<a href="#section-8.2.6.4-1" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.4-2">
<pre>
struct {
    Poplar1FieldInner[Fi * 3];
} Poplar1PrepMessageRoundOneInner;
</pre><a href="#section-8.2.6.4-2" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.4-3">For the first round and leaf field:<a href="#section-8.2.6.4-3" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.4-4">
<pre>
struct {
    Poplar1FieldLeaf sketch[Fl * 3];
} Poplar1PrepMessageRoundOneLeaf;
</pre><a href="#section-8.2.6.4-4" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.4-5">Note that these messages have the same structures as the prep shares for the
first round.<a href="#section-8.2.6.4-5" class="pilcrow">¶</a></p>
<p id="section-8.2.6.4-6">The second-round prep message is the empty string. This is because the sketch
shares are expected to sum to a particular value if the output shares are
valid; we represent a successful preparation with the empty string and
otherwise return an error.<a href="#section-8.2.6.4-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="aggregate-share">
<section id="section-8.2.6.5">
            <h5 id="name-aggregate-share">
<a href="#section-8.2.6.5" class="section-number selfRef">8.2.6.5. </a><a href="#name-aggregate-share" class="section-name selfRef">Aggregate Share</a>
            </h5>
<p id="section-8.2.6.5-1">The encoding of the aggregate share depends on whether the inner or leaf field
is used, and the number of candidate prefixes. Both of these are determined by
 the aggregation parameter.<a href="#section-8.2.6.5-1" class="pilcrow">¶</a></p>
<p id="section-8.2.6.5-2">Let <code>prefix_count</code> denote the number of candidate prefixes. For the inner field:<a href="#section-8.2.6.5-2" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.5-3">
<pre>
struct {
    Poplar1FieldInner agg_share[Fi * prefix_count];
} Poplar1AggShareInner;
</pre><a href="#section-8.2.6.5-3" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.5-4">For the leaf field:<a href="#section-8.2.6.5-4" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.5-5">
<pre>
struct {
    Poplar1FieldLeaf agg_share[Fl * prefix_count];
} Poplar1AggShareLeaf;
</pre><a href="#section-8.2.6.5-5" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="aggregation-parameter">
<section id="section-8.2.6.6">
            <h5 id="name-aggregation-parameter">
<a href="#section-8.2.6.6" class="section-number selfRef">8.2.6.6. </a><a href="#name-aggregation-parameter" class="section-name selfRef">Aggregation Parameter</a>
            </h5>
<p id="section-8.2.6.6-1">The aggregation parameter is encoded as follows:<a href="#section-8.2.6.6-1" class="pilcrow">¶</a></p>
<div class="lang-tls-presentation sourcecode" id="section-8.2.6.6-2">
<pre>
struct {
    uint16_t level;
    uint32_t num_prefixes;
    opaque encoded_prefixes[prefixes_len];
} Poplar1AggParam;
</pre><a href="#section-8.2.6.6-2" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.6-3">The fields in this struct are: <code>level</code>, the level of the IDPF tree of each
prefixes; <code>num_prefixes</code>, the number of prefixes to evaluate; and
<code>encoded_prefixes</code>, the sequence of prefixes encoded into a byte string of
length <code>prefixes_len</code>. Each prefix is packed into a byte string, with the bits
assigned in MSB-to-LSB order, and then the byte strings for each prefix are
concatenated together. The prefixes are encoded with the following procedure:<a href="#section-8.2.6.6-3" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-8.2.6.6-4">
<pre>
prefixes_len = ((level + 1) + 7) // 8 * len(prefixes)
encoded_prefixes = bytearray()
for prefix in prefixes:
    for chunk in itertools.batched(prefix, 8):
        byte_out = 0
        for (bit_position, bit) in enumerate(chunk):
            byte_out |= bit &lt;&lt; (7 - bit_position)
        encoded_prefixes.append(byte_out)
</pre><a href="#section-8.2.6.6-4" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.6-5">Decoding involves the following procedure:<a href="#section-8.2.6.6-5" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="section-8.2.6.6-6">
<pre>
prefixes = []

last_byte_mask = 0
leftover_bits = (level + 1) % 8
if leftover_bits &gt; 0:
    for bit_index in range(8 - leftover_bits, 8):
        last_byte_mask |= 1 &lt;&lt; bit_index;
    last_byte_mask ^= 255

bytes_per_prefix = ((level + 1) + 7) // 8
for chunk in itertools.batched(encoded_prefixes, bytes_per_prefix):
    if chunk[-1] &amp; last_byte_mask &gt; 0:
        raise ValueError('trailing bits in prefix')

    prefix = []
    for i in range(level + 1):
        byte_index = i // 8
        bit_offset = 7 - (i % 8)
        bit = (chunk[byte_index] &gt;&gt; bit_offset) &amp; 1 != 0
        prefix.append(bit)
    prefixes.append(tuple(prefix))
</pre><a href="#section-8.2.6.6-6" class="pilcrow">¶</a>
</div>
<p id="section-8.2.6.6-7">Implementation note: the aggregation parameter includes the level of the IDPF
tree and the sequence of indices to evaluate. For implementations that perform
per-report caching across executions of the VDAF, this may be more information
than is strictly needed. In particular, it may be sufficient to convey which
indices from the previous execution will have their children included in the
next. This would help reduce communication overhead.<a href="#section-8.2.6.6-7" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="idpf-bbcggi21">
<section id="section-8.3">
        <h3 id="name-idpf-specification">
<a href="#section-8.3" class="section-number selfRef">8.3. </a><a href="#name-idpf-specification" class="section-name selfRef">IDPF Specification</a>
        </h3>
<p id="section-8.3-1">In this section we specify a concrete IDPF suitable for instantiating Poplar1.
The constant and type definitions required by the <code>Idpf</code> interface are given in
<a href="#idpf-bbcggi21-param" class="auto internal xref">Table 17</a>.<a href="#section-8.3-1" class="pilcrow">¶</a></p>
<p id="section-8.3-2">Our IDPF requires an XOF for deriving the output shares, as well as a variety
of other artifacts used internally. For performance reasons, we instantiate
this object using XofFixedKeyAes128 (<a href="#xof-fixed-key-aes128" class="auto internal xref">Section 6.2.2</a>) wherever
possible. See <a href="#xof-vs-ro" class="auto internal xref">Section 9.6</a> for security considerations.<a href="#section-8.3-2" class="pilcrow">¶</a></p>
<span id="name-constants-and-type-definiti"></span><div id="idpf-bbcggi21-param">
<table class="center" id="table-17">
          <caption>
<a href="#table-17" class="selfRef">Table 17</a>:
<a href="#name-constants-and-type-definiti" class="selfRef">Constants and type definitions for our concrete IDPF.</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Parameter</th>
              <th class="text-left" rowspan="1" colspan="1">Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>xof</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>XofFixedKeyAes128</code> (<a href="#xof-fixed-key-aes128" class="auto internal xref">Section 6.2.2</a>)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>SHARES</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>2</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>BITS</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Any positive integer.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>VALUE_LEN</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">Any positive integer.</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>KEY_SIZE</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>xof.SEED_SIZE</code>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>FieldInner</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Field64</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">
                <code>FieldLeaf</code>
</td>
              <td class="text-left" rowspan="1" colspan="1">
                <code>Field255</code> (<a href="#fields" class="auto internal xref">Table 3</a>)</td>
            </tr>
          </tbody>
        </table>
</div>
<div id="overview-1">
<section id="section-8.3.1">
          <h4 id="name-overview-3">
<a href="#section-8.3.1" class="section-number selfRef">8.3.1. </a><a href="#name-overview-3" class="section-name selfRef">Overview</a>
          </h4>
<p id="section-8.3.1-1">At a high level, the IDPF maps a key generator's input <code>(alpha, beta_1, ...,
beta_BITS)</code> onto a binary tree with <code>BITS+1</code> levels, where each edge going from
a parent node to a left child is labeled <code>0</code>, and each right edge is labeled
<code>1</code>. Then each leaf node corresponds to a bit string of length <code>BITS</code>, where the
labels on the path from the root to <code>x</code> contain the individual bits.  Finally,
all nodes in the tree have an assigned value, with the nodes on the path
from the root to <code>alpha</code> having values <code>beta_1, ..., beta_BITS</code>, and all other
nodes having value <code>0</code>.<a href="#section-8.3.1-1" class="pilcrow">¶</a></p>
<p id="section-8.3.1-2">The IDPF construction now boils down to secret-sharing the values at each node
of that tree in an efficient way. Note that explicitly representing the tree
requires <code>O(2^BITS)</code> space, so the generator cannot just compute additive shares
of it and send them to the two evaluators. Instead, the evaluators will
re-generate shares of values at selected nodes of the tree using a XOF
(<a href="#xof" class="auto internal xref">Section 6.2</a>).<a href="#section-8.3.1-2" class="pilcrow">¶</a></p>
<p id="section-8.3.1-3">The basic observation is that if both evaluators have the same seed <code>s</code> of
length <code>KEY_SIZE</code>, then expanding <code>s</code> using a XOF will also result in the same
expansion. If we set the length of the XOF expansion to <code>2*KEY_SIZE</code>, it can
then be split again into two seeds <code>s_l</code>, <code>s_r</code>, that can again serve as XOF
seeds. Now if we view seeds as XOR-shares of integers, and if evaluators have
the same seed at the root of the tree, then their expanded trees will form a
secret-shared tree of zeros. The actual construction will additionally use a
<code>convert()</code> function before each expansion, which maps seeds into the
appropriate output domain (see <a href="#idpf-bbcggi21-helper-functions" class="auto internal xref">Section 8.3.4</a>), generating
a new seed for the next level in the process.<a href="#section-8.3.1-3" class="pilcrow">¶</a></p>
<p id="section-8.3.1-4">The open task now is to ensure that evaluators have different seeds at nodes
that lie on the path to <code>alpha</code>, while having the same seeds on all other nodes.
This is done using so-called "correction words" included in the public share.
The correction words are conditionally added to the XOF output by both
evaluators.  The condition here is a secret-shared bit, called a "control bit",
which indicates whether the current node is on the path to <code>alpha</code> or not. On
the path, the control bits add up to <code>1</code>, meaning only one evaluator will add
the correction word to its XOF output. Off the path, either none or both
evaluators add the correction word, and so the seeds at the next level stay the
same.<a href="#section-8.3.1-4" class="pilcrow">¶</a></p>
<p id="section-8.3.1-5">What remains is to turn the (now pseudorandom) values on the path to <code>alpha</code>
into the desired <code>beta</code> values. This is done by including "value correction
words" in the public share, which are chosen such that when added with the
pseudorandom shares at the <code>i</code>th node on the path to <code>alpha</code>, they add up to
shares of <code>beta_i</code>.<a href="#section-8.3.1-5" class="pilcrow">¶</a></p>
<p id="section-8.3.1-6">In the following two sections we describe the algorithms for key generation in
full detail.<a href="#section-8.3.1-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="key-generation">
<section id="section-8.3.2">
          <h4 id="name-key-generation">
<a href="#section-8.3.2" class="section-number selfRef">8.3.2. </a><a href="#name-key-generation" class="section-name selfRef">Key Generation</a>
          </h4>
<p id="section-8.3.2-1">The description of the IDPF-key generation algorithm makes use of auxiliary
functions <code>extend()</code> and <code>convert()</code> defined in
<a href="#idpf-bbcggi21-helper-functions" class="auto internal xref">Section 8.3.4</a>.<a href="#section-8.3.2-1" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-8.3.2-2">
<pre>
def gen(
        self,
        alpha: tuple[bool, ...],
        beta_inner: list[list[Field64]],
        beta_leaf: list[Field255],
        ctx: bytes,
        nonce: bytes,
        rand: bytes) -&gt; tuple[list[CorrectionWord], list[bytes]]:
    if len(alpha) != self.BITS:
        raise ValueError("incorrect alpha length")
    if len(beta_inner) != self.BITS - 1:
        raise ValueError("incorrect beta_inner length")
    if len(rand) != self.RAND_SIZE:
        raise ValueError("incorrect rand size")
    if len(nonce) != self.NONCE_SIZE:
        raise ValueError("incorrect nonce size")

    key = [
        rand[:XofFixedKeyAes128.SEED_SIZE],
        rand[XofFixedKeyAes128.SEED_SIZE:],
    ]

    seed = key.copy()
    ctrl = [False, True]
    public_share = []
    for level in range(self.BITS):
        bit = alpha[level]
        keep = int(bit)
        lose = 1 - keep

        (s0, t0) = self.extend(level, seed[0], ctx, nonce)
        (s1, t1) = self.extend(level, seed[1], ctx, nonce)
        seed_cw = xor(s0[lose], s1[lose])
        ctrl_cw = (
            t0[0] ^ t1[0] ^ (not bit),
            t0[1] ^ t1[1] ^ bit,
        )

        # Implementation note: these conditional XORs and
        # input-dependent array indices should be replaced with
        # constant-time selects in practice in order to reduce
        # leakage via timing side channels.
        if ctrl[0]:
            x0 = xor(s0[keep], seed_cw)
            ctrl[0] = t0[keep] ^ ctrl_cw[keep]
        else:
            x0 = s0[keep]
            ctrl[0] = t0[keep]
        if ctrl[1]:
            x1 = xor(s1[keep], seed_cw)
            ctrl[1] = t1[keep] ^ ctrl_cw[keep]
        else:
            x1 = s1[keep]
            ctrl[1] = t1[keep]
        (seed[0], w0) = self.convert(level, x0, ctx, nonce)
        (seed[1], w1) = self.convert(level, x1, ctx, nonce)

        if level &lt; self.BITS - 1:
            b = cast(list[Field], beta_inner[level])
        else:
            b = cast(list[Field], beta_leaf)
        if len(b) != self.VALUE_LEN:
            raise ValueError(
                "length of beta must match the value length"
            )

        w_cw = vec_add(vec_sub(b, w0), w1)
        # Implementation note: this conditional negation should be
        # replaced with a constant time select or a constant time
        # multiplication in practice in order to reduce leakage via
        # timing side channels.
        if ctrl[1]:
            for i in range(len(w_cw)):
                w_cw[i] = -w_cw[i]

        public_share.append((seed_cw, ctrl_cw, w_cw))
    return (public_share, key)
</pre><a href="#section-8.3.2-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="key-evaluation">
<section id="section-8.3.3">
          <h4 id="name-key-evaluation">
<a href="#section-8.3.3" class="section-number selfRef">8.3.3. </a><a href="#name-key-evaluation" class="section-name selfRef">Key Evaluation</a>
          </h4>
<p id="section-8.3.3-1">The description of the IDPF-evaluation algorithm makes use of auxiliary
functions <code>extend()</code> and <code>convert()</code> defined in
<a href="#idpf-bbcggi21-helper-functions" class="auto internal xref">Section 8.3.4</a>.<a href="#section-8.3.3-1" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="section-8.3.3-2">
<pre>
def eval(
        self,
        agg_id: int,
        public_share: list[CorrectionWord],
        key: bytes,
        level: int,
        prefixes: Sequence[tuple[bool, ...]],
        ctx: bytes,
        nonce: bytes) -&gt; list[list[Field64]] | list[list[Field255]]:
    if agg_id not in range(self.SHARES):
        raise ValueError('aggregator id out of range')
    if level not in range(self.BITS):
        raise ValueError('level out of range')
    if len(set(prefixes)) != len(prefixes):
        raise ValueError('prefixes must be unique')

    out_share = []
    for prefix in prefixes:
        if len(prefix) != level + 1:
            raise ValueError('incorrect prefix length')

        # The Aggregator's output share is the value of a node of
        # the IDPF tree at the given `level`. The node's value is
        # computed by traversing the path defined by the candidate
        # `prefix`. Each node in the tree is represented by a seed
        # (`seed`) and a control bit (`ctrl`).
        seed = key
        ctrl = bool(agg_id)
        y: FieldVec
        for current_level in range(level + 1):
            bit = int(prefix[current_level])

            # Implementation note: typically the current round of
            # candidate prefixes would have been derived from
            # aggregate results computed during previous rounds.
            # For example, when using the IDPF to compute heavy
            # hitters, a string whose hit count exceeded the
            # given threshold in the last round would be the
            # prefix of each `prefix` in the current round. (See
            # [BBCGGI21, Section 5.1].) In this case, part of the
            # path would have already been traversed.
            #
            # Re-computing nodes along previously traversed paths is
            # wasteful. Implementations can eliminate this added
            # complexity by caching nodes (i.e., `(seed, ctrl)`
            # pairs) output by previous calls to `eval_next()`.
            (seed, ctrl, y) = self.eval_next(
                seed,
                ctrl,
                public_share[current_level],
                current_level,
                bit,
                ctx,
                nonce,
            )
        if agg_id == 0:
            out_share.append(cast(list[Field], y))
        else:
            out_share.append(vec_neg(cast(list[Field], y)))
    return cast(
        list[list[Field64]] | list[list[Field255]],
        out_share,
    )

def eval_next(
        self,
        prev_seed: bytes,
        prev_ctrl: bool,
        correction_word: CorrectionWord,
        level: int,
        bit: int,
        ctx: bytes,
        nonce: bytes) -&gt; tuple[bytes, bool, FieldVec]:
    """
    Compute the next node in the IDPF tree along the path determined
    by a candidate prefix. The next node is determined by `bit`, the
    bit of the prefix corresponding to the next level of the tree.
    """

    seed_cw = correction_word[0]
    ctrl_cw = correction_word[1]
    w_cw = cast(list[Field], correction_word[2])
    (s, t) = self.extend(level, prev_seed, ctx, nonce)

    # Implementation note: these conditional operations and
    # input-dependent array indices should be replaced with
    # constant-time selects in practice in order to reduce leakage
    # via timing side channels.
    if prev_ctrl:
        s[0] = xor(s[0], seed_cw)
        s[1] = xor(s[1], seed_cw)
        t[0] ^= ctrl_cw[0]
        t[1] ^= ctrl_cw[1]

    next_ctrl = t[bit]
    convert_output = self.convert(level, s[bit], ctx, nonce)
    next_seed = convert_output[0]
    y = cast(list[Field], convert_output[1])
    # Implementation note: this conditional addition should be
    # replaced with a constant-time select in practice in order to
    # reduce leakage via timing side channels.
    if next_ctrl:
        for i in range(len(y)):
            y[i] += w_cw[i]

    return (next_seed, next_ctrl, cast(FieldVec, y))
</pre><a href="#section-8.3.3-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="idpf-bbcggi21-helper-functions">
<section id="section-8.3.4">
          <h4 id="name-auxiliary-functions-3">
<a href="#section-8.3.4" class="section-number selfRef">8.3.4. </a><a href="#name-auxiliary-functions-3" class="section-name selfRef">Auxiliary Functions</a>
          </h4>
<div class="breakable lang-python sourcecode" id="section-8.3.4-1">
<pre>
def extend(
        self,
        level: int,
        seed: bytes,
        ctx: bytes,
        nonce: bytes) -&gt; tuple[list[bytes], list[bool]]:
    xof = self.current_xof(
        level,
        seed,
        format_dst(1, 0, 0) + ctx,
        nonce,
    )
    s = [
        bytearray(xof.next(self.KEY_SIZE)),
        bytearray(xof.next(self.KEY_SIZE)),
    ]
    # Use the least significant bits as the control bit correction,
    # and then zero it out. This gives effectively 127 bits of
    # security, but reduces the number of AES calls needed by 1/3.
    t = [bool(s[0][0] &amp; 1), bool(s[1][0] &amp; 1)]
    s[0][0] &amp;= 0xFE
    s[1][0] &amp;= 0xFE
    return ([bytes(s[0]), bytes(s[1])], t)

def convert(
        self,
        level: int,
        seed: bytes,
        ctx: bytes,
        nonce: bytes) -&gt; tuple[bytes, FieldVec]:
    xof = self.current_xof(
        level,
        seed,
        format_dst(1, 0, 1) + ctx,
        nonce,
    )
    next_seed = xof.next(self.KEY_SIZE)
    field = self.current_field(level)
    w = xof.next_vec(field, self.VALUE_LEN)
    return (next_seed, cast(FieldVec, w))

def current_xof(self,
                level: int,
                seed: bytes,
                dst: bytes,
                nonce: bytes) -&gt; Xof:
    if level &lt; self.BITS-1:
        return XofFixedKeyAes128(seed, dst, nonce)
    return XofTurboShake128(seed, dst, nonce)
</pre><a href="#section-8.3.4-1" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="security">
<section id="section-9">
      <h2 id="name-security-considerations">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-9-1">VDAFs (<a href="#vdaf" class="auto internal xref">Section 5</a>) have two essential security goals:<a href="#section-9-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-9-2">
<li id="section-9-2.1">
          <p id="section-9-2.1.1">Privacy: an attacker that controls the Collector and a subset of Clients and
Aggregators learns nothing about the measurements of honest Clients beyond
what it can deduce from the aggregate result. We assume the attacker
controls the entire network except for channels between honest Clients and
honest Aggregators. In particular, it cannot forge or prevent transmission
of messages on these channels.<a href="#section-9-2.1.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-9-2.2">
          <p id="section-9-2.2.1">Verifiability: an attacker that controls a subset of Clients cannot cause
the Collector to compute anything other than the aggregate of the
measurements of honest Clients, plus valid measurements from some of the
attacker-controlled Clients. We assume the attacker eavesdrops on the
network but does not control transmission of messages between honest
parties.<a href="#section-9-2.2.1" class="pilcrow">¶</a></p>
</li>
      </ol>
<p id="section-9-3">Formal definitions of privacy and verifiability (i.e., robustness) can be found
in <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>. A VDAF is the core cryptographic primitive of a protocol that
achieves the above privacy and verifiability goals. It is not sufficient on its
own, however. The application will need to assure a few security properties,
for example:<a href="#section-9-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-9-4.1">
          <p id="section-9-4.1.1">Securely distributing the long-lived parameters, in particular the
verification key.<a href="#section-9-4.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-9-4.2">
          <p id="section-9-4.2.1">Establishing secure channels:<a href="#section-9-4.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-9-4.2.2.1">
              <p id="section-9-4.2.2.1.1">Confidential and authentic channels among Aggregators, and between the
Aggregators and the Collector; and<a href="#section-9-4.2.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-9-4.2.2.2">
              <p id="section-9-4.2.2.2.1">Confidential and Aggregator-authenticated channels between Clients and
Aggregators.<a href="#section-9-4.2.2.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</li>
        <li class="normal" id="section-9-4.3">
          <p id="section-9-4.3.1">Enforcing the non-collusion properties required of the specific VDAF in use.<a href="#section-9-4.3.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-9-5">In such an environment, a VDAF provides the high-level privacy property
described above: the Collector learns only the aggregate result, and nothing
about individual measurements aside from what can be inferred from the
aggregate result.  The Aggregators learn neither individual measurements nor
the aggregate result.  The Collector is assured that the aggregate statistic
accurately reflects the inputs as long as the Aggregators correctly executed
their role in the VDAF.<a href="#section-9-5" class="pilcrow">¶</a></p>
<p id="section-9-6">On their own, VDAFs do not provide:<a href="#section-9-6" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-9-7">
<li id="section-9-7.1">
          <p id="section-9-7.1.1">Mitigation of Sybil attacks <span>[<a href="#Dou02" class="cite xref">Dou02</a>]</span>. In this attack, the adversary
observes a subset of input shares transmitted by a Client it is interested
in. It allows the input shares to be processed, but corrupts and picks bogus
measurements for the remaining Clients.  Applications can guard against
these risks by adding additional controls on report submission, such as
Client authentication and rate limits.<a href="#section-9-7.1.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-9-7.2">
          <p id="section-9-7.2.1">Differential privacy <span>[<a href="#Dwo06" class="cite xref">Dwo06</a>]</span>. Depending on the distribution of the
measurements, the aggregate result itself can still leak a significant
amount of information about an individual measurement or the person that
generated it.<a href="#section-9-7.2.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-9-7.3">
          <p id="section-9-7.3.1">Verifiability in the presence of a malicious Aggregator. An Aggregator can,
without detection, manipulate the aggregate result by modifying its own
aggregate share.<a href="#section-9-7.3.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-9-7.4">
          <p id="section-9-7.4.1">Guaranteed output delivery <span>[<a href="#GSZ20" class="cite xref">GSZ20</a>]</span>. An attacker that controls transmission
of messages between honest parties can prevent computation of the aggregate
result by dropping messages.<a href="#section-9-7.4.1" class="pilcrow">¶</a></p>
</li>
      </ol>
<div id="the-verification-key">
<section id="section-9.1">
        <h3 id="name-the-verification-key">
<a href="#section-9.1" class="section-number selfRef">9.1. </a><a href="#name-the-verification-key" class="section-name selfRef">The Verification Key</a>
        </h3>
<p id="section-9.1-1">The Aggregators are responsible for exchanging the verification key in advance
of executing the VDAF. Any procedure is acceptable as long as the following
conditions are met:<a href="#section-9.1-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-9.1-2">
<li id="section-9.1-2.1">
            <p id="section-9.1-2.1.1">To ensure the computation is verifiably correct, the Aggregators <span class="bcp14">MUST NOT</span>
reveal the verification key to the Clients. Otherwise, a malicious Client
might be able to exploit knowledge of this key to craft an invalid report
that would be accepted by the Aggregators.<a href="#section-9.1-2.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-9.1-2.2">
            <p id="section-9.1-2.2.1">To ensure privacy of the measurements, the Aggregators <span class="bcp14">MUST</span> commit to the
verification key prior to processing reports generated by Clients.
Otherwise, the attacker may be able to craft a verification key that, for a
given report, causes an honest Aggregator to leak information about the
measurement during preparation.<a href="#section-9.1-2.2.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<p id="section-9.1-3">Meeting these requirements is relatively straightforward. For example, the
Aggregators may designate one of their peers to generate the verification key
and distribute it to the others. To assure Clients of key commitment, the
Clients and (honest) Aggregators <span class="bcp14">SHOULD</span> bind the verification key to the
application context. For instance, the "task ID" of DAP <span>[<a href="#DAP" class="cite xref">DAP</a>]</span> could be set to
the hash of the verification key; then as long as honest Aggregators only
consume reports for the task indicated by the Client, forging a new key after
the fact would reduce to finding collisions in the underlying hash function.
(Keeping the key secret from the Clients would require the hash function to be
one-way.) However, since rotating the key implies rotating the task ID, this
scheme would not allow key rotation over the lifetime of a task.<a href="#section-9.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="nonce-requirements">
<section id="section-9.2">
        <h3 id="name-the-nonce">
<a href="#section-9.2" class="section-number selfRef">9.2. </a><a href="#name-the-nonce" class="section-name selfRef">The Nonce</a>
        </h3>
<p id="section-9.2-1">The sharding and preparation steps of VDAF execution depend on a nonce
associated with the Client's report. To ensure privacy of the underlying
measurement, the Client <span class="bcp14">MUST</span> generate this nonce using a CSPRNG. This is
required in order to leverage security analysis for the privacy definition of
<span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>, which assumes the nonce is chosen at random prior to generating the
report. Uniqueness of the nonce is not sufficient because the verification key
is controlled by the attacker.<a href="#section-9.2-1" class="pilcrow">¶</a></p>
<p id="section-9.2-2">Applications will need to protect against replay attacks to prevent disallowed
re-use of reports (see <a href="#agg-param-security" class="auto internal xref">Section 9.4</a>). Furthermore, in applications
that aim to achieve differential privacy, it is necessary to limit how much
each party contributes to a single batch or multiple batches. It is <span class="bcp14">RECOMMENDED</span>
that the nonce generated by the Client be used by the Aggregators for replay
protection.<a href="#section-9.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="the-public-share">
<section id="section-9.3">
        <h3 id="name-the-public-share">
<a href="#section-9.3" class="section-number selfRef">9.3. </a><a href="#name-the-public-share" class="section-name selfRef">The Public Share</a>
        </h3>
<p id="section-9.3-1">The Aggregators <span class="bcp14">MUST</span> ensure they have both received the same public share from
the Client. It is sufficient, for example, to exchange a hash of the public
share over a secure channel.<a href="#section-9.3-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="agg-param-security">
<section id="section-9.4">
        <h3 id="name-the-aggregation-parameter">
<a href="#section-9.4" class="section-number selfRef">9.4. </a><a href="#name-the-aggregation-parameter" class="section-name selfRef">The Aggregation Parameter</a>
        </h3>
<p id="section-9.4-1">As described in <a href="#sec-daf-validity-scopes" class="auto internal xref">Section 4.3</a> and <a href="#sec-vdaf-validity-scopes" class="auto internal xref">Section 5.3</a>
respectively, DAFs and VDAFs may impose restrictions on the re-use of reports.
For Prio3, reports should only be aggregated once; for Poplar1, reports may be
aggregated multiple times, but never twice at the same level of the tree.
Otherwise, we risk re-using correlated randomness, which might compromise
confidentiality of the Client's measurement.<a href="#section-9.4-1" class="pilcrow">¶</a></p>
<p id="section-9.4-2">Higher level applications that use DAFs or VDAFs <span class="bcp14">MUST</span> enforce aggregation
parameter validity. In particular, prior to beginning preparation with an
aggregation parameter provided by the Collector, they <span class="bcp14">MUST</span> invoke <code>is_valid()</code>
to decide if the parameter is valid given the sequence of previously accepted
parameters.<a href="#section-9.4-2" class="pilcrow">¶</a></p>
<p id="section-9.4-3">Note that aggregating a batch of reports multiple times, even with a valid
sequence of aggregation parameters, can result in information leakage beyond
what is used by the application.<a href="#section-9.4-3" class="pilcrow">¶</a></p>
<p id="section-9.4-4">For example, when Poplar1 is used for heavy hitters, the Aggregators learn not
only the heavy hitters themselves, but also the prefix tree (as defined in
<a href="#poplar1" class="auto internal xref">Section 8</a>) computed along the way. Indeed, this leakage is inherent to any
construction that uses an IDPF (<a href="#idpf" class="auto internal xref">Section 8.1</a>) in the same way. Depending on the
distribution of the measurements, the prefix tree can leak a significant amount
of information about unpopular inputs. For instance, it is possible (though
perhaps unlikely) for a large set of non-heavy-hitter values to share a common
prefix, which would be leaked by a prefix tree with a sufficiently small
threshold.<a href="#section-9.4-4" class="pilcrow">¶</a></p>
<p id="section-9.4-5">A malicious adversary controlling the Collector and one of the Aggregators can
further turn arbitrary non-heavy prefixes into heavy ones by tampering with the
IDPF output at any position. While our construction ensures that the nodes
evaluated at one level are children of the nodes evaluated at the previous
level, this still may allow an adversary to discover individual non-heavy
strings. We call this a "steering attack".<a href="#section-9.4-5" class="pilcrow">¶</a></p>
<p id="section-9.4-6">The only practical, general-purpose defense against steering attacks is to
compose Poplar1 with some mechanism for differential privacy. It is therefore
<span class="bcp14">RECOMMENDED</span> to use differential privacy for any heavy-hitter type application.<a href="#section-9.4-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="idpf-extract">
<section id="section-9.5">
        <h3 id="name-safe-usage-of-idpf-outputs">
<a href="#section-9.5" class="section-number selfRef">9.5. </a><a href="#name-safe-usage-of-idpf-outputs" class="section-name selfRef">Safe Usage of IDPF Outputs</a>
        </h3>
<p id="section-9.5-1">The arithmetic sketch described in <a href="#poplar1" class="auto internal xref">Section 8</a> is used by the Aggregators to check
that the shares of the vector obtained by evaluating a Client's IDPF at a
sequence of candidate prefixes has at most one non-zero value, and that the
non-zero value is <code>1</code>. Depending on how the values are used, the arithmetic
sketch on its own may not be sufficient to verify the correctness of the
computation. In particular, a malicious Client may attempt to influence the
computation by choosing an IDPF that evaluates to <code>1</code> at more than one node at
a given level of the tree.<a href="#section-9.5-1" class="pilcrow">¶</a></p>
<p id="section-9.5-2">This issue can be mitigated by using an IDPF that is extractable as defined
in Appendix D of <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>. Extractability ensures that, for a particular
level of the tree, it is infeasible for an attacker to control values of the
IDPF such that it takes on chosen non-zero values at more than one node. (It
can practically only achieve the zero function, a point function, or a
pseudorandom function.)<a href="#section-9.5-2" class="pilcrow">¶</a></p>
<p id="section-9.5-3">The IDPF specified in <a href="#idpf" class="auto internal xref">Section 8.1</a> only guarantees extractability at the last level
of the tree. (This is by virtue of using a larger field for the leaves than for
inner nodes and using an XOF to derive leaves that is safe to model as a random
oracle. See <a href="#xof-vs-ro" class="auto internal xref">Section 9.6</a>.) For intermediate levels, it is feasible for a
client to produce IDPF shares with two controlled non-zero nodes.<a href="#section-9.5-3" class="pilcrow">¶</a></p>
<p id="section-9.5-4">This is not an issue for running heavy hitters, since (1) each node in the
prefix tree is a child of a previously traversed node, (2) the arithmetic sketch
would detect double voting at every level of the prefix tree, and (3) the IDPF
is extractable at the last level of the tree. However, the lack of
extractability at intermediate levels may result in attacks on the correctness of
the computation in certain applications.<a href="#section-9.5-4" class="pilcrow">¶</a></p>
<p id="section-9.5-5">Thus applications <span class="bcp14">SHOULD NOT</span> use prefix counts for intermediate levels for any
purpose beyond computing the prefix tree for heavy hitters.<a href="#section-9.5-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="xof-vs-ro">
<section id="section-9.6">
        <h3 id="name-safe-usage-of-xofs">
<a href="#section-9.6" class="section-number selfRef">9.6. </a><a href="#name-safe-usage-of-xofs" class="section-name selfRef">Safe Usage of XOFs</a>
        </h3>
<p id="section-9.6-1">In the security analyses of our protocols, XOFs (<a href="#xof" class="auto internal xref">Section 6.2</a>) are usually modeled
as random oracles. XofTurboShake128 is designed to be indifferentiable from a
random oracle <span>[<a href="#MRH04" class="cite xref">MRH04</a>]</span>, making it a suitable choice for most situations.<a href="#section-9.6-1" class="pilcrow">¶</a></p>
<p id="section-9.6-2">The one exception is the IDPF of <a href="#idpf-bbcggi21" class="auto internal xref">Section 8.3</a>. Here, a random oracle is not
needed to prove privacy, since the analysis of <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span>, Proposition 1, only
requires a Pseudorandom Generator (PRG). As observed in <span>[<a href="#GKWY20" class="cite xref">GKWY20</a>]</span>, a PRG can be
instantiated from a correlation-robust hash function <code>H</code>. Informally,
correlation robustness requires that for a random <code>r</code>, <code>H(xor(r, x))</code> is
computationally indistinguishable from a random function of <code>x</code>. A PRG can
therefore be constructed as<a href="#section-9.6-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-9.6-3">
<pre>
PRG(r) = H(xor(r, 1)) || H(xor(r, 2)) || ...
</pre><a href="#section-9.6-3" class="pilcrow">¶</a>
</div>
<p id="section-9.6-4">since each individual hash function evaluation is indistinguishable from a random
function.<a href="#section-9.6-4" class="pilcrow">¶</a></p>
<p id="section-9.6-5">XofFixedKeyAes128 in <a href="#xof-fixed-key-aes128" class="auto internal xref">Section 6.2.2</a> implements a correlation-robust
hash function using fixed-key AES. For security, it assumes that AES with a
fixed key can be modeled as a random permutation <span>[<a href="#GKWY20" class="cite xref">GKWY20</a>]</span>. Additionally, we
use a different AES key for every client, which in the ideal cipher model leads
to better concrete security <span>[<a href="#GKWWY20" class="cite xref">GKWWY20</a>]</span>.<a href="#section-9.6-5" class="pilcrow">¶</a></p>
<p id="section-9.6-6">We note that for verifiability, the analysis of <span>[<a href="#BBCGGI21" class="cite xref">BBCGGI21</a>]</span> still assumes a
random oracle to make the IDPF extractable. We therefore use XofTurboShake128
instead for the last level of the tree. It is important that XofTurboShake128
supports many seed lengths, in particular 16 bytes, as this is the seed size
for the inner levels.<a href="#section-9.6-6" class="pilcrow">¶</a></p>
<p id="section-9.6-7">While XofFixedKeyAes128 has been shown to be differentiable from a random
oracle <span>[<a href="#GKWWY20" class="cite xref">GKWWY20</a>]</span>, there are no known attacks exploiting this difference. We
also stress that even if the IDPF is not extractable, Poplar1 guarantees that
every client can contribute to at most one prefix among the ones being
evaluated by the helpers.<a href="#section-9.6-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="security-multiproof">
<section id="section-9.7">
        <h3 id="name-choosing-flp-parameters">
<a href="#section-9.7" class="section-number selfRef">9.7. </a><a href="#name-choosing-flp-parameters" class="section-name selfRef">Choosing FLP Parameters</a>
        </h3>
<p id="section-9.7-1">Prio3 and other systems built from the FLP of <a href="#flp-bbcggi19" class="auto internal xref">Section 7.3</a> may benefit from
choosing a field size that is as small as possible. Generally speaking, a
smaller field results in lower communication and storage costs. Care must be
taken, however, since a smaller field also results in degraded (or even
vacuous) verifiability.<a href="#section-9.7-1" class="pilcrow">¶</a></p>
<p id="section-9.7-2">Different variants of Prio3 (<a href="#prio3" class="auto internal xref">Section 7</a>) use different field sizes: Prio3Count
and Prio3Sum use Field64; but Prio3SumVec, Prio3Histogram, and
Prio3MultihotCountVec all use Field128, a field that is twice as large as
Field64. This is due to the use of joint randomness (<a href="#flp" class="auto internal xref">Section 7.1</a>) in the latter
variants. Joint randomness allows for more flexible circuit design (see
<a href="#flp-bbcggi19-overview-extensions" class="auto internal xref">Section 7.3.1.1</a>), but opens up Prio3 to offline attacks in
which the attacker searches for input shares for an invalid measurement that
derive joint randomness that causes the circuit to accept. Choosing a large
enough field ensures this computation is too expensive to be feasible. (See
<span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>, Theorem 1.) Note that privacy is not susceptible to such attacks.<a href="#section-9.7-2" class="pilcrow">¶</a></p>
<p id="section-9.7-3">Another way to mitigate this issue (or improve verifiability in general) is to
generate and verify multiple, independent proofs. (See <a href="#multiproofs" class="auto internal xref">Section 7.1.2</a>.) For
Prio3, the <code>PROOFS</code> parameter controls the number of proofs (at least one) that
are generated and verified. In general the soundness error of the FLP is given
by the following formula:<a href="#section-9.7-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-9.7-4">
<pre>
(circuit_soundness + flp_soundness)^PROOFS
</pre><a href="#section-9.7-4" class="pilcrow">¶</a>
</div>
<p id="section-9.7-5">where:<a href="#section-9.7-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-9.7-6.1">
            <p id="section-9.7-6.1.1"><code>circuit_soundness</code> is the soundness of the validity circuit
(<a href="#flp-bbcggi19-valid" class="auto internal xref">Section 7.3.2</a>)<a href="#section-9.7-6.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-9.7-6.2">
            <p id="section-9.7-6.2.1"><code>flp_soundness</code> is the base soundness of the proof system (<span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span>,
Theorem 4.3)<a href="#section-9.7-6.2.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-9.7-7">For circuits involving joint randomness, we aim for the soundness error to be
close to <code>2^-128</code> in order to mitigate offline attacks. Such circuits <span class="bcp14">MUST</span> use
Field128 with at least one proof or Field64 with at least three proofs.
Depending on the circuit, Field64 with two proofs might have significantly
lower soundness than Field128 with one proof.<a href="#section-9.7-7" class="pilcrow">¶</a></p>
<p id="section-9.7-8">We stress that weak parameters (too small a field, too few proofs, or both) can
be exploited to attack any aggregation task using those parameters. To
mitigate offline attacks, it is necessary to disable all tasks that use the
weak parameters.<a href="#section-9.7-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="num-aggregators">
<section id="section-9.8">
        <h3 id="name-choosing-the-number-of-aggr">
<a href="#section-9.8" class="section-number selfRef">9.8. </a><a href="#name-choosing-the-number-of-aggr" class="section-name selfRef">Choosing the Number of Aggregators</a>
        </h3>
<p id="section-9.8-1">Two Aggregators are required for privacy in our threat model, but some (V)DAFs,
including Prio3 (<a href="#prio3" class="auto internal xref">Section 7</a>), allow for any number of Aggregators, only one of
which needs to be trusted in order for the computation to be private. To hedge
against corruptions that happen during the course of the attack, deployments
may consider involving more than two Aggregators as described for example in
<a href="#star-topo" class="auto internal xref">Section 5.7.2</a>. Note however that some schemes are not compatible with this mode
of operation, such as Poplar1.<a href="#section-9.8-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="deep">
<section id="section-9.9">
        <h3 id="name-defense-in-depth-measures">
<a href="#section-9.9" class="section-number selfRef">9.9. </a><a href="#name-defense-in-depth-measures" class="section-name selfRef">Defense-in-Depth Measures</a>
        </h3>
<p id="section-9.9-1">Prio3 and Poplar1 are designed to resist some attacks that fall outside the
main threat model for VDAFs.<a href="#section-9.9-1" class="pilcrow">¶</a></p>
<p id="section-9.9-2">Broadly speaking, domain separation is used to prevent cross protocol attacks,
in which data from evaluation of one VDAF translates to an attack against another.
For example:<a href="#section-9.9-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-9.9-3">
<li id="section-9.9-3.1">
            <p id="section-9.9-3.1.1">Weak entropy sources: the VDAF algorithm ID is bound to each XOF invocation,
thereby ensuring the outputs are different between VDAF invocations, even if
the underlying randomness is the same. For example, two different instances
of Prio3 would compute different measurement shares.<a href="#section-9.9-3.1.1" class="pilcrow">¶</a></p>
</li>
          <li id="section-9.9-3.2">
            <p id="section-9.9-3.2.1">Weak parameters: Prio3 variants that require joint randomness are subject to
offline attacks against verifiability. These attacks are feasible if the field
size or number of proofs is sufficiently small. (See
<a href="#security-multiproof" class="auto internal xref">Section 9.7</a>.) The joint randomness derivation is bound to both
the field (via the algorithm ID) and the number of proofs, thereby ensuring
that joint randomness derived for weak parameters is not reused for stronger
parameters. In addition, the joint randomness is bound to the application
context, meaning any work the attacker does to attack some application is
not useful for other applications that use the same parameters.<a href="#section-9.9-3.2.1" class="pilcrow">¶</a></p>
</li>
        </ol>
<p id="section-9.9-4">There are also some important limitations to be aware of. For example, Prio3
provides domain separation between families of circuits, but does not provide
domain separation between instances of a circuit. Concretely, it is possible
for Aggregators to accept a report for Prio3SumVec from a Client who disagrees
with them on the value of <code>bits</code> and <code>length</code> (so long as the encoded
measurement is the same size). This is because there is no
binding of the circuit parameters to the computation.<a href="#section-9.9-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="side-channel-resistance">
<section id="section-9.10">
        <h3 id="name-side-channel-resistance">
<a href="#section-9.10" class="section-number selfRef">9.10. </a><a href="#name-side-channel-resistance" class="section-name selfRef">Side-Channel Resistance</a>
        </h3>
<p id="section-9.10-1">Implementations of VDAFs should incorporate defenses against side-channel
attacks. For side-channel attacks against the privacy security goal, the
relevant threat model includes an attacker that may control the Collector, a
subset of Clients, and a subset of Aggregators, and monitor side-channel
signals from the honest Clients and Aggregators. Side-channel attacks by third
parties may indirectly target verifiability by trying to leak the Aggregators'
verification key. Thus, implementations of Clients and Aggregators should treat
measurements, input shares, output shares, and the verification key as secret,
and avoid leaking those secret values or any intermediate computations that
depend on them.<a href="#section-9.10-1" class="pilcrow">¶</a></p>
<p id="section-9.10-2">For example, the following routines should all be implemented in a side-channel
resistant manner.<a href="#section-9.10-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-9.10-3.1">
            <p id="section-9.10-3.1.1">Finite field arithmetic<a href="#section-9.10-3.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-9.10-3.2">
            <p id="section-9.10-3.2.1">XOFs<a href="#section-9.10-3.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-9.10-3.3">
            <p id="section-9.10-3.3.1">IDPF generation and evaluation, including handling of control bits<a href="#section-9.10-3.3.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
</section>
</div>
<div id="iana-considerations">
<section id="section-10">
      <h2 id="name-iana-considerations">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-10-1">IANA is requested to make one new registry:<a href="#section-10-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-10-2.1">
          <p id="section-10-2.1.1">DAF and VDAF Identifiers<a href="#section-10-2.1.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-10-3">This registry should be created under the heading "Verifiable Distributed
Aggregation Functions (VDAF)", and administered under the Specification Required
policy <span>[<a href="#RFC8126" class="cite xref">RFC8126</a>]</span>.<a href="#section-10-3" class="pilcrow">¶</a></p>
<p id="section-10-4">The "VDAF Identifiers" registry lists identifiers for Distributed Aggregation
Functions (DAFs) and Verifiable Distributed Aggregation Functions (VDAFs). These
identifiers are four-byte values, so the minimum possible value is <code>0x00000000</code>
and the maximum possible value is <code>0xffffffff</code>.<a href="#section-10-4" class="pilcrow">¶</a></p>
<p id="section-10-5">Template:<a href="#section-10-5" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-10-6.1">
          <p id="section-10-6.1.1">Value: The four-byte identifier for the DAF or VDAF<a href="#section-10-6.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-10-6.2">
          <p id="section-10-6.2.1">Scheme: The name of the DAF or VDAF<a href="#section-10-6.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-10-6.3">
          <p id="section-10-6.3.1">Type: Either "DAF" for a Distributed Aggregation Function or "VDAF" for a
Verifiable Distributed Aggregation Function<a href="#section-10-6.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-10-6.4">
          <p id="section-10-6.4.1">Reference: Where the algorithm is defined<a href="#section-10-6.4.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-10-7">The initial contents of the registry are as follows:<a href="#section-10-7" class="pilcrow">¶</a></p>
<span id="name-verifiable-distributed-aggr"></span><div id="codepoints">
<table class="center" id="table-18">
        <caption>
<a href="#table-18" class="selfRef">Table 18</a>:
<a href="#name-verifiable-distributed-aggr" class="selfRef">Verifiable Distributed Aggregation Function Identifiers Registry</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">Value</th>
            <th class="text-left" rowspan="1" colspan="1">Scheme</th>
            <th class="text-left" rowspan="1" colspan="1">Type</th>
            <th class="text-left" rowspan="1" colspan="1">Reference</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00000000</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Reserved</td>
            <td class="text-left" rowspan="1" colspan="1">n/a</td>
            <td class="text-left" rowspan="1" colspan="1">RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00000001</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Prio3Count</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#prio3count" class="auto internal xref">Section 7.4.1</a> of RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00000002</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Prio3Sum</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#prio3sum" class="auto internal xref">Section 7.4.2</a> of RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00000003</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Prio3SumVec</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#prio3sumvec" class="auto internal xref">Section 7.4.3</a> of RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00000004</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Prio3Histogram</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#prio3histogram" class="auto internal xref">Section 7.4.4</a> of RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00000005</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Prio3MultihotCountVec</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#prio3multihotcountvec" class="auto internal xref">Section 7.4.5</a> of RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0x00000006</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Poplar1</td>
            <td class="text-left" rowspan="1" colspan="1">VDAF</td>
            <td class="text-left" rowspan="1" colspan="1">
              <a href="#poplar1-construction" class="auto internal xref">Section 8.2</a> of RFC XXXX</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">
              <code>0xFFFF0000</code> to <code>0xFFFFFFFF</code>
</td>
            <td class="text-left" rowspan="1" colspan="1">Reserved for Private Use</td>
            <td class="text-left" rowspan="1" colspan="1">n/a</td>
            <td class="text-left" rowspan="1" colspan="1">n/a</td>
          </tr>
        </tbody>
      </table>
</div>
<p id="section-10-9">(RFC EDITOR: Please replace "RFC XXXX" above with the RFC number assigned to
this document.)<a href="#section-10-9" class="pilcrow">¶</a></p>
<p id="section-10-10">VDAF identifiers are used for domain separation, as described in
<a href="#dst-binder" class="auto internal xref">Section 6.2.3</a>. Domain separation guards against cross protocol attacks and
certain failures of entropy sources. See <a href="#deep" class="auto internal xref">Section 9.9</a>.<a href="#section-10-10" class="pilcrow">¶</a></p>
<p id="section-10-11">The benefits of domain separation are undermined if different VDAFs are used
with the same VDAF Identifier.  The "Reserved for Private Use" code points
should thus be used judiciously, because they provide no defense against such
collisions.  Applications <span class="bcp14">SHOULD</span> prefer the use of registered code points.<a href="#section-10-11" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-combined-references">
<section id="section-11">
      <h2 id="name-references">
<a href="#section-11" class="section-number selfRef">11. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<div id="sec-normative-references">
<section id="section-11.1">
        <h3 id="name-normative-references">
<a href="#section-11.1" class="section-number selfRef">11.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="AES">[AES]</dt>
        <dd>
<span class="refAuthor">Dworkin, M. J.</span>, <span class="refAuthor">Barker, E.</span>, <span class="refAuthor">Nechvatal, J. R.</span>, <span class="refAuthor">Foti, J.</span>, <span class="refAuthor">Bassham, L. E.</span>, <span class="refAuthor">Roback, E.</span>, and <span class="refAuthor">J. Dray Jr</span>, <span class="refTitle">"Advanced Encryption Standard (AES)"</span>, <time datetime="2001" class="refDate">2001</time>, <span>&lt;<a href="https://www.nist.gov/publications/advanced-encryption-standard-aes">https://www.nist.gov/publications/advanced-encryption-standard-aes</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc2119">https://www.rfc-editor.org/rfc/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8126">[RFC8126]</dt>
        <dd>
<span class="refAuthor">Cotton, M.</span>, <span class="refAuthor">Leiba, B.</span>, and <span class="refAuthor">T. Narten</span>, <span class="refTitle">"Guidelines for Writing an IANA Considerations Section in RFCs"</span>, <span class="seriesInfo">BCP 26</span>, <span class="seriesInfo">RFC 8126</span>, <span class="seriesInfo">DOI 10.17487/RFC8126</span>, <time datetime="2017-06" class="refDate">June 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc8126">https://www.rfc-editor.org/rfc/rfc8126</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
        <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc8174">https://www.rfc-editor.org/rfc/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8446">[RFC8446]</dt>
        <dd>
<span class="refAuthor">Rescorla, E.</span>, <span class="refTitle">"The Transport Layer Security (TLS) Protocol Version 1.3"</span>, <span class="seriesInfo">RFC 8446</span>, <span class="seriesInfo">DOI 10.17487/RFC8446</span>, <time datetime="2018-08" class="refDate">August 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/rfc/rfc8446">https://www.rfc-editor.org/rfc/rfc8446</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="TurboSHAKE">[TurboSHAKE]</dt>
      <dd>
<span class="refAuthor">Viguier, B.</span>, <span class="refAuthor">Wong, D.</span>, <span class="refAuthor">Van Assche, G.</span>, <span class="refAuthor">Dang, Q.</span>, and <span class="refAuthor">J. Daemen</span>, <span class="refTitle">"KangarooTwelve and TurboSHAKE"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-irtf-cfrg-kangarootwelve-17</span>, <time datetime="2025-02-21" class="refDate">21 February 2025</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-kangarootwelve-17">https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-kangarootwelve-17</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</div>
<div id="sec-informative-references">
<section id="section-11.2">
        <h3 id="name-informative-references">
<a href="#section-11.2" class="section-number selfRef">11.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="AGJOP21">[AGJOP21]</dt>
        <dd>
<span class="refAuthor">Addanki, S.</span>, <span class="refAuthor">Garbe, K.</span>, <span class="refAuthor">Jaffe, E.</span>, <span class="refAuthor">Ostrovsky, R.</span>, and <span class="refAuthor">A. Polychroniadou</span>, <span class="refTitle">"Prio+: Privacy Preserving Aggregate Statistics via Boolean Shares"</span>, <span class="refContent">Security and Cryptography for Networks (SCN)</span>, <time datetime="2022" class="refDate">2022</time>, <span>&lt;<a href="https://ia.cr/2021/576">https://ia.cr/2021/576</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="BBCGGI19">[BBCGGI19]</dt>
        <dd>
<span class="refAuthor">Boneh, D.</span>, <span class="refAuthor">Boyle, E.</span>, <span class="refAuthor">Corrigan-Gibbs, H.</span>, <span class="refAuthor">Gilboa, N.</span>, and <span class="refAuthor">Y. Ishai</span>, <span class="refTitle">"Zero-Knowledge Proofs on Secret-Shared Data via Fully Linear PCPs"</span>, <span class="refContent">Crypto</span>, <time datetime="2019" class="refDate">2019</time>, <span>&lt;<a href="https://ia.cr/2019/188">https://ia.cr/2019/188</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="BBCGGI21">[BBCGGI21]</dt>
        <dd>
<span class="refAuthor">Boneh, D.</span>, <span class="refAuthor">Boyle, E.</span>, <span class="refAuthor">Corrigan-Gibbs, H.</span>, <span class="refAuthor">Gilboa, N.</span>, and <span class="refAuthor">Y. Ishai</span>, <span class="refTitle">"Lightweight Techniques for Private Heavy Hitters"</span>, <span class="refContent">IEEE Security &amp; Privacy (S&amp;P)</span>, <time datetime="2021" class="refDate">2021</time>, <span>&lt;<a href="https://ia.cr/2021/017">https://ia.cr/2021/017</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="BBCGGI23">[BBCGGI23]</dt>
        <dd>
<span class="refAuthor">Boneh, D.</span>, <span class="refAuthor">Boyle, E.</span>, <span class="refAuthor">Corrigan-Gibbs, H.</span>, <span class="refAuthor">Gilboa, N.</span>, and <span class="refAuthor">Y. Ishai</span>, <span class="refTitle">"Arithmetic Sketching"</span>, <span class="refContent">Crypto</span>, <time datetime="2023" class="refDate">2023</time>, <span>&lt;<a href="https://ia.cr/2023/1012">https://ia.cr/2023/1012</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="BGI15">[BGI15]</dt>
        <dd>
<span class="refAuthor">Boyle, E.</span>, <span class="refAuthor">Gilboa, N.</span>, and <span class="refAuthor">Y. Ishai</span>, <span class="refTitle">"Function Secret Sharing"</span>, <span class="refContent">Eurocrypt</span>, <time datetime="2015" class="refDate">2015</time>, <span>&lt;<a href="https://www.iacr.org/archive/eurocrypt2015/90560300/90560300.pdf">https://www.iacr.org/archive/eurocrypt2015/90560300/90560300.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="CGB17">[CGB17]</dt>
        <dd>
<span class="refAuthor">Boneh, D.</span> and <span class="refAuthor">H. Corrigan-Gibbs</span>, <span class="refTitle">"Prio: Private, Robust, and Scalable Computation of Aggregate Statistics"</span>, <span class="refContent">USENIX Symposium on Networked Systems Design and Implementation (NSDI)</span>, <time datetime="2017" class="refDate">2017</time>, <span>&lt;<a href="https://dl.acm.org/doi/10.5555/3154630.3154652">https://dl.acm.org/doi/10.5555/3154630.3154652</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="DAP">[DAP]</dt>
        <dd>
<span class="refAuthor">Geoghegan, T.</span>, <span class="refAuthor">Patton, C.</span>, <span class="refAuthor">Pitman, B.</span>, <span class="refAuthor">Rescorla, E.</span>, and <span class="refAuthor">C. A. Wood</span>, <span class="refTitle">"Distributed Aggregation Protocol for Privacy Preserving Measurement"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-ppm-dap-15</span>, <time datetime="2025-04-29" class="refDate">29 April 2025</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-ppm-dap-15">https://datatracker.ietf.org/doc/html/draft-ietf-ppm-dap-15</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Dou02">[Dou02]</dt>
        <dd>
<span class="refAuthor">Douceur, J. R.</span>, <span class="refTitle">"The Sybil Attack"</span>, <span class="refContent">International Workshop on Peer-to-Peer Systems (IPTPS)</span>, <time datetime="2002" class="refDate">2002</time>, <span>&lt;<a href="https://doi.org/10.1007/3-540-45748-8_24">https://doi.org/10.1007/3-540-45748-8_24</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="DPRS23">[DPRS23]</dt>
        <dd>
<span class="refAuthor">Hannah Davis</span>, <span class="refAuthor">Christopher Patton</span>, <span class="refAuthor">Mike Rosulek</span>, and <span class="refAuthor">Phillipp Schoppmann</span>, <span class="refTitle">"Verifiable Distributed Aggregation Functions"</span>, <span class="refContent">Privacy Enhancing Technologies Symposium (PETS)</span>, <time datetime="2023" class="refDate">2023</time>, <span>&lt;<a href="https://ia.cr/2023/130">https://ia.cr/2023/130</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Dwo06">[Dwo06]</dt>
        <dd>
<span class="refAuthor">Cynthia Dwork</span>, <span class="refTitle">"Differential Privacy"</span>, <span class="refContent">International Colloquium on Automata, Languages, and Programming (ICALP)</span>, <time datetime="2006" class="refDate">2006</time>, <span>&lt;<a href="https://link.springer.com/chapter/10.1007/11787006_1">https://link.springer.com/chapter/10.1007/11787006_1</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="ENPA">[ENPA]</dt>
        <dd>
<span class="refTitle">"Exposure Notification Privacy-preserving Analytics (ENPA) White Paper"</span>, <time datetime="2021" class="refDate">2021</time>, <span>&lt;<a href="https://covid19-static.cdn-apple.com/applications/covid19/current/static/contact-tracing/pdf/ENPA_White_Paper.pdf">https://covid19-static.cdn-apple.com/applications/covid19/current/static/contact-tracing/pdf/ENPA_White_Paper.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="EPK14">[EPK14]</dt>
        <dd>
<span class="refAuthor">Erlingsson, Ú.</span>, <span class="refAuthor">Pihur, V.</span>, and <span class="refAuthor">A. Korolova</span>, <span class="refTitle">"RAPPOR: Randomized Aggregatable Privacy-Preserving Ordinal Response"</span>, <span class="refContent">ACM Conference on Computer and Communications Security (CCS)</span>, <time datetime="2014" class="refDate">2014</time>, <span>&lt;<a href="https://dl.acm.org/doi/10.1145/2660267.2660348">https://dl.acm.org/doi/10.1145/2660267.2660348</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="GI14">[GI14]</dt>
        <dd>
<span class="refAuthor">Gilboa, N.</span> and <span class="refAuthor">Y. Ishai</span>, <span class="refTitle">"Distributed Point Functions and Their Applications"</span>, <span class="refContent">Eurocrypt</span>, <time datetime="2014" class="refDate">2014</time>, <span>&lt;<a href="https://link.springer.com/chapter/10.1007/978-3-642-55220-5_35">https://link.springer.com/chapter/10.1007/978-3-642-55220-5_35</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="GKWWY20">[GKWWY20]</dt>
        <dd>
<span class="refAuthor">Guo, C.</span>, <span class="refAuthor">Katz, J.</span>, <span class="refAuthor">Wang, X.</span>, <span class="refAuthor">Weng, C.</span>, and <span class="refAuthor">Y. Yu</span>, <span class="refTitle">"Better concrete security for half-gates garbling (in the multi-instance setting)"</span>, <span class="refContent">Crypto</span>, <time datetime="2020" class="refDate">2020</time>, <span>&lt;<a href="https://link.springer.com/chapter/10.1007/978-3-030-56880-1_28">https://link.springer.com/chapter/10.1007/978-3-030-56880-1_28</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="GKWY20">[GKWY20]</dt>
        <dd>
<span class="refAuthor">Guo, C.</span>, <span class="refAuthor">Katz, J.</span>, <span class="refAuthor">Wang, X.</span>, and <span class="refAuthor">Y. Yu</span>, <span class="refTitle">"Efficient and Secure Multiparty Computation from Fixed-Key Block Ciphers"</span>, <span class="refContent">IEEE Security &amp; Privacy (S&amp;P)</span>, <time datetime="2020" class="refDate">2020</time>, <span>&lt;<a href="https://eprint.iacr.org/2019/074">https://eprint.iacr.org/2019/074</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="GSZ20">[GSZ20]</dt>
        <dd>
<span class="refAuthor">Goyal, V.</span>, <span class="refAuthor">Song, Y.</span>, and <span class="refAuthor">C. Zhu</span>, <span class="refTitle">"Guaranteed Output Delivery Comes Free in Honest Majority MPC"</span>, <span class="refContent">Crypto</span>, <time datetime="2020" class="refDate">2020</time>, <span>&lt;<a href="https://link.springer.com/chapter/10.1007/978-3-030-56880-1_22">https://link.springer.com/chapter/10.1007/978-3-030-56880-1_22</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="MPDST25">[MPDST25]</dt>
        <dd>
<span class="refAuthor">Mouris, D.</span>, <span class="refAuthor">Patton, C.</span>, <span class="refAuthor">Davis, H.</span>, <span class="refAuthor">Sarkar, P.</span>, and <span class="refAuthor">N. G. Tsoutsos</span>, <span class="refTitle">"Mastic: Private Weighted Heavy-Hitters and Attribute-Based Metrics"</span>, <span class="refContent">Privacy Enhancing Technologies Symposium (PETS)</span>, <time datetime="2025" class="refDate">2025</time>, <span>&lt;<a href="https://eprint.iacr.org/2024/221">https://eprint.iacr.org/2024/221</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="MPRV09">[MPRV09]</dt>
        <dd>
<span class="refAuthor">Mironov, I.</span>, <span class="refAuthor">Pandey, O.</span>, <span class="refAuthor">Reingold, O.</span>, and <span class="refAuthor">S. Vadhan</span>, <span class="refTitle">"Computational Differential Privacy"</span>, <span class="refContent">Crypto</span>, <time datetime="2009" class="refDate">2009</time>, <span>&lt;<a href="https://link.springer.com/chapter/10.1007/978-3-642-03356-8_8">https://link.springer.com/chapter/10.1007/978-3-642-03356-8_8</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="MRH04">[MRH04]</dt>
        <dd>
<span class="refAuthor">Maurer, U.</span>, <span class="refAuthor">Renner, R.</span>, and <span class="refAuthor">C. Holenstein</span>, <span class="refTitle">"Indifferentiability, impossibility results on reductions, and applications to the random oracle methodology"</span>, <span class="refContent">Theory of Cryptography (TCC)</span>, <time datetime="2004" class="refDate">2004</time>, <span>&lt;<a href="https://doi.org/10.1007/978-3-540-24638-1_2">https://doi.org/10.1007/978-3-540-24638-1_2</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="OriginTelemetry">[OriginTelemetry]</dt>
        <dd>
<span class="refTitle">"Origin Telemetry"</span>, <time datetime="2020" class="refDate">2020</time>, <span>&lt;<a href="https://web.archive.org/web/20221025174046/https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/collection/origin.html">https://web.archive.org/web/20221025174046/https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/collection/origin.html</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="SML24">[SML24]</dt>
        <dd>
<span class="refAuthor">Satriawan, A.</span>, <span class="refAuthor">Mareta, R.</span>, and <span class="refAuthor">H. Lee</span>, <span class="refTitle">"A Complete Beginner Guide to the Number Theoretic Transform (NTT)"</span>, <span class="refContent">IEEE Access, vol. 11</span>, <time datetime="2024" class="refDate">2024</time>, <span>&lt;<a href="https://eprint.iacr.org/2024/585">https://eprint.iacr.org/2024/585</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="TestVectors">[TestVectors]</dt>
      <dd>
<span class="refTitle">"Test vectors for Prio3 and Poplar1"</span>, <span class="refContent">commit hash 5b7df1d</span>, <time datetime="2024-12" class="refDate">December 2024</time>, <span>&lt;<a href="https://github.com/cfrg/draft-irtf-cfrg-vdaf">https://github.com/cfrg/draft-irtf-cfrg-vdaf</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</div>
</section>
</div>
<div id="gadgets">
<section id="appendix-A">
      <h2 id="name-flp-gadgets">
<a href="#appendix-A" class="section-number selfRef">Appendix A. </a><a href="#name-flp-gadgets" class="section-name selfRef">FLP Gadgets</a>
      </h2>
<p id="appendix-A-1">This section defines gadgets used to specify variants of Prio3 defined in
<a href="#prio3-instantiations" class="auto internal xref">Section 7.4</a> and to construct FLPs as defined in <a href="#flp-bbcggi19" class="auto internal xref">Section 7.3</a>.<a href="#appendix-A-1" class="pilcrow">¶</a></p>
<div id="gadget-mul">
<section id="appendix-A.1">
        <h3 id="name-multiplication">
<a href="#appendix-A.1" class="section-number selfRef">A.1. </a><a href="#name-multiplication" class="section-name selfRef">Multiplication</a>
        </h3>
<p id="appendix-A.1-1">The multiplication gadget takes in a pair of inputs and multiplies them
together. The degree of this circuit is <code>2</code>.<a href="#appendix-A.1-1" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="appendix-A.1-2">
<pre>
class Mul(Gadget[F]):
    ARITY = 2
    DEGREE = 2

    def eval(self, _field: type[F], inp: list[F]) -&gt; F:
        return inp[0] * inp[1]

    def eval_poly(self,
                  field: type[F],
                  inp_poly: list[list[F]]) -&gt; list[F]:
        return poly_mul(field, inp_poly[0], inp_poly[1])
</pre><a href="#appendix-A.1-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="gadget-poly-eval">
<section id="appendix-A.2">
        <h3 id="name-polynomial-evaluation">
<a href="#appendix-A.2" class="section-number selfRef">A.2. </a><a href="#name-polynomial-evaluation" class="section-name selfRef">Polynomial Evaluation</a>
        </h3>
<p id="appendix-A.2-1">The polynomial-evaluation gadget takes in a single input <code>x</code> and returns
<code>p(x)</code>, where <code>p</code> is a polynomial specified by the user. Its degree is the same
as <code>p</code>.<a href="#appendix-A.2-1" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="appendix-A.2-2">
<pre>
class PolyEval(Gadget[F]):
    ARITY = 1
    p: list[int]  # polynomial coefficients

    def __init__(self, p: list[int]):
        """
        Instantiate this gadget with the given polynomial.
        """
        # Strip leading zeros.
        for i in reversed(range(len(p))):
            if p[i] != 0:
                p = p[:i+1]
                break
        if len(p) &lt; 1:
            raise ValueError('invalid polynomial: zero length')

        self.p = p
        self.DEGREE = len(p) - 1

    def eval(self, field: type[F], inp: list[F]) -&gt; F:
        p = [field(coeff) for coeff in self.p]
        return poly_eval(field, p, inp[0])

    def eval_poly(self,
                  field: type[F],
                  inp_poly: list[list[F]]) -&gt; list[F]:
        p = [field(coeff) for coeff in self.p]
        out = [field(0)] * (self.DEGREE * len(inp_poly[0]))
        out[0] = p[0]
        x = inp_poly[0]
        for i in range(1, len(p)):
            for j in range(len(x)):
                out[j] += p[i] * x[j]
            x = poly_mul(field, x, inp_poly[0])
        return poly_strip(field, out)
</pre><a href="#appendix-A.2-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="gadget-parallel-sum">
<section id="appendix-A.3">
        <h3 id="name-parallel-sum">
<a href="#appendix-A.3" class="section-number selfRef">A.3. </a><a href="#name-parallel-sum" class="section-name selfRef">Parallel Sum</a>
        </h3>
<p id="appendix-A.3-1">The parallel-sum gadget applies a subcircuit to multiple inputs in parallel,
then returns the sum of the results. The arity of the gadget is equal to <code>count</code>
times the arity of the subcircuit, where <code>count</code> denotes the number of times the
subcircuit is called. The degree of the gadget is equal to the degree of the
subcircuit.<a href="#appendix-A.3-1" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="appendix-A.3-2">
<pre>
class ParallelSum(Gadget[F]):
    subcircuit: Gadget[F]
    count: int

    def __init__(self, subcircuit: Gadget[F], count: int):
        self.subcircuit = subcircuit
        self.count = count
        self.ARITY = subcircuit.ARITY * count
        self.DEGREE = subcircuit.DEGREE

    def eval(self, field: type[F], inp: list[F]) -&gt; F:
        out = field(0)
        for i in range(self.count):
            start_index = i * self.subcircuit.ARITY
            end_index = (i + 1) * self.subcircuit.ARITY
            out += self.subcircuit.eval(
                field,
                inp[start_index:end_index],
            )
        return out

    def eval_poly(self,
                  field: type[F],
                  inp_poly: list[list[F]]) -&gt; list[F]:
        output_poly_length = self.DEGREE * (len(inp_poly[0]) - 1) + 1
        out_sum = [field(0) for _ in range(output_poly_length)]
        for i in range(self.count):
            start_index = i * self.subcircuit.ARITY
            end_index = (i + 1) * self.subcircuit.ARITY
            out_current = self.subcircuit.eval_poly(
                field,
                inp_poly[start_index:end_index]
            )
            for j in range(output_poly_length):
                out_sum[j] += out_current[j]
        return poly_strip(field, out_sum)
</pre><a href="#appendix-A.3-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="gadget-wrappers">
<section id="appendix-A.4">
        <h3 id="name-shims-for-generating-and-qu">
<a href="#appendix-A.4" class="section-number selfRef">A.4. </a><a href="#name-shims-for-generating-and-qu" class="section-name selfRef">Shims for Generating and Querying Proofs</a>
        </h3>
<p id="appendix-A.4-1">This section specifies two "shim" gadgets, one for generating an FLP as
specified in <a href="#flp-bbcggi19-construction-prove" class="auto internal xref">Section 7.3.3</a> and another for querying an FLP
as specified in <a href="#flp-bbcggi19-construction-query" class="auto internal xref">Section 7.3.4</a>.<a href="#appendix-A.4-1" class="pilcrow">¶</a></p>
<div class="breakable lang-python sourcecode" id="appendix-A.4-2">
<pre>
class ProveGadget(Gadget[F]):
    """
    Gadget wrapper that records the input wires for each evaluation.
    """

    def __init__(self,
                 field: type[F],
                 wire_seeds: list[F],
                 g: Gadget[F],
                 g_calls: int):
        p = next_power_of_2(1 + g_calls)
        self.inner = g
        self.ARITY = g.ARITY
        self.DEGREE = g.DEGREE
        self.wires = []
        self.k = 0  # evaluation counter
        for s in wire_seeds:
            wire = field.zeros(p)
            wire[0] = s  # set the wire seed
            self.wires.append(wire)

    def eval(self, field: type[F], inp: list[F]) -&gt; F:
        self.k += 1
        for j in range(len(inp)):
            self.wires[j][self.k] = inp[j]
        return self.inner.eval(field, inp)

    def eval_poly(self,
                  field: type[F],
                  inp_poly: list[list[F]]) -&gt; list[F]:
        return self.inner.eval_poly(field, inp_poly)

    @classmethod
    def wrap(cls,
             valid: Valid[Measurement, AggResult, F],
             prove_rand: list[F],
             ) -&gt; Valid[Measurement, AggResult, F]:
        """
        Make a copy of `valid` with each gadget wrapped for recording
        the wire inputs. `prove_rand` is used to produce the wire
        seeds for each gadget.
        """
        wrapped_gadgets: list[Gadget[F]] = []
        for (g, g_calls) in zip(valid.GADGETS, valid.GADGET_CALLS):
            (wire_seeds, prove_rand) = front(g.ARITY, prove_rand)
            wrapped = cls(valid.field, wire_seeds, g, g_calls)
            wrapped_gadgets.append(wrapped)
        wrapped_valid = deepcopy(valid)
        wrapped_valid.GADGETS = wrapped_gadgets
        return wrapped_valid

class QueryGadget(Gadget[F]):
    """
    Gadget wrapper that records the input wires for each evaluation.
    Rather than evaluate the circuit, use the provided gadget
    polynomial to produce the output.
    """

    def __init__(
            self,
            field: type[F],
            wire_seeds: list[F],
            gadget_poly: list[F],
            g: Gadget[F],
            g_calls: int):
        p = next_power_of_2(1 + g_calls)
        self.alpha = field.gen() ** (field.GEN_ORDER // p)
        self.poly = gadget_poly
        self.ARITY = g.ARITY
        self.DEGREE = g.DEGREE
        self.wires = []
        self.k = 0
        for s in wire_seeds:
            wire = field.zeros(p)
            wire[0] = s  # set the wire seed
            self.wires.append(wire)

    def eval(self, field: type[F], inp: list[F]) -&gt; F:
        self.k += 1
        for j in range(len(inp)):
            self.wires[j][self.k] = inp[j]
        return poly_eval(field, self.poly, self.alpha ** self.k)

    @classmethod
    def wrap(cls,
             valid: Valid[Measurement, AggResult, F],
             proof: list[F]) -&gt; Valid[Measurement, AggResult, F]:
        wrapped_gadgets: list[Gadget[F]] = []
        for (g, g_calls) in zip(valid.GADGETS, valid.GADGET_CALLS):
            p = next_power_of_2(1 + g_calls)
            gadget_poly_len = g.DEGREE * (p - 1) + 1
            (wire_seeds, proof) = front(g.ARITY, proof)
            (gadget_poly, proof) = front(gadget_poly_len, proof)
            wrapped = cls(valid.field,
                          wire_seeds,
                          gadget_poly,
                          g,
                          g_calls)
            wrapped_gadgets.append(wrapped)
        wrapped_valid = deepcopy(valid)
        wrapped_valid.GADGETS = wrapped_gadgets
        return wrapped_valid
</pre><a href="#appendix-A.4-2" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="topo-states">
<section id="appendix-B">
      <h2 id="name-vdaf-preparation-state">
<a href="#appendix-B" class="section-number selfRef">Appendix B. </a><a href="#name-vdaf-preparation-state" class="section-name selfRef">VDAF Preparation State</a>
      </h2>
<p id="appendix-B-1">This section lists the classes used to define each Aggregator's state during
VDAF preparation (<a href="#vdaf-prep-comm" class="auto internal xref">Section 5.7</a>).<a href="#appendix-B-1" class="pilcrow">¶</a></p>
<div class="lang-python sourcecode" id="appendix-B-2">
<pre>
class State:
    pass

class Start(State):
    pass

class Continued(State, Generic[PrepState]):
    def __init__(self,
                 prep_state: PrepState,
                 prep_round: int,
                 outbound: bytes):
        self.prep_state = prep_state
        self.prep_round = prep_round
        self.outbound = outbound

    def __eq__(self, other: object) -&gt; bool:
        return isinstance(other, Continued) and \
            self.prep_state == other.prep_state and \
            self.prep_round == other.prep_round and \
            self.outbound == other.outbound

class Finished(State, Generic[OutShare]):
    def __init__(self, out_share: OutShare):
        self.out_share = out_share

    def __eq__(self, other: object) -&gt; bool:
        return isinstance(other, Finished) and \
            self.out_share == other.out_share

class FinishedWithOutbound(State, Generic[OutShare]):
    def __init__(self, out_share: OutShare, outbound: bytes):
        self.out_share = out_share
        self.outbound = outbound

    def __eq__(self, other: object) -&gt; bool:
        return isinstance(other, FinishedWithOutbound) and \
            self.out_share == other.out_share and \
            self.outbound == other.outbound

class Rejected(State):
    pass
</pre><a href="#appendix-B-2" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="test-vectors">
<section id="appendix-C">
      <h2 id="name-test-vectors">
<a href="#appendix-C" class="section-number selfRef">Appendix C. </a><a href="#name-test-vectors" class="section-name selfRef">Test Vectors</a>
      </h2>
<p id="appendix-C-1">Test vectors for Prio3 (<a href="#prio3" class="auto internal xref">Section 7</a>) and Poplar1 (<a href="#poplar1" class="auto internal xref">Section 8</a>) are available at
<span>[<a href="#TestVectors" class="cite xref">TestVectors</a>]</span>. The test vector directory, <code>test_vec/vdaf</code>, contains a set of
JSON files. Each file contains a test vector for an instance of class <code>Vdaf</code> as
defined in <a href="#vdaf" class="auto internal xref">Section 5</a>. A test vector covers sharding, preparation, aggregation,
and unsharding of a batch of several measurements. The test vector schema is
defined below.<a href="#appendix-C-1" class="pilcrow">¶</a></p>
<div id="schema">
<section id="appendix-C.1">
        <h3 id="name-schema">
<a href="#appendix-C.1" class="section-number selfRef">C.1. </a><a href="#name-schema" class="section-name selfRef">Schema</a>
        </h3>
<span class="break"></span><dl class="dlParallel" id="appendix-C.1-1">
          <dt id="appendix-C.1-1.1">
<code>ctx</code>:</dt>
          <dd style="margin-left: 1.5em" id="appendix-C.1-1.2">
            <p id="appendix-C.1-1.2.1">The application context string encoded in hexadecimal.<a href="#appendix-C.1-1.2.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="appendix-C.1-1.3">
<code>verify_key</code>:</dt>
          <dd style="margin-left: 1.5em" id="appendix-C.1-1.4">
            <p id="appendix-C.1-1.4.1">The verification key encoded in hexadecimal.<a href="#appendix-C.1-1.4.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="appendix-C.1-1.5">
<code>agg_param</code>:</dt>
          <dd style="margin-left: 1.5em" id="appendix-C.1-1.6">
            <p id="appendix-C.1-1.6.1">The aggregation parameter encoded in hexadecimal.<a href="#appendix-C.1-1.6.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="appendix-C.1-1.7">
<code>prep</code>:</dt>
          <dd style="margin-left: 1.5em" id="appendix-C.1-1.8">
            <p id="appendix-C.1-1.8.1">A list of objects with the following schema:<a href="#appendix-C.1-1.8.1" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="appendix-C.1-1.8.2">
              <dt id="appendix-C.1-1.8.2.1">
<code>measurement</code>:</dt>
              <dd style="margin-left: 1.5em" id="appendix-C.1-1.8.2.2">
                <p id="appendix-C.1-1.8.2.2.1">The measurement of type <code>Measurement</code> defined by the VDAF.<a href="#appendix-C.1-1.8.2.2.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="appendix-C.1-1.8.2.3">
<code>nonce</code>:</dt>
              <dd style="margin-left: 1.5em" id="appendix-C.1-1.8.2.4">
                <p id="appendix-C.1-1.8.2.4.1">The nonce encoded in hexadecimal.<a href="#appendix-C.1-1.8.2.4.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="appendix-C.1-1.8.2.5">
<code>rand</code>:</dt>
              <dd style="margin-left: 1.5em" id="appendix-C.1-1.8.2.6">
                <p id="appendix-C.1-1.8.2.6.1">The sharding randomness encoded in hexadecimal.<a href="#appendix-C.1-1.8.2.6.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="appendix-C.1-1.8.2.7">
<code>public_share</code>:</dt>
              <dd style="margin-left: 1.5em" id="appendix-C.1-1.8.2.8">
                <p id="appendix-C.1-1.8.2.8.1">The expected public share encoded in hexadecimal.<a href="#appendix-C.1-1.8.2.8.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="appendix-C.1-1.8.2.9">
<code>input_shares</code>:</dt>
              <dd style="margin-left: 1.5em" id="appendix-C.1-1.8.2.10">
                <p id="appendix-C.1-1.8.2.10.1">The expected list of input shares, each encoded in hexadecimal.<a href="#appendix-C.1-1.8.2.10.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="appendix-C.1-1.8.2.11">
<code>prep_shares</code>:</dt>
              <dd style="margin-left: 1.5em" id="appendix-C.1-1.8.2.12">
                <p id="appendix-C.1-1.8.2.12.1">The expected list of prep shares generated by each Aggregator at each
round of preparation, encoded in hexadecimal.<a href="#appendix-C.1-1.8.2.12.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="appendix-C.1-1.8.2.13">
<code>prep_messages</code>:</dt>
              <dd style="margin-left: 1.5em" id="appendix-C.1-1.8.2.14">
                <p id="appendix-C.1-1.8.2.14.1">The expected list of prep messages for each round of preparation, encoded
in hexadecimal.<a href="#appendix-C.1-1.8.2.14.1" class="pilcrow">¶</a></p>
</dd>
              <dd class="break"></dd>
<dt id="appendix-C.1-1.8.2.15">
<code>out_shares</code>:</dt>
              <dd style="margin-left: 1.5em" id="appendix-C.1-1.8.2.16">
                <p id="appendix-C.1-1.8.2.16.1">The expected list of output shares, encoded in hexadecimal.<a href="#appendix-C.1-1.8.2.16.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
</dl>
</dd>
          <dd class="break"></dd>
<dt id="appendix-C.1-1.9">
<code>agg_shares</code>:</dt>
          <dd style="margin-left: 1.5em" id="appendix-C.1-1.10">
            <p id="appendix-C.1-1.10.1">The expected aggregate shares encoded in hexadecimal.<a href="#appendix-C.1-1.10.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="appendix-C.1-1.11">
<code>agg_result</code>:</dt>
          <dd style="margin-left: 1.5em" id="appendix-C.1-1.12">
            <p id="appendix-C.1-1.12.1">The expected aggregate result of type <code>AggResult</code> defined by the VDAF.<a href="#appendix-C.1-1.12.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="appendix-C.1-1.13">
<code>operations</code>:</dt>
          <dd style="margin-left: 1.5em" id="appendix-C.1-1.14">
            <p id="appendix-C.1-1.14.1">This lists the VDAF operations that should be executed as part of known
answer tests, using messages from this test vector as input. Operations
should be executed in the order they appear, to ensure that prepare state
values are computed before they are consumed. Prepare state values are not
included in test vectors because this document does not specify their
representation or encoding.<a href="#appendix-C.1-1.14.1" class="pilcrow">¶</a></p>
</dd>
        <dd class="break"></dd>
</dl>
<p id="appendix-C.1-2">Each operation in the <code>operations</code> list has the following schema:<a href="#appendix-C.1-2" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlParallel" id="appendix-C.1-3">
          <dt id="appendix-C.1-3.1">
<code>operation</code>:</dt>
          <dd style="margin-left: 1.5em" id="appendix-C.1-3.2">
            <p id="appendix-C.1-3.2.1">The type of operation to be performed. This is one of "shard", "prep_init",
"prep_shares_to_prep", "prep_next", "aggregate", or "unshard".<a href="#appendix-C.1-3.2.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="appendix-C.1-3.3">
<code>round</code>:</dt>
          <dd style="margin-left: 1.5em" id="appendix-C.1-3.4">
            <p id="appendix-C.1-3.4.1">For any preparation operation, the round number of the operation to be
performed. This determines which prepare share, prepare state, and/or prepare
message to use.<a href="#appendix-C.1-3.4.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="appendix-C.1-3.5">
<code>aggregator_id</code>:</dt>
          <dd style="margin-left: 1.5em" id="appendix-C.1-3.6">
            <p id="appendix-C.1-3.6.1">The aggregator ID to use when performing this operation. This determines
which messages and which prepare state to use, in addition to the aggregator ID
argument itself.<a href="#appendix-C.1-3.6.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="appendix-C.1-3.7">
<code>report_index</code>:</dt>
          <dd style="margin-left: 1.5em" id="appendix-C.1-3.8">
            <p id="appendix-C.1-3.8.1">The index of the report on which to perform this operation. This is an index
into the <code>prep</code> array.<a href="#appendix-C.1-3.8.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
<dt id="appendix-C.1-3.9">
<code>success</code>:</dt>
          <dd style="margin-left: 1.5em" id="appendix-C.1-3.10">
            <p id="appendix-C.1-3.10.1">If this is <code>True</code>, the operation should succeed, and its output should match
the corresponding values in the test vector. If this is <code>False</code>, the operation
should fail, terminating preparation of this report.<a href="#appendix-C.1-3.10.1" class="pilcrow">¶</a></p>
</dd>
        <dd class="break"></dd>
</dl>
<p id="appendix-C.1-4">The test vector schema also includes whatever parameters are required to
instantiate the VDAF. These are listed in the subsections below.<a href="#appendix-C.1-4" class="pilcrow">¶</a></p>
<div id="prio3count-1">
<section id="appendix-C.1.1">
          <h4 id="name-prio3count-2">
<a href="#appendix-C.1.1" class="section-number selfRef">C.1.1. </a><a href="#name-prio3count-2" class="section-name selfRef">Prio3Count</a>
          </h4>
<span class="break"></span><dl class="dlParallel" id="appendix-C.1.1-1">
            <dt id="appendix-C.1.1-1.1">
<code>shares</code>:</dt>
            <dd style="margin-left: 1.5em" id="appendix-C.1.1-1.2">
              <p id="appendix-C.1.1-1.2.1">The number of shares, an integer.<a href="#appendix-C.1.1-1.2.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
<div id="prio3sum-1">
<section id="appendix-C.1.2">
          <h4 id="name-prio3sum-2">
<a href="#appendix-C.1.2" class="section-number selfRef">C.1.2. </a><a href="#name-prio3sum-2" class="section-name selfRef">Prio3Sum</a>
          </h4>
<span class="break"></span><dl class="dlParallel" id="appendix-C.1.2-1">
            <dt id="appendix-C.1.2-1.1">
<code>shares</code>:</dt>
            <dd style="margin-left: 1.5em" id="appendix-C.1.2-1.2">
              <p id="appendix-C.1.2-1.2.1">The number of shares, an integer.<a href="#appendix-C.1.2-1.2.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="appendix-C.1.2-1.3">
<code>max_measurement</code>:</dt>
            <dd style="margin-left: 1.5em" id="appendix-C.1.2-1.4">
              <p id="appendix-C.1.2-1.4.1">The largest valid measurement, an integer. Each measurement is in the range
  <code>[0, max_measurement]</code>.<a href="#appendix-C.1.2-1.4.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
<div id="prio3sumvec-1">
<section id="appendix-C.1.3">
          <h4 id="name-prio3sumvec-2">
<a href="#appendix-C.1.3" class="section-number selfRef">C.1.3. </a><a href="#name-prio3sumvec-2" class="section-name selfRef">Prio3SumVec</a>
          </h4>
<span class="break"></span><dl class="dlParallel" id="appendix-C.1.3-1">
            <dt id="appendix-C.1.3-1.1">
<code>shares</code>:</dt>
            <dd style="margin-left: 1.5em" id="appendix-C.1.3-1.2">
              <p id="appendix-C.1.3-1.2.1">The number of shares, an integer.<a href="#appendix-C.1.3-1.2.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="appendix-C.1.3-1.3">
<code>length</code>:</dt>
            <dd style="margin-left: 1.5em" id="appendix-C.1.3-1.4">
              <p id="appendix-C.1.3-1.4.1">The length of the vector, an integer.<a href="#appendix-C.1.3-1.4.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="appendix-C.1.3-1.5">
<code>chunk_length</code>:</dt>
            <dd style="margin-left: 1.5em" id="appendix-C.1.3-1.6">
              <p id="appendix-C.1.3-1.6.1">a parameter of the ParallelSum gadget, an integer.<a href="#appendix-C.1.3-1.6.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="appendix-C.1.3-1.7">
<code>bits</code>:</dt>
            <dd style="margin-left: 1.5em" id="appendix-C.1.3-1.8">
              <p id="appendix-C.1.3-1.8.1">the bit length of each element of the vector, an integer. Each element is in
the range <code>[0, 2^bits)</code>.<a href="#appendix-C.1.3-1.8.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
<div id="prio3histogram-1">
<section id="appendix-C.1.4">
          <h4 id="name-prio3histogram-2">
<a href="#appendix-C.1.4" class="section-number selfRef">C.1.4. </a><a href="#name-prio3histogram-2" class="section-name selfRef">Prio3Histogram</a>
          </h4>
<span class="break"></span><dl class="dlParallel" id="appendix-C.1.4-1">
            <dt id="appendix-C.1.4-1.1">
<code>shares</code>:</dt>
            <dd style="margin-left: 1.5em" id="appendix-C.1.4-1.2">
              <p id="appendix-C.1.4-1.2.1">The number of shares, an integer.<a href="#appendix-C.1.4-1.2.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="appendix-C.1.4-1.3">
<code>length</code>:</dt>
            <dd style="margin-left: 1.5em" id="appendix-C.1.4-1.4">
              <p id="appendix-C.1.4-1.4.1">The length of the vector, an integer.<a href="#appendix-C.1.4-1.4.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="appendix-C.1.4-1.5">
<code>chunk_length</code>:</dt>
            <dd style="margin-left: 1.5em" id="appendix-C.1.4-1.6">
              <p id="appendix-C.1.4-1.6.1">a parameter of the ParallelSum gadget, an integer.<a href="#appendix-C.1.4-1.6.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
<div id="prio3multihotcountvec-1">
<section id="appendix-C.1.5">
          <h4 id="name-prio3multihotcountvec-2">
<a href="#appendix-C.1.5" class="section-number selfRef">C.1.5. </a><a href="#name-prio3multihotcountvec-2" class="section-name selfRef">Prio3MultihotCountVec</a>
          </h4>
<span class="break"></span><dl class="dlParallel" id="appendix-C.1.5-1">
            <dt id="appendix-C.1.5-1.1">
<code>shares</code>:</dt>
            <dd style="margin-left: 1.5em" id="appendix-C.1.5-1.2">
              <p id="appendix-C.1.5-1.2.1">The number of shares, an integer.<a href="#appendix-C.1.5-1.2.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="appendix-C.1.5-1.3">
<code>length</code>:</dt>
            <dd style="margin-left: 1.5em" id="appendix-C.1.5-1.4">
              <p id="appendix-C.1.5-1.4.1">The length of the vector, an integer.<a href="#appendix-C.1.5-1.4.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="appendix-C.1.5-1.5">
<code>chunk_length</code>:</dt>
            <dd style="margin-left: 1.5em" id="appendix-C.1.5-1.6">
              <p id="appendix-C.1.5-1.6.1">a parameter of the ParallelSum gadget, an integer.<a href="#appendix-C.1.5-1.6.1" class="pilcrow">¶</a></p>
</dd>
            <dd class="break"></dd>
<dt id="appendix-C.1.5-1.7">
<code>max_weight</code>:</dt>
            <dd style="margin-left: 1.5em" id="appendix-C.1.5-1.8">
              <p id="appendix-C.1.5-1.8.1">The largest vector weight, an integer. The sum of the elements of the
measurement must be in the range <code>[0, max_weight]</code>.<a href="#appendix-C.1.5-1.8.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
<div id="poplar1-test-vec-param">
<section id="appendix-C.1.6">
          <h4 id="name-poplar1-2">
<a href="#appendix-C.1.6" class="section-number selfRef">C.1.6. </a><a href="#name-poplar1-2" class="section-name selfRef">Poplar1</a>
          </h4>
<span class="break"></span><dl class="dlParallel" id="appendix-C.1.6-1">
            <dt id="appendix-C.1.6-1.1">
<code>bits</code>:</dt>
            <dd style="margin-left: 1.5em" id="appendix-C.1.6-1.2">
              <p id="appendix-C.1.6-1.2.1">The length of each input in bits, an integer.<a href="#appendix-C.1.6-1.2.1" class="pilcrow">¶</a></p>
</dd>
          <dd class="break"></dd>
</dl>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="acknowledgments">
<section id="appendix-D">
      <h2 id="name-acknowledgments">
<a href="#name-acknowledgments" class="section-name selfRef">Acknowledgments</a>
      </h2>
<p id="appendix-D-1">The impetus of this work is the success of recent deployments of predecessors
of Prio3. These include the Mozilla Origin Telemetry project
<span>[<a href="#OriginTelemetry" class="cite xref">OriginTelemetry</a>]</span> and the Exposure Notification Private Analytics system
<span>[<a href="#ENPA" class="cite xref">ENPA</a>]</span> developed jointly by ISRG, Google, Apple, and others. Together these
systems have aggregated data from hundreds of millions of users.<a href="#appendix-D-1" class="pilcrow">¶</a></p>
<p id="appendix-D-2">As the name implies, Prio3 is a descendant of the original Prio construction
<span>[<a href="#CGB17" class="cite xref">CGB17</a>]</span>. A second iteration was deployed in the <span>[<a href="#ENPA" class="cite xref">ENPA</a>]</span> system, and like the
VDAF described here, the ENPA system was built from techniques introduced in
<span>[<a href="#BBCGGI19" class="cite xref">BBCGGI19</a>]</span> that significantly improve communication cost. That system was
specialized for a particular aggregation function; the goal of Prio3 is to
provide the same level of generality as the original construction.<a href="#appendix-D-2" class="pilcrow">¶</a></p>
<p id="appendix-D-3">The security considerations in <a href="#security" class="auto internal xref">Section 9</a> are based largely on the security
analysis of <span>[<a href="#DPRS23" class="cite xref">DPRS23</a>]</span>. Thanks to Hannah Davis and Mike Rosulek, who lent their
time to developing definitions and security proofs.<a href="#appendix-D-3" class="pilcrow">¶</a></p>
<p id="appendix-D-4">Thanks to Junye Chen, Henry Corrigan-Gibbs, Armando Faz-Hernández, Simon
Friedberger, Tim Geoghegan, Albert Liu, Brandon Pitman, Mariana Raykova,
Michael Rosenberg, Jacob Rothstein, Shan Wang, Xiao Wang, Bas Westerbaan, and
Christopher Wood for useful feedback on and contributions to the spec.<a href="#appendix-D-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="authors-addresses">
<section id="appendix-E">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Richard L. Barnes</span></div>
<div dir="auto" class="left"><span class="org">Cisco</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:rlb@ipv.sx" class="email">rlb@ipv.sx</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">David Cook</span></div>
<div dir="auto" class="left"><span class="org">ISRG</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:divergentdave@gmail.com" class="email">divergentdave@gmail.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Christopher Patton</span></div>
<div dir="auto" class="left"><span class="org">Cloudflare</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:chrispatton+ietf@gmail.com" class="email">chrispatton+ietf@gmail.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Phillipp Schoppmann</span></div>
<div dir="auto" class="left"><span class="org">Google</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:schoppmann@google.com" class="email">schoppmann@google.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
